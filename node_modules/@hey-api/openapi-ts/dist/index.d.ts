import { C as Comments, P as PluginHandler, a as Plugin, I as ImportExportItemObject, t as tsNodeToString, S as StringCase, U as UserConfig, L as Logger, b as Client$6, c as IR } from './types.d-44bOq98L.js';
export { j as Client, D as DefinePlugin, E as ExpressionTransformer, k as LegacyIR, O as OpenApi, d as OpenApiMetaObject, e as OpenApiOperationObject, f as OpenApiParameterObject, g as OpenApiRequestBodyObject, h as OpenApiResponseObject, i as OpenApiSchemaObject, T as TypeTransformer } from './types.d-44bOq98L.js';
import { HttpHeaders, HttpClient, HttpRequest, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Injector } from '@angular/core';
import { CreateAxiosDefaults, AxiosStatic, AxiosInstance, AxiosRequestHeaders, AxiosResponse, AxiosError } from 'axios';
import { UseFetchOptions, AsyncDataOptions, useAsyncData, useFetch, useLazyAsyncData, useLazyFetch } from 'nuxt/app';
import { Ref } from 'vue';
import * as typescript from 'typescript';
import typescript__default from 'typescript';
import 'semver';
import '@hey-api/codegen-core';
import 'node:fs';

type AccessLevel = 'private' | 'protected' | 'public';
type FunctionParameter = {
    accessLevel?: AccessLevel;
    default?: any;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string;
    type?: any | typescript__default.TypeNode;
} | {
    destructure: ReadonlyArray<FunctionParameter>;
    type?: any | typescript__default.TypeNode;
};
interface FunctionTypeParameter {
    default?: any;
    extends?: string | typescript__default.TypeNode;
    name: string | typescript__default.Identifier;
}
type SyntaxKindKeyword = 'any' | 'async' | 'boolean' | 'export' | 'never' | 'number' | 'private' | 'protected' | 'public' | 'readonly' | 'static' | 'string' | 'undefined' | 'unknown' | 'void';
type ObjectValue = {
    assertion?: 'any' | typescript__default.TypeNode;
    comments?: Comments;
    spread: string;
} | {
    comments?: Comments;
    isValueAccess?: boolean;
    key: string;
    shorthand?: boolean;
    value: any;
};

type AuthToken = string | undefined;
interface Auth {
    /**
     * Which part of the request do we use to send the auth?
     *
     * @default 'header'
     */
    in?: 'header' | 'query' | 'cookie';
    /**
     * Header or query parameter name.
     *
     * @default 'Authorization'
     */
    name?: string;
    scheme?: 'basic' | 'bearer';
    type: 'apiKey' | 'http';
}

interface SerializerOptions<T> {
    /**
     * @default true
     */
    explode: boolean;
    style: T;
}
type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';
type ObjectStyle = 'form' | 'deepObject';

type QuerySerializer$1 = (query: Record<string, unknown>) => string;
type BodySerializer = (body: any) => any;
interface QuerySerializerOptions {
    allowReserved?: boolean;
    array?: SerializerOptions<ArrayStyle>;
    object?: SerializerOptions<ObjectStyle>;
}

type HttpMethod = 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace';
type Client$5<RequestFn = never, Config = unknown, MethodFn = never, BuildUrlFn = never, SseFn = never> = {
    /**
     * Returns the final request URL.
     */
    buildUrl: BuildUrlFn;
    getConfig: () => Config;
    request: RequestFn;
    setConfig: (config: Config) => Config;
} & {
    [K in HttpMethod]: MethodFn;
} & ([SseFn] extends [never] ? {
    sse?: never;
} : {
    sse: {
        [K in HttpMethod]: SseFn;
    };
});
interface Config$5 {
    /**
     * Auth token or a function returning auth token. The resolved value will be
     * added to the request payload as defined by its `security` array.
     */
    auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
    /**
     * A function for serializing request body parameter. By default,
     * {@link JSON.stringify()} will be used.
     */
    bodySerializer?: BodySerializer | null;
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `Headers` object with.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
     */
    headers?: RequestInit['headers'] | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * The request method.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
     */
    method?: Uppercase<HttpMethod>;
    /**
     * A function for serializing request query parameters. By default, arrays
     * will be exploded in form style, objects will be exploded in deepObject
     * style, and reserved characters are percent-encoded.
     *
     * This method will have no effect if the native `paramsSerializer()` Axios
     * API function is used.
     *
     * {@link https://swagger.io/docs/specification/serialization/#query View examples}
     */
    querySerializer?: QuerySerializer$1 | QuerySerializerOptions;
    /**
     * A function validating request data. This is useful if you want to ensure
     * the request conforms to the desired shape, so it can be safely sent to
     * the server.
     */
    requestValidator?: (data: unknown) => Promise<unknown>;
    /**
     * A function transforming response data before it's returned. This is useful
     * for post-processing data, e.g. converting ISO strings into Date objects.
     */
    responseTransformer?: (data: unknown) => Promise<unknown>;
    /**
     * A function validating response data. This is useful if you want to ensure
     * the response conforms to the desired shape, so it can be safely passed to
     * the transformers and returned to the user.
     */
    responseValidator?: (data: unknown) => Promise<unknown>;
}

type ServerSentEventsOptions<TData = unknown> = Omit<RequestInit, 'method'> & Pick<Config$5, 'method' | 'responseTransformer' | 'responseValidator'> & {
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Implementing clients can call request interceptors inside this hook.
     */
    onRequest?: (url: string, init: RequestInit) => Promise<Request>;
    /**
     * Callback invoked when a network or parsing error occurs during streaming.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param error The error that occurred.
     */
    onSseError?: (error: unknown) => void;
    /**
     * Callback invoked when an event is streamed from the server.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param event Event streamed from the server.
     * @returns Nothing (void).
     */
    onSseEvent?: (event: StreamEvent<TData>) => void;
    serializedBody?: RequestInit['body'];
    /**
     * Default retry delay in milliseconds.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 3000
     */
    sseDefaultRetryDelay?: number;
    /**
     * Maximum number of retry attempts before giving up.
     */
    sseMaxRetryAttempts?: number;
    /**
     * Maximum retry delay in milliseconds.
     *
     * Applies only when exponential backoff is used.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 30000
     */
    sseMaxRetryDelay?: number;
    /**
     * Optional sleep function for retry backoff.
     *
     * Defaults to using `setTimeout`.
     */
    sseSleepFn?: (ms: number) => Promise<void>;
    url: string;
};
interface StreamEvent<TData = unknown> {
    data: TData;
    event?: string;
    id?: string;
    retry?: number;
}
type ServerSentEventsResult<TData = unknown, TReturn = void, TNext = unknown> = {
    stream: AsyncGenerator<TData extends Record<string, unknown> ? TData[keyof TData] : TData, TReturn, TNext>;
};

type ErrInterceptor$2<Err, Res, Req, Options> = (error: Err, response: Res, request: Req, options: Options) => Err | Promise<Err>;
type ReqInterceptor$2<Req, Options> = (request: Req, options: Options) => Req | Promise<Req>;
type ResInterceptor$2<Res, Req, Options> = (response: Res, request: Req, options: Options) => Res | Promise<Res>;
declare class Interceptors$2<Interceptor> {
    _fns: (Interceptor | null)[];
    constructor();
    clear(): void;
    getInterceptorIndex(id: number | Interceptor): number;
    exists(id: number | Interceptor): boolean;
    eject(id: number | Interceptor): void;
    update(id: number | Interceptor, fn: Interceptor): number | false | Interceptor;
    use(fn: Interceptor): number;
}
interface Middleware$2<Req, Res, Err, Options> {
    error: Pick<Interceptors$2<ErrInterceptor$2<Err, Res, Req, Options>>, 'eject' | 'use'>;
    request: Pick<Interceptors$2<ReqInterceptor$2<Req, Options>>, 'eject' | 'use'>;
    response: Pick<Interceptors$2<ResInterceptor$2<Res, Req, Options>>, 'eject' | 'use'>;
}

type ResponseStyle$1 = 'data' | 'fields';
interface Config$4<T extends ClientOptions$4 = ClientOptions$4> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Omit<Config$5, 'headers'> {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `HttpHeaders` object with.
     *
     * {@link https://angular.dev/api/common/http/HttpHeaders#constructor See more}
     */
    headers?: HttpHeaders | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * The HTTP client to use for making requests.
     */
    httpClient?: HttpClient;
    /**
     * Should we return only data or multiple fields (data, error, response, etc.)?
     *
     * @default 'fields'
     */
    responseStyle?: ResponseStyle$1;
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions$4<TData = unknown, TResponseStyle extends ResponseStyle$1 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$4<{
    responseStyle: TResponseStyle;
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    /**
     * Optional custom injector for dependency resolution if you don't implicitly or explicitly provide one.
     */
    injector?: Injector;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ResolvedRequestOptions$2<TResponseStyle extends ResponseStyle$1 = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$4<unknown, TResponseStyle, ThrowOnError, Url> {
    serializedBody?: string;
}
type RequestResult$4<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle$1 = 'fields'> = Promise<ThrowOnError extends true ? TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    request: HttpRequest<unknown>;
    response: HttpResponse<TData>;
} : TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : {
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    error: undefined;
    request: HttpRequest<unknown>;
    response: HttpResponse<TData>;
} | {
    data: undefined;
    error: TError[keyof TError];
    request: HttpRequest<unknown>;
    response: HttpErrorResponse & {
        error: TError[keyof TError] | null;
    };
}>;
interface ClientOptions$4 {
    baseUrl?: string;
    responseStyle?: ResponseStyle$1;
    throwOnError?: boolean;
}
type MethodFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$4<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult$4<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$4<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$4 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: Omit<RequestOptions$4<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$4<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult$4<TData, TError, ThrowOnError, TResponseStyle>;
type RequestOptionsFn = <ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle$1 = 'fields'>(options: RequestOptions$4<unknown, TResponseStyle, ThrowOnError>) => HttpRequest<unknown>;
type BuildUrlFn$4 = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Options$4<TData>) => string;
type Client$4 = Client$5<RequestFn$4, Config$4, MethodFn$4, BuildUrlFn$4, SseFn$4> & {
    interceptors: Middleware$2<HttpRequest<unknown>, HttpResponse<unknown>, unknown, ResolvedRequestOptions$2>;
    requestOptions: RequestOptionsFn;
};
interface TDataShape$4 {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys$4<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options$4<TData extends TDataShape$4 = TDataShape$4, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle$1 = 'fields'> = OmitKeys$4<RequestOptions$4<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

interface Config$3<T extends ClientOptions$3 = ClientOptions$3> extends Omit<CreateAxiosDefaults, 'auth' | 'baseURL' | 'headers' | 'method'>, Config$5 {
    /**
     * Axios implementation. You can use this option to provide either an
     * `AxiosStatic` or an `AxiosInstance`.
     *
     * @default axios
     */
    axios?: AxiosStatic | AxiosInstance;
    /**
     * Base URL for all requests made by this client.
     */
    baseURL?: T['baseURL'];
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `Headers` object with.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
     */
    headers?: AxiosRequestHeaders | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions$3<TData = unknown, ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$3<{
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ClientOptions$3 {
    baseURL?: string;
    throwOnError?: boolean;
}
type RequestResult$3<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean> = ThrowOnError extends true ? Promise<AxiosResponse<TData extends Record<string, unknown> ? TData[keyof TData] : TData>> : Promise<(AxiosResponse<TData extends Record<string, unknown> ? TData[keyof TData] : TData> & {
    error: undefined;
}) | (AxiosError<TError extends Record<string, unknown> ? TError[keyof TError] : TError> & {
    data: undefined;
    error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
})>;
type MethodFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$3<TData, ThrowOnError>, 'method'>) => RequestResult$3<TData, TError, ThrowOnError>;
type SseFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$3<TData, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$3 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$3<TData, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$3<TData, ThrowOnError>>, 'method'>) => RequestResult$3<TData, TError, ThrowOnError>;
type BuildUrlFn$3 = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Omit<Options$3<TData>, 'axios'>) => string;
type Client$3 = Client$5<RequestFn$3, Config$3, MethodFn$3, BuildUrlFn$3, SseFn$3> & {
    instance: AxiosInstance;
};
interface TDataShape$3 {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys$3<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options$3<TData extends TDataShape$3 = TDataShape$3, ThrowOnError extends boolean = boolean, TResponse = unknown> = OmitKeys$3<RequestOptions$3<TResponse, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

type ErrInterceptor$1<Err, Res, Req, Options> = (error: Err, response: Res, request: Req, options: Options) => Err | Promise<Err>;
type ReqInterceptor$1<Req, Options> = (request: Req, options: Options) => Req | Promise<Req>;
type ResInterceptor$1<Res, Req, Options> = (response: Res, request: Req, options: Options) => Res | Promise<Res>;
declare class Interceptors$1<Interceptor> {
    _fns: (Interceptor | null)[];
    constructor();
    clear(): void;
    getInterceptorIndex(id: number | Interceptor): number;
    exists(id: number | Interceptor): boolean;
    eject(id: number | Interceptor): void;
    update(id: number | Interceptor, fn: Interceptor): number | false | Interceptor;
    use(fn: Interceptor): number;
}
interface Middleware$1<Req, Res, Err, Options> {
    error: Pick<Interceptors$1<ErrInterceptor$1<Err, Res, Req, Options>>, 'eject' | 'use'>;
    request: Pick<Interceptors$1<ReqInterceptor$1<Req, Options>>, 'eject' | 'use'>;
    response: Pick<Interceptors$1<ResInterceptor$1<Res, Req, Options>>, 'eject' | 'use'>;
}

type ResponseStyle = 'data' | 'fields';
interface Config$2<T extends ClientOptions$2 = ClientOptions$2> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config$5 {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Please don't use the Fetch client for Next.js applications. The `next`
     * options won't have any effect.
     *
     * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
     */
    next?: never;
    /**
     * Return the response data parsed in a specified format. By default, `auto`
     * will infer the appropriate method from the `Content-Type` response header.
     * You can override this behavior with any of the {@link Body} methods.
     * Select `stream` if you don't want to parse response data at all.
     *
     * @default 'auto'
     */
    parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
    /**
     * Should we return only data or multiple fields (data, error, response, etc.)?
     *
     * @default 'fields'
     */
    responseStyle?: ResponseStyle;
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions$2<TData = unknown, TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$2<{
    responseStyle: TResponseStyle;
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ResolvedRequestOptions$1<TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$2<unknown, TResponseStyle, ThrowOnError, Url> {
    serializedBody?: string;
}
type RequestResult$2<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle = 'fields'> = ThrowOnError extends true ? Promise<TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    request: Request;
    response: Response;
}> : Promise<TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : ({
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    error: undefined;
} | {
    data: undefined;
    error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
    request: Request;
    response: Response;
}>;
interface ClientOptions$2 {
    baseUrl?: string;
    responseStyle?: ResponseStyle;
    throwOnError?: boolean;
}
type MethodFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions$2<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult$2<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions$2<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$2 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions$2<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$2<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult$2<TData, TError, ThrowOnError, TResponseStyle>;
type BuildUrlFn$2 = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Options$2<TData>) => string;
type Client$2 = Client$5<RequestFn$2, Config$2, MethodFn$2, BuildUrlFn$2, SseFn$2> & {
    interceptors: Middleware$1<Request, Response, unknown, ResolvedRequestOptions$1>;
};
interface TDataShape$2 {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys$2<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options$2<TData extends TDataShape$2 = TDataShape$2, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle = 'fields'> = OmitKeys$2<RequestOptions$2<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

type ErrInterceptor<Err, Res, Options> = (error: Err, response: Res, options: Options) => Err | Promise<Err>;
type ReqInterceptor<Options> = (options: Options) => void | Promise<void>;
type ResInterceptor<Res, Options> = (response: Res, options: Options) => Res | Promise<Res>;
declare class Interceptors<Interceptor> {
    _fns: (Interceptor | null)[];
    constructor();
    clear(): void;
    getInterceptorIndex(id: number | Interceptor): number;
    exists(id: number | Interceptor): boolean;
    eject(id: number | Interceptor): void;
    update(id: number | Interceptor, fn: Interceptor): number | false | Interceptor;
    use(fn: Interceptor): number;
}
interface Middleware<Res, Err, Options> {
    error: Pick<Interceptors<ErrInterceptor<Err, Res, Options>>, 'eject' | 'use'>;
    request: Pick<Interceptors<ReqInterceptor<Options>>, 'eject' | 'use'>;
    response: Pick<Interceptors<ResInterceptor<Res, Options>>, 'eject' | 'use'>;
}

interface Config$1<T extends ClientOptions$1 = ClientOptions$1> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config$5 {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Return the response data parsed in a specified format. By default, `auto`
     * will infer the appropriate method from the `Content-Type` response header.
     * You can override this behavior with any of the {@link Body} methods.
     * Select `stream` if you don't want to parse response data at all.
     *
     * @default 'auto'
     */
    parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions$1<TData = unknown, ThrowOnError extends boolean = boolean, Url extends string = string> extends Config$1<{
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ResolvedRequestOptions<ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions$1<unknown, ThrowOnError, Url> {
    serializedBody?: string;
}
type RequestResult$1<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean> = ThrowOnError extends true ? Promise<{
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    response: Response;
}> : Promise<({
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    error: undefined;
} | {
    data: undefined;
    error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
    response: Response;
}>;
interface ClientOptions$1 {
    baseUrl?: string;
    throwOnError?: boolean;
}
type MethodFn$1 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$1<TData, ThrowOnError>, 'method'>) => RequestResult$1<TData, TError, ThrowOnError>;
type SseFn$1 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$1<TData, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn$1 = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false>(options: Omit<RequestOptions$1<TData, ThrowOnError>, 'method'> & Pick<Required<RequestOptions$1<TData, ThrowOnError>>, 'method'>) => RequestResult$1<TData, TError, ThrowOnError>;
type BuildUrlFn$1 = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Options$1<TData>) => string;
type Client$1 = Client$5<RequestFn$1, Config$1, MethodFn$1, BuildUrlFn$1, SseFn$1> & {
    interceptors: Middleware<Response, unknown, ResolvedRequestOptions>;
};
interface TDataShape$1 {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys$1<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options$1<TData extends TDataShape$1 = TDataShape$1, ThrowOnError extends boolean = boolean, TResponse = unknown> = OmitKeys$1<RequestOptions$1<TResponse, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

type QuerySerializer = (query: Parameters<Client['buildUrl']>[0]['query']) => string;
type WithRefs<TData> = {
    [K in keyof TData]: NonNullable<TData[K]> extends object ? WithRefs<NonNullable<TData[K]>> | Ref<NonNullable<TData[K]>> : NonNullable<TData[K]> | Ref<NonNullable<TData[K]>>;
};
type KeysOf<T> = Array<T extends T ? (keyof T extends string ? keyof T : never) : never>;
interface Config<T extends ClientOptions = ClientOptions> extends Omit<FetchOptions<unknown>, 'baseURL' | 'body' | 'headers' | 'method' | 'query'>, WithRefs<Pick<FetchOptions<unknown>, 'query'>>, Omit<Config$5, 'querySerializer'> {
    /**
     * Base URL for all requests made by this client.
     */
    baseURL?: T['baseURL'];
    /**
     * A function for serializing request query parameters. By default, arrays
     * will be exploded in form style, objects will be exploded in deepObject
     * style, and reserved characters are percent-encoded.
     *
     * {@link https://swagger.io/docs/specification/serialization/#query View examples}
     */
    querySerializer?: QuerySerializer | QuerySerializerOptions;
}
interface RequestOptions<TComposable extends Composable = Composable, ResT = unknown, DefaultT = undefined, Url extends string = string> extends Config, WithRefs<{
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: FetchOptions<unknown>['query'];
    query?: FetchOptions<unknown>['query'];
    rawBody?: unknown;
}>, Pick<ServerSentEventsOptions<ResT>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    asyncDataOptions?: AsyncDataOptions<ResT, ResT, KeysOf<ResT>, DefaultT>;
    composable: TComposable;
    key?: string;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
type RequestResult<TComposable extends Composable, ResT, TError> = TComposable extends '$fetch' ? ReturnType<typeof $fetch<ResT>> : TComposable extends 'useAsyncData' ? ReturnType<typeof useAsyncData<ResT | null, TError>> : TComposable extends 'useFetch' ? ReturnType<typeof useFetch<ResT | null, TError>> : TComposable extends 'useLazyAsyncData' ? ReturnType<typeof useLazyAsyncData<ResT | null, TError>> : TComposable extends 'useLazyFetch' ? ReturnType<typeof useLazyFetch<ResT | null, TError>> : never;
interface ClientOptions {
    baseURL?: string;
}
type MethodFn = <TComposable extends Composable, ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions<TComposable, ResT, DefaultT>, 'method'>) => RequestResult<TComposable, ResT, TError>;
type SseFn = <TComposable extends Composable, ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions<TComposable, ResT, DefaultT>, 'method'>) => Promise<ServerSentEventsResult<RequestResult<TComposable, ResT, TError>>>;
type RequestFn = <TComposable extends Composable, ResT = unknown, TError = unknown, DefaultT = undefined>(options: Omit<RequestOptions<TComposable, ResT, DefaultT>, 'method'> & Pick<Required<RequestOptions<TComposable, ResT, DefaultT>>, 'method'>) => RequestResult<TComposable, ResT, TError>;
interface TDataShape {
    body?: unknown;
    headers?: unknown;
    path?: FetchOptions<unknown>['query'];
    query?: FetchOptions<unknown>['query'];
    url: string;
}
type BuildUrlOptions<TData extends Omit<TDataShape, 'headers'> = Omit<TDataShape, 'headers'>> = Pick<WithRefs<TData>, 'path' | 'query'> & Pick<TData, 'url'> & Pick<Options<'$fetch', TData>, 'baseURL' | 'querySerializer'>;
type BuildUrlFn = <TData extends Omit<TDataShape, 'headers'>>(options: BuildUrlOptions<TData>) => string;
type Client = Client$5<RequestFn, Config, MethodFn, BuildUrlFn, SseFn>;
type OmitKeys<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options<TComposable extends Composable, TData extends TDataShape = TDataShape, ResT = unknown, DefaultT = undefined> = OmitKeys<RequestOptions<TComposable, ResT, DefaultT>, 'body' | 'path' | 'query' | 'url'> & WithRefs<Omit<TData, 'url'>>;
type FetchOptions<TData> = Omit<UseFetchOptions<TData, TData>, keyof AsyncDataOptions<TData>>;
type Composable = '$fetch' | 'useAsyncData' | 'useFetch' | 'useLazyAsyncData' | 'useLazyFetch';

declare const defaultPaginationKeywords: readonly ["after", "before", "cursor", "offset", "page", "start"];

/**
 * Default plugins used to generate artifacts if plugins aren't specified.
 */
declare const defaultPlugins: readonly ["@hey-api/typescript", "@hey-api/sdk"];

declare const clientDefaultConfig: {
    readonly baseUrl: true;
    readonly bundle: true;
    readonly exportFromIndex: false;
};
declare const clientDefaultMeta: {
    readonly dependencies: readonly ["@hey-api/typescript"];
    readonly output: "client";
    readonly tags: readonly ["client"];
};

declare const clientPluginHandler: ({ plugin, }: Parameters<PluginHandler>[0]) => void;

declare const definePluginConfig: <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) => (userConfig?: Omit<Plugin.UserConfig<T["config"]>, "name">) => Omit<Plugin.Config<T>, "name"> & {
    /**
     * Cast name to `any` so it doesn't throw type error in `plugins` array.
     * We could allow any `string` as plugin `name` in the object syntax, but
     * that TypeScript trick would cause all string methods to appear as
     * suggested auto completions, which is undesirable.
     */
    name: any;
};

type ImportExportItem = ImportExportItemObject | string;

type Property = {
    comment?: Comments;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string | typescript__default.PropertyName;
    type: any | typescript__default.TypeNode;
};

declare const tsc: {
    anonymousFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        returnType?: string | typescript.TypeNode;
        statements?: ReadonlyArray<typescript.Statement>;
        types?: FunctionTypeParameter[];
    }) => typescript.FunctionExpression;
    arrayLiteralExpression: <T>({ elements, multiLine, }: {
        elements: T[];
        multiLine?: boolean;
    }) => typescript.ArrayLiteralExpression;
    arrowFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[] | typescript.Expression;
        types?: FunctionTypeParameter[];
    }) => typescript.ArrowFunction;
    asExpression: ({ expression, type, }: {
        expression: typescript.Expression;
        type: typescript.TypeNode;
    }) => typescript.AsExpression;
    assignment: ({ left, right, }: {
        left: typescript.Expression;
        right: typescript.Expression;
    }) => typescript.AssignmentExpression<typescript.EqualsToken>;
    awaitExpression: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.AwaitExpression;
    binaryExpression: ({ left, operator, right, }: {
        left: typescript.Expression;
        operator?: "=" | "===" | "in" | "??";
        right: typescript.Expression | string;
    }) => typescript.BinaryExpression;
    block: ({ multiLine, statements, }: {
        multiLine?: boolean;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.Block;
    callExpression: ({ functionName, parameters, types, }: {
        functionName: string | typescript.PropertyAccessExpression | typescript.PropertyAccessChain | typescript.ElementAccessExpression | typescript.Expression;
        parameters?: Array<string | typescript.Expression | undefined>;
        types?: ReadonlyArray<typescript.TypeNode>;
    }) => typescript.CallExpression;
    classDeclaration: ({ decorator, exportClass, extendedClasses, name, nodes, }: {
        decorator?: {
            args: any[];
            name: string;
        };
        exportClass?: boolean;
        extendedClasses?: ReadonlyArray<string>;
        name: string;
        nodes: ReadonlyArray<typescript.ClassElement>;
    }) => typescript.ClassDeclaration;
    conditionalExpression: ({ condition, whenFalse, whenTrue, }: {
        condition: typescript.Expression;
        whenFalse: typescript.Expression;
        whenTrue: typescript.Expression;
    }) => typescript.ConditionalExpression;
    constVariable: ({ assertion, comment, destructure, exportConst, expression, name, typeName, }: {
        assertion?: "const" | typescript.TypeNode;
        comment?: Comments;
        destructure?: boolean;
        exportConst?: boolean;
        expression: typescript.Expression;
        name: string | typescript.TypeReferenceNode;
        typeName?: string | typescript.IndexedAccessTypeNode | typescript.TypeNode;
    }) => typescript.VariableStatement;
    constructorDeclaration: ({ accessLevel, comment, multiLine, parameters, statements, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        statements?: typescript.Statement[];
    }) => typescript.ConstructorDeclaration;
    enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({ asConst, comments: enumMemberComments, leadingComment: comments, name, obj, }: {
        asConst: boolean;
        comments?: Record<string | number, Comments>;
        leadingComment?: Comments;
        name: string | typescript.TypeReferenceNode;
        obj: T;
    }) => typescript.EnumDeclaration;
    exportAllDeclaration: ({ module, shouldAppendJs, }: {
        module: string;
        shouldAppendJs?: boolean;
    }) => typescript.ExportDeclaration;
    exportNamedDeclaration: ({ exports, module, }: {
        exports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ExportDeclaration;
    expressionToStatement: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.ExpressionStatement;
    forOfStatement: ({ awaitModifier, expression, initializer, statement, }: {
        awaitModifier?: typescript.AwaitKeyword;
        expression: typescript.Expression;
        initializer: typescript.ForInitializer;
        statement: typescript.Statement;
    }) => typescript.ForOfStatement;
    functionTypeNode: ({ parameters, returnType, typeParameters, }: {
        parameters?: typescript.ParameterDeclaration[];
        returnType: typescript.TypeNode;
        typeParameters?: typescript.TypeParameterDeclaration[];
    }) => typescript.FunctionTypeNode;
    getAccessorDeclaration: ({ name, returnType, statements, }: {
        name: string | typescript.PropertyName;
        returnType?: string | typescript.Identifier;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.GetAccessorDeclaration;
    identifier: ({ text }: {
        text: string;
    }) => typescript.Identifier;
    ifStatement: ({ elseStatement, expression, thenStatement, }: {
        elseStatement?: typescript.Statement;
        expression: typescript.Expression;
        thenStatement: typescript.Statement;
    }) => typescript.IfStatement;
    indexedAccessTypeNode: ({ indexType, objectType, }: {
        indexType: typescript.TypeNode;
        objectType: typescript.TypeNode;
    }) => typescript.IndexedAccessTypeNode;
    isTsNode: (node: any) => node is typescript.Expression;
    keywordTypeNode: ({ keyword, }: {
        keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
    }) => typescript.KeywordTypeNode<typescript.SyntaxKind.VoidKeyword | typescript.SyntaxKind.AnyKeyword | typescript.SyntaxKind.BooleanKeyword | typescript.SyntaxKind.NeverKeyword | typescript.SyntaxKind.NumberKeyword | typescript.SyntaxKind.StringKeyword | typescript.SyntaxKind.UndefinedKeyword | typescript.SyntaxKind.UnknownKeyword>;
    literalTypeNode: ({ literal, }: {
        literal: typescript.LiteralTypeNode["literal"];
    }) => typescript.LiteralTypeNode;
    mappedTypeNode: ({ members, nameType, questionToken, readonlyToken, type, typeParameter, }: {
        members?: typescript.NodeArray<typescript.TypeElement>;
        nameType?: typescript.TypeNode;
        questionToken?: typescript.QuestionToken | typescript.PlusToken | typescript.MinusToken;
        readonlyToken?: typescript.ReadonlyKeyword | typescript.PlusToken | typescript.MinusToken;
        type?: typescript.TypeNode;
        typeParameter: typescript.TypeParameterDeclaration;
    }) => typescript.MappedTypeNode;
    methodDeclaration: ({ accessLevel, comment, isStatic, multiLine, name, parameters, returnType, statements, types, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        isStatic?: boolean;
        multiLine?: boolean;
        name: string;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[];
        types?: FunctionTypeParameter[];
    }) => typescript.MethodDeclaration;
    namedImportDeclarations: ({ imports, module, }: {
        imports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ImportDeclaration;
    namespaceDeclaration: ({ name, statements, }: {
        name: string;
        statements: Array<typescript.Statement>;
    }) => typescript.ModuleDeclaration;
    newExpression: ({ argumentsArray, expression, typeArguments, }: {
        argumentsArray?: Array<typescript.Expression>;
        expression: typescript.Expression;
        typeArguments?: Array<typescript.TypeNode>;
    }) => typescript.NewExpression;
    nodeToString: typeof tsNodeToString;
    null: () => typescript.NullLiteral;
    objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({ comments, identifiers, multiLine, obj, shorthand, unescape, }: {
        comments?: Comments;
        identifiers?: string[];
        multiLine?: boolean;
        obj: T;
        shorthand?: boolean;
        unescape?: boolean;
    }) => typescript.ObjectLiteralExpression;
    ots: {
        boolean: (value: boolean) => typescript.TrueLiteral | typescript.FalseLiteral;
        export: ({ alias, asType, name }: ImportExportItemObject) => typescript.ExportSpecifier;
        import: ({ alias, asType, name }: ImportExportItemObject) => typescript.ImportSpecifier;
        number: (value: number) => typescript.NumericLiteral | typescript.PrefixUnaryExpression;
        string: (value: string, unescape?: boolean) => typescript.Identifier | typescript.StringLiteral;
    };
    parameterDeclaration: ({ initializer, modifiers, name, required, type, }: {
        initializer?: typescript.Expression;
        modifiers?: ReadonlyArray<typescript.ModifierLike>;
        name: string | typescript.BindingName;
        required?: boolean;
        type?: typescript.TypeNode;
    }) => typescript.ParameterDeclaration;
    propertyAccessExpression: ({ expression, isOptional, name, }: {
        expression: string | typescript.Expression;
        isOptional?: boolean;
        name: string | number | typescript.MemberName;
    }) => typescript.PropertyAccessChain | typescript.PropertyAccessExpression | typescript.ElementAccessExpression;
    propertyAccessExpressions: ({ expressions, }: {
        expressions: Array<string | typescript.Expression | typescript.MemberName>;
    }) => typescript.PropertyAccessExpression;
    propertyAssignment: ({ initializer, name, }: {
        initializer: typescript.Expression;
        name: string | typescript.PropertyName;
    }) => typescript.PropertyAssignment;
    propertyDeclaration: ({ initializer, modifier, name, type, }: {
        initializer?: typescript.Expression;
        modifier?: AccessLevel | "async" | "export" | "readonly" | "static";
        name: string | typescript.PropertyName;
        type?: typescript.TypeNode;
    }) => typescript.PropertyDeclaration;
    regularExpressionLiteral: ({ flags, text, }: {
        flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
        text: string;
    }) => typescript.RegularExpressionLiteral;
    returnFunctionCall: ({ args, name, types, }: {
        args: any[];
        name: string | typescript.Expression;
        types?: ReadonlyArray<string | typescript.StringLiteral>;
    }) => typescript.ReturnStatement;
    returnStatement: ({ expression, }: {
        expression?: typescript.Expression;
    }) => typescript.ReturnStatement;
    returnVariable: ({ expression, }: {
        expression: string | typescript.Expression;
    }) => typescript.ReturnStatement;
    safeAccessExpression: (path: string[]) => typescript.Expression;
    stringLiteral: ({ isSingleQuote, text, }: {
        isSingleQuote?: boolean;
        text: string;
    }) => typescript.StringLiteral;
    templateLiteralType: ({ value, }: {
        value: ReadonlyArray<string | typescript.TypeNode>;
    }) => typescript.TemplateLiteralTypeNode;
    this: () => typescript.ThisExpression;
    transformArrayMap: ({ path, transformExpression, }: {
        path: string[];
        transformExpression: typescript.Expression;
    }) => typescript.IfStatement;
    transformArrayMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.Statement;
    transformDateMutation: ({ path, }: {
        path: string[];
    }) => typescript.Statement;
    transformFunctionMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.IfStatement[];
    transformNewDate: ({ parameterName, }: {
        parameterName: string;
    }) => typescript.NewExpression;
    typeAliasDeclaration: ({ comment, exportType, name, type, typeParameters, }: {
        comment?: Comments;
        exportType?: boolean;
        name: string | typescript.TypeReferenceNode;
        type: string | typescript.TypeNode | typescript.Identifier;
        typeParameters?: FunctionTypeParameter[];
    }) => typescript.TypeAliasDeclaration;
    typeArrayNode: (types: ReadonlyArray<any | typescript.TypeNode> | typescript.TypeNode | typescript.Identifier | string, isNullable?: boolean) => typescript.TypeNode;
    typeInterfaceNode: ({ indexKey, indexProperty, isNullable, properties, useLegacyResolution, }: {
        indexKey?: typescript.TypeReferenceNode;
        indexProperty?: Property;
        isNullable?: boolean;
        properties: Property[];
        useLegacyResolution: boolean;
    }) => typescript.TypeNode;
    typeIntersectionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | typescript.TypeNode)[];
    }) => typescript.TypeNode;
    typeNode: (base: any | typescript.TypeNode, args?: (any | typescript.TypeNode)[]) => typescript.TypeNode;
    typeOfExpression: ({ text, }: {
        text: string | typescript.Identifier;
    }) => typescript.TypeOfExpression;
    typeOperatorNode: ({ operator, type, }: {
        operator: "keyof" | "readonly" | "unique";
        type: typescript.TypeNode;
    }) => typescript.TypeOperatorNode;
    typeParameterDeclaration: ({ constraint, defaultType, modifiers, name, }: {
        constraint?: typescript.TypeNode;
        defaultType?: typescript.TypeNode;
        modifiers?: Array<typescript.Modifier>;
        name: string | typescript.Identifier;
    }) => typescript.TypeParameterDeclaration;
    typeParenthesizedNode: ({ type }: {
        type: typescript.TypeNode;
    }) => typescript.ParenthesizedTypeNode;
    typeRecordNode: (keys: (any | typescript.TypeNode)[], values: (any | typescript.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript.TypeNode;
    typeReferenceNode: ({ typeArguments, typeName, }: {
        typeArguments?: typescript.TypeNode[];
        typeName: string | typescript.EntityName;
    }) => typescript.TypeReferenceNode;
    typeTupleNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: Array<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    typeUnionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: ReadonlyArray<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    valueToExpression: <T = unknown>({ identifiers, isValueAccess, shorthand, unescape, value, }: {
        identifiers?: string[];
        isValueAccess?: boolean;
        shorthand?: boolean;
        unescape?: boolean;
        value: T;
    }) => typescript.Expression | undefined;
};
/** @deprecated use tsc */
declare const compiler: {
    anonymousFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        returnType?: string | typescript.TypeNode;
        statements?: ReadonlyArray<typescript.Statement>;
        types?: FunctionTypeParameter[];
    }) => typescript.FunctionExpression;
    arrayLiteralExpression: <T>({ elements, multiLine, }: {
        elements: T[];
        multiLine?: boolean;
    }) => typescript.ArrayLiteralExpression;
    arrowFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[] | typescript.Expression;
        types?: FunctionTypeParameter[];
    }) => typescript.ArrowFunction;
    asExpression: ({ expression, type, }: {
        expression: typescript.Expression;
        type: typescript.TypeNode;
    }) => typescript.AsExpression;
    assignment: ({ left, right, }: {
        left: typescript.Expression;
        right: typescript.Expression;
    }) => typescript.AssignmentExpression<typescript.EqualsToken>;
    awaitExpression: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.AwaitExpression;
    binaryExpression: ({ left, operator, right, }: {
        left: typescript.Expression;
        operator?: "=" | "===" | "in" | "??";
        right: typescript.Expression | string;
    }) => typescript.BinaryExpression;
    block: ({ multiLine, statements, }: {
        multiLine?: boolean;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.Block;
    callExpression: ({ functionName, parameters, types, }: {
        functionName: string | typescript.PropertyAccessExpression | typescript.PropertyAccessChain | typescript.ElementAccessExpression | typescript.Expression;
        parameters?: Array<string | typescript.Expression | undefined>;
        types?: ReadonlyArray<typescript.TypeNode>;
    }) => typescript.CallExpression;
    classDeclaration: ({ decorator, exportClass, extendedClasses, name, nodes, }: {
        decorator?: {
            args: any[];
            name: string;
        };
        exportClass?: boolean;
        extendedClasses?: ReadonlyArray<string>;
        name: string;
        nodes: ReadonlyArray<typescript.ClassElement>;
    }) => typescript.ClassDeclaration;
    conditionalExpression: ({ condition, whenFalse, whenTrue, }: {
        condition: typescript.Expression;
        whenFalse: typescript.Expression;
        whenTrue: typescript.Expression;
    }) => typescript.ConditionalExpression;
    constVariable: ({ assertion, comment, destructure, exportConst, expression, name, typeName, }: {
        assertion?: "const" | typescript.TypeNode;
        comment?: Comments;
        destructure?: boolean;
        exportConst?: boolean;
        expression: typescript.Expression;
        name: string | typescript.TypeReferenceNode;
        typeName?: string | typescript.IndexedAccessTypeNode | typescript.TypeNode;
    }) => typescript.VariableStatement;
    constructorDeclaration: ({ accessLevel, comment, multiLine, parameters, statements, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        statements?: typescript.Statement[];
    }) => typescript.ConstructorDeclaration;
    enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({ asConst, comments: enumMemberComments, leadingComment: comments, name, obj, }: {
        asConst: boolean;
        comments?: Record<string | number, Comments>;
        leadingComment?: Comments;
        name: string | typescript.TypeReferenceNode;
        obj: T;
    }) => typescript.EnumDeclaration;
    exportAllDeclaration: ({ module, shouldAppendJs, }: {
        module: string;
        shouldAppendJs?: boolean;
    }) => typescript.ExportDeclaration;
    exportNamedDeclaration: ({ exports, module, }: {
        exports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ExportDeclaration;
    expressionToStatement: ({ expression, }: {
        expression: typescript.Expression;
    }) => typescript.ExpressionStatement;
    forOfStatement: ({ awaitModifier, expression, initializer, statement, }: {
        awaitModifier?: typescript.AwaitKeyword;
        expression: typescript.Expression;
        initializer: typescript.ForInitializer;
        statement: typescript.Statement;
    }) => typescript.ForOfStatement;
    functionTypeNode: ({ parameters, returnType, typeParameters, }: {
        parameters?: typescript.ParameterDeclaration[];
        returnType: typescript.TypeNode;
        typeParameters?: typescript.TypeParameterDeclaration[];
    }) => typescript.FunctionTypeNode;
    getAccessorDeclaration: ({ name, returnType, statements, }: {
        name: string | typescript.PropertyName;
        returnType?: string | typescript.Identifier;
        statements: ReadonlyArray<typescript.Statement>;
    }) => typescript.GetAccessorDeclaration;
    identifier: ({ text }: {
        text: string;
    }) => typescript.Identifier;
    ifStatement: ({ elseStatement, expression, thenStatement, }: {
        elseStatement?: typescript.Statement;
        expression: typescript.Expression;
        thenStatement: typescript.Statement;
    }) => typescript.IfStatement;
    indexedAccessTypeNode: ({ indexType, objectType, }: {
        indexType: typescript.TypeNode;
        objectType: typescript.TypeNode;
    }) => typescript.IndexedAccessTypeNode;
    isTsNode: (node: any) => node is typescript.Expression;
    keywordTypeNode: ({ keyword, }: {
        keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
    }) => typescript.KeywordTypeNode<typescript.SyntaxKind.VoidKeyword | typescript.SyntaxKind.AnyKeyword | typescript.SyntaxKind.BooleanKeyword | typescript.SyntaxKind.NeverKeyword | typescript.SyntaxKind.NumberKeyword | typescript.SyntaxKind.StringKeyword | typescript.SyntaxKind.UndefinedKeyword | typescript.SyntaxKind.UnknownKeyword>;
    literalTypeNode: ({ literal, }: {
        literal: typescript.LiteralTypeNode["literal"];
    }) => typescript.LiteralTypeNode;
    mappedTypeNode: ({ members, nameType, questionToken, readonlyToken, type, typeParameter, }: {
        members?: typescript.NodeArray<typescript.TypeElement>;
        nameType?: typescript.TypeNode;
        questionToken?: typescript.QuestionToken | typescript.PlusToken | typescript.MinusToken;
        readonlyToken?: typescript.ReadonlyKeyword | typescript.PlusToken | typescript.MinusToken;
        type?: typescript.TypeNode;
        typeParameter: typescript.TypeParameterDeclaration;
    }) => typescript.MappedTypeNode;
    methodDeclaration: ({ accessLevel, comment, isStatic, multiLine, name, parameters, returnType, statements, types, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        isStatic?: boolean;
        multiLine?: boolean;
        name: string;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | typescript.TypeNode;
        statements?: typescript.Statement[];
        types?: FunctionTypeParameter[];
    }) => typescript.MethodDeclaration;
    namedImportDeclarations: ({ imports, module, }: {
        imports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => typescript.ImportDeclaration;
    namespaceDeclaration: ({ name, statements, }: {
        name: string;
        statements: Array<typescript.Statement>;
    }) => typescript.ModuleDeclaration;
    newExpression: ({ argumentsArray, expression, typeArguments, }: {
        argumentsArray?: Array<typescript.Expression>;
        expression: typescript.Expression;
        typeArguments?: Array<typescript.TypeNode>;
    }) => typescript.NewExpression;
    nodeToString: typeof tsNodeToString;
    null: () => typescript.NullLiteral;
    objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({ comments, identifiers, multiLine, obj, shorthand, unescape, }: {
        comments?: Comments;
        identifiers?: string[];
        multiLine?: boolean;
        obj: T;
        shorthand?: boolean;
        unescape?: boolean;
    }) => typescript.ObjectLiteralExpression;
    ots: {
        boolean: (value: boolean) => typescript.TrueLiteral | typescript.FalseLiteral;
        export: ({ alias, asType, name }: ImportExportItemObject) => typescript.ExportSpecifier;
        import: ({ alias, asType, name }: ImportExportItemObject) => typescript.ImportSpecifier;
        number: (value: number) => typescript.NumericLiteral | typescript.PrefixUnaryExpression;
        string: (value: string, unescape?: boolean) => typescript.Identifier | typescript.StringLiteral;
    };
    parameterDeclaration: ({ initializer, modifiers, name, required, type, }: {
        initializer?: typescript.Expression;
        modifiers?: ReadonlyArray<typescript.ModifierLike>;
        name: string | typescript.BindingName;
        required?: boolean;
        type?: typescript.TypeNode;
    }) => typescript.ParameterDeclaration;
    propertyAccessExpression: ({ expression, isOptional, name, }: {
        expression: string | typescript.Expression;
        isOptional?: boolean;
        name: string | number | typescript.MemberName;
    }) => typescript.PropertyAccessChain | typescript.PropertyAccessExpression | typescript.ElementAccessExpression;
    propertyAccessExpressions: ({ expressions, }: {
        expressions: Array<string | typescript.Expression | typescript.MemberName>;
    }) => typescript.PropertyAccessExpression;
    propertyAssignment: ({ initializer, name, }: {
        initializer: typescript.Expression;
        name: string | typescript.PropertyName;
    }) => typescript.PropertyAssignment;
    propertyDeclaration: ({ initializer, modifier, name, type, }: {
        initializer?: typescript.Expression;
        modifier?: AccessLevel | "async" | "export" | "readonly" | "static";
        name: string | typescript.PropertyName;
        type?: typescript.TypeNode;
    }) => typescript.PropertyDeclaration;
    regularExpressionLiteral: ({ flags, text, }: {
        flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
        text: string;
    }) => typescript.RegularExpressionLiteral;
    returnFunctionCall: ({ args, name, types, }: {
        args: any[];
        name: string | typescript.Expression;
        types?: ReadonlyArray<string | typescript.StringLiteral>;
    }) => typescript.ReturnStatement;
    returnStatement: ({ expression, }: {
        expression?: typescript.Expression;
    }) => typescript.ReturnStatement;
    returnVariable: ({ expression, }: {
        expression: string | typescript.Expression;
    }) => typescript.ReturnStatement;
    safeAccessExpression: (path: string[]) => typescript.Expression;
    stringLiteral: ({ isSingleQuote, text, }: {
        isSingleQuote?: boolean;
        text: string;
    }) => typescript.StringLiteral;
    templateLiteralType: ({ value, }: {
        value: ReadonlyArray<string | typescript.TypeNode>;
    }) => typescript.TemplateLiteralTypeNode;
    this: () => typescript.ThisExpression;
    transformArrayMap: ({ path, transformExpression, }: {
        path: string[];
        transformExpression: typescript.Expression;
    }) => typescript.IfStatement;
    transformArrayMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.Statement;
    transformDateMutation: ({ path, }: {
        path: string[];
    }) => typescript.Statement;
    transformFunctionMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => typescript.IfStatement[];
    transformNewDate: ({ parameterName, }: {
        parameterName: string;
    }) => typescript.NewExpression;
    typeAliasDeclaration: ({ comment, exportType, name, type, typeParameters, }: {
        comment?: Comments;
        exportType?: boolean;
        name: string | typescript.TypeReferenceNode;
        type: string | typescript.TypeNode | typescript.Identifier;
        typeParameters?: FunctionTypeParameter[];
    }) => typescript.TypeAliasDeclaration;
    typeArrayNode: (types: ReadonlyArray<any | typescript.TypeNode> | typescript.TypeNode | typescript.Identifier | string, isNullable?: boolean) => typescript.TypeNode;
    typeInterfaceNode: ({ indexKey, indexProperty, isNullable, properties, useLegacyResolution, }: {
        indexKey?: typescript.TypeReferenceNode;
        indexProperty?: Property;
        isNullable?: boolean;
        properties: Property[];
        useLegacyResolution: boolean;
    }) => typescript.TypeNode;
    typeIntersectionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | typescript.TypeNode)[];
    }) => typescript.TypeNode;
    typeNode: (base: any | typescript.TypeNode, args?: (any | typescript.TypeNode)[]) => typescript.TypeNode;
    typeOfExpression: ({ text, }: {
        text: string | typescript.Identifier;
    }) => typescript.TypeOfExpression;
    typeOperatorNode: ({ operator, type, }: {
        operator: "keyof" | "readonly" | "unique";
        type: typescript.TypeNode;
    }) => typescript.TypeOperatorNode;
    typeParameterDeclaration: ({ constraint, defaultType, modifiers, name, }: {
        constraint?: typescript.TypeNode;
        defaultType?: typescript.TypeNode;
        modifiers?: Array<typescript.Modifier>;
        name: string | typescript.Identifier;
    }) => typescript.TypeParameterDeclaration;
    typeParenthesizedNode: ({ type }: {
        type: typescript.TypeNode;
    }) => typescript.ParenthesizedTypeNode;
    typeRecordNode: (keys: (any | typescript.TypeNode)[], values: (any | typescript.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => typescript.TypeNode;
    typeReferenceNode: ({ typeArguments, typeName, }: {
        typeArguments?: typescript.TypeNode[];
        typeName: string | typescript.EntityName;
    }) => typescript.TypeReferenceNode;
    typeTupleNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: Array<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    typeUnionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: ReadonlyArray<any | typescript.TypeNode>;
    }) => typescript.TypeNode;
    valueToExpression: <T = unknown>({ identifiers, isValueAccess, shorthand, unescape, value, }: {
        identifiers?: string[];
        isValueAccess?: boolean;
        shorthand?: boolean;
        unescape?: boolean;
        value: T;
    }) => typescript.Expression | undefined;
};

declare const utils: {
    stringCase: ({ case: _case, stripLeadingSeparators, value, }: {
        readonly case: StringCase | undefined;
        stripLeadingSeparators?: boolean;
        value: string;
    }) => string;
};

type Configs = UserConfig | (() => UserConfig) | (() => Promise<UserConfig>);
/**
 * Generate a client from the provided configuration.
 *
 * @param userConfig User provided {@link UserConfig} configuration.
 */
declare const createClient: (userConfig?: Configs, logger?: Logger) => Promise<ReadonlyArray<Client$6 | IR.Context>>;
/**
 * Type helper for openapi-ts.config.ts, returns {@link UserConfig} object
 */
declare const defineConfig: (config: Configs) => Promise<UserConfig>;

export { type Client$4 as AngularClient, type Client$3 as AxiosClient, type Client$2 as FetchClient, IR, Logger, type Client$1 as NextClient, type Client as NuxtClient, Plugin, UserConfig, clientDefaultConfig, clientDefaultMeta, clientPluginHandler, compiler, createClient, defaultPaginationKeywords, defaultPlugins, defineConfig, definePluginConfig, tsc, utils };
