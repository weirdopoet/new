/**
 * Arbitrary metadata passed to render functions.
 *
 * Implementors should extend this interface for their own needs.
 */
interface ICodegenMeta {
  [key: string]: unknown;
}

interface ICodegenOutput {
  /**
   * The main content of the file to output.
   *
   * A raw string representing source code.
   *
   * @example "function foo(): void {\n  // implementation\n}\n"
   */
  content: string;
  /**
   * Optional metadata or hints for the emitter, such as formatting options,
   * source maps, or language-specific flags.
   *
   * @example { format: "prettier", sourceMap: true }
   */
  meta: Record<string, unknown>;
  /**
   * Logical output path (used for writing the file).
   *
   * @example "models/user.ts"
   */
  path: string;
}

interface ICodegenRenderer {
  /**
   * Optional: hook for renderer-level setup logic (e.g., formatting, config)
   */
  configure?(options: Record<string, unknown>): void;
  /**
   * Unique identifier for this renderer.
   *
   * @example "typescript"
   */
  id: string;
  /**
   * Returns printable data.
   *
   * @param file The file to render.
   * @param meta Arbitrary metadata.
   * @returns Output for file emit step
   */
  render(file: CodegenFile, meta?: ICodegenMeta): ICodegenOutput;
}

interface ICodegenSymbol {
  /**
   * Optional description or doc comment.
   *
   * @example "Represents a user in the system"
   */
  description?: string;
  /**
   * Optional kind of symbol (e.g. "class", "function", "type", etc.).
   *
   * @example "class"
   */
  kind?: string;
  /**
   * Unique identifier for the symbol within its file.
   *
   * @example "UserModel"
   */
  name: string;
  /**
   * Internal representation of the symbol (e.g. AST node, IR object, raw
   * code). Used to generate output.
   */
  value?: unknown;
}

interface ICodegenFile {
  /**
   * Adds an export to this file.
   *
   * This is also known as a re-export.
   *
   * @param exp The export to add
   */
  addExport(exp: ICodegenImport): void;
  /**
   * Adds an import to this file.
   *
   * @param imp The import to add
   */
  addImport(imp: ICodegenImport): void;
  /**
   * Adds a symbol defined by this file.
   *
   * @param symbol The symbol to add
   */
  addSymbol(symbol: ICodegenSymbol): void;
  /**
   * Symbols exported from other files.
   **/
  exports: ReadonlyArray<ICodegenImport>;
  /**
   * Returns all symbols used in this file (declared + imported).
   *
   * @returns List of all symbols used in this file
   */
  getAllSymbols(): ReadonlyArray<ICodegenSymbol>;
  /**
   * Checks if this file contains any content.
   *
   * This is used to determine whether we want to process the file further.
   * By default, we consider only symbols and exports as content.
   *
   * @returns True if the file contains content
   */
  hasContent(): boolean;
  /**
   * Checks if this file defines a symbol with the given name.
   *
   * @param name Symbol name to check
   * @returns True if the symbol is defined by this file
   */
  hasSymbol(name: string): boolean;
  /**
   * Symbols imported from other files.
   **/
  imports: ReadonlyArray<ICodegenImport>;
  /**
   * Optional metadata about the file.
   **/
  meta: {
    /**
     * Optional file extension.
     *
     * @example ".ts"
     */
    extension?: '.ts' | (string & {});
    /**
     * Optional logical module or package name.
     *
     * @example "models.user"
     */
    moduleName?: string;
    /**
     * Optional path transformer.
     *
     * @param path Original file path passed to the constructor.
     */
    path?: ((path: string) => string) | string;
    /**
     * Renderer ID.
     *
     * @example "typescript"
     */
    renderer?: ICodegenRenderer['id'];
  };
  /**
   * Logical output path (used for writing the file).
   *
   * @example "models/user.ts"
   */
  path: string;
  /**
   * Returns a relative path to this file from another file.
   *
   * @param file The file from which we want the relative path to this file.
   * @example "./this-file.ts"
   */
  relativePathFromFile(file: Pick<ICodegenFile, 'path'>): string;
  /**
   * Returns a relative path to file from this file.
   *
   * @param file The file to which we want the relative path.
   * @example "./another-file.ts"
   */
  relativePathToFile(file: Pick<ICodegenFile, 'path'>): string;
  /**
   * Top-level symbols declared in this file.
   **/
  symbols: ReadonlyArray<ICodegenSymbol>;
}

interface ICodegenImport {
  /**
   * Optional aliasing map for imported symbols.
   *
   * Keys must be a subset of `names`, values are aliases.
   *
   * @example { User: "ImportedUser" }
   */
  aliases?: Record<string, string>;
  /**
   * Name of the default import, if any.
   *
   * @example "React"
   */
  defaultImport?: string;
  /**
   * Source file or external module from which symbols are imported.
   *
   * For internal files, this should be a ICodegenFile instance to enable
   * dynamic path computation. For external or system modules, use a string.
   *
   * @example "./models/user"
   * @example "node:path"
   */
  from: ICodegenFile | string;
  /**
   * Names of the symbols imported from the source.
   *
   * Must be non-empty unless `isNamespaceImport` is true.
   * All imported names, regardless of whether they are used as types or values.
   *
   * @example ["User", "UserDTO"]
   */
  names?: ReadonlyArray<string>;
  /**
   * If this import is a namespace import (e.g. `import * as ns from "..."`),
   * this should be the namespace alias. Set to `true` if no alias is needed.
   *
   * @example "utils"
   * @example true
   */
  namespaceImport?: boolean | string;
  /**
   * Whether the default import is type-only.
   *
   * @example true
   */
  typeDefaultImport?: boolean;
  /**
   * Subset of `names` that are imported using the `type` modifier.
   * These symbols will be emitted as type-only imports in TypeScript.
   *
   * @example ["UserDTO"]
   */
  typeNames?: ReadonlyArray<string>;
  /**
   * Whether the namespace import is type-only.
   *
   * @example true
   */
  typeNamespaceImport?: boolean;
}

declare class CodegenFile implements ICodegenFile {
    path: string;
    meta: ICodegenFile['meta'];
    private cache;
    private state;
    constructor(path: string, meta?: ICodegenFile['meta']);
    addExport(exp: ICodegenImport): void;
    addImport(imp: ICodegenImport): void;
    private addImportExport;
    addSymbol(symbol: ICodegenSymbol): void;
    get exports(): ReadonlyArray<ICodegenImport>;
    getAllSymbols(): ReadonlyArray<ICodegenSymbol>;
    hasContent(): boolean;
    hasSymbol(name: string): boolean;
    get imports(): ReadonlyArray<ICodegenImport>;
    private mergeImportExportValues;
    static pathToFilePath(source: string): string;
    relativePathFromFile(file: Pick<ICodegenFile, 'path'>): string;
    relativePathToFile(file: Pick<ICodegenFile, 'path'>): string;
    get symbols(): ReadonlyArray<ICodegenSymbol>;
}

/**
 * Represents a code generation project consisting of multiple codegen files.
 * Manages imports, symbols, and output generation across the project.
 */
interface ICodegenProject {
  /**
   * Adds an export declaration to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the export.
   * @param imp - The export declaration to add.
   * @example
   * project.addExportToFile("models/user.ts", { from: "lib", names: ["User"] });
   */
  addExportToFile(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
  /**
   * Adds an import declaration to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the import.
   * @param imp - The import declaration to add.
   * @example
   * project.addImportToFile("models/user.ts", { from: "lib", names: ["User"] });
   */
  addImportToFile(fileOrPath: ICodegenFile | string, imp: ICodegenImport): void;
  /**
   * Adds a symbol to a specific file, creating the file if it doesn't exist.
   *
   * @param fileOrPath - File instance or file path where to add the symbol.
   * @param symbol - The symbol to add.
   * @example
   * project.addSymbolToFile("models/user.ts", { name: "User", value: tsNode });
   */
  addSymbolToFile(
    fileOrPath: ICodegenFile | string,
    symbol: ICodegenSymbol,
  ): void;
  /**
   * Creates a new codegen file with optional metadata and adds it to the project.
   *
   * If a file with the same path already exists, it is returned instead.
   *
   * @param path - The logical output path for the file (e.g. "models/user.ts").
   * @param meta - Optional renderer and metadata to attach to the file (e.g. { isInternal: true }).
   * @returns The newly created file instance.
   * @example
   * const file = project.createFile("models/user.ts", { isInternal: true });
   */
  createFile(
    path: string,
    meta?: ICodegenFile['meta'] & { renderer?: ICodegenRenderer },
  ): ICodegenFile;
  /**
   * Ensures a codegen file exists and returns it.
   *
   * If a file does not exist yet, it is created with minimal information.
   * Later, it is expected `createFile()` will be called which will fill in
   * the missing information such as optional metadata.
   *
   * @param fileOrPath - The logical output path for the file or the file itself.
   * @returns The file instance.
   * @example
   * const file = project.ensureFile("models/user.ts");
   */
  ensureFile(fileOrPath: ICodegenFile | string): ICodegenFile;
  /**
   * Returns all files in the project in insertion order.
   *
   * @example
   * project.files.forEach(file => console.log(file.path));
   */
  readonly files: ReadonlyArray<ICodegenFile>;
  /**
   * Returns all symbols declared or imported across all files.
   *
   * @returns Flattened list of all codegen symbols.
   * @example
   * project.getAllSymbols().filter(s => s.name === "User");
   */
  getAllSymbols(): ReadonlyArray<ICodegenSymbol>;
  /**
   * Retrieves a file by its logical output path.
   *
   * @param path - The file path to find.
   * @returns The file if found, or undefined otherwise.
   * @example
   * const file = project.getFileByPath("models/user.ts");
   */
  getFileByPath(path: string): ICodegenFile | undefined;
  /**
   * Produces output representations for all files in the project.
   *
   * @param meta Arbitrary metadata.
   * @returns Array of outputs ready for writing or further processing.
   * @example
   * project.render().forEach(output => writeFile(output));
   */
  render(meta?: ICodegenMeta): ReadonlyArray<ICodegenOutput>;
}

declare class CodegenProject implements ICodegenProject {
    private filesMap;
    private filesOrder;
    private renderers;
    addExportToFile(fileOrPath: CodegenFile | string, imp: ICodegenImport): void;
    addImportToFile(fileOrPath: CodegenFile | string, imp: ICodegenImport): void;
    addSymbolToFile(fileOrPath: CodegenFile | string, symbol: ICodegenSymbol): void;
    createFile(path: string, meta?: Omit<CodegenFile['meta'], 'renderer'> & {
        /**
         * Renderer to use to render this file.
         */
        renderer?: ICodegenRenderer;
    }): CodegenFile;
    ensureFile(fileOrPath: CodegenFile | string): CodegenFile;
    private ensureRenderer;
    get files(): ReadonlyArray<CodegenFile>;
    getAllSymbols(): ReadonlyArray<ICodegenSymbol>;
    getFileByPath(path: string): CodegenFile | undefined;
    render(meta?: ICodegenMeta): ReadonlyArray<ICodegenOutput>;
}

export { CodegenFile, CodegenProject, type ICodegenFile, type ICodegenImport, type ICodegenMeta, type ICodegenOutput, type ICodegenProject, type ICodegenRenderer, type ICodegenSymbol };
