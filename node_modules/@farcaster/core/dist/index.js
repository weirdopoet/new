"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// ../../node_modules/long/src/long.js
var require_long = __commonJS({
  "../../node_modules/long/src/long.js"(exports2, module2) {
    init_cjs_shims();
    module2.exports = Long9;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long9(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long9.prototype.__isLong__;
    Object.defineProperty(Long9.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long9.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long9.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long9.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long9(lowBits, highBits, unsigned);
    }
    Long9.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long9.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long9.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long9.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long9.UZERO = UZERO;
    var ONE = fromInt(1);
    Long9.ONE = ONE;
    var UONE = fromInt(1, true);
    Long9.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long9.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long9.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long9.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long9.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long9.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber2() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long9.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long9.fromBytesLE(bytes, unsigned) : Long9.fromBytesBE(bytes, unsigned);
    };
    Long9.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long9(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long9.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long9(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err10) {
          if (pending) {
            pending = false;
            if (err10)
              reject(err10);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err10) {
          if (pending) {
            pending = false;
            reject(err10);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber2(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask2 = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask2) >>> 0;
      this.lo = (this.lo << 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask2 = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask2) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask2) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject3(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet11(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge2;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err10, response) {
            if (err10) {
              self2.emit("error", err10, method);
              return callback(err10);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err11) {
                self2.emit("error", err11, method);
                return callback(err11);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err10) {
        self2.emit("error", err10, method);
        setTimeout(function() {
          callback(err10);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/lodash.mergewith/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.mergewith/index.js"(exports2, module2) {
    init_cjs_shims();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject3(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject3(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject3(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject3(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = mergeWith2;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BUNDLER_ADDRESS: () => BUNDLER_ADDRESS,
  BlockConfirmedBody: () => BlockConfirmedBody,
  BlockConfirmedBody_EventCountsByTypeEntry: () => BlockConfirmedBody_EventCountsByTypeEntry,
  BlocksRequest: () => BlocksRequest,
  BulkMessageResponse: () => BulkMessageResponse,
  CastAddBody: () => CastAddBody,
  CastId: () => CastId,
  CastRemoveBody: () => CastRemoveBody,
  CastType: () => CastType,
  CastsByParentRequest: () => CastsByParentRequest,
  ContactInfo: () => ContactInfo,
  ContactInfoBody: () => ContactInfoBody,
  DbStats: () => DbStats,
  DbTrieNode: () => DbTrieNode,
  DbTrieNode_ChildHashesEntry: () => DbTrieNode_ChildHashesEntry,
  Ed25519Signer: () => Ed25519Signer,
  Eip712Signer: () => Eip712Signer,
  Embed: () => Embed,
  EthersEip712Signer: () => EthersEip712Signer,
  EthersV5Eip712Signer: () => EthersV5Eip712Signer,
  EventRequest: () => EventRequest,
  EventsRequest: () => EventsRequest,
  EventsResponse: () => EventsResponse,
  FARCASTER_EPOCH: () => FARCASTER_EPOCH,
  Factories: () => Factories,
  FarcasterNetwork: () => FarcasterNetwork,
  FidAddressTypeRequest: () => FidAddressTypeRequest,
  FidAddressTypeResponse: () => FidAddressTypeResponse,
  FidRequest: () => FidRequest,
  FidTimestampRequest: () => FidTimestampRequest,
  FidsRequest: () => FidsRequest,
  FidsResponse: () => FidsResponse,
  FrameActionBody: () => FrameActionBody,
  GetConnectedPeersRequest: () => GetConnectedPeersRequest,
  GetConnectedPeersResponse: () => GetConnectedPeersResponse,
  GetInfoRequest: () => GetInfoRequest,
  GetInfoResponse: () => GetInfoResponse,
  GossipMessage: () => GossipMessage,
  HashScheme: () => HashScheme,
  HubError: () => HubError,
  HubEvent: () => HubEvent,
  HubEventType: () => HubEventType,
  HubState: () => HubState,
  ID_GATEWAY_ADDRESS: () => ID_GATEWAY_ADDRESS,
  ID_GATEWAY_EIP_712_DOMAIN: () => ID_GATEWAY_EIP_712_DOMAIN,
  ID_GATEWAY_EIP_712_TYPES: () => ID_GATEWAY_EIP_712_TYPES,
  ID_GATEWAY_REGISTER_TYPE: () => ID_GATEWAY_REGISTER_TYPE,
  ID_REGISTRY_ADDRESS: () => ID_REGISTRY_ADDRESS,
  ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE: () => ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE,
  ID_REGISTRY_EIP_712_DOMAIN: () => ID_REGISTRY_EIP_712_DOMAIN,
  ID_REGISTRY_EIP_712_TYPES: () => ID_REGISTRY_EIP_712_TYPES,
  ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE: () => ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE,
  ID_REGISTRY_TRANSFER_TYPE: () => ID_REGISTRY_TRANSFER_TYPE,
  IdRegisterEventBody: () => IdRegisterEventBody,
  IdRegisterEventType: () => IdRegisterEventType,
  IdRegistryEventByAddressRequest: () => IdRegistryEventByAddressRequest,
  KEY_GATEWAY_ADDRESS: () => KEY_GATEWAY_ADDRESS,
  KEY_GATEWAY_ADD_TYPE: () => KEY_GATEWAY_ADD_TYPE,
  KEY_GATEWAY_EIP_712_DOMAIN: () => KEY_GATEWAY_EIP_712_DOMAIN,
  KEY_GATEWAY_EIP_712_TYPES: () => KEY_GATEWAY_EIP_712_TYPES,
  KEY_REGISTRY_ADDRESS: () => KEY_REGISTRY_ADDRESS,
  KEY_REGISTRY_EIP_712_DOMAIN: () => KEY_REGISTRY_EIP_712_DOMAIN,
  KEY_REGISTRY_EIP_712_TYPES: () => KEY_REGISTRY_EIP_712_TYPES,
  KEY_REGISTRY_REMOVE_TYPE: () => KEY_REGISTRY_REMOVE_TYPE,
  LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP: () => LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP,
  LinkBody: () => LinkBody,
  LinkCompactStateBody: () => LinkCompactStateBody,
  LinkRequest: () => LinkRequest,
  LinksByFidRequest: () => LinksByFidRequest,
  LinksByTargetRequest: () => LinksByTargetRequest,
  MergeFailureBody: () => MergeFailureBody,
  MergeMessageBody: () => MergeMessageBody,
  MergeOnChainEventBody: () => MergeOnChainEventBody,
  MergeUserNameProofBody: () => MergeUserNameProofBody,
  Message: () => Message,
  MessageData: () => MessageData,
  MessageError: () => MessageError,
  MessageType: () => MessageType,
  MessagesResponse: () => MessagesResponse,
  NobleEd25519Signer: () => NobleEd25519Signer,
  OnChainEvent: () => OnChainEvent,
  OnChainEventRequest: () => OnChainEventRequest,
  OnChainEventResponse: () => OnChainEventResponse,
  OnChainEventType: () => OnChainEventType,
  Protocol: () => Protocol,
  PruneMessageBody: () => PruneMessageBody,
  ReactionBody: () => ReactionBody,
  ReactionRequest: () => ReactionRequest,
  ReactionType: () => ReactionType,
  ReactionsByFidRequest: () => ReactionsByFidRequest,
  ReactionsByTargetRequest: () => ReactionsByTargetRequest,
  RevokeMessageBody: () => RevokeMessageBody,
  RevokeMessagesBySignerJobPayload: () => RevokeMessagesBySignerJobPayload,
  SIGNED_KEY_REQUEST_TYPE: () => SIGNED_KEY_REQUEST_TYPE,
  SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS: () => SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN: () => SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES: () => SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
  STORAGE_REGISTRY_ADDRESS: () => STORAGE_REGISTRY_ADDRESS,
  ShardChunksRequest: () => ShardChunksRequest,
  ShardChunksResponse: () => ShardChunksResponse,
  ShardInfo: () => ShardInfo,
  SignatureScheme: () => SignatureScheme,
  SignerEventBody: () => SignerEventBody,
  SignerEventType: () => SignerEventType,
  SignerMigratedEventBody: () => SignerMigratedEventBody,
  SignerRequest: () => SignerRequest,
  StorageLimit: () => StorageLimit,
  StorageLimitsResponse: () => StorageLimitsResponse,
  StorageRentEventBody: () => StorageRentEventBody,
  StorageUnitDetails: () => StorageUnitDetails,
  StorageUnitType: () => StorageUnitType,
  StoreType: () => StoreType,
  SubmitBulkMessagesRequest: () => SubmitBulkMessagesRequest,
  SubmitBulkMessagesResponse: () => SubmitBulkMessagesResponse,
  SubscribeRequest: () => SubscribeRequest,
  TierDetails: () => TierDetails,
  TierPurchaseBody: () => TierPurchaseBody,
  TierType: () => TierType,
  TrieNodeMetadataRequest: () => TrieNodeMetadataRequest,
  TrieNodeMetadataResponse: () => TrieNodeMetadataResponse,
  UNIT_TYPE_2024__CUTOFF_TIMESTAMP: () => UNIT_TYPE_2024__CUTOFF_TIMESTAMP,
  UpdateNameRegistryEventExpiryJobPayload: () => UpdateNameRegistryEventExpiryJobPayload,
  UserDataBody: () => UserDataBody,
  UserDataRequest: () => UserDataRequest,
  UserDataType: () => UserDataType,
  UserNameProof: () => UserNameProof,
  UserNameType: () => UserNameType,
  UsernameProofRequest: () => UsernameProofRequest,
  UsernameProofsResponse: () => UsernameProofsResponse,
  ValidateOrRevokeJobState: () => ValidateOrRevokeJobState,
  ValidationResponse: () => ValidationResponse,
  VerificationAddAddressBody: () => VerificationAddAddressBody,
  VerificationRemoveBody: () => VerificationRemoveBody,
  VerificationRequest: () => VerificationRequest,
  ViemLocalEip712Signer: () => ViemLocalEip712Signer,
  ViemWalletEip712Signer: () => ViemWalletEip712Signer,
  base58ToBytes: () => base58ToBytes,
  bigIntToBytes: () => bigIntToBytes,
  bundlerABI: () => bundlerABI,
  bytesCompare: () => bytesCompare,
  bytesDecrement: () => bytesDecrement,
  bytesIncrement: () => bytesIncrement,
  bytesStartsWith: () => bytesStartsWith,
  bytesToBase58: () => bytesToBase58,
  bytesToBigInt: () => bytesToBigInt,
  bytesToHexString: () => bytesToHexString,
  bytesToUtf8String: () => bytesToUtf8String,
  castTypeFromJSON: () => castTypeFromJSON,
  castTypeToJSON: () => castTypeToJSON,
  chains: () => chains_exports,
  clients: () => clients_exports,
  ed25519: () => ed25519_exports,
  eip712: () => eip712_exports,
  extractEventTimestamp: () => extractEventTimestamp,
  extractTimestampFromEvent: () => extractTimestampFromEvent,
  farcasterNetworkFromJSON: () => farcasterNetworkFromJSON,
  farcasterNetworkToJSON: () => farcasterNetworkToJSON,
  fromFarcasterTime: () => fromFarcasterTime,
  getDefaultStoreLimit: () => getDefaultStoreLimit,
  getFarcasterTime: () => getFarcasterTime,
  getStorageExpiryTimestampFromBlockTimestamp: () => getStorageExpiryTimestampFromBlockTimestamp,
  getStorageUnitExpiry: () => getStorageUnitExpiry,
  getStorageUnitType: () => getStorageUnitType,
  getStoreLimit: () => getStoreLimit,
  getStoreLimits: () => getStoreLimits,
  hashSchemeFromJSON: () => hashSchemeFromJSON,
  hashSchemeToJSON: () => hashSchemeToJSON,
  hexStringToBytes: () => hexStringToBytes,
  hubEventTypeFromJSON: () => hubEventTypeFromJSON,
  hubEventTypeToJSON: () => hubEventTypeToJSON,
  idGatewayABI: () => idGatewayABI,
  idRegisterEventTypeFromJSON: () => idRegisterEventTypeFromJSON,
  idRegisterEventTypeToJSON: () => idRegisterEventTypeToJSON,
  idRegistryABI: () => idRegistryABI,
  isBlockConfirmedHubEvent: () => isBlockConfirmedHubEvent,
  isCastAddData: () => isCastAddData,
  isCastAddMessage: () => isCastAddMessage,
  isCastRemoveData: () => isCastRemoveData,
  isCastRemoveMessage: () => isCastRemoveMessage,
  isFrameActionData: () => isFrameActionData,
  isFrameActionMessage: () => isFrameActionMessage,
  isHubError: () => isHubError,
  isIdRegisterOnChainEvent: () => isIdRegisterOnChainEvent,
  isLinkAddData: () => isLinkAddData,
  isLinkAddMessage: () => isLinkAddMessage,
  isLinkCompactStateMessage: () => isLinkCompactStateMessage,
  isLinkRemoveData: () => isLinkRemoveData,
  isLinkRemoveMessage: () => isLinkRemoveMessage,
  isMergeFailureHubEvent: () => isMergeFailureHubEvent,
  isMergeMessageHubEvent: () => isMergeMessageHubEvent,
  isMergeOnChainHubEvent: () => isMergeOnChainHubEvent,
  isMergeUsernameProofHubEvent: () => isMergeUsernameProofHubEvent,
  isPruneMessageHubEvent: () => isPruneMessageHubEvent,
  isReactionAddData: () => isReactionAddData,
  isReactionAddMessage: () => isReactionAddMessage,
  isReactionRemoveData: () => isReactionRemoveData,
  isReactionRemoveMessage: () => isReactionRemoveMessage,
  isRevokeMessageHubEvent: () => isRevokeMessageHubEvent,
  isSignerMigratedOnChainEvent: () => isSignerMigratedOnChainEvent,
  isSignerOnChainEvent: () => isSignerOnChainEvent,
  isStorageRentOnChainEvent: () => isStorageRentOnChainEvent,
  isTierPurchaseOnChainEvent: () => isTierPurchaseOnChainEvent,
  isUserDataAddData: () => isUserDataAddData,
  isUserDataAddMessage: () => isUserDataAddMessage,
  isUsernameProofData: () => isUsernameProofData,
  isUsernameProofMessage: () => isUsernameProofMessage,
  isVerificationAddAddressData: () => isVerificationAddAddressData,
  isVerificationAddAddressMessage: () => isVerificationAddAddressMessage,
  isVerificationRemoveData: () => isVerificationRemoveData,
  isVerificationRemoveMessage: () => isVerificationRemoveMessage,
  keyGatewayABI: () => keyGatewayABI,
  keyRegistryABI: () => keyRegistryABI,
  makeCastAdd: () => makeCastAdd,
  makeCastAddData: () => makeCastAddData,
  makeCastRemove: () => makeCastRemove,
  makeCastRemoveData: () => makeCastRemoveData,
  makeEventId: () => makeEventId,
  makeFrameAction: () => makeFrameAction,
  makeFrameActionData: () => makeFrameActionData,
  makeLinkAdd: () => makeLinkAdd,
  makeLinkAddData: () => makeLinkAddData,
  makeLinkCompactState: () => makeLinkCompactState,
  makeLinkCompactStateData: () => makeLinkCompactStateData,
  makeLinkRemove: () => makeLinkRemove,
  makeLinkRemoveData: () => makeLinkRemoveData,
  makeMessage: () => makeMessage,
  makeMessageHash: () => makeMessageHash,
  makeMessageWithSignature: () => makeMessageWithSignature,
  makeReactionAdd: () => makeReactionAdd,
  makeReactionAddData: () => makeReactionAddData,
  makeReactionRemove: () => makeReactionRemove,
  makeReactionRemoveData: () => makeReactionRemoveData,
  makeUserDataAdd: () => makeUserDataAdd,
  makeUserDataAddData: () => makeUserDataAddData,
  makeUserNameProofClaim: () => makeUserNameProofClaim,
  makeUsernameProof: () => makeUsernameProof,
  makeUsernameProofData: () => makeUsernameProofData,
  makeVerificationAddEthAddress: () => makeVerificationAddEthAddress,
  makeVerificationAddEthAddressData: () => makeVerificationAddEthAddressData,
  makeVerificationAddressClaim: () => makeVerificationAddressClaim,
  makeVerificationRemove: () => makeVerificationRemove,
  makeVerificationRemoveData: () => makeVerificationRemoveData,
  messageTypeFromJSON: () => messageTypeFromJSON,
  messageTypeToJSON: () => messageTypeToJSON,
  onChainEventTypeFromJSON: () => onChainEventTypeFromJSON,
  onChainEventTypeToJSON: () => onChainEventTypeToJSON,
  protocolFromJSON: () => protocolFromJSON,
  protocolToJSON: () => protocolToJSON,
  reactionTypeFromJSON: () => reactionTypeFromJSON,
  reactionTypeToJSON: () => reactionTypeToJSON,
  recreateSolanaClaimMessage: () => recreateSolanaClaimMessage,
  signatureSchemeFromJSON: () => signatureSchemeFromJSON,
  signatureSchemeToJSON: () => signatureSchemeToJSON,
  signedKeyRequestValidatorABI: () => signedKeyRequestValidatorABI,
  signerEventTypeFromJSON: () => signerEventTypeFromJSON,
  signerEventTypeToJSON: () => signerEventTypeToJSON,
  storageRegistryABI: () => storageRegistryABI,
  storageUnitTypeFromJSON: () => storageUnitTypeFromJSON,
  storageUnitTypeToJSON: () => storageUnitTypeToJSON,
  storeTypeFromJSON: () => storeTypeFromJSON,
  storeTypeToJSON: () => storeTypeToJSON,
  tierTypeFromJSON: () => tierTypeFromJSON,
  tierTypeToJSON: () => tierTypeToJSON,
  toFarcasterTime: () => toFarcasterTime,
  userDataTypeFromJSON: () => userDataTypeFromJSON,
  userDataTypeToJSON: () => userDataTypeToJSON,
  userNameTypeFromJSON: () => userNameTypeFromJSON,
  userNameTypeToJSON: () => userNameTypeToJSON,
  utf8StringToBytes: () => utf8StringToBytes,
  validations: () => validations_exports,
  verifyAdd: () => verifyAdd,
  verifyChangeRecoveryAddress: () => verifyChangeRecoveryAddress,
  verifyKeyRequest: () => verifyKeyRequest,
  verifyRegister: () => verifyRegister,
  verifyRemove: () => verifyRemove,
  verifyTransfer: () => verifyTransfer,
  verifyTransferAndChangeRecovery: () => verifyTransferAndChangeRecovery
});
module.exports = __toCommonJS(src_exports);
init_cjs_shims();

// src/protobufs/index.ts
init_cjs_shims();

// src/protobufs/generated/gossip.ts
init_cjs_shims();
var import_long5 = __toESM(require_long());
var import_minimal5 = __toESM(require_minimal2());

// src/protobufs/generated/blocks.ts
init_cjs_shims();
var import_long4 = __toESM(require_long());
var import_minimal4 = __toESM(require_minimal2());

// src/protobufs/generated/message.ts
init_cjs_shims();
var import_long2 = __toESM(require_long());
var import_minimal2 = __toESM(require_minimal2());

// src/protobufs/generated/username_proof.ts
init_cjs_shims();
var import_long = __toESM(require_long());
var import_minimal = __toESM(require_minimal2());
var UserNameType = /* @__PURE__ */ ((UserNameType2) => {
  UserNameType2[UserNameType2["USERNAME_TYPE_NONE"] = 0] = "USERNAME_TYPE_NONE";
  UserNameType2[UserNameType2["USERNAME_TYPE_FNAME"] = 1] = "USERNAME_TYPE_FNAME";
  UserNameType2[UserNameType2["USERNAME_TYPE_ENS_L1"] = 2] = "USERNAME_TYPE_ENS_L1";
  UserNameType2[UserNameType2["USERNAME_TYPE_BASENAME"] = 3] = "USERNAME_TYPE_BASENAME";
  return UserNameType2;
})(UserNameType || {});
function userNameTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USERNAME_TYPE_NONE":
      return 0 /* USERNAME_TYPE_NONE */;
    case 1:
    case "USERNAME_TYPE_FNAME":
      return 1 /* USERNAME_TYPE_FNAME */;
    case 2:
    case "USERNAME_TYPE_ENS_L1":
      return 2 /* USERNAME_TYPE_ENS_L1 */;
    case 3:
    case "USERNAME_TYPE_BASENAME":
      return 3 /* USERNAME_TYPE_BASENAME */;
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum UserNameType");
  }
}
function userNameTypeToJSON(object) {
  switch (object) {
    case 0 /* USERNAME_TYPE_NONE */:
      return "USERNAME_TYPE_NONE";
    case 1 /* USERNAME_TYPE_FNAME */:
      return "USERNAME_TYPE_FNAME";
    case 2 /* USERNAME_TYPE_ENS_L1 */:
      return "USERNAME_TYPE_ENS_L1";
    case 3 /* USERNAME_TYPE_BASENAME */:
      return "USERNAME_TYPE_BASENAME";
    default:
      throw new tsProtoGlobalThis.Error("Unrecognized enum value " + object + " for enum UserNameType");
  }
}
function createBaseUserNameProof() {
  return {
    timestamp: 0,
    name: new Uint8Array(),
    owner: new Uint8Array(),
    signature: new Uint8Array(),
    fid: 0,
    type: 0
  };
}
var UserNameProof = {
  encode(message, writer = import_minimal.default.Writer.create()) {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.name.length !== 0) {
      writer.uint32(18).bytes(message.name);
    }
    if (message.owner.length !== 0) {
      writer.uint32(26).bytes(message.owner);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.fid !== 0) {
      writer.uint32(40).uint64(message.fid);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserNameProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.timestamp = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.name = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.owner = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.signature = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.fid = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      timestamp: isSet(object.timestamp) ? Number(object.timestamp) : 0,
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(),
      owner: isSet(object.owner) ? bytesFromBase64(object.owner) : new Uint8Array(),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
      fid: isSet(object.fid) ? Number(object.fid) : 0,
      type: isSet(object.type) ? userNameTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.name !== void 0 && (obj.name = base64FromBytes(message.name !== void 0 ? message.name : new Uint8Array()));
    message.owner !== void 0 && (obj.owner = base64FromBytes(message.owner !== void 0 ? message.owner : new Uint8Array()));
    message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.type !== void 0 && (obj.type = userNameTypeToJSON(message.type));
    return obj;
  },
  create(base) {
    return UserNameProof.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseUserNameProof();
    message.timestamp = (_a = object.timestamp) != null ? _a : 0;
    message.name = (_b = object.name) != null ? _b : new Uint8Array();
    message.owner = (_c = object.owner) != null ? _c : new Uint8Array();
    message.signature = (_d = object.signature) != null ? _d : new Uint8Array();
    message.fid = (_e = object.fid) != null ? _e : 0;
    message.type = (_f = object.type) != null ? _f : 0;
    return message;
  }
};
var tsProtoGlobalThis = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}
function longToNumber(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal.default.util.Long !== import_long.default) {
  import_minimal.default.util.Long = import_long.default;
  import_minimal.default.configure();
}
function isSet(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/message.ts
var HashScheme = /* @__PURE__ */ ((HashScheme2) => {
  HashScheme2[HashScheme2["NONE"] = 0] = "NONE";
  HashScheme2[HashScheme2["BLAKE3"] = 1] = "BLAKE3";
  return HashScheme2;
})(HashScheme || {});
function hashSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "HASH_SCHEME_NONE":
      return 0 /* NONE */;
    case 1:
    case "HASH_SCHEME_BLAKE3":
      return 1 /* BLAKE3 */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum HashScheme");
  }
}
function hashSchemeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "HASH_SCHEME_NONE";
    case 1 /* BLAKE3 */:
      return "HASH_SCHEME_BLAKE3";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum HashScheme");
  }
}
var SignatureScheme = /* @__PURE__ */ ((SignatureScheme2) => {
  SignatureScheme2[SignatureScheme2["NONE"] = 0] = "NONE";
  SignatureScheme2[SignatureScheme2["ED25519"] = 1] = "ED25519";
  SignatureScheme2[SignatureScheme2["EIP712"] = 2] = "EIP712";
  return SignatureScheme2;
})(SignatureScheme || {});
function signatureSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "SIGNATURE_SCHEME_NONE":
      return 0 /* NONE */;
    case 1:
    case "SIGNATURE_SCHEME_ED25519":
      return 1 /* ED25519 */;
    case 2:
    case "SIGNATURE_SCHEME_EIP712":
      return 2 /* EIP712 */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum SignatureScheme");
  }
}
function signatureSchemeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "SIGNATURE_SCHEME_NONE";
    case 1 /* ED25519 */:
      return "SIGNATURE_SCHEME_ED25519";
    case 2 /* EIP712 */:
      return "SIGNATURE_SCHEME_EIP712";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum SignatureScheme");
  }
}
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["NONE"] = 0] = "NONE";
  MessageType2[MessageType2["CAST_ADD"] = 1] = "CAST_ADD";
  MessageType2[MessageType2["CAST_REMOVE"] = 2] = "CAST_REMOVE";
  MessageType2[MessageType2["REACTION_ADD"] = 3] = "REACTION_ADD";
  MessageType2[MessageType2["REACTION_REMOVE"] = 4] = "REACTION_REMOVE";
  MessageType2[MessageType2["LINK_ADD"] = 5] = "LINK_ADD";
  MessageType2[MessageType2["LINK_REMOVE"] = 6] = "LINK_REMOVE";
  MessageType2[MessageType2["VERIFICATION_ADD_ETH_ADDRESS"] = 7] = "VERIFICATION_ADD_ETH_ADDRESS";
  MessageType2[MessageType2["VERIFICATION_REMOVE"] = 8] = "VERIFICATION_REMOVE";
  MessageType2[MessageType2["USER_DATA_ADD"] = 11] = "USER_DATA_ADD";
  MessageType2[MessageType2["USERNAME_PROOF"] = 12] = "USERNAME_PROOF";
  MessageType2[MessageType2["FRAME_ACTION"] = 13] = "FRAME_ACTION";
  MessageType2[MessageType2["LINK_COMPACT_STATE"] = 14] = "LINK_COMPACT_STATE";
  return MessageType2;
})(MessageType || {});
function messageTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "MESSAGE_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "MESSAGE_TYPE_CAST_ADD":
      return 1 /* CAST_ADD */;
    case 2:
    case "MESSAGE_TYPE_CAST_REMOVE":
      return 2 /* CAST_REMOVE */;
    case 3:
    case "MESSAGE_TYPE_REACTION_ADD":
      return 3 /* REACTION_ADD */;
    case 4:
    case "MESSAGE_TYPE_REACTION_REMOVE":
      return 4 /* REACTION_REMOVE */;
    case 5:
    case "MESSAGE_TYPE_LINK_ADD":
      return 5 /* LINK_ADD */;
    case 6:
    case "MESSAGE_TYPE_LINK_REMOVE":
      return 6 /* LINK_REMOVE */;
    case 7:
    case "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS":
      return 7 /* VERIFICATION_ADD_ETH_ADDRESS */;
    case 8:
    case "MESSAGE_TYPE_VERIFICATION_REMOVE":
      return 8 /* VERIFICATION_REMOVE */;
    case 11:
    case "MESSAGE_TYPE_USER_DATA_ADD":
      return 11 /* USER_DATA_ADD */;
    case 12:
    case "MESSAGE_TYPE_USERNAME_PROOF":
      return 12 /* USERNAME_PROOF */;
    case 13:
    case "MESSAGE_TYPE_FRAME_ACTION":
      return 13 /* FRAME_ACTION */;
    case 14:
    case "MESSAGE_TYPE_LINK_COMPACT_STATE":
      return 14 /* LINK_COMPACT_STATE */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum MessageType");
  }
}
function messageTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "MESSAGE_TYPE_NONE";
    case 1 /* CAST_ADD */:
      return "MESSAGE_TYPE_CAST_ADD";
    case 2 /* CAST_REMOVE */:
      return "MESSAGE_TYPE_CAST_REMOVE";
    case 3 /* REACTION_ADD */:
      return "MESSAGE_TYPE_REACTION_ADD";
    case 4 /* REACTION_REMOVE */:
      return "MESSAGE_TYPE_REACTION_REMOVE";
    case 5 /* LINK_ADD */:
      return "MESSAGE_TYPE_LINK_ADD";
    case 6 /* LINK_REMOVE */:
      return "MESSAGE_TYPE_LINK_REMOVE";
    case 7 /* VERIFICATION_ADD_ETH_ADDRESS */:
      return "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS";
    case 8 /* VERIFICATION_REMOVE */:
      return "MESSAGE_TYPE_VERIFICATION_REMOVE";
    case 11 /* USER_DATA_ADD */:
      return "MESSAGE_TYPE_USER_DATA_ADD";
    case 12 /* USERNAME_PROOF */:
      return "MESSAGE_TYPE_USERNAME_PROOF";
    case 13 /* FRAME_ACTION */:
      return "MESSAGE_TYPE_FRAME_ACTION";
    case 14 /* LINK_COMPACT_STATE */:
      return "MESSAGE_TYPE_LINK_COMPACT_STATE";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum MessageType");
  }
}
var FarcasterNetwork = /* @__PURE__ */ ((FarcasterNetwork5) => {
  FarcasterNetwork5[FarcasterNetwork5["NONE"] = 0] = "NONE";
  FarcasterNetwork5[FarcasterNetwork5["MAINNET"] = 1] = "MAINNET";
  FarcasterNetwork5[FarcasterNetwork5["TESTNET"] = 2] = "TESTNET";
  FarcasterNetwork5[FarcasterNetwork5["DEVNET"] = 3] = "DEVNET";
  return FarcasterNetwork5;
})(FarcasterNetwork || {});
function farcasterNetworkFromJSON(object) {
  switch (object) {
    case 0:
    case "FARCASTER_NETWORK_NONE":
      return 0 /* NONE */;
    case 1:
    case "FARCASTER_NETWORK_MAINNET":
      return 1 /* MAINNET */;
    case 2:
    case "FARCASTER_NETWORK_TESTNET":
      return 2 /* TESTNET */;
    case 3:
    case "FARCASTER_NETWORK_DEVNET":
      return 3 /* DEVNET */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum FarcasterNetwork");
  }
}
function farcasterNetworkToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "FARCASTER_NETWORK_NONE";
    case 1 /* MAINNET */:
      return "FARCASTER_NETWORK_MAINNET";
    case 2 /* TESTNET */:
      return "FARCASTER_NETWORK_TESTNET";
    case 3 /* DEVNET */:
      return "FARCASTER_NETWORK_DEVNET";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum FarcasterNetwork");
  }
}
var UserDataType = /* @__PURE__ */ ((UserDataType3) => {
  UserDataType3[UserDataType3["NONE"] = 0] = "NONE";
  UserDataType3[UserDataType3["PFP"] = 1] = "PFP";
  UserDataType3[UserDataType3["DISPLAY"] = 2] = "DISPLAY";
  UserDataType3[UserDataType3["BIO"] = 3] = "BIO";
  UserDataType3[UserDataType3["URL"] = 5] = "URL";
  UserDataType3[UserDataType3["USERNAME"] = 6] = "USERNAME";
  UserDataType3[UserDataType3["LOCATION"] = 7] = "LOCATION";
  UserDataType3[UserDataType3["TWITTER"] = 8] = "TWITTER";
  UserDataType3[UserDataType3["GITHUB"] = 9] = "GITHUB";
  UserDataType3[UserDataType3["BANNER"] = 10] = "BANNER";
  UserDataType3[UserDataType3["USER_DATA_PRIMARY_ADDRESS_ETHEREUM"] = 11] = "USER_DATA_PRIMARY_ADDRESS_ETHEREUM";
  UserDataType3[UserDataType3["USER_DATA_PRIMARY_ADDRESS_SOLANA"] = 12] = "USER_DATA_PRIMARY_ADDRESS_SOLANA";
  return UserDataType3;
})(UserDataType || {});
function userDataTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "USER_DATA_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "USER_DATA_TYPE_PFP":
      return 1 /* PFP */;
    case 2:
    case "USER_DATA_TYPE_DISPLAY":
      return 2 /* DISPLAY */;
    case 3:
    case "USER_DATA_TYPE_BIO":
      return 3 /* BIO */;
    case 5:
    case "USER_DATA_TYPE_URL":
      return 5 /* URL */;
    case 6:
    case "USER_DATA_TYPE_USERNAME":
      return 6 /* USERNAME */;
    case 7:
    case "USER_DATA_TYPE_LOCATION":
      return 7 /* LOCATION */;
    case 8:
    case "USER_DATA_TYPE_TWITTER":
      return 8 /* TWITTER */;
    case 9:
    case "USER_DATA_TYPE_GITHUB":
      return 9 /* GITHUB */;
    case 10:
    case "USER_DATA_TYPE_BANNER":
      return 10 /* BANNER */;
    case 11:
    case "USER_DATA_PRIMARY_ADDRESS_ETHEREUM":
      return 11 /* USER_DATA_PRIMARY_ADDRESS_ETHEREUM */;
    case 12:
    case "USER_DATA_PRIMARY_ADDRESS_SOLANA":
      return 12 /* USER_DATA_PRIMARY_ADDRESS_SOLANA */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum UserDataType");
  }
}
function userDataTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "USER_DATA_TYPE_NONE";
    case 1 /* PFP */:
      return "USER_DATA_TYPE_PFP";
    case 2 /* DISPLAY */:
      return "USER_DATA_TYPE_DISPLAY";
    case 3 /* BIO */:
      return "USER_DATA_TYPE_BIO";
    case 5 /* URL */:
      return "USER_DATA_TYPE_URL";
    case 6 /* USERNAME */:
      return "USER_DATA_TYPE_USERNAME";
    case 7 /* LOCATION */:
      return "USER_DATA_TYPE_LOCATION";
    case 8 /* TWITTER */:
      return "USER_DATA_TYPE_TWITTER";
    case 9 /* GITHUB */:
      return "USER_DATA_TYPE_GITHUB";
    case 10 /* BANNER */:
      return "USER_DATA_TYPE_BANNER";
    case 11 /* USER_DATA_PRIMARY_ADDRESS_ETHEREUM */:
      return "USER_DATA_PRIMARY_ADDRESS_ETHEREUM";
    case 12 /* USER_DATA_PRIMARY_ADDRESS_SOLANA */:
      return "USER_DATA_PRIMARY_ADDRESS_SOLANA";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum UserDataType");
  }
}
var CastType = /* @__PURE__ */ ((CastType2) => {
  CastType2[CastType2["CAST"] = 0] = "CAST";
  CastType2[CastType2["LONG_CAST"] = 1] = "LONG_CAST";
  CastType2[CastType2["TEN_K_CAST"] = 2] = "TEN_K_CAST";
  return CastType2;
})(CastType || {});
function castTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "CAST":
      return 0 /* CAST */;
    case 1:
    case "LONG_CAST":
      return 1 /* LONG_CAST */;
    case 2:
    case "TEN_K_CAST":
      return 2 /* TEN_K_CAST */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum CastType");
  }
}
function castTypeToJSON(object) {
  switch (object) {
    case 0 /* CAST */:
      return "CAST";
    case 1 /* LONG_CAST */:
      return "LONG_CAST";
    case 2 /* TEN_K_CAST */:
      return "TEN_K_CAST";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum CastType");
  }
}
var ReactionType = /* @__PURE__ */ ((ReactionType3) => {
  ReactionType3[ReactionType3["NONE"] = 0] = "NONE";
  ReactionType3[ReactionType3["LIKE"] = 1] = "LIKE";
  ReactionType3[ReactionType3["RECAST"] = 2] = "RECAST";
  return ReactionType3;
})(ReactionType || {});
function reactionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "REACTION_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "REACTION_TYPE_LIKE":
      return 1 /* LIKE */;
    case 2:
    case "REACTION_TYPE_RECAST":
      return 2 /* RECAST */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum ReactionType");
  }
}
function reactionTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "REACTION_TYPE_NONE";
    case 1 /* LIKE */:
      return "REACTION_TYPE_LIKE";
    case 2 /* RECAST */:
      return "REACTION_TYPE_RECAST";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum ReactionType");
  }
}
var Protocol = /* @__PURE__ */ ((Protocol2) => {
  Protocol2[Protocol2["ETHEREUM"] = 0] = "ETHEREUM";
  Protocol2[Protocol2["SOLANA"] = 1] = "SOLANA";
  return Protocol2;
})(Protocol || {});
function protocolFromJSON(object) {
  switch (object) {
    case 0:
    case "PROTOCOL_ETHEREUM":
      return 0 /* ETHEREUM */;
    case 1:
    case "PROTOCOL_SOLANA":
      return 1 /* SOLANA */;
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum Protocol");
  }
}
function protocolToJSON(object) {
  switch (object) {
    case 0 /* ETHEREUM */:
      return "PROTOCOL_ETHEREUM";
    case 1 /* SOLANA */:
      return "PROTOCOL_SOLANA";
    default:
      throw new tsProtoGlobalThis2.Error("Unrecognized enum value " + object + " for enum Protocol");
  }
}
function createBaseMessage() {
  return {
    data: void 0,
    hash: new Uint8Array(),
    hashScheme: 0,
    signature: new Uint8Array(),
    signatureScheme: 0,
    signer: new Uint8Array(),
    dataBytes: void 0
  };
}
var Message = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.data !== void 0) {
      MessageData.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.hashScheme !== 0) {
      writer.uint32(24).int32(message.hashScheme);
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.signatureScheme !== 0) {
      writer.uint32(40).int32(message.signatureScheme);
    }
    if (message.signer.length !== 0) {
      writer.uint32(50).bytes(message.signer);
    }
    if (message.dataBytes !== void 0) {
      writer.uint32(58).bytes(message.dataBytes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.data = MessageData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.hashScheme = reader.int32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.signature = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.signatureScheme = reader.int32();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.signer = reader.bytes();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.dataBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet2(object.data) ? MessageData.fromJSON(object.data) : void 0,
      hash: isSet2(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array(),
      hashScheme: isSet2(object.hashScheme) ? hashSchemeFromJSON(object.hashScheme) : 0,
      signature: isSet2(object.signature) ? bytesFromBase642(object.signature) : new Uint8Array(),
      signatureScheme: isSet2(object.signatureScheme) ? signatureSchemeFromJSON(object.signatureScheme) : 0,
      signer: isSet2(object.signer) ? bytesFromBase642(object.signer) : new Uint8Array(),
      dataBytes: isSet2(object.dataBytes) ? bytesFromBase642(object.dataBytes) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.data !== void 0 && (obj.data = message.data ? MessageData.toJSON(message.data) : void 0);
    message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.hashScheme !== void 0 && (obj.hashScheme = hashSchemeToJSON(message.hashScheme));
    message.signature !== void 0 && (obj.signature = base64FromBytes2(message.signature !== void 0 ? message.signature : new Uint8Array()));
    message.signatureScheme !== void 0 && (obj.signatureScheme = signatureSchemeToJSON(message.signatureScheme));
    message.signer !== void 0 && (obj.signer = base64FromBytes2(message.signer !== void 0 ? message.signer : new Uint8Array()));
    message.dataBytes !== void 0 && (obj.dataBytes = message.dataBytes !== void 0 ? base64FromBytes2(message.dataBytes) : void 0);
    return obj;
  },
  create(base) {
    return Message.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseMessage();
    message.data = object.data !== void 0 && object.data !== null ? MessageData.fromPartial(object.data) : void 0;
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.hashScheme = (_b = object.hashScheme) != null ? _b : 0;
    message.signature = (_c = object.signature) != null ? _c : new Uint8Array();
    message.signatureScheme = (_d = object.signatureScheme) != null ? _d : 0;
    message.signer = (_e = object.signer) != null ? _e : new Uint8Array();
    message.dataBytes = (_f = object.dataBytes) != null ? _f : void 0;
    return message;
  }
};
function createBaseMessageData() {
  return {
    type: 0,
    fid: 0,
    timestamp: 0,
    network: 0,
    castAddBody: void 0,
    castRemoveBody: void 0,
    reactionBody: void 0,
    verificationAddAddressBody: void 0,
    verificationRemoveBody: void 0,
    userDataBody: void 0,
    linkBody: void 0,
    usernameProofBody: void 0,
    frameActionBody: void 0,
    linkCompactStateBody: void 0
  };
}
var MessageData = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.fid !== 0) {
      writer.uint32(16).uint64(message.fid);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.network !== 0) {
      writer.uint32(32).int32(message.network);
    }
    if (message.castAddBody !== void 0) {
      CastAddBody.encode(message.castAddBody, writer.uint32(42).fork()).ldelim();
    }
    if (message.castRemoveBody !== void 0) {
      CastRemoveBody.encode(message.castRemoveBody, writer.uint32(50).fork()).ldelim();
    }
    if (message.reactionBody !== void 0) {
      ReactionBody.encode(message.reactionBody, writer.uint32(58).fork()).ldelim();
    }
    if (message.verificationAddAddressBody !== void 0) {
      VerificationAddAddressBody.encode(message.verificationAddAddressBody, writer.uint32(74).fork()).ldelim();
    }
    if (message.verificationRemoveBody !== void 0) {
      VerificationRemoveBody.encode(message.verificationRemoveBody, writer.uint32(82).fork()).ldelim();
    }
    if (message.userDataBody !== void 0) {
      UserDataBody.encode(message.userDataBody, writer.uint32(98).fork()).ldelim();
    }
    if (message.linkBody !== void 0) {
      LinkBody.encode(message.linkBody, writer.uint32(114).fork()).ldelim();
    }
    if (message.usernameProofBody !== void 0) {
      UserNameProof.encode(message.usernameProofBody, writer.uint32(122).fork()).ldelim();
    }
    if (message.frameActionBody !== void 0) {
      FrameActionBody.encode(message.frameActionBody, writer.uint32(130).fork()).ldelim();
    }
    if (message.linkCompactStateBody !== void 0) {
      LinkCompactStateBody.encode(message.linkCompactStateBody, writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.fid = longToNumber2(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.network = reader.int32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.castAddBody = CastAddBody.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.castRemoveBody = CastRemoveBody.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.reactionBody = ReactionBody.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.verificationAddAddressBody = VerificationAddAddressBody.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.verificationRemoveBody = VerificationRemoveBody.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.userDataBody = UserDataBody.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag != 114) {
            break;
          }
          message.linkBody = LinkBody.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag != 122) {
            break;
          }
          message.usernameProofBody = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag != 130) {
            break;
          }
          message.frameActionBody = FrameActionBody.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag != 138) {
            break;
          }
          message.linkCompactStateBody = LinkCompactStateBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? messageTypeFromJSON(object.type) : 0,
      fid: isSet2(object.fid) ? Number(object.fid) : 0,
      timestamp: isSet2(object.timestamp) ? Number(object.timestamp) : 0,
      network: isSet2(object.network) ? farcasterNetworkFromJSON(object.network) : 0,
      castAddBody: isSet2(object.castAddBody) ? CastAddBody.fromJSON(object.castAddBody) : void 0,
      castRemoveBody: isSet2(object.castRemoveBody) ? CastRemoveBody.fromJSON(object.castRemoveBody) : void 0,
      reactionBody: isSet2(object.reactionBody) ? ReactionBody.fromJSON(object.reactionBody) : void 0,
      verificationAddAddressBody: isSet2(object.verificationAddAddressBody) ? VerificationAddAddressBody.fromJSON(object.verificationAddAddressBody) : void 0,
      verificationRemoveBody: isSet2(object.verificationRemoveBody) ? VerificationRemoveBody.fromJSON(object.verificationRemoveBody) : void 0,
      userDataBody: isSet2(object.userDataBody) ? UserDataBody.fromJSON(object.userDataBody) : void 0,
      linkBody: isSet2(object.linkBody) ? LinkBody.fromJSON(object.linkBody) : void 0,
      usernameProofBody: isSet2(object.usernameProofBody) ? UserNameProof.fromJSON(object.usernameProofBody) : void 0,
      frameActionBody: isSet2(object.frameActionBody) ? FrameActionBody.fromJSON(object.frameActionBody) : void 0,
      linkCompactStateBody: isSet2(object.linkCompactStateBody) ? LinkCompactStateBody.fromJSON(object.linkCompactStateBody) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = messageTypeToJSON(message.type));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.network !== void 0 && (obj.network = farcasterNetworkToJSON(message.network));
    message.castAddBody !== void 0 && (obj.castAddBody = message.castAddBody ? CastAddBody.toJSON(message.castAddBody) : void 0);
    message.castRemoveBody !== void 0 && (obj.castRemoveBody = message.castRemoveBody ? CastRemoveBody.toJSON(message.castRemoveBody) : void 0);
    message.reactionBody !== void 0 && (obj.reactionBody = message.reactionBody ? ReactionBody.toJSON(message.reactionBody) : void 0);
    message.verificationAddAddressBody !== void 0 && (obj.verificationAddAddressBody = message.verificationAddAddressBody ? VerificationAddAddressBody.toJSON(message.verificationAddAddressBody) : void 0);
    message.verificationRemoveBody !== void 0 && (obj.verificationRemoveBody = message.verificationRemoveBody ? VerificationRemoveBody.toJSON(message.verificationRemoveBody) : void 0);
    message.userDataBody !== void 0 && (obj.userDataBody = message.userDataBody ? UserDataBody.toJSON(message.userDataBody) : void 0);
    message.linkBody !== void 0 && (obj.linkBody = message.linkBody ? LinkBody.toJSON(message.linkBody) : void 0);
    message.usernameProofBody !== void 0 && (obj.usernameProofBody = message.usernameProofBody ? UserNameProof.toJSON(message.usernameProofBody) : void 0);
    message.frameActionBody !== void 0 && (obj.frameActionBody = message.frameActionBody ? FrameActionBody.toJSON(message.frameActionBody) : void 0);
    message.linkCompactStateBody !== void 0 && (obj.linkCompactStateBody = message.linkCompactStateBody ? LinkCompactStateBody.toJSON(message.linkCompactStateBody) : void 0);
    return obj;
  },
  create(base) {
    return MessageData.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseMessageData();
    message.type = (_a = object.type) != null ? _a : 0;
    message.fid = (_b = object.fid) != null ? _b : 0;
    message.timestamp = (_c = object.timestamp) != null ? _c : 0;
    message.network = (_d = object.network) != null ? _d : 0;
    message.castAddBody = object.castAddBody !== void 0 && object.castAddBody !== null ? CastAddBody.fromPartial(object.castAddBody) : void 0;
    message.castRemoveBody = object.castRemoveBody !== void 0 && object.castRemoveBody !== null ? CastRemoveBody.fromPartial(object.castRemoveBody) : void 0;
    message.reactionBody = object.reactionBody !== void 0 && object.reactionBody !== null ? ReactionBody.fromPartial(object.reactionBody) : void 0;
    message.verificationAddAddressBody = object.verificationAddAddressBody !== void 0 && object.verificationAddAddressBody !== null ? VerificationAddAddressBody.fromPartial(object.verificationAddAddressBody) : void 0;
    message.verificationRemoveBody = object.verificationRemoveBody !== void 0 && object.verificationRemoveBody !== null ? VerificationRemoveBody.fromPartial(object.verificationRemoveBody) : void 0;
    message.userDataBody = object.userDataBody !== void 0 && object.userDataBody !== null ? UserDataBody.fromPartial(object.userDataBody) : void 0;
    message.linkBody = object.linkBody !== void 0 && object.linkBody !== null ? LinkBody.fromPartial(object.linkBody) : void 0;
    message.usernameProofBody = object.usernameProofBody !== void 0 && object.usernameProofBody !== null ? UserNameProof.fromPartial(object.usernameProofBody) : void 0;
    message.frameActionBody = object.frameActionBody !== void 0 && object.frameActionBody !== null ? FrameActionBody.fromPartial(object.frameActionBody) : void 0;
    message.linkCompactStateBody = object.linkCompactStateBody !== void 0 && object.linkCompactStateBody !== null ? LinkCompactStateBody.fromPartial(object.linkCompactStateBody) : void 0;
    return message;
  }
};
function createBaseUserDataBody() {
  return { type: 0, value: "" };
}
var UserDataBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.value = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? userDataTypeFromJSON(object.type) : 0,
      value: isSet2(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = userDataTypeToJSON(message.type));
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  create(base) {
    return UserDataBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUserDataBody();
    message.type = (_a = object.type) != null ? _a : 0;
    message.value = (_b = object.value) != null ? _b : "";
    return message;
  }
};
function createBaseEmbed() {
  return { url: void 0, castId: void 0 };
}
var Embed = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.url !== void 0) {
      writer.uint32(10).string(message.url);
    }
    if (message.castId !== void 0) {
      CastId.encode(message.castId, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmbed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.url = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.castId = CastId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet2(object.url) ? String(object.url) : void 0,
      castId: isSet2(object.castId) ? CastId.fromJSON(object.castId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = message.url);
    message.castId !== void 0 && (obj.castId = message.castId ? CastId.toJSON(message.castId) : void 0);
    return obj;
  },
  create(base) {
    return Embed.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEmbed();
    message.url = (_a = object.url) != null ? _a : void 0;
    message.castId = object.castId !== void 0 && object.castId !== null ? CastId.fromPartial(object.castId) : void 0;
    return message;
  }
};
function createBaseCastAddBody() {
  return {
    embedsDeprecated: [],
    mentions: [],
    parentCastId: void 0,
    parentUrl: void 0,
    text: "",
    mentionsPositions: [],
    embeds: [],
    type: 0
  };
}
var CastAddBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    for (const v of message.embedsDeprecated) {
      writer.uint32(10).string(v);
    }
    writer.uint32(18).fork();
    for (const v of message.mentions) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.parentCastId !== void 0) {
      CastId.encode(message.parentCastId, writer.uint32(26).fork()).ldelim();
    }
    if (message.parentUrl !== void 0) {
      writer.uint32(58).string(message.parentUrl);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    writer.uint32(42).fork();
    for (const v of message.mentionsPositions) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.embeds) {
      Embed.encode(v, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastAddBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.embedsDeprecated.push(reader.string());
          continue;
        case 2:
          if (tag == 16) {
            message.mentions.push(longToNumber2(reader.uint64()));
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mentions.push(longToNumber2(reader.uint64()));
            }
            continue;
          }
          break;
        case 3:
          if (tag != 26) {
            break;
          }
          message.parentCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.parentUrl = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.text = reader.string();
          continue;
        case 5:
          if (tag == 40) {
            message.mentionsPositions.push(reader.uint32());
            continue;
          }
          if (tag == 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mentionsPositions.push(reader.uint32());
            }
            continue;
          }
          break;
        case 6:
          if (tag != 50) {
            break;
          }
          message.embeds.push(Embed.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      embedsDeprecated: Array.isArray(object == null ? void 0 : object.embedsDeprecated) ? object.embedsDeprecated.map((e) => String(e)) : [],
      mentions: Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => Number(e)) : [],
      parentCastId: isSet2(object.parentCastId) ? CastId.fromJSON(object.parentCastId) : void 0,
      parentUrl: isSet2(object.parentUrl) ? String(object.parentUrl) : void 0,
      text: isSet2(object.text) ? String(object.text) : "",
      mentionsPositions: Array.isArray(object == null ? void 0 : object.mentionsPositions) ? object.mentionsPositions.map((e) => Number(e)) : [],
      embeds: Array.isArray(object == null ? void 0 : object.embeds) ? object.embeds.map((e) => Embed.fromJSON(e)) : [],
      type: isSet2(object.type) ? castTypeFromJSON(object.type) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.embedsDeprecated) {
      obj.embedsDeprecated = message.embedsDeprecated.map((e) => e);
    } else {
      obj.embedsDeprecated = [];
    }
    if (message.mentions) {
      obj.mentions = message.mentions.map((e) => Math.round(e));
    } else {
      obj.mentions = [];
    }
    message.parentCastId !== void 0 && (obj.parentCastId = message.parentCastId ? CastId.toJSON(message.parentCastId) : void 0);
    message.parentUrl !== void 0 && (obj.parentUrl = message.parentUrl);
    message.text !== void 0 && (obj.text = message.text);
    if (message.mentionsPositions) {
      obj.mentionsPositions = message.mentionsPositions.map((e) => Math.round(e));
    } else {
      obj.mentionsPositions = [];
    }
    if (message.embeds) {
      obj.embeds = message.embeds.map((e) => e ? Embed.toJSON(e) : void 0);
    } else {
      obj.embeds = [];
    }
    message.type !== void 0 && (obj.type = castTypeToJSON(message.type));
    return obj;
  },
  create(base) {
    return CastAddBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseCastAddBody();
    message.embedsDeprecated = ((_a = object.embedsDeprecated) == null ? void 0 : _a.map((e) => e)) || [];
    message.mentions = ((_b = object.mentions) == null ? void 0 : _b.map((e) => e)) || [];
    message.parentCastId = object.parentCastId !== void 0 && object.parentCastId !== null ? CastId.fromPartial(object.parentCastId) : void 0;
    message.parentUrl = (_c = object.parentUrl) != null ? _c : void 0;
    message.text = (_d = object.text) != null ? _d : "";
    message.mentionsPositions = ((_e = object.mentionsPositions) == null ? void 0 : _e.map((e) => e)) || [];
    message.embeds = ((_f = object.embeds) == null ? void 0 : _f.map((e) => Embed.fromPartial(e))) || [];
    message.type = (_g = object.type) != null ? _g : 0;
    return message;
  }
};
function createBaseCastRemoveBody() {
  return { targetHash: new Uint8Array() };
}
var CastRemoveBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.targetHash.length !== 0) {
      writer.uint32(10).bytes(message.targetHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastRemoveBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.targetHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { targetHash: isSet2(object.targetHash) ? bytesFromBase642(object.targetHash) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.targetHash !== void 0 && (obj.targetHash = base64FromBytes2(message.targetHash !== void 0 ? message.targetHash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return CastRemoveBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCastRemoveBody();
    message.targetHash = (_a = object.targetHash) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseCastId() {
  return { fid: 0, hash: new Uint8Array() };
}
var CastId = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber2(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet2(object.fid) ? Number(object.fid) : 0,
      hash: isSet2(object.hash) ? bytesFromBase642(object.hash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.hash !== void 0 && (obj.hash = base64FromBytes2(message.hash !== void 0 ? message.hash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return CastId.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCastId();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.hash = (_b = object.hash) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseReactionBody() {
  return { type: 0, targetCastId: void 0, targetUrl: void 0 };
}
var ReactionBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(26).string(message.targetUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? reactionTypeFromJSON(object.type) : 0,
      targetCastId: isSet2(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet2(object.targetUrl) ? String(object.targetUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = reactionTypeToJSON(message.type));
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    return obj;
  },
  create(base) {
    return ReactionBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseReactionBody();
    message.type = (_a = object.type) != null ? _a : 0;
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_b = object.targetUrl) != null ? _b : void 0;
    return message;
  }
};
function createBaseVerificationAddAddressBody() {
  return {
    address: new Uint8Array(),
    claimSignature: new Uint8Array(),
    blockHash: new Uint8Array(),
    verificationType: 0,
    chainId: 0,
    protocol: 0
  };
}
var VerificationAddAddressBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.claimSignature.length !== 0) {
      writer.uint32(18).bytes(message.claimSignature);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(26).bytes(message.blockHash);
    }
    if (message.verificationType !== 0) {
      writer.uint32(32).uint32(message.verificationType);
    }
    if (message.chainId !== 0) {
      writer.uint32(40).uint32(message.chainId);
    }
    if (message.protocol !== 0) {
      writer.uint32(56).int32(message.protocol);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationAddAddressBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.claimSignature = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.blockHash = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.verificationType = reader.uint32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.chainId = reader.uint32();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.protocol = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
      claimSignature: isSet2(object.claimSignature) ? bytesFromBase642(object.claimSignature) : new Uint8Array(),
      blockHash: isSet2(object.blockHash) ? bytesFromBase642(object.blockHash) : new Uint8Array(),
      verificationType: isSet2(object.verificationType) ? Number(object.verificationType) : 0,
      chainId: isSet2(object.chainId) ? Number(object.chainId) : 0,
      protocol: isSet2(object.protocol) ? protocolFromJSON(object.protocol) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    message.claimSignature !== void 0 && (obj.claimSignature = base64FromBytes2(
      message.claimSignature !== void 0 ? message.claimSignature : new Uint8Array()
    ));
    message.blockHash !== void 0 && (obj.blockHash = base64FromBytes2(message.blockHash !== void 0 ? message.blockHash : new Uint8Array()));
    message.verificationType !== void 0 && (obj.verificationType = Math.round(message.verificationType));
    message.chainId !== void 0 && (obj.chainId = Math.round(message.chainId));
    message.protocol !== void 0 && (obj.protocol = protocolToJSON(message.protocol));
    return obj;
  },
  create(base) {
    return VerificationAddAddressBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseVerificationAddAddressBody();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    message.claimSignature = (_b = object.claimSignature) != null ? _b : new Uint8Array();
    message.blockHash = (_c = object.blockHash) != null ? _c : new Uint8Array();
    message.verificationType = (_d = object.verificationType) != null ? _d : 0;
    message.chainId = (_e = object.chainId) != null ? _e : 0;
    message.protocol = (_f = object.protocol) != null ? _f : 0;
    return message;
  }
};
function createBaseVerificationRemoveBody() {
  return { address: new Uint8Array(), protocol: 0 };
}
var VerificationRemoveBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.protocol !== 0) {
      writer.uint32(16).int32(message.protocol);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationRemoveBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.protocol = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array(),
      protocol: isSet2(object.protocol) ? protocolFromJSON(object.protocol) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    message.protocol !== void 0 && (obj.protocol = protocolToJSON(message.protocol));
    return obj;
  },
  create(base) {
    return VerificationRemoveBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVerificationRemoveBody();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    message.protocol = (_b = object.protocol) != null ? _b : 0;
    return message;
  }
};
function createBaseLinkBody() {
  return { type: "", displayTimestamp: void 0, targetFid: void 0 };
}
var LinkBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.displayTimestamp !== void 0) {
      writer.uint32(16).uint32(message.displayTimestamp);
    }
    if (message.targetFid !== void 0) {
      writer.uint32(24).uint64(message.targetFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.displayTimestamp = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.targetFid = longToNumber2(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? String(object.type) : "",
      displayTimestamp: isSet2(object.displayTimestamp) ? Number(object.displayTimestamp) : void 0,
      targetFid: isSet2(object.targetFid) ? Number(object.targetFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    message.displayTimestamp !== void 0 && (obj.displayTimestamp = Math.round(message.displayTimestamp));
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    return obj;
  },
  create(base) {
    return LinkBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseLinkBody();
    message.type = (_a = object.type) != null ? _a : "";
    message.displayTimestamp = (_b = object.displayTimestamp) != null ? _b : void 0;
    message.targetFid = (_c = object.targetFid) != null ? _c : void 0;
    return message;
  }
};
function createBaseLinkCompactStateBody() {
  return { type: "", targetFids: [] };
}
var LinkCompactStateBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    writer.uint32(18).fork();
    for (const v of message.targetFids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkCompactStateBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.type = reader.string();
          continue;
        case 2:
          if (tag == 16) {
            message.targetFids.push(longToNumber2(reader.uint64()));
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetFids.push(longToNumber2(reader.uint64()));
            }
            continue;
          }
          break;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? String(object.type) : "",
      targetFids: Array.isArray(object == null ? void 0 : object.targetFids) ? object.targetFids.map((e) => Number(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    if (message.targetFids) {
      obj.targetFids = message.targetFids.map((e) => Math.round(e));
    } else {
      obj.targetFids = [];
    }
    return obj;
  },
  create(base) {
    return LinkCompactStateBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLinkCompactStateBody();
    message.type = (_a = object.type) != null ? _a : "";
    message.targetFids = ((_b = object.targetFids) == null ? void 0 : _b.map((e) => e)) || [];
    return message;
  }
};
function createBaseFrameActionBody() {
  return {
    url: new Uint8Array(),
    buttonIndex: 0,
    castId: void 0,
    inputText: new Uint8Array(),
    state: new Uint8Array(),
    transactionId: new Uint8Array(),
    address: new Uint8Array()
  };
}
var FrameActionBody = {
  encode(message, writer = import_minimal2.default.Writer.create()) {
    if (message.url.length !== 0) {
      writer.uint32(10).bytes(message.url);
    }
    if (message.buttonIndex !== 0) {
      writer.uint32(16).uint32(message.buttonIndex);
    }
    if (message.castId !== void 0) {
      CastId.encode(message.castId, writer.uint32(26).fork()).ldelim();
    }
    if (message.inputText.length !== 0) {
      writer.uint32(34).bytes(message.inputText);
    }
    if (message.state.length !== 0) {
      writer.uint32(42).bytes(message.state);
    }
    if (message.transactionId.length !== 0) {
      writer.uint32(50).bytes(message.transactionId);
    }
    if (message.address.length !== 0) {
      writer.uint32(58).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFrameActionBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.url = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.buttonIndex = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.castId = CastId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.inputText = reader.bytes();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.state = reader.bytes();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.transactionId = reader.bytes();
          continue;
        case 7:
          if (tag != 58) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet2(object.url) ? bytesFromBase642(object.url) : new Uint8Array(),
      buttonIndex: isSet2(object.buttonIndex) ? Number(object.buttonIndex) : 0,
      castId: isSet2(object.castId) ? CastId.fromJSON(object.castId) : void 0,
      inputText: isSet2(object.inputText) ? bytesFromBase642(object.inputText) : new Uint8Array(),
      state: isSet2(object.state) ? bytesFromBase642(object.state) : new Uint8Array(),
      transactionId: isSet2(object.transactionId) ? bytesFromBase642(object.transactionId) : new Uint8Array(),
      address: isSet2(object.address) ? bytesFromBase642(object.address) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.url !== void 0 && (obj.url = base64FromBytes2(message.url !== void 0 ? message.url : new Uint8Array()));
    message.buttonIndex !== void 0 && (obj.buttonIndex = Math.round(message.buttonIndex));
    message.castId !== void 0 && (obj.castId = message.castId ? CastId.toJSON(message.castId) : void 0);
    message.inputText !== void 0 && (obj.inputText = base64FromBytes2(message.inputText !== void 0 ? message.inputText : new Uint8Array()));
    message.state !== void 0 && (obj.state = base64FromBytes2(message.state !== void 0 ? message.state : new Uint8Array()));
    message.transactionId !== void 0 && (obj.transactionId = base64FromBytes2(
      message.transactionId !== void 0 ? message.transactionId : new Uint8Array()
    ));
    message.address !== void 0 && (obj.address = base64FromBytes2(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return FrameActionBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseFrameActionBody();
    message.url = (_a = object.url) != null ? _a : new Uint8Array();
    message.buttonIndex = (_b = object.buttonIndex) != null ? _b : 0;
    message.castId = object.castId !== void 0 && object.castId !== null ? CastId.fromPartial(object.castId) : void 0;
    message.inputText = (_c = object.inputText) != null ? _c : new Uint8Array();
    message.state = (_d = object.state) != null ? _d : new Uint8Array();
    message.transactionId = (_e = object.transactionId) != null ? _e : new Uint8Array();
    message.address = (_f = object.address) != null ? _f : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis2 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase642(b64) {
  if (tsProtoGlobalThis2.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis2.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis2.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes2(arr) {
  if (tsProtoGlobalThis2.Buffer) {
    return tsProtoGlobalThis2.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis2.btoa(bin.join(""));
  }
}
function longToNumber2(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal2.default.util.Long !== import_long2.default) {
  import_minimal2.default.util.Long = import_long2.default;
  import_minimal2.default.configure();
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/onchain_event.ts
init_cjs_shims();
var import_long3 = __toESM(require_long());
var import_minimal3 = __toESM(require_minimal2());
var OnChainEventType = /* @__PURE__ */ ((OnChainEventType3) => {
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_NONE"] = 0] = "EVENT_TYPE_NONE";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_SIGNER"] = 1] = "EVENT_TYPE_SIGNER";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_SIGNER_MIGRATED"] = 2] = "EVENT_TYPE_SIGNER_MIGRATED";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_ID_REGISTER"] = 3] = "EVENT_TYPE_ID_REGISTER";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_STORAGE_RENT"] = 4] = "EVENT_TYPE_STORAGE_RENT";
  OnChainEventType3[OnChainEventType3["EVENT_TYPE_TIER_PURCHASE"] = 5] = "EVENT_TYPE_TIER_PURCHASE";
  return OnChainEventType3;
})(OnChainEventType || {});
function onChainEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "EVENT_TYPE_NONE":
      return 0 /* EVENT_TYPE_NONE */;
    case 1:
    case "EVENT_TYPE_SIGNER":
      return 1 /* EVENT_TYPE_SIGNER */;
    case 2:
    case "EVENT_TYPE_SIGNER_MIGRATED":
      return 2 /* EVENT_TYPE_SIGNER_MIGRATED */;
    case 3:
    case "EVENT_TYPE_ID_REGISTER":
      return 3 /* EVENT_TYPE_ID_REGISTER */;
    case 4:
    case "EVENT_TYPE_STORAGE_RENT":
      return 4 /* EVENT_TYPE_STORAGE_RENT */;
    case 5:
    case "EVENT_TYPE_TIER_PURCHASE":
      return 5 /* EVENT_TYPE_TIER_PURCHASE */;
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum OnChainEventType");
  }
}
function onChainEventTypeToJSON(object) {
  switch (object) {
    case 0 /* EVENT_TYPE_NONE */:
      return "EVENT_TYPE_NONE";
    case 1 /* EVENT_TYPE_SIGNER */:
      return "EVENT_TYPE_SIGNER";
    case 2 /* EVENT_TYPE_SIGNER_MIGRATED */:
      return "EVENT_TYPE_SIGNER_MIGRATED";
    case 3 /* EVENT_TYPE_ID_REGISTER */:
      return "EVENT_TYPE_ID_REGISTER";
    case 4 /* EVENT_TYPE_STORAGE_RENT */:
      return "EVENT_TYPE_STORAGE_RENT";
    case 5 /* EVENT_TYPE_TIER_PURCHASE */:
      return "EVENT_TYPE_TIER_PURCHASE";
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum OnChainEventType");
  }
}
var TierType = /* @__PURE__ */ ((TierType3) => {
  TierType3[TierType3["None"] = 0] = "None";
  TierType3[TierType3["Pro"] = 1] = "Pro";
  return TierType3;
})(TierType || {});
function tierTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "None":
      return 0 /* None */;
    case 1:
    case "Pro":
      return 1 /* Pro */;
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum TierType");
  }
}
function tierTypeToJSON(object) {
  switch (object) {
    case 0 /* None */:
      return "None";
    case 1 /* Pro */:
      return "Pro";
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum TierType");
  }
}
var SignerEventType = /* @__PURE__ */ ((SignerEventType2) => {
  SignerEventType2[SignerEventType2["NONE"] = 0] = "NONE";
  SignerEventType2[SignerEventType2["ADD"] = 1] = "ADD";
  SignerEventType2[SignerEventType2["REMOVE"] = 2] = "REMOVE";
  SignerEventType2[SignerEventType2["ADMIN_RESET"] = 3] = "ADMIN_RESET";
  return SignerEventType2;
})(SignerEventType || {});
function signerEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "SIGNER_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "SIGNER_EVENT_TYPE_ADD":
      return 1 /* ADD */;
    case 2:
    case "SIGNER_EVENT_TYPE_REMOVE":
      return 2 /* REMOVE */;
    case 3:
    case "SIGNER_EVENT_TYPE_ADMIN_RESET":
      return 3 /* ADMIN_RESET */;
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum SignerEventType");
  }
}
function signerEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "SIGNER_EVENT_TYPE_NONE";
    case 1 /* ADD */:
      return "SIGNER_EVENT_TYPE_ADD";
    case 2 /* REMOVE */:
      return "SIGNER_EVENT_TYPE_REMOVE";
    case 3 /* ADMIN_RESET */:
      return "SIGNER_EVENT_TYPE_ADMIN_RESET";
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum SignerEventType");
  }
}
var IdRegisterEventType = /* @__PURE__ */ ((IdRegisterEventType2) => {
  IdRegisterEventType2[IdRegisterEventType2["NONE"] = 0] = "NONE";
  IdRegisterEventType2[IdRegisterEventType2["REGISTER"] = 1] = "REGISTER";
  IdRegisterEventType2[IdRegisterEventType2["TRANSFER"] = 2] = "TRANSFER";
  IdRegisterEventType2[IdRegisterEventType2["CHANGE_RECOVERY"] = 3] = "CHANGE_RECOVERY";
  return IdRegisterEventType2;
})(IdRegisterEventType || {});
function idRegisterEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ID_REGISTER_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "ID_REGISTER_EVENT_TYPE_REGISTER":
      return 1 /* REGISTER */;
    case 2:
    case "ID_REGISTER_EVENT_TYPE_TRANSFER":
      return 2 /* TRANSFER */;
    case 3:
    case "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY":
      return 3 /* CHANGE_RECOVERY */;
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum IdRegisterEventType");
  }
}
function idRegisterEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "ID_REGISTER_EVENT_TYPE_NONE";
    case 1 /* REGISTER */:
      return "ID_REGISTER_EVENT_TYPE_REGISTER";
    case 2 /* TRANSFER */:
      return "ID_REGISTER_EVENT_TYPE_TRANSFER";
    case 3 /* CHANGE_RECOVERY */:
      return "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY";
    default:
      throw new tsProtoGlobalThis3.Error("Unrecognized enum value " + object + " for enum IdRegisterEventType");
  }
}
function createBaseOnChainEvent() {
  return {
    type: 0,
    chainId: 0,
    blockNumber: 0,
    blockHash: new Uint8Array(),
    blockTimestamp: 0,
    transactionHash: new Uint8Array(),
    logIndex: 0,
    fid: 0,
    signerEventBody: void 0,
    signerMigratedEventBody: void 0,
    idRegisterEventBody: void 0,
    storageRentEventBody: void 0,
    tierPurchaseEventBody: void 0,
    txIndex: 0,
    version: 0
  };
}
var OnChainEvent = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.chainId !== 0) {
      writer.uint32(16).uint32(message.chainId);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(24).uint32(message.blockNumber);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(34).bytes(message.blockHash);
    }
    if (message.blockTimestamp !== 0) {
      writer.uint32(40).uint64(message.blockTimestamp);
    }
    if (message.transactionHash.length !== 0) {
      writer.uint32(50).bytes(message.transactionHash);
    }
    if (message.logIndex !== 0) {
      writer.uint32(56).uint32(message.logIndex);
    }
    if (message.fid !== 0) {
      writer.uint32(64).uint64(message.fid);
    }
    if (message.signerEventBody !== void 0) {
      SignerEventBody.encode(message.signerEventBody, writer.uint32(74).fork()).ldelim();
    }
    if (message.signerMigratedEventBody !== void 0) {
      SignerMigratedEventBody.encode(message.signerMigratedEventBody, writer.uint32(82).fork()).ldelim();
    }
    if (message.idRegisterEventBody !== void 0) {
      IdRegisterEventBody.encode(message.idRegisterEventBody, writer.uint32(90).fork()).ldelim();
    }
    if (message.storageRentEventBody !== void 0) {
      StorageRentEventBody.encode(message.storageRentEventBody, writer.uint32(98).fork()).ldelim();
    }
    if (message.tierPurchaseEventBody !== void 0) {
      TierPurchaseBody.encode(message.tierPurchaseEventBody, writer.uint32(122).fork()).ldelim();
    }
    if (message.txIndex !== 0) {
      writer.uint32(104).uint32(message.txIndex);
    }
    if (message.version !== 0) {
      writer.uint32(112).uint32(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.chainId = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.blockNumber = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.blockHash = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.blockTimestamp = longToNumber3(reader.uint64());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.transactionHash = reader.bytes();
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.logIndex = reader.uint32();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.fid = longToNumber3(reader.uint64());
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.signerEventBody = SignerEventBody.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag != 82) {
            break;
          }
          message.signerMigratedEventBody = SignerMigratedEventBody.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.idRegisterEventBody = IdRegisterEventBody.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 98) {
            break;
          }
          message.storageRentEventBody = StorageRentEventBody.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag != 122) {
            break;
          }
          message.tierPurchaseEventBody = TierPurchaseBody.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag != 104) {
            break;
          }
          message.txIndex = reader.uint32();
          continue;
        case 14:
          if (tag != 112) {
            break;
          }
          message.version = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet3(object.type) ? onChainEventTypeFromJSON(object.type) : 0,
      chainId: isSet3(object.chainId) ? Number(object.chainId) : 0,
      blockNumber: isSet3(object.blockNumber) ? Number(object.blockNumber) : 0,
      blockHash: isSet3(object.blockHash) ? bytesFromBase643(object.blockHash) : new Uint8Array(),
      blockTimestamp: isSet3(object.blockTimestamp) ? Number(object.blockTimestamp) : 0,
      transactionHash: isSet3(object.transactionHash) ? bytesFromBase643(object.transactionHash) : new Uint8Array(),
      logIndex: isSet3(object.logIndex) ? Number(object.logIndex) : 0,
      fid: isSet3(object.fid) ? Number(object.fid) : 0,
      signerEventBody: isSet3(object.signerEventBody) ? SignerEventBody.fromJSON(object.signerEventBody) : void 0,
      signerMigratedEventBody: isSet3(object.signerMigratedEventBody) ? SignerMigratedEventBody.fromJSON(object.signerMigratedEventBody) : void 0,
      idRegisterEventBody: isSet3(object.idRegisterEventBody) ? IdRegisterEventBody.fromJSON(object.idRegisterEventBody) : void 0,
      storageRentEventBody: isSet3(object.storageRentEventBody) ? StorageRentEventBody.fromJSON(object.storageRentEventBody) : void 0,
      tierPurchaseEventBody: isSet3(object.tierPurchaseEventBody) ? TierPurchaseBody.fromJSON(object.tierPurchaseEventBody) : void 0,
      txIndex: isSet3(object.txIndex) ? Number(object.txIndex) : 0,
      version: isSet3(object.version) ? Number(object.version) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = onChainEventTypeToJSON(message.type));
    message.chainId !== void 0 && (obj.chainId = Math.round(message.chainId));
    message.blockNumber !== void 0 && (obj.blockNumber = Math.round(message.blockNumber));
    message.blockHash !== void 0 && (obj.blockHash = base64FromBytes3(message.blockHash !== void 0 ? message.blockHash : new Uint8Array()));
    message.blockTimestamp !== void 0 && (obj.blockTimestamp = Math.round(message.blockTimestamp));
    message.transactionHash !== void 0 && (obj.transactionHash = base64FromBytes3(
      message.transactionHash !== void 0 ? message.transactionHash : new Uint8Array()
    ));
    message.logIndex !== void 0 && (obj.logIndex = Math.round(message.logIndex));
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signerEventBody !== void 0 && (obj.signerEventBody = message.signerEventBody ? SignerEventBody.toJSON(message.signerEventBody) : void 0);
    message.signerMigratedEventBody !== void 0 && (obj.signerMigratedEventBody = message.signerMigratedEventBody ? SignerMigratedEventBody.toJSON(message.signerMigratedEventBody) : void 0);
    message.idRegisterEventBody !== void 0 && (obj.idRegisterEventBody = message.idRegisterEventBody ? IdRegisterEventBody.toJSON(message.idRegisterEventBody) : void 0);
    message.storageRentEventBody !== void 0 && (obj.storageRentEventBody = message.storageRentEventBody ? StorageRentEventBody.toJSON(message.storageRentEventBody) : void 0);
    message.tierPurchaseEventBody !== void 0 && (obj.tierPurchaseEventBody = message.tierPurchaseEventBody ? TierPurchaseBody.toJSON(message.tierPurchaseEventBody) : void 0);
    message.txIndex !== void 0 && (obj.txIndex = Math.round(message.txIndex));
    message.version !== void 0 && (obj.version = Math.round(message.version));
    return obj;
  },
  create(base) {
    return OnChainEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const message = createBaseOnChainEvent();
    message.type = (_a = object.type) != null ? _a : 0;
    message.chainId = (_b = object.chainId) != null ? _b : 0;
    message.blockNumber = (_c = object.blockNumber) != null ? _c : 0;
    message.blockHash = (_d = object.blockHash) != null ? _d : new Uint8Array();
    message.blockTimestamp = (_e = object.blockTimestamp) != null ? _e : 0;
    message.transactionHash = (_f = object.transactionHash) != null ? _f : new Uint8Array();
    message.logIndex = (_g = object.logIndex) != null ? _g : 0;
    message.fid = (_h = object.fid) != null ? _h : 0;
    message.signerEventBody = object.signerEventBody !== void 0 && object.signerEventBody !== null ? SignerEventBody.fromPartial(object.signerEventBody) : void 0;
    message.signerMigratedEventBody = object.signerMigratedEventBody !== void 0 && object.signerMigratedEventBody !== null ? SignerMigratedEventBody.fromPartial(object.signerMigratedEventBody) : void 0;
    message.idRegisterEventBody = object.idRegisterEventBody !== void 0 && object.idRegisterEventBody !== null ? IdRegisterEventBody.fromPartial(object.idRegisterEventBody) : void 0;
    message.storageRentEventBody = object.storageRentEventBody !== void 0 && object.storageRentEventBody !== null ? StorageRentEventBody.fromPartial(object.storageRentEventBody) : void 0;
    message.tierPurchaseEventBody = object.tierPurchaseEventBody !== void 0 && object.tierPurchaseEventBody !== null ? TierPurchaseBody.fromPartial(object.tierPurchaseEventBody) : void 0;
    message.txIndex = (_i = object.txIndex) != null ? _i : 0;
    message.version = (_j = object.version) != null ? _j : 0;
    return message;
  }
};
function createBaseTierPurchaseBody() {
  return { tierType: 0, forDays: 0, payer: new Uint8Array() };
}
var TierPurchaseBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.tierType !== 0) {
      writer.uint32(8).int32(message.tierType);
    }
    if (message.forDays !== 0) {
      writer.uint32(16).uint64(message.forDays);
    }
    if (message.payer.length !== 0) {
      writer.uint32(26).bytes(message.payer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTierPurchaseBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.tierType = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.forDays = longToNumber3(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.payer = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tierType: isSet3(object.tierType) ? tierTypeFromJSON(object.tierType) : 0,
      forDays: isSet3(object.forDays) ? Number(object.forDays) : 0,
      payer: isSet3(object.payer) ? bytesFromBase643(object.payer) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.tierType !== void 0 && (obj.tierType = tierTypeToJSON(message.tierType));
    message.forDays !== void 0 && (obj.forDays = Math.round(message.forDays));
    message.payer !== void 0 && (obj.payer = base64FromBytes3(message.payer !== void 0 ? message.payer : new Uint8Array()));
    return obj;
  },
  create(base) {
    return TierPurchaseBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseTierPurchaseBody();
    message.tierType = (_a = object.tierType) != null ? _a : 0;
    message.forDays = (_b = object.forDays) != null ? _b : 0;
    message.payer = (_c = object.payer) != null ? _c : new Uint8Array();
    return message;
  }
};
function createBaseSignerEventBody() {
  return { key: new Uint8Array(), keyType: 0, eventType: 0, metadata: new Uint8Array(), metadataType: 0 };
}
var SignerEventBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.keyType !== 0) {
      writer.uint32(16).uint32(message.keyType);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(34).bytes(message.metadata);
    }
    if (message.metadataType !== 0) {
      writer.uint32(40).uint32(message.metadataType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.keyType = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.metadata = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.metadataType = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? bytesFromBase643(object.key) : new Uint8Array(),
      keyType: isSet3(object.keyType) ? Number(object.keyType) : 0,
      eventType: isSet3(object.eventType) ? signerEventTypeFromJSON(object.eventType) : 0,
      metadata: isSet3(object.metadata) ? bytesFromBase643(object.metadata) : new Uint8Array(),
      metadataType: isSet3(object.metadataType) ? Number(object.metadataType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes3(message.key !== void 0 ? message.key : new Uint8Array()));
    message.keyType !== void 0 && (obj.keyType = Math.round(message.keyType));
    message.eventType !== void 0 && (obj.eventType = signerEventTypeToJSON(message.eventType));
    message.metadata !== void 0 && (obj.metadata = base64FromBytes3(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
    message.metadataType !== void 0 && (obj.metadataType = Math.round(message.metadataType));
    return obj;
  },
  create(base) {
    return SignerEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseSignerEventBody();
    message.key = (_a = object.key) != null ? _a : new Uint8Array();
    message.keyType = (_b = object.keyType) != null ? _b : 0;
    message.eventType = (_c = object.eventType) != null ? _c : 0;
    message.metadata = (_d = object.metadata) != null ? _d : new Uint8Array();
    message.metadataType = (_e = object.metadataType) != null ? _e : 0;
    return message;
  }
};
function createBaseSignerMigratedEventBody() {
  return { migratedAt: 0 };
}
var SignerMigratedEventBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.migratedAt !== 0) {
      writer.uint32(8).uint32(message.migratedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerMigratedEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.migratedAt = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { migratedAt: isSet3(object.migratedAt) ? Number(object.migratedAt) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.migratedAt !== void 0 && (obj.migratedAt = Math.round(message.migratedAt));
    return obj;
  },
  create(base) {
    return SignerMigratedEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSignerMigratedEventBody();
    message.migratedAt = (_a = object.migratedAt) != null ? _a : 0;
    return message;
  }
};
function createBaseIdRegisterEventBody() {
  return { to: new Uint8Array(), eventType: 0, from: new Uint8Array(), recoveryAddress: new Uint8Array() };
}
var IdRegisterEventBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.to.length !== 0) {
      writer.uint32(10).bytes(message.to);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.from.length !== 0) {
      writer.uint32(26).bytes(message.from);
    }
    if (message.recoveryAddress.length !== 0) {
      writer.uint32(34).bytes(message.recoveryAddress);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIdRegisterEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.to = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.from = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.recoveryAddress = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      to: isSet3(object.to) ? bytesFromBase643(object.to) : new Uint8Array(),
      eventType: isSet3(object.eventType) ? idRegisterEventTypeFromJSON(object.eventType) : 0,
      from: isSet3(object.from) ? bytesFromBase643(object.from) : new Uint8Array(),
      recoveryAddress: isSet3(object.recoveryAddress) ? bytesFromBase643(object.recoveryAddress) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.to !== void 0 && (obj.to = base64FromBytes3(message.to !== void 0 ? message.to : new Uint8Array()));
    message.eventType !== void 0 && (obj.eventType = idRegisterEventTypeToJSON(message.eventType));
    message.from !== void 0 && (obj.from = base64FromBytes3(message.from !== void 0 ? message.from : new Uint8Array()));
    message.recoveryAddress !== void 0 && (obj.recoveryAddress = base64FromBytes3(
      message.recoveryAddress !== void 0 ? message.recoveryAddress : new Uint8Array()
    ));
    return obj;
  },
  create(base) {
    return IdRegisterEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseIdRegisterEventBody();
    message.to = (_a = object.to) != null ? _a : new Uint8Array();
    message.eventType = (_b = object.eventType) != null ? _b : 0;
    message.from = (_c = object.from) != null ? _c : new Uint8Array();
    message.recoveryAddress = (_d = object.recoveryAddress) != null ? _d : new Uint8Array();
    return message;
  }
};
function createBaseStorageRentEventBody() {
  return { payer: new Uint8Array(), units: 0, expiry: 0 };
}
var StorageRentEventBody = {
  encode(message, writer = import_minimal3.default.Writer.create()) {
    if (message.payer.length !== 0) {
      writer.uint32(10).bytes(message.payer);
    }
    if (message.units !== 0) {
      writer.uint32(16).uint32(message.units);
    }
    if (message.expiry !== 0) {
      writer.uint32(24).uint32(message.expiry);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageRentEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.payer = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.units = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.expiry = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      payer: isSet3(object.payer) ? bytesFromBase643(object.payer) : new Uint8Array(),
      units: isSet3(object.units) ? Number(object.units) : 0,
      expiry: isSet3(object.expiry) ? Number(object.expiry) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.payer !== void 0 && (obj.payer = base64FromBytes3(message.payer !== void 0 ? message.payer : new Uint8Array()));
    message.units !== void 0 && (obj.units = Math.round(message.units));
    message.expiry !== void 0 && (obj.expiry = Math.round(message.expiry));
    return obj;
  },
  create(base) {
    return StorageRentEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseStorageRentEventBody();
    message.payer = (_a = object.payer) != null ? _a : new Uint8Array();
    message.units = (_b = object.units) != null ? _b : 0;
    message.expiry = (_c = object.expiry) != null ? _c : 0;
    return message;
  }
};
var tsProtoGlobalThis3 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase643(b64) {
  if (tsProtoGlobalThis3.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis3.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis3.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes3(arr) {
  if (tsProtoGlobalThis3.Buffer) {
    return tsProtoGlobalThis3.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis3.btoa(bin.join(""));
  }
}
function longToNumber3(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal3.default.util.Long !== import_long3.default) {
  import_minimal3.default.util.Long = import_long3.default;
  import_minimal3.default.configure();
}
function isSet3(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/blocks.ts
function voteTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "PREVOTE":
      return 0 /* PREVOTE */;
    case 1:
    case "PRECOMMIT":
      return 1 /* PRECOMMIT */;
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum VoteType");
  }
}
function voteTypeToJSON(object) {
  switch (object) {
    case 0 /* PREVOTE */:
      return "PREVOTE";
    case 1 /* PRECOMMIT */:
      return "PRECOMMIT";
    default:
      throw new tsProtoGlobalThis4.Error("Unrecognized enum value " + object + " for enum VoteType");
  }
}
function createBaseHeight() {
  return { shardIndex: 0, blockNumber: 0 };
}
var Height = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.shardIndex !== 0) {
      writer.uint32(8).uint32(message.shardIndex);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(16).uint64(message.blockNumber);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.blockNumber = longToNumber4(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardIndex: isSet4(object.shardIndex) ? Number(object.shardIndex) : 0,
      blockNumber: isSet4(object.blockNumber) ? Number(object.blockNumber) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    message.blockNumber !== void 0 && (obj.blockNumber = Math.round(message.blockNumber));
    return obj;
  },
  create(base) {
    return Height.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseHeight();
    message.shardIndex = (_a = object.shardIndex) != null ? _a : 0;
    message.blockNumber = (_b = object.blockNumber) != null ? _b : 0;
    return message;
  }
};
function createBaseShardHash() {
  return { shardIndex: 0, hash: new Uint8Array() };
}
var ShardHash = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.shardIndex !== 0) {
      writer.uint32(8).uint32(message.shardIndex);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardIndex: isSet4(object.shardIndex) ? Number(object.shardIndex) : 0,
      hash: isSet4(object.hash) ? bytesFromBase644(object.hash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    message.hash !== void 0 && (obj.hash = base64FromBytes4(message.hash !== void 0 ? message.hash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return ShardHash.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseShardHash();
    message.shardIndex = (_a = object.shardIndex) != null ? _a : 0;
    message.hash = (_b = object.hash) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseVote() {
  return { type: 0, height: void 0, round: 0, value: void 0, voter: new Uint8Array() };
}
var Vote = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(18).fork()).ldelim();
    }
    if (message.round !== 0) {
      writer.uint32(24).int64(message.round);
    }
    if (message.value !== void 0) {
      ShardHash.encode(message.value, writer.uint32(34).fork()).ldelim();
    }
    if (message.voter.length !== 0) {
      writer.uint32(42).bytes(message.voter);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.round = longToNumber4(reader.int64());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.value = ShardHash.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.voter = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet4(object.type) ? voteTypeFromJSON(object.type) : 0,
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      round: isSet4(object.round) ? Number(object.round) : 0,
      value: isSet4(object.value) ? ShardHash.fromJSON(object.value) : void 0,
      voter: isSet4(object.voter) ? bytesFromBase644(object.voter) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = voteTypeToJSON(message.type));
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.round !== void 0 && (obj.round = Math.round(message.round));
    message.value !== void 0 && (obj.value = message.value ? ShardHash.toJSON(message.value) : void 0);
    message.voter !== void 0 && (obj.voter = base64FromBytes4(message.voter !== void 0 ? message.voter : new Uint8Array()));
    return obj;
  },
  create(base) {
    return Vote.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseVote();
    message.type = (_a = object.type) != null ? _a : 0;
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.round = (_b = object.round) != null ? _b : 0;
    message.value = object.value !== void 0 && object.value !== null ? ShardHash.fromPartial(object.value) : void 0;
    message.voter = (_c = object.voter) != null ? _c : new Uint8Array();
    return message;
  }
};
function createBaseCommitSignature() {
  return { signer: new Uint8Array(), signature: new Uint8Array() };
}
var CommitSignature = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.signer.length !== 0) {
      writer.uint32(10).bytes(message.signer);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommitSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.signer = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      signer: isSet4(object.signer) ? bytesFromBase644(object.signer) : new Uint8Array(),
      signature: isSet4(object.signature) ? bytesFromBase644(object.signature) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.signer !== void 0 && (obj.signer = base64FromBytes4(message.signer !== void 0 ? message.signer : new Uint8Array()));
    message.signature !== void 0 && (obj.signature = base64FromBytes4(message.signature !== void 0 ? message.signature : new Uint8Array()));
    return obj;
  },
  create(base) {
    return CommitSignature.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCommitSignature();
    message.signer = (_a = object.signer) != null ? _a : new Uint8Array();
    message.signature = (_b = object.signature) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseCommits() {
  return { height: void 0, round: 0, value: void 0, signatures: [] };
}
var Commits = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.round !== 0) {
      writer.uint32(16).int64(message.round);
    }
    if (message.value !== void 0) {
      ShardHash.encode(message.value, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.signatures) {
      CommitSignature.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.round = longToNumber4(reader.int64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.value = ShardHash.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.signatures.push(CommitSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      round: isSet4(object.round) ? Number(object.round) : 0,
      value: isSet4(object.value) ? ShardHash.fromJSON(object.value) : void 0,
      signatures: Array.isArray(object == null ? void 0 : object.signatures) ? object.signatures.map((e) => CommitSignature.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.round !== void 0 && (obj.round = Math.round(message.round));
    message.value !== void 0 && (obj.value = message.value ? ShardHash.toJSON(message.value) : void 0);
    if (message.signatures) {
      obj.signatures = message.signatures.map((e) => e ? CommitSignature.toJSON(e) : void 0);
    } else {
      obj.signatures = [];
    }
    return obj;
  },
  create(base) {
    return Commits.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCommits();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.round = (_a = object.round) != null ? _a : 0;
    message.value = object.value !== void 0 && object.value !== null ? ShardHash.fromPartial(object.value) : void 0;
    message.signatures = ((_b = object.signatures) == null ? void 0 : _b.map((e) => CommitSignature.fromPartial(e))) || [];
    return message;
  }
};
function createBaseProposal() {
  return { height: void 0, round: 0, polRound: 0, proposer: new Uint8Array(), value: void 0 };
}
var Proposal = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.round !== 0) {
      writer.uint32(16).int64(message.round);
    }
    if (message.polRound !== 0) {
      writer.uint32(24).int64(message.polRound);
    }
    if (message.proposer.length !== 0) {
      writer.uint32(34).bytes(message.proposer);
    }
    if (message.value !== void 0) {
      ShardHash.encode(message.value, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.round = longToNumber4(reader.int64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.polRound = longToNumber4(reader.int64());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.proposer = reader.bytes();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.value = ShardHash.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      round: isSet4(object.round) ? Number(object.round) : 0,
      polRound: isSet4(object.polRound) ? Number(object.polRound) : 0,
      proposer: isSet4(object.proposer) ? bytesFromBase644(object.proposer) : new Uint8Array(),
      value: isSet4(object.value) ? ShardHash.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.round !== void 0 && (obj.round = Math.round(message.round));
    message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
    message.proposer !== void 0 && (obj.proposer = base64FromBytes4(message.proposer !== void 0 ? message.proposer : new Uint8Array()));
    message.value !== void 0 && (obj.value = message.value ? ShardHash.toJSON(message.value) : void 0);
    return obj;
  },
  create(base) {
    return Proposal.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseProposal();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.round = (_a = object.round) != null ? _a : 0;
    message.polRound = (_b = object.polRound) != null ? _b : 0;
    message.proposer = (_c = object.proposer) != null ? _c : new Uint8Array();
    message.value = object.value !== void 0 && object.value !== null ? ShardHash.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseFullProposal() {
  return { height: void 0, round: 0, proposer: new Uint8Array(), block: void 0, shard: void 0 };
}
var FullProposal = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.round !== 0) {
      writer.uint32(16).int64(message.round);
    }
    if (message.proposer.length !== 0) {
      writer.uint32(26).bytes(message.proposer);
    }
    if (message.block !== void 0) {
      Block.encode(message.block, writer.uint32(34).fork()).ldelim();
    }
    if (message.shard !== void 0) {
      ShardChunk.encode(message.shard, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFullProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.round = longToNumber4(reader.int64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.proposer = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.block = Block.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.shard = ShardChunk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      round: isSet4(object.round) ? Number(object.round) : 0,
      proposer: isSet4(object.proposer) ? bytesFromBase644(object.proposer) : new Uint8Array(),
      block: isSet4(object.block) ? Block.fromJSON(object.block) : void 0,
      shard: isSet4(object.shard) ? ShardChunk.fromJSON(object.shard) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.round !== void 0 && (obj.round = Math.round(message.round));
    message.proposer !== void 0 && (obj.proposer = base64FromBytes4(message.proposer !== void 0 ? message.proposer : new Uint8Array()));
    message.block !== void 0 && (obj.block = message.block ? Block.toJSON(message.block) : void 0);
    message.shard !== void 0 && (obj.shard = message.shard ? ShardChunk.toJSON(message.shard) : void 0);
    return obj;
  },
  create(base) {
    return FullProposal.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFullProposal();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.round = (_a = object.round) != null ? _a : 0;
    message.proposer = (_b = object.proposer) != null ? _b : new Uint8Array();
    message.block = object.block !== void 0 && object.block !== null ? Block.fromPartial(object.block) : void 0;
    message.shard = object.shard !== void 0 && object.shard !== null ? ShardChunk.fromPartial(object.shard) : void 0;
    return message;
  }
};
function createBaseDecidedValue() {
  return { block: void 0, shard: void 0 };
}
var DecidedValue = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.block !== void 0) {
      Block.encode(message.block, writer.uint32(18).fork()).ldelim();
    }
    if (message.shard !== void 0) {
      ShardChunk.encode(message.shard, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDecidedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 18) {
            break;
          }
          message.block = Block.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.shard = ShardChunk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      block: isSet4(object.block) ? Block.fromJSON(object.block) : void 0,
      shard: isSet4(object.shard) ? ShardChunk.fromJSON(object.shard) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.block !== void 0 && (obj.block = message.block ? Block.toJSON(message.block) : void 0);
    message.shard !== void 0 && (obj.shard = message.shard ? ShardChunk.toJSON(message.shard) : void 0);
    return obj;
  },
  create(base) {
    return DecidedValue.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseDecidedValue();
    message.block = object.block !== void 0 && object.block !== null ? Block.fromPartial(object.block) : void 0;
    message.shard = object.shard !== void 0 && object.shard !== null ? ShardChunk.fromPartial(object.shard) : void 0;
    return message;
  }
};
function createBaseReadNodeMessage() {
  return { decidedValue: void 0 };
}
var ReadNodeMessage = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.decidedValue !== void 0) {
      DecidedValue.encode(message.decidedValue, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReadNodeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.decidedValue = DecidedValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { decidedValue: isSet4(object.decidedValue) ? DecidedValue.fromJSON(object.decidedValue) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.decidedValue !== void 0 && (obj.decidedValue = message.decidedValue ? DecidedValue.toJSON(message.decidedValue) : void 0);
    return obj;
  },
  create(base) {
    return ReadNodeMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseReadNodeMessage();
    message.decidedValue = object.decidedValue !== void 0 && object.decidedValue !== null ? DecidedValue.fromPartial(object.decidedValue) : void 0;
    return message;
  }
};
function createBaseConsensusMessage() {
  return { vote: void 0, proposal: void 0, signature: new Uint8Array() };
}
var ConsensusMessage = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.vote !== void 0) {
      Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
    }
    if (message.proposal !== void 0) {
      Proposal.encode(message.proposal, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConsensusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.vote = Vote.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.proposal = Proposal.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      vote: isSet4(object.vote) ? Vote.fromJSON(object.vote) : void 0,
      proposal: isSet4(object.proposal) ? Proposal.fromJSON(object.proposal) : void 0,
      signature: isSet4(object.signature) ? bytesFromBase644(object.signature) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.vote !== void 0 && (obj.vote = message.vote ? Vote.toJSON(message.vote) : void 0);
    message.proposal !== void 0 && (obj.proposal = message.proposal ? Proposal.toJSON(message.proposal) : void 0);
    message.signature !== void 0 && (obj.signature = base64FromBytes4(message.signature !== void 0 ? message.signature : new Uint8Array()));
    return obj;
  },
  create(base) {
    return ConsensusMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConsensusMessage();
    message.vote = object.vote !== void 0 && object.vote !== null ? Vote.fromPartial(object.vote) : void 0;
    message.proposal = object.proposal !== void 0 && object.proposal !== null ? Proposal.fromPartial(object.proposal) : void 0;
    message.signature = (_a = object.signature) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseBlockHeader() {
  return {
    height: void 0,
    timestamp: 0,
    version: 0,
    chainId: 0,
    shardWitnessesHash: new Uint8Array(),
    parentHash: new Uint8Array()
  };
}
var BlockHeader = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint64(message.timestamp);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.chainId !== 0) {
      writer.uint32(32).int32(message.chainId);
    }
    if (message.shardWitnessesHash.length !== 0) {
      writer.uint32(42).bytes(message.shardWitnessesHash);
    }
    if (message.parentHash.length !== 0) {
      writer.uint32(50).bytes(message.parentHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.timestamp = longToNumber4(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.version = reader.uint32();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.chainId = reader.int32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.shardWitnessesHash = reader.bytes();
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.parentHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      timestamp: isSet4(object.timestamp) ? Number(object.timestamp) : 0,
      version: isSet4(object.version) ? Number(object.version) : 0,
      chainId: isSet4(object.chainId) ? farcasterNetworkFromJSON(object.chainId) : 0,
      shardWitnessesHash: isSet4(object.shardWitnessesHash) ? bytesFromBase644(object.shardWitnessesHash) : new Uint8Array(),
      parentHash: isSet4(object.parentHash) ? bytesFromBase644(object.parentHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.version !== void 0 && (obj.version = Math.round(message.version));
    message.chainId !== void 0 && (obj.chainId = farcasterNetworkToJSON(message.chainId));
    message.shardWitnessesHash !== void 0 && (obj.shardWitnessesHash = base64FromBytes4(
      message.shardWitnessesHash !== void 0 ? message.shardWitnessesHash : new Uint8Array()
    ));
    message.parentHash !== void 0 && (obj.parentHash = base64FromBytes4(message.parentHash !== void 0 ? message.parentHash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return BlockHeader.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseBlockHeader();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.timestamp = (_a = object.timestamp) != null ? _a : 0;
    message.version = (_b = object.version) != null ? _b : 0;
    message.chainId = (_c = object.chainId) != null ? _c : 0;
    message.shardWitnessesHash = (_d = object.shardWitnessesHash) != null ? _d : new Uint8Array();
    message.parentHash = (_e = object.parentHash) != null ? _e : new Uint8Array();
    return message;
  }
};
function createBaseShardWitness() {
  return { shardChunkWitnesses: [] };
}
var ShardWitness = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    for (const v of message.shardChunkWitnesses) {
      ShardChunkWitness.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.shardChunkWitnesses.push(ShardChunkWitness.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardChunkWitnesses: Array.isArray(object == null ? void 0 : object.shardChunkWitnesses) ? object.shardChunkWitnesses.map((e) => ShardChunkWitness.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.shardChunkWitnesses) {
      obj.shardChunkWitnesses = message.shardChunkWitnesses.map((e) => e ? ShardChunkWitness.toJSON(e) : void 0);
    } else {
      obj.shardChunkWitnesses = [];
    }
    return obj;
  },
  create(base) {
    return ShardWitness.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseShardWitness();
    message.shardChunkWitnesses = ((_a = object.shardChunkWitnesses) == null ? void 0 : _a.map((e) => ShardChunkWitness.fromPartial(e))) || [];
    return message;
  }
};
function createBaseShardChunkWitness() {
  return { height: void 0, shardRoot: new Uint8Array(), shardHash: new Uint8Array() };
}
var ShardChunkWitness = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.shardRoot.length !== 0) {
      writer.uint32(18).bytes(message.shardRoot);
    }
    if (message.shardHash.length !== 0) {
      writer.uint32(26).bytes(message.shardHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardChunkWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.shardRoot = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.shardHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      shardRoot: isSet4(object.shardRoot) ? bytesFromBase644(object.shardRoot) : new Uint8Array(),
      shardHash: isSet4(object.shardHash) ? bytesFromBase644(object.shardHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.shardRoot !== void 0 && (obj.shardRoot = base64FromBytes4(message.shardRoot !== void 0 ? message.shardRoot : new Uint8Array()));
    message.shardHash !== void 0 && (obj.shardHash = base64FromBytes4(message.shardHash !== void 0 ? message.shardHash : new Uint8Array()));
    return obj;
  },
  create(base) {
    return ShardChunkWitness.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseShardChunkWitness();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.shardRoot = (_a = object.shardRoot) != null ? _a : new Uint8Array();
    message.shardHash = (_b = object.shardHash) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseBlock() {
  return { header: void 0, hash: new Uint8Array(), shardWitness: void 0, commits: void 0 };
}
var Block = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.header !== void 0) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.shardWitness !== void 0) {
      ShardWitness.encode(message.shardWitness, writer.uint32(26).fork()).ldelim();
    }
    if (message.commits !== void 0) {
      Commits.encode(message.commits, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.shardWitness = ShardWitness.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.commits = Commits.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      header: isSet4(object.header) ? BlockHeader.fromJSON(object.header) : void 0,
      hash: isSet4(object.hash) ? bytesFromBase644(object.hash) : new Uint8Array(),
      shardWitness: isSet4(object.shardWitness) ? ShardWitness.fromJSON(object.shardWitness) : void 0,
      commits: isSet4(object.commits) ? Commits.fromJSON(object.commits) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.header !== void 0 && (obj.header = message.header ? BlockHeader.toJSON(message.header) : void 0);
    message.hash !== void 0 && (obj.hash = base64FromBytes4(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.shardWitness !== void 0 && (obj.shardWitness = message.shardWitness ? ShardWitness.toJSON(message.shardWitness) : void 0);
    message.commits !== void 0 && (obj.commits = message.commits ? Commits.toJSON(message.commits) : void 0);
    return obj;
  },
  create(base) {
    return Block.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBlock();
    message.header = object.header !== void 0 && object.header !== null ? BlockHeader.fromPartial(object.header) : void 0;
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.shardWitness = object.shardWitness !== void 0 && object.shardWitness !== null ? ShardWitness.fromPartial(object.shardWitness) : void 0;
    message.commits = object.commits !== void 0 && object.commits !== null ? Commits.fromPartial(object.commits) : void 0;
    return message;
  }
};
function createBaseShardHeader() {
  return { height: void 0, timestamp: 0, parentHash: new Uint8Array(), shardRoot: new Uint8Array() };
}
var ShardHeader = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint64(message.timestamp);
    }
    if (message.parentHash.length !== 0) {
      writer.uint32(26).bytes(message.parentHash);
    }
    if (message.shardRoot.length !== 0) {
      writer.uint32(34).bytes(message.shardRoot);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.timestamp = longToNumber4(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.parentHash = reader.bytes();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.shardRoot = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      timestamp: isSet4(object.timestamp) ? Number(object.timestamp) : 0,
      parentHash: isSet4(object.parentHash) ? bytesFromBase644(object.parentHash) : new Uint8Array(),
      shardRoot: isSet4(object.shardRoot) ? bytesFromBase644(object.shardRoot) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.parentHash !== void 0 && (obj.parentHash = base64FromBytes4(message.parentHash !== void 0 ? message.parentHash : new Uint8Array()));
    message.shardRoot !== void 0 && (obj.shardRoot = base64FromBytes4(message.shardRoot !== void 0 ? message.shardRoot : new Uint8Array()));
    return obj;
  },
  create(base) {
    return ShardHeader.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseShardHeader();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.timestamp = (_a = object.timestamp) != null ? _a : 0;
    message.parentHash = (_b = object.parentHash) != null ? _b : new Uint8Array();
    message.shardRoot = (_c = object.shardRoot) != null ? _c : new Uint8Array();
    return message;
  }
};
function createBaseShardChunk() {
  return { header: void 0, hash: new Uint8Array(), transactions: [], commits: void 0 };
}
var ShardChunk = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.header !== void 0) {
      ShardHeader.encode(message.header, writer.uint32(10).fork()).ldelim();
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    for (const v of message.transactions) {
      Transaction.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.commits !== void 0) {
      Commits.encode(message.commits, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.header = ShardHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.commits = Commits.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      header: isSet4(object.header) ? ShardHeader.fromJSON(object.header) : void 0,
      hash: isSet4(object.hash) ? bytesFromBase644(object.hash) : new Uint8Array(),
      transactions: Array.isArray(object == null ? void 0 : object.transactions) ? object.transactions.map((e) => Transaction.fromJSON(e)) : [],
      commits: isSet4(object.commits) ? Commits.fromJSON(object.commits) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.header !== void 0 && (obj.header = message.header ? ShardHeader.toJSON(message.header) : void 0);
    message.hash !== void 0 && (obj.hash = base64FromBytes4(message.hash !== void 0 ? message.hash : new Uint8Array()));
    if (message.transactions) {
      obj.transactions = message.transactions.map((e) => e ? Transaction.toJSON(e) : void 0);
    } else {
      obj.transactions = [];
    }
    message.commits !== void 0 && (obj.commits = message.commits ? Commits.toJSON(message.commits) : void 0);
    return obj;
  },
  create(base) {
    return ShardChunk.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseShardChunk();
    message.header = object.header !== void 0 && object.header !== null ? ShardHeader.fromPartial(object.header) : void 0;
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.transactions = ((_b = object.transactions) == null ? void 0 : _b.map((e) => Transaction.fromPartial(e))) || [];
    message.commits = object.commits !== void 0 && object.commits !== null ? Commits.fromPartial(object.commits) : void 0;
    return message;
  }
};
function createBaseTransaction() {
  return { fid: 0, userMessages: [], systemMessages: [], accountRoot: new Uint8Array() };
}
var Transaction = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    for (const v of message.userMessages) {
      Message.encode(v, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.systemMessages) {
      ValidatorMessage.encode(v, writer.uint32(26).fork()).ldelim();
    }
    if (message.accountRoot.length !== 0) {
      writer.uint32(34).bytes(message.accountRoot);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber4(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.userMessages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.systemMessages.push(ValidatorMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.accountRoot = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet4(object.fid) ? Number(object.fid) : 0,
      userMessages: Array.isArray(object == null ? void 0 : object.userMessages) ? object.userMessages.map((e) => Message.fromJSON(e)) : [],
      systemMessages: Array.isArray(object == null ? void 0 : object.systemMessages) ? object.systemMessages.map((e) => ValidatorMessage.fromJSON(e)) : [],
      accountRoot: isSet4(object.accountRoot) ? bytesFromBase644(object.accountRoot) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    if (message.userMessages) {
      obj.userMessages = message.userMessages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.userMessages = [];
    }
    if (message.systemMessages) {
      obj.systemMessages = message.systemMessages.map((e) => e ? ValidatorMessage.toJSON(e) : void 0);
    } else {
      obj.systemMessages = [];
    }
    message.accountRoot !== void 0 && (obj.accountRoot = base64FromBytes4(message.accountRoot !== void 0 ? message.accountRoot : new Uint8Array()));
    return obj;
  },
  create(base) {
    return Transaction.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseTransaction();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.userMessages = ((_b = object.userMessages) == null ? void 0 : _b.map((e) => Message.fromPartial(e))) || [];
    message.systemMessages = ((_c = object.systemMessages) == null ? void 0 : _c.map((e) => ValidatorMessage.fromPartial(e))) || [];
    message.accountRoot = (_d = object.accountRoot) != null ? _d : new Uint8Array();
    return message;
  }
};
function createBaseFnameTransfer() {
  return { id: 0, fromFid: 0, proof: void 0 };
}
var FnameTransfer = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.fromFid !== 0) {
      writer.uint32(16).uint64(message.fromFid);
    }
    if (message.proof !== void 0) {
      UserNameProof.encode(message.proof, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFnameTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.id = longToNumber4(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.fromFid = longToNumber4(reader.uint64());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.proof = UserNameProof.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet4(object.id) ? Number(object.id) : 0,
      fromFid: isSet4(object.fromFid) ? Number(object.fromFid) : 0,
      proof: isSet4(object.proof) ? UserNameProof.fromJSON(object.proof) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.fromFid !== void 0 && (obj.fromFid = Math.round(message.fromFid));
    message.proof !== void 0 && (obj.proof = message.proof ? UserNameProof.toJSON(message.proof) : void 0);
    return obj;
  },
  create(base) {
    return FnameTransfer.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFnameTransfer();
    message.id = (_a = object.id) != null ? _a : 0;
    message.fromFid = (_b = object.fromFid) != null ? _b : 0;
    message.proof = object.proof !== void 0 && object.proof !== null ? UserNameProof.fromPartial(object.proof) : void 0;
    return message;
  }
};
function createBaseValidatorMessage() {
  return { onChainEvent: void 0, fnameTransfer: void 0 };
}
var ValidatorMessage = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.onChainEvent !== void 0) {
      OnChainEvent.encode(message.onChainEvent, writer.uint32(10).fork()).ldelim();
    }
    if (message.fnameTransfer !== void 0) {
      FnameTransfer.encode(message.fnameTransfer, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidatorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.onChainEvent = OnChainEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.fnameTransfer = FnameTransfer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      onChainEvent: isSet4(object.onChainEvent) ? OnChainEvent.fromJSON(object.onChainEvent) : void 0,
      fnameTransfer: isSet4(object.fnameTransfer) ? FnameTransfer.fromJSON(object.fnameTransfer) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.onChainEvent !== void 0 && (obj.onChainEvent = message.onChainEvent ? OnChainEvent.toJSON(message.onChainEvent) : void 0);
    message.fnameTransfer !== void 0 && (obj.fnameTransfer = message.fnameTransfer ? FnameTransfer.toJSON(message.fnameTransfer) : void 0);
    return obj;
  },
  create(base) {
    return ValidatorMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseValidatorMessage();
    message.onChainEvent = object.onChainEvent !== void 0 && object.onChainEvent !== null ? OnChainEvent.fromPartial(object.onChainEvent) : void 0;
    message.fnameTransfer = object.fnameTransfer !== void 0 && object.fnameTransfer !== null ? FnameTransfer.fromPartial(object.fnameTransfer) : void 0;
    return message;
  }
};
function createBaseMempoolMessage() {
  return { userMessage: void 0 };
}
var MempoolMessage = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.userMessage !== void 0) {
      Message.encode(message.userMessage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMempoolMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.userMessage = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { userMessage: isSet4(object.userMessage) ? Message.fromJSON(object.userMessage) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.userMessage !== void 0 && (obj.userMessage = message.userMessage ? Message.toJSON(message.userMessage) : void 0);
    return obj;
  },
  create(base) {
    return MempoolMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMempoolMessage();
    message.userMessage = object.userMessage !== void 0 && object.userMessage !== null ? Message.fromPartial(object.userMessage) : void 0;
    return message;
  }
};
function createBaseStatusMessage() {
  return { peerId: new Uint8Array(), height: void 0, minHeight: void 0 };
}
var StatusMessage = {
  encode(message, writer = import_minimal4.default.Writer.create()) {
    if (message.peerId.length !== 0) {
      writer.uint32(10).bytes(message.peerId);
    }
    if (message.height !== void 0) {
      Height.encode(message.height, writer.uint32(18).fork()).ldelim();
    }
    if (message.minHeight !== void 0) {
      Height.encode(message.minHeight, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStatusMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.peerId = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.height = Height.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.minHeight = Height.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      peerId: isSet4(object.peerId) ? bytesFromBase644(object.peerId) : new Uint8Array(),
      height: isSet4(object.height) ? Height.fromJSON(object.height) : void 0,
      minHeight: isSet4(object.minHeight) ? Height.fromJSON(object.minHeight) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.peerId !== void 0 && (obj.peerId = base64FromBytes4(message.peerId !== void 0 ? message.peerId : new Uint8Array()));
    message.height !== void 0 && (obj.height = message.height ? Height.toJSON(message.height) : void 0);
    message.minHeight !== void 0 && (obj.minHeight = message.minHeight ? Height.toJSON(message.minHeight) : void 0);
    return obj;
  },
  create(base) {
    return StatusMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStatusMessage();
    message.peerId = (_a = object.peerId) != null ? _a : new Uint8Array();
    message.height = object.height !== void 0 && object.height !== null ? Height.fromPartial(object.height) : void 0;
    message.minHeight = object.minHeight !== void 0 && object.minHeight !== null ? Height.fromPartial(object.minHeight) : void 0;
    return message;
  }
};
var tsProtoGlobalThis4 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase644(b64) {
  if (tsProtoGlobalThis4.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis4.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis4.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes4(arr) {
  if (tsProtoGlobalThis4.Buffer) {
    return tsProtoGlobalThis4.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis4.btoa(bin.join(""));
  }
}
function longToNumber4(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis4.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal4.default.util.Long !== import_long4.default) {
  import_minimal4.default.util.Long = import_long4.default;
  import_minimal4.default.configure();
}
function isSet4(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/gossip.ts
function createBaseContactInfoBody() {
  return { gossipAddress: "", peerId: new Uint8Array(), snapchainVersion: "", network: 0, timestamp: 0 };
}
var ContactInfoBody = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.gossipAddress !== "") {
      writer.uint32(10).string(message.gossipAddress);
    }
    if (message.peerId.length !== 0) {
      writer.uint32(18).bytes(message.peerId);
    }
    if (message.snapchainVersion !== "") {
      writer.uint32(26).string(message.snapchainVersion);
    }
    if (message.network !== 0) {
      writer.uint32(32).int32(message.network);
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).uint64(message.timestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContactInfoBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.gossipAddress = reader.string();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.peerId = reader.bytes();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.snapchainVersion = reader.string();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.network = reader.int32();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.timestamp = longToNumber5(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      gossipAddress: isSet5(object.gossipAddress) ? String(object.gossipAddress) : "",
      peerId: isSet5(object.peerId) ? bytesFromBase645(object.peerId) : new Uint8Array(),
      snapchainVersion: isSet5(object.snapchainVersion) ? String(object.snapchainVersion) : "",
      network: isSet5(object.network) ? farcasterNetworkFromJSON(object.network) : 0,
      timestamp: isSet5(object.timestamp) ? Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.gossipAddress !== void 0 && (obj.gossipAddress = message.gossipAddress);
    message.peerId !== void 0 && (obj.peerId = base64FromBytes5(message.peerId !== void 0 ? message.peerId : new Uint8Array()));
    message.snapchainVersion !== void 0 && (obj.snapchainVersion = message.snapchainVersion);
    message.network !== void 0 && (obj.network = farcasterNetworkToJSON(message.network));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
  create(base) {
    return ContactInfoBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseContactInfoBody();
    message.gossipAddress = (_a = object.gossipAddress) != null ? _a : "";
    message.peerId = (_b = object.peerId) != null ? _b : new Uint8Array();
    message.snapchainVersion = (_c = object.snapchainVersion) != null ? _c : "";
    message.network = (_d = object.network) != null ? _d : 0;
    message.timestamp = (_e = object.timestamp) != null ? _e : 0;
    return message;
  }
};
function createBaseContactInfo() {
  return { body: void 0 };
}
var ContactInfo = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.body !== void 0) {
      ContactInfoBody.encode(message.body, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContactInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.body = ContactInfoBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { body: isSet5(object.body) ? ContactInfoBody.fromJSON(object.body) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body ? ContactInfoBody.toJSON(message.body) : void 0);
    return obj;
  },
  create(base) {
    return ContactInfo.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseContactInfo();
    message.body = object.body !== void 0 && object.body !== null ? ContactInfoBody.fromPartial(object.body) : void 0;
    return message;
  }
};
function createBaseGossipMessage() {
  return {
    consensus: void 0,
    fullProposal: void 0,
    mempoolMessage: void 0,
    status: void 0,
    readNodeMessage: void 0,
    contactInfoMessage: void 0
  };
}
var GossipMessage = {
  encode(message, writer = import_minimal5.default.Writer.create()) {
    if (message.consensus !== void 0) {
      ConsensusMessage.encode(message.consensus, writer.uint32(10).fork()).ldelim();
    }
    if (message.fullProposal !== void 0) {
      FullProposal.encode(message.fullProposal, writer.uint32(18).fork()).ldelim();
    }
    if (message.mempoolMessage !== void 0) {
      MempoolMessage.encode(message.mempoolMessage, writer.uint32(26).fork()).ldelim();
    }
    if (message.status !== void 0) {
      StatusMessage.encode(message.status, writer.uint32(34).fork()).ldelim();
    }
    if (message.readNodeMessage !== void 0) {
      ReadNodeMessage.encode(message.readNodeMessage, writer.uint32(42).fork()).ldelim();
    }
    if (message.contactInfoMessage !== void 0) {
      ContactInfo.encode(message.contactInfoMessage, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGossipMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.consensus = ConsensusMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.fullProposal = FullProposal.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.mempoolMessage = MempoolMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.status = StatusMessage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.readNodeMessage = ReadNodeMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.contactInfoMessage = ContactInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      consensus: isSet5(object.consensus) ? ConsensusMessage.fromJSON(object.consensus) : void 0,
      fullProposal: isSet5(object.fullProposal) ? FullProposal.fromJSON(object.fullProposal) : void 0,
      mempoolMessage: isSet5(object.mempoolMessage) ? MempoolMessage.fromJSON(object.mempoolMessage) : void 0,
      status: isSet5(object.status) ? StatusMessage.fromJSON(object.status) : void 0,
      readNodeMessage: isSet5(object.readNodeMessage) ? ReadNodeMessage.fromJSON(object.readNodeMessage) : void 0,
      contactInfoMessage: isSet5(object.contactInfoMessage) ? ContactInfo.fromJSON(object.contactInfoMessage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.consensus !== void 0 && (obj.consensus = message.consensus ? ConsensusMessage.toJSON(message.consensus) : void 0);
    message.fullProposal !== void 0 && (obj.fullProposal = message.fullProposal ? FullProposal.toJSON(message.fullProposal) : void 0);
    message.mempoolMessage !== void 0 && (obj.mempoolMessage = message.mempoolMessage ? MempoolMessage.toJSON(message.mempoolMessage) : void 0);
    message.status !== void 0 && (obj.status = message.status ? StatusMessage.toJSON(message.status) : void 0);
    message.readNodeMessage !== void 0 && (obj.readNodeMessage = message.readNodeMessage ? ReadNodeMessage.toJSON(message.readNodeMessage) : void 0);
    message.contactInfoMessage !== void 0 && (obj.contactInfoMessage = message.contactInfoMessage ? ContactInfo.toJSON(message.contactInfoMessage) : void 0);
    return obj;
  },
  create(base) {
    return GossipMessage.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseGossipMessage();
    message.consensus = object.consensus !== void 0 && object.consensus !== null ? ConsensusMessage.fromPartial(object.consensus) : void 0;
    message.fullProposal = object.fullProposal !== void 0 && object.fullProposal !== null ? FullProposal.fromPartial(object.fullProposal) : void 0;
    message.mempoolMessage = object.mempoolMessage !== void 0 && object.mempoolMessage !== null ? MempoolMessage.fromPartial(object.mempoolMessage) : void 0;
    message.status = object.status !== void 0 && object.status !== null ? StatusMessage.fromPartial(object.status) : void 0;
    message.readNodeMessage = object.readNodeMessage !== void 0 && object.readNodeMessage !== null ? ReadNodeMessage.fromPartial(object.readNodeMessage) : void 0;
    message.contactInfoMessage = object.contactInfoMessage !== void 0 && object.contactInfoMessage !== null ? ContactInfo.fromPartial(object.contactInfoMessage) : void 0;
    return message;
  }
};
var tsProtoGlobalThis5 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase645(b64) {
  if (tsProtoGlobalThis5.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis5.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis5.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes5(arr) {
  if (tsProtoGlobalThis5.Buffer) {
    return tsProtoGlobalThis5.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis5.btoa(bin.join(""));
  }
}
function longToNumber5(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis5.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal5.default.util.Long !== import_long5.default) {
  import_minimal5.default.util.Long = import_long5.default;
  import_minimal5.default.configure();
}
function isSet5(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/hub_event.ts
init_cjs_shims();
var import_long6 = __toESM(require_long());
var import_minimal6 = __toESM(require_minimal2());
var HubEventType = /* @__PURE__ */ ((HubEventType3) => {
  HubEventType3[HubEventType3["NONE"] = 0] = "NONE";
  HubEventType3[HubEventType3["MERGE_MESSAGE"] = 1] = "MERGE_MESSAGE";
  HubEventType3[HubEventType3["PRUNE_MESSAGE"] = 2] = "PRUNE_MESSAGE";
  HubEventType3[HubEventType3["REVOKE_MESSAGE"] = 3] = "REVOKE_MESSAGE";
  HubEventType3[HubEventType3["MERGE_USERNAME_PROOF"] = 6] = "MERGE_USERNAME_PROOF";
  HubEventType3[HubEventType3["MERGE_ON_CHAIN_EVENT"] = 9] = "MERGE_ON_CHAIN_EVENT";
  HubEventType3[HubEventType3["MERGE_FAILURE"] = 10] = "MERGE_FAILURE";
  HubEventType3[HubEventType3["BLOCK_CONFIRMED"] = 11] = "BLOCK_CONFIRMED";
  return HubEventType3;
})(HubEventType || {});
function hubEventTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "HUB_EVENT_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "HUB_EVENT_TYPE_MERGE_MESSAGE":
      return 1 /* MERGE_MESSAGE */;
    case 2:
    case "HUB_EVENT_TYPE_PRUNE_MESSAGE":
      return 2 /* PRUNE_MESSAGE */;
    case 3:
    case "HUB_EVENT_TYPE_REVOKE_MESSAGE":
      return 3 /* REVOKE_MESSAGE */;
    case 6:
    case "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF":
      return 6 /* MERGE_USERNAME_PROOF */;
    case 9:
    case "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT":
      return 9 /* MERGE_ON_CHAIN_EVENT */;
    case 10:
    case "HUB_EVENT_TYPE_MERGE_FAILURE":
      return 10 /* MERGE_FAILURE */;
    case 11:
    case "HUB_EVENT_TYPE_BLOCK_CONFIRMED":
      return 11 /* BLOCK_CONFIRMED */;
    default:
      throw new tsProtoGlobalThis6.Error("Unrecognized enum value " + object + " for enum HubEventType");
  }
}
function hubEventTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "HUB_EVENT_TYPE_NONE";
    case 1 /* MERGE_MESSAGE */:
      return "HUB_EVENT_TYPE_MERGE_MESSAGE";
    case 2 /* PRUNE_MESSAGE */:
      return "HUB_EVENT_TYPE_PRUNE_MESSAGE";
    case 3 /* REVOKE_MESSAGE */:
      return "HUB_EVENT_TYPE_REVOKE_MESSAGE";
    case 6 /* MERGE_USERNAME_PROOF */:
      return "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF";
    case 9 /* MERGE_ON_CHAIN_EVENT */:
      return "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT";
    case 10 /* MERGE_FAILURE */:
      return "HUB_EVENT_TYPE_MERGE_FAILURE";
    case 11 /* BLOCK_CONFIRMED */:
      return "HUB_EVENT_TYPE_BLOCK_CONFIRMED";
    default:
      throw new tsProtoGlobalThis6.Error("Unrecognized enum value " + object + " for enum HubEventType");
  }
}
function createBaseMergeMessageBody() {
  return { message: void 0, deletedMessages: [] };
}
var MergeMessageBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.deletedMessages) {
      Message.encode(v, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.deletedMessages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet6(object.message) ? Message.fromJSON(object.message) : void 0,
      deletedMessages: Array.isArray(object == null ? void 0 : object.deletedMessages) ? object.deletedMessages.map((e) => Message.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    if (message.deletedMessages) {
      obj.deletedMessages = message.deletedMessages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.deletedMessages = [];
    }
    return obj;
  },
  create(base) {
    return MergeMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMergeMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.deletedMessages = ((_a = object.deletedMessages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMergeFailureBody() {
  return { message: void 0, code: "", reason: "" };
}
var MergeFailureBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeFailureBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.code = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet6(object.message) ? Message.fromJSON(object.message) : void 0,
      code: isSet6(object.code) ? String(object.code) : "",
      reason: isSet6(object.reason) ? String(object.reason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    message.code !== void 0 && (obj.code = message.code);
    message.reason !== void 0 && (obj.reason = message.reason);
    return obj;
  },
  create(base) {
    return MergeFailureBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMergeFailureBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.code = (_a = object.code) != null ? _a : "";
    message.reason = (_b = object.reason) != null ? _b : "";
    return message;
  }
};
function createBasePruneMessageBody() {
  return { message: void 0 };
}
var PruneMessageBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePruneMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet6(object.message) ? Message.fromJSON(object.message) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return PruneMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBasePruneMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseRevokeMessageBody() {
  return { message: void 0 };
}
var RevokeMessageBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessageBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { message: isSet6(object.message) ? Message.fromJSON(object.message) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return RevokeMessageBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseRevokeMessageBody();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseBlockConfirmedBody() {
  return {
    blockNumber: 0,
    shardIndex: 0,
    timestamp: 0,
    blockHash: new Uint8Array(),
    totalEvents: 0,
    eventCountsByType: {}
  };
}
var BlockConfirmedBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.blockNumber !== 0) {
      writer.uint32(8).uint64(message.blockNumber);
    }
    if (message.shardIndex !== 0) {
      writer.uint32(16).uint32(message.shardIndex);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).uint64(message.timestamp);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(34).bytes(message.blockHash);
    }
    if (message.totalEvents !== 0) {
      writer.uint32(40).uint64(message.totalEvents);
    }
    Object.entries(message.eventCountsByType).forEach(([key, value]) => {
      BlockConfirmedBody_EventCountsByTypeEntry.encode({ key, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfirmedBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.blockNumber = longToNumber6(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.timestamp = longToNumber6(reader.uint64());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.blockHash = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.totalEvents = longToNumber6(reader.uint64());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          const entry6 = BlockConfirmedBody_EventCountsByTypeEntry.decode(reader, reader.uint32());
          if (entry6.value !== void 0) {
            message.eventCountsByType[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      blockNumber: isSet6(object.blockNumber) ? Number(object.blockNumber) : 0,
      shardIndex: isSet6(object.shardIndex) ? Number(object.shardIndex) : 0,
      timestamp: isSet6(object.timestamp) ? Number(object.timestamp) : 0,
      blockHash: isSet6(object.blockHash) ? bytesFromBase646(object.blockHash) : new Uint8Array(),
      totalEvents: isSet6(object.totalEvents) ? Number(object.totalEvents) : 0,
      eventCountsByType: isObject(object.eventCountsByType) ? Object.entries(object.eventCountsByType).reduce((acc, [key, value]) => {
        acc[Number(key)] = Number(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.blockNumber !== void 0 && (obj.blockNumber = Math.round(message.blockNumber));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    message.blockHash !== void 0 && (obj.blockHash = base64FromBytes6(message.blockHash !== void 0 ? message.blockHash : new Uint8Array()));
    message.totalEvents !== void 0 && (obj.totalEvents = Math.round(message.totalEvents));
    obj.eventCountsByType = {};
    if (message.eventCountsByType) {
      Object.entries(message.eventCountsByType).forEach(([k, v]) => {
        obj.eventCountsByType[k] = Math.round(v);
      });
    }
    return obj;
  },
  create(base) {
    return BlockConfirmedBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseBlockConfirmedBody();
    message.blockNumber = (_a = object.blockNumber) != null ? _a : 0;
    message.shardIndex = (_b = object.shardIndex) != null ? _b : 0;
    message.timestamp = (_c = object.timestamp) != null ? _c : 0;
    message.blockHash = (_d = object.blockHash) != null ? _d : new Uint8Array();
    message.totalEvents = (_e = object.totalEvents) != null ? _e : 0;
    message.eventCountsByType = Object.entries((_f = object.eventCountsByType) != null ? _f : {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[Number(key)] = Number(value);
        }
        return acc;
      },
      {}
    );
    return message;
  }
};
function createBaseBlockConfirmedBody_EventCountsByTypeEntry() {
  return { key: 0, value: 0 };
}
var BlockConfirmedBody_EventCountsByTypeEntry = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlockConfirmedBody_EventCountsByTypeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.key = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.value = longToNumber6(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { key: isSet6(object.key) ? Number(object.key) : 0, value: isSet6(object.value) ? Number(object.value) : 0 };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = Math.round(message.key));
    message.value !== void 0 && (obj.value = Math.round(message.value));
    return obj;
  },
  create(base) {
    return BlockConfirmedBody_EventCountsByTypeEntry.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBlockConfirmedBody_EventCountsByTypeEntry();
    message.key = (_a = object.key) != null ? _a : 0;
    message.value = (_b = object.value) != null ? _b : 0;
    return message;
  }
};
function createBaseMergeOnChainEventBody() {
  return { onChainEvent: void 0 };
}
var MergeOnChainEventBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.onChainEvent !== void 0) {
      OnChainEvent.encode(message.onChainEvent, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeOnChainEventBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.onChainEvent = OnChainEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { onChainEvent: isSet6(object.onChainEvent) ? OnChainEvent.fromJSON(object.onChainEvent) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    message.onChainEvent !== void 0 && (obj.onChainEvent = message.onChainEvent ? OnChainEvent.toJSON(message.onChainEvent) : void 0);
    return obj;
  },
  create(base) {
    return MergeOnChainEventBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMergeOnChainEventBody();
    message.onChainEvent = object.onChainEvent !== void 0 && object.onChainEvent !== null ? OnChainEvent.fromPartial(object.onChainEvent) : void 0;
    return message;
  }
};
function createBaseMergeUserNameProofBody() {
  return {
    usernameProof: void 0,
    deletedUsernameProof: void 0,
    usernameProofMessage: void 0,
    deletedUsernameProofMessage: void 0
  };
}
var MergeUserNameProofBody = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.usernameProof !== void 0) {
      UserNameProof.encode(message.usernameProof, writer.uint32(10).fork()).ldelim();
    }
    if (message.deletedUsernameProof !== void 0) {
      UserNameProof.encode(message.deletedUsernameProof, writer.uint32(18).fork()).ldelim();
    }
    if (message.usernameProofMessage !== void 0) {
      Message.encode(message.usernameProofMessage, writer.uint32(26).fork()).ldelim();
    }
    if (message.deletedUsernameProofMessage !== void 0) {
      Message.encode(message.deletedUsernameProofMessage, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMergeUserNameProofBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.usernameProof = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.deletedUsernameProof = UserNameProof.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.usernameProofMessage = Message.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.deletedUsernameProofMessage = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      usernameProof: isSet6(object.usernameProof) ? UserNameProof.fromJSON(object.usernameProof) : void 0,
      deletedUsernameProof: isSet6(object.deletedUsernameProof) ? UserNameProof.fromJSON(object.deletedUsernameProof) : void 0,
      usernameProofMessage: isSet6(object.usernameProofMessage) ? Message.fromJSON(object.usernameProofMessage) : void 0,
      deletedUsernameProofMessage: isSet6(object.deletedUsernameProofMessage) ? Message.fromJSON(object.deletedUsernameProofMessage) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.usernameProof !== void 0 && (obj.usernameProof = message.usernameProof ? UserNameProof.toJSON(message.usernameProof) : void 0);
    message.deletedUsernameProof !== void 0 && (obj.deletedUsernameProof = message.deletedUsernameProof ? UserNameProof.toJSON(message.deletedUsernameProof) : void 0);
    message.usernameProofMessage !== void 0 && (obj.usernameProofMessage = message.usernameProofMessage ? Message.toJSON(message.usernameProofMessage) : void 0);
    message.deletedUsernameProofMessage !== void 0 && (obj.deletedUsernameProofMessage = message.deletedUsernameProofMessage ? Message.toJSON(message.deletedUsernameProofMessage) : void 0);
    return obj;
  },
  create(base) {
    return MergeUserNameProofBody.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMergeUserNameProofBody();
    message.usernameProof = object.usernameProof !== void 0 && object.usernameProof !== null ? UserNameProof.fromPartial(object.usernameProof) : void 0;
    message.deletedUsernameProof = object.deletedUsernameProof !== void 0 && object.deletedUsernameProof !== null ? UserNameProof.fromPartial(object.deletedUsernameProof) : void 0;
    message.usernameProofMessage = object.usernameProofMessage !== void 0 && object.usernameProofMessage !== null ? Message.fromPartial(object.usernameProofMessage) : void 0;
    message.deletedUsernameProofMessage = object.deletedUsernameProofMessage !== void 0 && object.deletedUsernameProofMessage !== null ? Message.fromPartial(object.deletedUsernameProofMessage) : void 0;
    return message;
  }
};
function createBaseHubEvent() {
  return {
    type: 0,
    id: 0,
    mergeMessageBody: void 0,
    pruneMessageBody: void 0,
    revokeMessageBody: void 0,
    mergeUsernameProofBody: void 0,
    mergeOnChainEventBody: void 0,
    mergeFailure: void 0,
    blockConfirmedBody: void 0,
    blockNumber: 0,
    shardIndex: 0,
    timestamp: 0
  };
}
var HubEvent = {
  encode(message, writer = import_minimal6.default.Writer.create()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.mergeMessageBody !== void 0) {
      MergeMessageBody.encode(message.mergeMessageBody, writer.uint32(26).fork()).ldelim();
    }
    if (message.pruneMessageBody !== void 0) {
      PruneMessageBody.encode(message.pruneMessageBody, writer.uint32(34).fork()).ldelim();
    }
    if (message.revokeMessageBody !== void 0) {
      RevokeMessageBody.encode(message.revokeMessageBody, writer.uint32(42).fork()).ldelim();
    }
    if (message.mergeUsernameProofBody !== void 0) {
      MergeUserNameProofBody.encode(message.mergeUsernameProofBody, writer.uint32(66).fork()).ldelim();
    }
    if (message.mergeOnChainEventBody !== void 0) {
      MergeOnChainEventBody.encode(message.mergeOnChainEventBody, writer.uint32(90).fork()).ldelim();
    }
    if (message.mergeFailure !== void 0) {
      MergeFailureBody.encode(message.mergeFailure, writer.uint32(106).fork()).ldelim();
    }
    if (message.blockConfirmedBody !== void 0) {
      BlockConfirmedBody.encode(message.blockConfirmedBody, writer.uint32(130).fork()).ldelim();
    }
    if (message.blockNumber !== 0) {
      writer.uint32(96).uint64(message.blockNumber);
    }
    if (message.shardIndex !== 0) {
      writer.uint32(112).uint32(message.shardIndex);
    }
    if (message.timestamp !== 0) {
      writer.uint32(120).uint64(message.timestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal6.default.Reader ? input : import_minimal6.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.id = longToNumber6(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.mergeMessageBody = MergeMessageBody.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pruneMessageBody = PruneMessageBody.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.revokeMessageBody = RevokeMessageBody.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag != 66) {
            break;
          }
          message.mergeUsernameProofBody = MergeUserNameProofBody.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag != 90) {
            break;
          }
          message.mergeOnChainEventBody = MergeOnChainEventBody.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag != 106) {
            break;
          }
          message.mergeFailure = MergeFailureBody.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag != 130) {
            break;
          }
          message.blockConfirmedBody = BlockConfirmedBody.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag != 96) {
            break;
          }
          message.blockNumber = longToNumber6(reader.uint64());
          continue;
        case 14:
          if (tag != 112) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
        case 15:
          if (tag != 120) {
            break;
          }
          message.timestamp = longToNumber6(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet6(object.type) ? hubEventTypeFromJSON(object.type) : 0,
      id: isSet6(object.id) ? Number(object.id) : 0,
      mergeMessageBody: isSet6(object.mergeMessageBody) ? MergeMessageBody.fromJSON(object.mergeMessageBody) : void 0,
      pruneMessageBody: isSet6(object.pruneMessageBody) ? PruneMessageBody.fromJSON(object.pruneMessageBody) : void 0,
      revokeMessageBody: isSet6(object.revokeMessageBody) ? RevokeMessageBody.fromJSON(object.revokeMessageBody) : void 0,
      mergeUsernameProofBody: isSet6(object.mergeUsernameProofBody) ? MergeUserNameProofBody.fromJSON(object.mergeUsernameProofBody) : void 0,
      mergeOnChainEventBody: isSet6(object.mergeOnChainEventBody) ? MergeOnChainEventBody.fromJSON(object.mergeOnChainEventBody) : void 0,
      mergeFailure: isSet6(object.mergeFailure) ? MergeFailureBody.fromJSON(object.mergeFailure) : void 0,
      blockConfirmedBody: isSet6(object.blockConfirmedBody) ? BlockConfirmedBody.fromJSON(object.blockConfirmedBody) : void 0,
      blockNumber: isSet6(object.blockNumber) ? Number(object.blockNumber) : 0,
      shardIndex: isSet6(object.shardIndex) ? Number(object.shardIndex) : 0,
      timestamp: isSet6(object.timestamp) ? Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = hubEventTypeToJSON(message.type));
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.mergeMessageBody !== void 0 && (obj.mergeMessageBody = message.mergeMessageBody ? MergeMessageBody.toJSON(message.mergeMessageBody) : void 0);
    message.pruneMessageBody !== void 0 && (obj.pruneMessageBody = message.pruneMessageBody ? PruneMessageBody.toJSON(message.pruneMessageBody) : void 0);
    message.revokeMessageBody !== void 0 && (obj.revokeMessageBody = message.revokeMessageBody ? RevokeMessageBody.toJSON(message.revokeMessageBody) : void 0);
    message.mergeUsernameProofBody !== void 0 && (obj.mergeUsernameProofBody = message.mergeUsernameProofBody ? MergeUserNameProofBody.toJSON(message.mergeUsernameProofBody) : void 0);
    message.mergeOnChainEventBody !== void 0 && (obj.mergeOnChainEventBody = message.mergeOnChainEventBody ? MergeOnChainEventBody.toJSON(message.mergeOnChainEventBody) : void 0);
    message.mergeFailure !== void 0 && (obj.mergeFailure = message.mergeFailure ? MergeFailureBody.toJSON(message.mergeFailure) : void 0);
    message.blockConfirmedBody !== void 0 && (obj.blockConfirmedBody = message.blockConfirmedBody ? BlockConfirmedBody.toJSON(message.blockConfirmedBody) : void 0);
    message.blockNumber !== void 0 && (obj.blockNumber = Math.round(message.blockNumber));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    message.timestamp !== void 0 && (obj.timestamp = Math.round(message.timestamp));
    return obj;
  },
  create(base) {
    return HubEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseHubEvent();
    message.type = (_a = object.type) != null ? _a : 0;
    message.id = (_b = object.id) != null ? _b : 0;
    message.mergeMessageBody = object.mergeMessageBody !== void 0 && object.mergeMessageBody !== null ? MergeMessageBody.fromPartial(object.mergeMessageBody) : void 0;
    message.pruneMessageBody = object.pruneMessageBody !== void 0 && object.pruneMessageBody !== null ? PruneMessageBody.fromPartial(object.pruneMessageBody) : void 0;
    message.revokeMessageBody = object.revokeMessageBody !== void 0 && object.revokeMessageBody !== null ? RevokeMessageBody.fromPartial(object.revokeMessageBody) : void 0;
    message.mergeUsernameProofBody = object.mergeUsernameProofBody !== void 0 && object.mergeUsernameProofBody !== null ? MergeUserNameProofBody.fromPartial(object.mergeUsernameProofBody) : void 0;
    message.mergeOnChainEventBody = object.mergeOnChainEventBody !== void 0 && object.mergeOnChainEventBody !== null ? MergeOnChainEventBody.fromPartial(object.mergeOnChainEventBody) : void 0;
    message.mergeFailure = object.mergeFailure !== void 0 && object.mergeFailure !== null ? MergeFailureBody.fromPartial(object.mergeFailure) : void 0;
    message.blockConfirmedBody = object.blockConfirmedBody !== void 0 && object.blockConfirmedBody !== null ? BlockConfirmedBody.fromPartial(object.blockConfirmedBody) : void 0;
    message.blockNumber = (_c = object.blockNumber) != null ? _c : 0;
    message.shardIndex = (_d = object.shardIndex) != null ? _d : 0;
    message.timestamp = (_e = object.timestamp) != null ? _e : 0;
    return message;
  }
};
var tsProtoGlobalThis6 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase646(b64) {
  if (tsProtoGlobalThis6.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis6.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis6.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes6(arr) {
  if (tsProtoGlobalThis6.Buffer) {
    return tsProtoGlobalThis6.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis6.btoa(bin.join(""));
  }
}
function longToNumber6(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis6.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal6.default.util.Long !== import_long6.default) {
  import_minimal6.default.util.Long = import_long6.default;
  import_minimal6.default.configure();
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet6(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/hub_state.ts
init_cjs_shims();
var import_long7 = __toESM(require_long());
var import_minimal7 = __toESM(require_minimal2());
function createBaseValidateOrRevokeJobState() {
  return { lastJobTimestamp: 0, lastFid: 0 };
}
var ValidateOrRevokeJobState = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.lastJobTimestamp !== 0) {
      writer.uint32(8).uint32(message.lastJobTimestamp);
    }
    if (message.lastFid !== 0) {
      writer.uint32(16).uint32(message.lastFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : import_minimal7.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidateOrRevokeJobState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.lastJobTimestamp = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.lastFid = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastJobTimestamp: isSet7(object.lastJobTimestamp) ? Number(object.lastJobTimestamp) : 0,
      lastFid: isSet7(object.lastFid) ? Number(object.lastFid) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.lastJobTimestamp !== void 0 && (obj.lastJobTimestamp = Math.round(message.lastJobTimestamp));
    message.lastFid !== void 0 && (obj.lastFid = Math.round(message.lastFid));
    return obj;
  },
  create(base) {
    return ValidateOrRevokeJobState.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseValidateOrRevokeJobState();
    message.lastJobTimestamp = (_a = object.lastJobTimestamp) != null ? _a : 0;
    message.lastFid = (_b = object.lastFid) != null ? _b : 0;
    return message;
  }
};
function createBaseHubState() {
  return { lastFnameProof: 0, lastL2Block: 0, validateOrRevokeState: void 0 };
}
var HubState = {
  encode(message, writer = import_minimal7.default.Writer.create()) {
    if (message.lastFnameProof !== 0) {
      writer.uint32(16).uint64(message.lastFnameProof);
    }
    if (message.lastL2Block !== 0) {
      writer.uint32(24).uint64(message.lastL2Block);
    }
    if (message.validateOrRevokeState !== void 0) {
      ValidateOrRevokeJobState.encode(message.validateOrRevokeState, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal7.default.Reader ? input : import_minimal7.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseHubState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag != 16) {
            break;
          }
          message.lastFnameProof = longToNumber7(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.lastL2Block = longToNumber7(reader.uint64());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.validateOrRevokeState = ValidateOrRevokeJobState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastFnameProof: isSet7(object.lastFnameProof) ? Number(object.lastFnameProof) : 0,
      lastL2Block: isSet7(object.lastL2Block) ? Number(object.lastL2Block) : 0,
      validateOrRevokeState: isSet7(object.validateOrRevokeState) ? ValidateOrRevokeJobState.fromJSON(object.validateOrRevokeState) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.lastFnameProof !== void 0 && (obj.lastFnameProof = Math.round(message.lastFnameProof));
    message.lastL2Block !== void 0 && (obj.lastL2Block = Math.round(message.lastL2Block));
    message.validateOrRevokeState !== void 0 && (obj.validateOrRevokeState = message.validateOrRevokeState ? ValidateOrRevokeJobState.toJSON(message.validateOrRevokeState) : void 0);
    return obj;
  },
  create(base) {
    return HubState.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseHubState();
    message.lastFnameProof = (_a = object.lastFnameProof) != null ? _a : 0;
    message.lastL2Block = (_b = object.lastL2Block) != null ? _b : 0;
    message.validateOrRevokeState = object.validateOrRevokeState !== void 0 && object.validateOrRevokeState !== null ? ValidateOrRevokeJobState.fromPartial(object.validateOrRevokeState) : void 0;
    return message;
  }
};
var tsProtoGlobalThis7 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function longToNumber7(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis7.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal7.default.util.Long !== import_long7.default) {
  import_minimal7.default.util.Long = import_long7.default;
  import_minimal7.default.configure();
}
function isSet7(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/job.ts
init_cjs_shims();
var import_minimal8 = __toESM(require_minimal2());
function createBaseRevokeMessagesBySignerJobPayload() {
  return { fid: 0, signer: new Uint8Array() };
}
var RevokeMessagesBySignerJobPayload = {
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint32(message.fid);
    }
    if (message.signer.length !== 0) {
      writer.uint32(18).bytes(message.signer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessagesBySignerJobPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.signer = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet8(object.fid) ? Number(object.fid) : 0,
      signer: isSet8(object.signer) ? bytesFromBase647(object.signer) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signer !== void 0 && (obj.signer = base64FromBytes7(message.signer !== void 0 ? message.signer : new Uint8Array()));
    return obj;
  },
  create(base) {
    return RevokeMessagesBySignerJobPayload.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseRevokeMessagesBySignerJobPayload();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.signer = (_b = object.signer) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseUpdateNameRegistryEventExpiryJobPayload() {
  return { fname: new Uint8Array() };
}
var UpdateNameRegistryEventExpiryJobPayload = {
  encode(message, writer = import_minimal8.default.Writer.create()) {
    if (message.fname.length !== 0) {
      writer.uint32(10).bytes(message.fname);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal8.default.Reader ? input : import_minimal8.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUpdateNameRegistryEventExpiryJobPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.fname = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fname: isSet8(object.fname) ? bytesFromBase647(object.fname) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.fname !== void 0 && (obj.fname = base64FromBytes7(message.fname !== void 0 ? message.fname : new Uint8Array()));
    return obj;
  },
  create(base) {
    return UpdateNameRegistryEventExpiryJobPayload.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUpdateNameRegistryEventExpiryJobPayload();
    message.fname = (_a = object.fname) != null ? _a : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis8 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase647(b64) {
  if (tsProtoGlobalThis8.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis8.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis8.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes7(arr) {
  if (tsProtoGlobalThis8.Buffer) {
    return tsProtoGlobalThis8.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis8.btoa(bin.join(""));
  }
}
function isSet8(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/sync_trie.ts
init_cjs_shims();
var import_minimal9 = __toESM(require_minimal2());
function createBaseDbTrieNode() {
  return { key: new Uint8Array(), childChars: [], items: 0, childHashes: {} };
}
var DbTrieNode = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    writer.uint32(18).fork();
    for (const v of message.childChars) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.items !== 0) {
      writer.uint32(24).uint32(message.items);
    }
    Object.entries(message.childHashes).forEach(([key, value]) => {
      DbTrieNode_ChildHashesEntry.encode({ key, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDbTrieNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        case 2:
          if (tag == 16) {
            message.childChars.push(reader.uint32());
            continue;
          }
          if (tag == 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.childChars.push(reader.uint32());
            }
            continue;
          }
          break;
        case 3:
          if (tag != 24) {
            break;
          }
          message.items = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          const entry4 = DbTrieNode_ChildHashesEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.childHashes[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet9(object.key) ? bytesFromBase648(object.key) : new Uint8Array(),
      childChars: Array.isArray(object == null ? void 0 : object.childChars) ? object.childChars.map((e) => Number(e)) : [],
      items: isSet9(object.items) ? Number(object.items) : 0,
      childHashes: isObject2(object.childHashes) ? Object.entries(object.childHashes).reduce((acc, [key, value]) => {
        acc[Number(key)] = bytesFromBase648(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes8(message.key !== void 0 ? message.key : new Uint8Array()));
    if (message.childChars) {
      obj.childChars = message.childChars.map((e) => Math.round(e));
    } else {
      obj.childChars = [];
    }
    message.items !== void 0 && (obj.items = Math.round(message.items));
    obj.childHashes = {};
    if (message.childHashes) {
      Object.entries(message.childHashes).forEach(([k, v]) => {
        obj.childHashes[k] = base64FromBytes8(v);
      });
    }
    return obj;
  },
  create(base) {
    return DbTrieNode.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseDbTrieNode();
    message.key = (_a = object.key) != null ? _a : new Uint8Array();
    message.childChars = ((_b = object.childChars) == null ? void 0 : _b.map((e) => e)) || [];
    message.items = (_c = object.items) != null ? _c : 0;
    message.childHashes = Object.entries((_d = object.childHashes) != null ? _d : {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[Number(key)] = value;
        }
        return acc;
      },
      {}
    );
    return message;
  }
};
function createBaseDbTrieNode_ChildHashesEntry() {
  return { key: 0, value: new Uint8Array() };
}
var DbTrieNode_ChildHashesEntry = {
  encode(message, writer = import_minimal9.default.Writer.create()) {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal9.default.Reader ? input : import_minimal9.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDbTrieNode_ChildHashesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.key = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet9(object.key) ? Number(object.key) : 0,
      value: isSet9(object.value) ? bytesFromBase648(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = Math.round(message.key));
    message.value !== void 0 && (obj.value = base64FromBytes8(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  create(base) {
    return DbTrieNode_ChildHashesEntry.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseDbTrieNode_ChildHashesEntry();
    message.key = (_a = object.key) != null ? _a : 0;
    message.value = (_b = object.value) != null ? _b : new Uint8Array();
    return message;
  }
};
var tsProtoGlobalThis9 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase648(b64) {
  if (tsProtoGlobalThis9.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis9.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis9.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes8(arr) {
  if (tsProtoGlobalThis9.Buffer) {
    return tsProtoGlobalThis9.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis9.btoa(bin.join(""));
  }
}
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet9(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/generated/request_response.ts
init_cjs_shims();
var import_long8 = __toESM(require_long());
var import_minimal10 = __toESM(require_minimal2());
var StoreType = /* @__PURE__ */ ((StoreType2) => {
  StoreType2[StoreType2["NONE"] = 0] = "NONE";
  StoreType2[StoreType2["CASTS"] = 1] = "CASTS";
  StoreType2[StoreType2["LINKS"] = 2] = "LINKS";
  StoreType2[StoreType2["REACTIONS"] = 3] = "REACTIONS";
  StoreType2[StoreType2["USER_DATA"] = 4] = "USER_DATA";
  StoreType2[StoreType2["VERIFICATIONS"] = 5] = "VERIFICATIONS";
  StoreType2[StoreType2["USERNAME_PROOFS"] = 6] = "USERNAME_PROOFS";
  return StoreType2;
})(StoreType || {});
function storeTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "STORE_TYPE_NONE":
      return 0 /* NONE */;
    case 1:
    case "STORE_TYPE_CASTS":
      return 1 /* CASTS */;
    case 2:
    case "STORE_TYPE_LINKS":
      return 2 /* LINKS */;
    case 3:
    case "STORE_TYPE_REACTIONS":
      return 3 /* REACTIONS */;
    case 4:
    case "STORE_TYPE_USER_DATA":
      return 4 /* USER_DATA */;
    case 5:
    case "STORE_TYPE_VERIFICATIONS":
      return 5 /* VERIFICATIONS */;
    case 6:
    case "STORE_TYPE_USERNAME_PROOFS":
      return 6 /* USERNAME_PROOFS */;
    default:
      throw new tsProtoGlobalThis10.Error("Unrecognized enum value " + object + " for enum StoreType");
  }
}
function storeTypeToJSON(object) {
  switch (object) {
    case 0 /* NONE */:
      return "STORE_TYPE_NONE";
    case 1 /* CASTS */:
      return "STORE_TYPE_CASTS";
    case 2 /* LINKS */:
      return "STORE_TYPE_LINKS";
    case 3 /* REACTIONS */:
      return "STORE_TYPE_REACTIONS";
    case 4 /* USER_DATA */:
      return "STORE_TYPE_USER_DATA";
    case 5 /* VERIFICATIONS */:
      return "STORE_TYPE_VERIFICATIONS";
    case 6 /* USERNAME_PROOFS */:
      return "STORE_TYPE_USERNAME_PROOFS";
    default:
      throw new tsProtoGlobalThis10.Error("Unrecognized enum value " + object + " for enum StoreType");
  }
}
var StorageUnitType = /* @__PURE__ */ ((StorageUnitType2) => {
  StorageUnitType2[StorageUnitType2["UNIT_TYPE_LEGACY"] = 0] = "UNIT_TYPE_LEGACY";
  StorageUnitType2[StorageUnitType2["UNIT_TYPE_2024"] = 1] = "UNIT_TYPE_2024";
  StorageUnitType2[StorageUnitType2["UNIT_TYPE_2025"] = 2] = "UNIT_TYPE_2025";
  return StorageUnitType2;
})(StorageUnitType || {});
function storageUnitTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNIT_TYPE_LEGACY":
      return 0 /* UNIT_TYPE_LEGACY */;
    case 1:
    case "UNIT_TYPE_2024":
      return 1 /* UNIT_TYPE_2024 */;
    case 2:
    case "UNIT_TYPE_2025":
      return 2 /* UNIT_TYPE_2025 */;
    default:
      throw new tsProtoGlobalThis10.Error("Unrecognized enum value " + object + " for enum StorageUnitType");
  }
}
function storageUnitTypeToJSON(object) {
  switch (object) {
    case 0 /* UNIT_TYPE_LEGACY */:
      return "UNIT_TYPE_LEGACY";
    case 1 /* UNIT_TYPE_2024 */:
      return "UNIT_TYPE_2024";
    case 2 /* UNIT_TYPE_2025 */:
      return "UNIT_TYPE_2025";
    default:
      throw new tsProtoGlobalThis10.Error("Unrecognized enum value " + object + " for enum StorageUnitType");
  }
}
function createBaseBlocksRequest() {
  return { shardId: 0, startBlockNumber: 0, stopBlockNumber: void 0 };
}
var BlocksRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    if (message.startBlockNumber !== 0) {
      writer.uint32(16).uint64(message.startBlockNumber);
    }
    if (message.stopBlockNumber !== void 0) {
      writer.uint32(24).uint64(message.stopBlockNumber);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlocksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.startBlockNumber = longToNumber8(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.stopBlockNumber = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardId: isSet10(object.shardId) ? Number(object.shardId) : 0,
      startBlockNumber: isSet10(object.startBlockNumber) ? Number(object.startBlockNumber) : 0,
      stopBlockNumber: isSet10(object.stopBlockNumber) ? Number(object.stopBlockNumber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardId !== void 0 && (obj.shardId = Math.round(message.shardId));
    message.startBlockNumber !== void 0 && (obj.startBlockNumber = Math.round(message.startBlockNumber));
    message.stopBlockNumber !== void 0 && (obj.stopBlockNumber = Math.round(message.stopBlockNumber));
    return obj;
  },
  create(base) {
    return BlocksRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseBlocksRequest();
    message.shardId = (_a = object.shardId) != null ? _a : 0;
    message.startBlockNumber = (_b = object.startBlockNumber) != null ? _b : 0;
    message.stopBlockNumber = (_c = object.stopBlockNumber) != null ? _c : void 0;
    return message;
  }
};
function createBaseShardChunksRequest() {
  return { shardId: 0, startBlockNumber: 0, stopBlockNumber: void 0 };
}
var ShardChunksRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    if (message.startBlockNumber !== 0) {
      writer.uint32(16).uint64(message.startBlockNumber);
    }
    if (message.stopBlockNumber !== void 0) {
      writer.uint32(24).uint64(message.stopBlockNumber);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.startBlockNumber = longToNumber8(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.stopBlockNumber = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardId: isSet10(object.shardId) ? Number(object.shardId) : 0,
      startBlockNumber: isSet10(object.startBlockNumber) ? Number(object.startBlockNumber) : 0,
      stopBlockNumber: isSet10(object.stopBlockNumber) ? Number(object.stopBlockNumber) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardId !== void 0 && (obj.shardId = Math.round(message.shardId));
    message.startBlockNumber !== void 0 && (obj.startBlockNumber = Math.round(message.startBlockNumber));
    message.stopBlockNumber !== void 0 && (obj.stopBlockNumber = Math.round(message.stopBlockNumber));
    return obj;
  },
  create(base) {
    return ShardChunksRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseShardChunksRequest();
    message.shardId = (_a = object.shardId) != null ? _a : 0;
    message.startBlockNumber = (_b = object.startBlockNumber) != null ? _b : 0;
    message.stopBlockNumber = (_c = object.stopBlockNumber) != null ? _c : void 0;
    return message;
  }
};
function createBaseShardChunksResponse() {
  return { shardChunks: [] };
}
var ShardChunksResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.shardChunks) {
      ShardChunk.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardChunksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.shardChunks.push(ShardChunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardChunks: Array.isArray(object == null ? void 0 : object.shardChunks) ? object.shardChunks.map((e) => ShardChunk.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.shardChunks) {
      obj.shardChunks = message.shardChunks.map((e) => e ? ShardChunk.toJSON(e) : void 0);
    } else {
      obj.shardChunks = [];
    }
    return obj;
  },
  create(base) {
    return ShardChunksResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseShardChunksResponse();
    message.shardChunks = ((_a = object.shardChunks) == null ? void 0 : _a.map((e) => ShardChunk.fromPartial(e))) || [];
    return message;
  }
};
function createBaseSubscribeRequest() {
  return { eventTypes: [], fromId: void 0, shardIndex: void 0 };
}
var SubscribeRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.eventTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.fromId !== void 0) {
      writer.uint32(16).uint64(message.fromId);
    }
    if (message.shardIndex !== void 0) {
      writer.uint32(32).uint32(message.shardIndex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.eventTypes.push(reader.int32());
            continue;
          }
          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventTypes.push(reader.int32());
            }
            continue;
          }
          break;
        case 2:
          if (tag != 16) {
            break;
          }
          message.fromId = longToNumber8(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      eventTypes: Array.isArray(object == null ? void 0 : object.eventTypes) ? object.eventTypes.map((e) => hubEventTypeFromJSON(e)) : [],
      fromId: isSet10(object.fromId) ? Number(object.fromId) : void 0,
      shardIndex: isSet10(object.shardIndex) ? Number(object.shardIndex) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.eventTypes) {
      obj.eventTypes = message.eventTypes.map((e) => hubEventTypeToJSON(e));
    } else {
      obj.eventTypes = [];
    }
    message.fromId !== void 0 && (obj.fromId = Math.round(message.fromId));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    return obj;
  },
  create(base) {
    return SubscribeRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseSubscribeRequest();
    message.eventTypes = ((_a = object.eventTypes) == null ? void 0 : _a.map((e) => e)) || [];
    message.fromId = (_b = object.fromId) != null ? _b : void 0;
    message.shardIndex = (_c = object.shardIndex) != null ? _c : void 0;
    return message;
  }
};
function createBaseDbStats() {
  return { numMessages: 0, numFidRegistrations: 0, approxSize: 0 };
}
var DbStats = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.numMessages !== 0) {
      writer.uint32(8).uint64(message.numMessages);
    }
    if (message.numFidRegistrations !== 0) {
      writer.uint32(16).uint64(message.numFidRegistrations);
    }
    if (message.approxSize !== 0) {
      writer.uint32(32).uint64(message.approxSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDbStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.numMessages = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.numFidRegistrations = longToNumber8(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.approxSize = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      numMessages: isSet10(object.numMessages) ? Number(object.numMessages) : 0,
      numFidRegistrations: isSet10(object.numFidRegistrations) ? Number(object.numFidRegistrations) : 0,
      approxSize: isSet10(object.approxSize) ? Number(object.approxSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.numFidRegistrations !== void 0 && (obj.numFidRegistrations = Math.round(message.numFidRegistrations));
    message.approxSize !== void 0 && (obj.approxSize = Math.round(message.approxSize));
    return obj;
  },
  create(base) {
    return DbStats.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseDbStats();
    message.numMessages = (_a = object.numMessages) != null ? _a : 0;
    message.numFidRegistrations = (_b = object.numFidRegistrations) != null ? _b : 0;
    message.approxSize = (_c = object.approxSize) != null ? _c : 0;
    return message;
  }
};
function createBaseShardInfo() {
  return {
    shardId: 0,
    maxHeight: 0,
    numMessages: 0,
    numFidRegistrations: 0,
    approxSize: 0,
    blockDelay: 0,
    mempoolSize: 0
  };
}
var ShardInfo = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    if (message.maxHeight !== 0) {
      writer.uint32(16).uint64(message.maxHeight);
    }
    if (message.numMessages !== 0) {
      writer.uint32(24).uint64(message.numMessages);
    }
    if (message.numFidRegistrations !== 0) {
      writer.uint32(32).uint64(message.numFidRegistrations);
    }
    if (message.approxSize !== 0) {
      writer.uint32(40).uint64(message.approxSize);
    }
    if (message.blockDelay !== 0) {
      writer.uint32(48).uint64(message.blockDelay);
    }
    if (message.mempoolSize !== 0) {
      writer.uint32(56).uint64(message.mempoolSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseShardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardId = reader.uint32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.maxHeight = longToNumber8(reader.uint64());
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.numMessages = longToNumber8(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.numFidRegistrations = longToNumber8(reader.uint64());
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.approxSize = longToNumber8(reader.uint64());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.blockDelay = longToNumber8(reader.uint64());
          continue;
        case 7:
          if (tag != 56) {
            break;
          }
          message.mempoolSize = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardId: isSet10(object.shardId) ? Number(object.shardId) : 0,
      maxHeight: isSet10(object.maxHeight) ? Number(object.maxHeight) : 0,
      numMessages: isSet10(object.numMessages) ? Number(object.numMessages) : 0,
      numFidRegistrations: isSet10(object.numFidRegistrations) ? Number(object.numFidRegistrations) : 0,
      approxSize: isSet10(object.approxSize) ? Number(object.approxSize) : 0,
      blockDelay: isSet10(object.blockDelay) ? Number(object.blockDelay) : 0,
      mempoolSize: isSet10(object.mempoolSize) ? Number(object.mempoolSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardId !== void 0 && (obj.shardId = Math.round(message.shardId));
    message.maxHeight !== void 0 && (obj.maxHeight = Math.round(message.maxHeight));
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.numFidRegistrations !== void 0 && (obj.numFidRegistrations = Math.round(message.numFidRegistrations));
    message.approxSize !== void 0 && (obj.approxSize = Math.round(message.approxSize));
    message.blockDelay !== void 0 && (obj.blockDelay = Math.round(message.blockDelay));
    message.mempoolSize !== void 0 && (obj.mempoolSize = Math.round(message.mempoolSize));
    return obj;
  },
  create(base) {
    return ShardInfo.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseShardInfo();
    message.shardId = (_a = object.shardId) != null ? _a : 0;
    message.maxHeight = (_b = object.maxHeight) != null ? _b : 0;
    message.numMessages = (_c = object.numMessages) != null ? _c : 0;
    message.numFidRegistrations = (_d = object.numFidRegistrations) != null ? _d : 0;
    message.approxSize = (_e = object.approxSize) != null ? _e : 0;
    message.blockDelay = (_f = object.blockDelay) != null ? _f : 0;
    message.mempoolSize = (_g = object.mempoolSize) != null ? _g : 0;
    return message;
  }
};
function createBaseGetInfoRequest() {
  return {};
}
var GetInfoRequest = {
  encode(_, writer = import_minimal10.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetInfoRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetInfoRequest();
    return message;
  }
};
function createBaseGetInfoResponse() {
  return { version: "", dbStats: void 0, peerId: "", numShards: 0, shardInfos: [] };
}
var GetInfoResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.dbStats !== void 0) {
      DbStats.encode(message.dbStats, writer.uint32(42).fork()).ldelim();
    }
    if (message.peerId !== "") {
      writer.uint32(50).string(message.peerId);
    }
    if (message.numShards !== 0) {
      writer.uint32(64).uint32(message.numShards);
    }
    for (const v of message.shardInfos) {
      ShardInfo.encode(v, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.version = reader.string();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.dbStats = DbStats.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.peerId = reader.string();
          continue;
        case 8:
          if (tag != 64) {
            break;
          }
          message.numShards = reader.uint32();
          continue;
        case 9:
          if (tag != 74) {
            break;
          }
          message.shardInfos.push(ShardInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet10(object.version) ? String(object.version) : "",
      dbStats: isSet10(object.dbStats) ? DbStats.fromJSON(object.dbStats) : void 0,
      peerId: isSet10(object.peerId) ? String(object.peerId) : "",
      numShards: isSet10(object.numShards) ? Number(object.numShards) : 0,
      shardInfos: Array.isArray(object == null ? void 0 : object.shardInfos) ? object.shardInfos.map((e) => ShardInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.version !== void 0 && (obj.version = message.version);
    message.dbStats !== void 0 && (obj.dbStats = message.dbStats ? DbStats.toJSON(message.dbStats) : void 0);
    message.peerId !== void 0 && (obj.peerId = message.peerId);
    message.numShards !== void 0 && (obj.numShards = Math.round(message.numShards));
    if (message.shardInfos) {
      obj.shardInfos = message.shardInfos.map((e) => e ? ShardInfo.toJSON(e) : void 0);
    } else {
      obj.shardInfos = [];
    }
    return obj;
  },
  create(base) {
    return GetInfoResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseGetInfoResponse();
    message.version = (_a = object.version) != null ? _a : "";
    message.dbStats = object.dbStats !== void 0 && object.dbStats !== null ? DbStats.fromPartial(object.dbStats) : void 0;
    message.peerId = (_b = object.peerId) != null ? _b : "";
    message.numShards = (_c = object.numShards) != null ? _c : 0;
    message.shardInfos = ((_d = object.shardInfos) == null ? void 0 : _d.map((e) => ShardInfo.fromPartial(e))) || [];
    return message;
  }
};
function createBaseEventRequest() {
  return { id: 0, shardIndex: 0 };
}
var EventRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.shardIndex !== 0) {
      writer.uint32(40).uint32(message.shardIndex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.id = longToNumber8(reader.uint64());
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet10(object.id) ? Number(object.id) : 0,
      shardIndex: isSet10(object.shardIndex) ? Number(object.shardIndex) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.id !== void 0 && (obj.id = Math.round(message.id));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    return obj;
  },
  create(base) {
    return EventRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseEventRequest();
    message.id = (_a = object.id) != null ? _a : 0;
    message.shardIndex = (_b = object.shardIndex) != null ? _b : 0;
    return message;
  }
};
function createBaseFidRequest() {
  return { fid: 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var FidRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return FidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    return message;
  }
};
function createBaseFidTimestampRequest() {
  return {
    fid: 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0,
    startTimestamp: void 0,
    stopTimestamp: void 0
  };
}
var FidTimestampRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    if (message.startTimestamp !== void 0) {
      writer.uint32(40).uint64(message.startTimestamp);
    }
    if (message.stopTimestamp !== void 0) {
      writer.uint32(48).uint64(message.stopTimestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidTimestampRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.startTimestamp = longToNumber8(reader.uint64());
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.stopTimestamp = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0,
      startTimestamp: isSet10(object.startTimestamp) ? Number(object.startTimestamp) : void 0,
      stopTimestamp: isSet10(object.stopTimestamp) ? Number(object.stopTimestamp) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    message.startTimestamp !== void 0 && (obj.startTimestamp = Math.round(message.startTimestamp));
    message.stopTimestamp !== void 0 && (obj.stopTimestamp = Math.round(message.stopTimestamp));
    return obj;
  },
  create(base) {
    return FidTimestampRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseFidTimestampRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    message.startTimestamp = (_e = object.startTimestamp) != null ? _e : void 0;
    message.stopTimestamp = (_f = object.stopTimestamp) != null ? _f : void 0;
    return message;
  }
};
function createBaseFidsRequest() {
  return { pageSize: void 0, pageToken: void 0, reverse: void 0, shardId: 0 };
}
var FidsRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.pageSize !== void 0) {
      writer.uint32(8).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(18).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(24).bool(message.reverse);
    }
    if (message.shardId !== 0) {
      writer.uint32(32).uint32(message.shardId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.reverse = reader.bool();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.shardId = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0,
      shardId: isSet10(object.shardId) ? Number(object.shardId) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    message.shardId !== void 0 && (obj.shardId = Math.round(message.shardId));
    return obj;
  },
  create(base) {
    return FidsRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseFidsRequest();
    message.pageSize = (_a = object.pageSize) != null ? _a : void 0;
    message.pageToken = (_b = object.pageToken) != null ? _b : void 0;
    message.reverse = (_c = object.reverse) != null ? _c : void 0;
    message.shardId = (_d = object.shardId) != null ? _d : 0;
    return message;
  }
};
function createBaseFidsResponse() {
  return { fids: [], nextPageToken: void 0 };
}
var FidsResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    writer.uint32(10).fork();
    for (const v of message.fids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag == 8) {
            message.fids.push(longToNumber8(reader.uint64()));
            continue;
          }
          if (tag == 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fids.push(longToNumber8(reader.uint64()));
            }
            continue;
          }
          break;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fids: Array.isArray(object == null ? void 0 : object.fids) ? object.fids.map((e) => Number(e)) : [],
      nextPageToken: isSet10(object.nextPageToken) ? bytesFromBase649(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fids) {
      obj.fids = message.fids.map((e) => Math.round(e));
    } else {
      obj.fids = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes9(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return FidsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFidsResponse();
    message.fids = ((_a = object.fids) == null ? void 0 : _a.map((e) => e)) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseMessagesResponse() {
  return { messages: [], nextPageToken: void 0 };
}
var MessagesResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => Message.fromJSON(e)) : [],
      nextPageToken: isSet10(object.nextPageToken) ? bytesFromBase649(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes9(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return MessagesResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMessagesResponse();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseCastsByParentRequest() {
  return {
    parentCastId: void 0,
    parentUrl: void 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0
  };
}
var CastsByParentRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.parentCastId !== void 0) {
      CastId.encode(message.parentCastId, writer.uint32(10).fork()).ldelim();
    }
    if (message.parentUrl !== void 0) {
      writer.uint32(42).string(message.parentUrl);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(26).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(32).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCastsByParentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.parentCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.parentUrl = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      parentCastId: isSet10(object.parentCastId) ? CastId.fromJSON(object.parentCastId) : void 0,
      parentUrl: isSet10(object.parentUrl) ? String(object.parentUrl) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.parentCastId !== void 0 && (obj.parentCastId = message.parentCastId ? CastId.toJSON(message.parentCastId) : void 0);
    message.parentUrl !== void 0 && (obj.parentUrl = message.parentUrl);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return CastsByParentRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCastsByParentRequest();
    message.parentCastId = object.parentCastId !== void 0 && object.parentCastId !== null ? CastId.fromPartial(object.parentCastId) : void 0;
    message.parentUrl = (_a = object.parentUrl) != null ? _a : void 0;
    message.pageSize = (_b = object.pageSize) != null ? _b : void 0;
    message.pageToken = (_c = object.pageToken) != null ? _c : void 0;
    message.reverse = (_d = object.reverse) != null ? _d : void 0;
    return message;
  }
};
function createBaseReactionRequest() {
  return { fid: 0, reactionType: 0, targetCastId: void 0, targetUrl: void 0 };
}
var ReactionRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.reactionType !== 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(26).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(34).string(message.targetUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      reactionType: isSet10(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : 0,
      targetCastId: isSet10(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet10(object.targetUrl) ? String(object.targetUrl) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.reactionType !== void 0 && (obj.reactionType = reactionTypeToJSON(message.reactionType));
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    return obj;
  },
  create(base) {
    return ReactionRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseReactionRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : 0;
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_c = object.targetUrl) != null ? _c : void 0;
    return message;
  }
};
function createBaseReactionsByFidRequest() {
  return { fid: 0, reactionType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var ReactionsByFidRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.reactionType !== void 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionsByFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      reactionType: isSet10(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.reactionType !== void 0 && (obj.reactionType = message.reactionType !== void 0 ? reactionTypeToJSON(message.reactionType) : void 0);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return ReactionsByFidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseReactionsByFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseReactionsByTargetRequest() {
  return {
    targetCastId: void 0,
    targetUrl: void 0,
    reactionType: void 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0
  };
}
var ReactionsByTargetRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.targetCastId !== void 0) {
      CastId.encode(message.targetCastId, writer.uint32(10).fork()).ldelim();
    }
    if (message.targetUrl !== void 0) {
      writer.uint32(50).string(message.targetUrl);
    }
    if (message.reactionType !== void 0) {
      writer.uint32(16).int32(message.reactionType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseReactionsByTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.targetCastId = CastId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.targetUrl = reader.string();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.reactionType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      targetCastId: isSet10(object.targetCastId) ? CastId.fromJSON(object.targetCastId) : void 0,
      targetUrl: isSet10(object.targetUrl) ? String(object.targetUrl) : void 0,
      reactionType: isSet10(object.reactionType) ? reactionTypeFromJSON(object.reactionType) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.targetCastId !== void 0 && (obj.targetCastId = message.targetCastId ? CastId.toJSON(message.targetCastId) : void 0);
    message.targetUrl !== void 0 && (obj.targetUrl = message.targetUrl);
    message.reactionType !== void 0 && (obj.reactionType = message.reactionType !== void 0 ? reactionTypeToJSON(message.reactionType) : void 0);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return ReactionsByTargetRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseReactionsByTargetRequest();
    message.targetCastId = object.targetCastId !== void 0 && object.targetCastId !== null ? CastId.fromPartial(object.targetCastId) : void 0;
    message.targetUrl = (_a = object.targetUrl) != null ? _a : void 0;
    message.reactionType = (_b = object.reactionType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseUserDataRequest() {
  return { fid: 0, userDataType: 0 };
}
var UserDataRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.userDataType !== 0) {
      writer.uint32(16).int32(message.userDataType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.userDataType = reader.int32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      userDataType: isSet10(object.userDataType) ? userDataTypeFromJSON(object.userDataType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.userDataType !== void 0 && (obj.userDataType = userDataTypeToJSON(message.userDataType));
    return obj;
  },
  create(base) {
    return UserDataRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUserDataRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.userDataType = (_b = object.userDataType) != null ? _b : 0;
    return message;
  }
};
function createBaseOnChainEventRequest() {
  return { fid: 0, eventType: 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var OnChainEventRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.eventType = reader.int32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      eventType: isSet10(object.eventType) ? onChainEventTypeFromJSON(object.eventType) : 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.eventType !== void 0 && (obj.eventType = onChainEventTypeToJSON(message.eventType));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return OnChainEventRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseOnChainEventRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.eventType = (_b = object.eventType) != null ? _b : 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseOnChainEventResponse() {
  return { events: [], nextPageToken: void 0 };
}
var OnChainEventResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.events) {
      OnChainEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOnChainEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.events.push(OnChainEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: Array.isArray(object == null ? void 0 : object.events) ? object.events.map((e) => OnChainEvent.fromJSON(e)) : [],
      nextPageToken: isSet10(object.nextPageToken) ? bytesFromBase649(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events) {
      obj.events = message.events.map((e) => e ? OnChainEvent.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes9(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return OnChainEventResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseOnChainEventResponse();
    message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => OnChainEvent.fromPartial(e))) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseTierDetails() {
  return { tierType: 0, expiresAt: 0 };
}
var TierDetails = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.tierType !== 0) {
      writer.uint32(8).int32(message.tierType);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).uint64(message.expiresAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTierDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.tierType = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.expiresAt = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tierType: isSet10(object.tierType) ? tierTypeFromJSON(object.tierType) : 0,
      expiresAt: isSet10(object.expiresAt) ? Number(object.expiresAt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.tierType !== void 0 && (obj.tierType = tierTypeToJSON(message.tierType));
    message.expiresAt !== void 0 && (obj.expiresAt = Math.round(message.expiresAt));
    return obj;
  },
  create(base) {
    return TierDetails.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTierDetails();
    message.tierType = (_a = object.tierType) != null ? _a : 0;
    message.expiresAt = (_b = object.expiresAt) != null ? _b : 0;
    return message;
  }
};
function createBaseStorageLimitsResponse() {
  return { limits: [], units: 0, unitDetails: [], tierSubscriptions: [] };
}
var StorageLimitsResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.limits) {
      StorageLimit.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.units !== 0) {
      writer.uint32(16).uint32(message.units);
    }
    for (const v of message.unitDetails) {
      StorageUnitDetails.encode(v, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.tierSubscriptions) {
      TierDetails.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.limits.push(StorageLimit.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.units = reader.uint32();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.unitDetails.push(StorageUnitDetails.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.tierSubscriptions.push(TierDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      limits: Array.isArray(object == null ? void 0 : object.limits) ? object.limits.map((e) => StorageLimit.fromJSON(e)) : [],
      units: isSet10(object.units) ? Number(object.units) : 0,
      unitDetails: Array.isArray(object == null ? void 0 : object.unitDetails) ? object.unitDetails.map((e) => StorageUnitDetails.fromJSON(e)) : [],
      tierSubscriptions: Array.isArray(object == null ? void 0 : object.tierSubscriptions) ? object.tierSubscriptions.map((e) => TierDetails.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.limits) {
      obj.limits = message.limits.map((e) => e ? StorageLimit.toJSON(e) : void 0);
    } else {
      obj.limits = [];
    }
    message.units !== void 0 && (obj.units = Math.round(message.units));
    if (message.unitDetails) {
      obj.unitDetails = message.unitDetails.map((e) => e ? StorageUnitDetails.toJSON(e) : void 0);
    } else {
      obj.unitDetails = [];
    }
    if (message.tierSubscriptions) {
      obj.tierSubscriptions = message.tierSubscriptions.map((e) => e ? TierDetails.toJSON(e) : void 0);
    } else {
      obj.tierSubscriptions = [];
    }
    return obj;
  },
  create(base) {
    return StorageLimitsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseStorageLimitsResponse();
    message.limits = ((_a = object.limits) == null ? void 0 : _a.map((e) => StorageLimit.fromPartial(e))) || [];
    message.units = (_b = object.units) != null ? _b : 0;
    message.unitDetails = ((_c = object.unitDetails) == null ? void 0 : _c.map((e) => StorageUnitDetails.fromPartial(e))) || [];
    message.tierSubscriptions = ((_d = object.tierSubscriptions) == null ? void 0 : _d.map((e) => TierDetails.fromPartial(e))) || [];
    return message;
  }
};
function createBaseStorageUnitDetails() {
  return { unitType: 0, unitSize: 0 };
}
var StorageUnitDetails = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.unitType !== 0) {
      writer.uint32(8).int32(message.unitType);
    }
    if (message.unitSize !== 0) {
      writer.uint32(16).uint32(message.unitSize);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageUnitDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.unitType = reader.int32();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.unitSize = reader.uint32();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      unitType: isSet10(object.unitType) ? storageUnitTypeFromJSON(object.unitType) : 0,
      unitSize: isSet10(object.unitSize) ? Number(object.unitSize) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.unitType !== void 0 && (obj.unitType = storageUnitTypeToJSON(message.unitType));
    message.unitSize !== void 0 && (obj.unitSize = Math.round(message.unitSize));
    return obj;
  },
  create(base) {
    return StorageUnitDetails.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseStorageUnitDetails();
    message.unitType = (_a = object.unitType) != null ? _a : 0;
    message.unitSize = (_b = object.unitSize) != null ? _b : 0;
    return message;
  }
};
function createBaseStorageLimit() {
  return { storeType: 0, name: "", limit: 0, used: 0, earliestTimestamp: 0, earliestHash: new Uint8Array() };
}
var StorageLimit = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.storeType !== 0) {
      writer.uint32(8).int32(message.storeType);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.used !== 0) {
      writer.uint32(32).uint64(message.used);
    }
    if (message.earliestTimestamp !== 0) {
      writer.uint32(40).uint64(message.earliestTimestamp);
    }
    if (message.earliestHash.length !== 0) {
      writer.uint32(50).bytes(message.earliestHash);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStorageLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.storeType = reader.int32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.name = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.limit = longToNumber8(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.used = longToNumber8(reader.uint64());
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.earliestTimestamp = longToNumber8(reader.uint64());
          continue;
        case 6:
          if (tag != 50) {
            break;
          }
          message.earliestHash = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      storeType: isSet10(object.storeType) ? storeTypeFromJSON(object.storeType) : 0,
      name: isSet10(object.name) ? String(object.name) : "",
      limit: isSet10(object.limit) ? Number(object.limit) : 0,
      used: isSet10(object.used) ? Number(object.used) : 0,
      earliestTimestamp: isSet10(object.earliestTimestamp) ? Number(object.earliestTimestamp) : 0,
      earliestHash: isSet10(object.earliestHash) ? bytesFromBase649(object.earliestHash) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.storeType !== void 0 && (obj.storeType = storeTypeToJSON(message.storeType));
    message.name !== void 0 && (obj.name = message.name);
    message.limit !== void 0 && (obj.limit = Math.round(message.limit));
    message.used !== void 0 && (obj.used = Math.round(message.used));
    message.earliestTimestamp !== void 0 && (obj.earliestTimestamp = Math.round(message.earliestTimestamp));
    message.earliestHash !== void 0 && (obj.earliestHash = base64FromBytes9(
      message.earliestHash !== void 0 ? message.earliestHash : new Uint8Array()
    ));
    return obj;
  },
  create(base) {
    return StorageLimit.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseStorageLimit();
    message.storeType = (_a = object.storeType) != null ? _a : 0;
    message.name = (_b = object.name) != null ? _b : "";
    message.limit = (_c = object.limit) != null ? _c : 0;
    message.used = (_d = object.used) != null ? _d : 0;
    message.earliestTimestamp = (_e = object.earliestTimestamp) != null ? _e : 0;
    message.earliestHash = (_f = object.earliestHash) != null ? _f : new Uint8Array();
    return message;
  }
};
function createBaseUsernameProofRequest() {
  return { name: new Uint8Array() };
}
var UsernameProofRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.name = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet10(object.name) ? bytesFromBase649(object.name) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.name !== void 0 && (obj.name = base64FromBytes9(message.name !== void 0 ? message.name : new Uint8Array()));
    return obj;
  },
  create(base) {
    return UsernameProofRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUsernameProofRequest();
    message.name = (_a = object.name) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseUsernameProofsResponse() {
  return { proofs: [] };
}
var UsernameProofsResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.proofs) {
      UserNameProof.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUsernameProofsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.proofs.push(UserNameProof.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proofs: Array.isArray(object == null ? void 0 : object.proofs) ? object.proofs.map((e) => UserNameProof.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.proofs) {
      obj.proofs = message.proofs.map((e) => e ? UserNameProof.toJSON(e) : void 0);
    } else {
      obj.proofs = [];
    }
    return obj;
  },
  create(base) {
    return UsernameProofsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUsernameProofsResponse();
    message.proofs = ((_a = object.proofs) == null ? void 0 : _a.map((e) => UserNameProof.fromPartial(e))) || [];
    return message;
  }
};
function createBaseValidationResponse() {
  return { valid: false, message: void 0 };
}
var ValidationResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.valid === true) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValidationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.valid = reader.bool();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      valid: isSet10(object.valid) ? Boolean(object.valid) : false,
      message: isSet10(object.message) ? Message.fromJSON(object.message) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.valid !== void 0 && (obj.valid = message.valid);
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    return obj;
  },
  create(base) {
    return ValidationResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseValidationResponse();
    message.valid = (_a = object.valid) != null ? _a : false;
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    return message;
  }
};
function createBaseVerificationRequest() {
  return { fid: 0, address: new Uint8Array() };
}
var VerificationRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      address: isSet10(object.address) ? bytesFromBase649(object.address) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.address !== void 0 && (obj.address = base64FromBytes9(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return VerificationRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVerificationRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.address = (_b = object.address) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseSignerRequest() {
  return { fid: 0, signer: new Uint8Array() };
}
var SignerRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.signer.length !== 0) {
      writer.uint32(18).bytes(message.signer);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSignerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.signer = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      signer: isSet10(object.signer) ? bytesFromBase649(object.signer) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.signer !== void 0 && (obj.signer = base64FromBytes9(message.signer !== void 0 ? message.signer : new Uint8Array()));
    return obj;
  },
  create(base) {
    return SignerRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseSignerRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.signer = (_b = object.signer) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseLinkRequest() {
  return { fid: 0, linkType: "", targetFid: void 0 };
}
var LinkRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.linkType !== "") {
      writer.uint32(18).string(message.linkType);
    }
    if (message.targetFid !== void 0) {
      writer.uint32(24).uint64(message.targetFid);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.targetFid = longToNumber8(reader.uint64());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      linkType: isSet10(object.linkType) ? String(object.linkType) : "",
      targetFid: isSet10(object.targetFid) ? Number(object.targetFid) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    return obj;
  },
  create(base) {
    return LinkRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseLinkRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.linkType = (_b = object.linkType) != null ? _b : "";
    message.targetFid = (_c = object.targetFid) != null ? _c : void 0;
    return message;
  }
};
function createBaseLinksByFidRequest() {
  return { fid: 0, linkType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var LinksByFidRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.linkType !== void 0) {
      writer.uint32(18).string(message.linkType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinksByFidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      linkType: isSet10(object.linkType) ? String(object.linkType) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return LinksByFidRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLinksByFidRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.linkType = (_b = object.linkType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseLinksByTargetRequest() {
  return { targetFid: void 0, linkType: void 0, pageSize: void 0, pageToken: void 0, reverse: void 0 };
}
var LinksByTargetRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.targetFid !== void 0) {
      writer.uint32(8).uint64(message.targetFid);
    }
    if (message.linkType !== void 0) {
      writer.uint32(18).string(message.linkType);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(24).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(34).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(40).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLinksByTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.targetFid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.linkType = reader.string();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 5:
          if (tag != 40) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      targetFid: isSet10(object.targetFid) ? Number(object.targetFid) : void 0,
      linkType: isSet10(object.linkType) ? String(object.linkType) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.targetFid !== void 0 && (obj.targetFid = Math.round(message.targetFid));
    message.linkType !== void 0 && (obj.linkType = message.linkType);
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return LinksByTargetRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLinksByTargetRequest();
    message.targetFid = (_a = object.targetFid) != null ? _a : void 0;
    message.linkType = (_b = object.linkType) != null ? _b : void 0;
    message.pageSize = (_c = object.pageSize) != null ? _c : void 0;
    message.pageToken = (_d = object.pageToken) != null ? _d : void 0;
    message.reverse = (_e = object.reverse) != null ? _e : void 0;
    return message;
  }
};
function createBaseIdRegistryEventByAddressRequest() {
  return { address: new Uint8Array() };
}
var IdRegistryEventByAddressRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseIdRegistryEventByAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { address: isSet10(object.address) ? bytesFromBase649(object.address) : new Uint8Array() };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = base64FromBytes9(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return IdRegistryEventByAddressRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseIdRegistryEventByAddressRequest();
    message.address = (_a = object.address) != null ? _a : new Uint8Array();
    return message;
  }
};
function createBaseSubmitBulkMessagesRequest() {
  return { messages: [] };
}
var SubmitBulkMessagesRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitBulkMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => Message.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  create(base) {
    return SubmitBulkMessagesRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSubmitBulkMessagesRequest();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMessageError() {
  return { hash: new Uint8Array(), errCode: "", message: "" };
}
var MessageError = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.errCode !== "") {
      writer.uint32(18).string(message.errCode);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessageError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.errCode = reader.string();
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.message = reader.string();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet10(object.hash) ? bytesFromBase649(object.hash) : new Uint8Array(),
      errCode: isSet10(object.errCode) ? String(object.errCode) : "",
      message: isSet10(object.message) ? String(object.message) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = base64FromBytes9(message.hash !== void 0 ? message.hash : new Uint8Array()));
    message.errCode !== void 0 && (obj.errCode = message.errCode);
    message.message !== void 0 && (obj.message = message.message);
    return obj;
  },
  create(base) {
    return MessageError.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseMessageError();
    message.hash = (_a = object.hash) != null ? _a : new Uint8Array();
    message.errCode = (_b = object.errCode) != null ? _b : "";
    message.message = (_c = object.message) != null ? _c : "";
    return message;
  }
};
function createBaseBulkMessageResponse() {
  return { message: void 0, messageError: void 0 };
}
var BulkMessageResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.message !== void 0) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.messageError !== void 0) {
      MessageError.encode(message.messageError, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBulkMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.messageError = MessageError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet10(object.message) ? Message.fromJSON(object.message) : void 0,
      messageError: isSet10(object.messageError) ? MessageError.fromJSON(object.messageError) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.message !== void 0 && (obj.message = message.message ? Message.toJSON(message.message) : void 0);
    message.messageError !== void 0 && (obj.messageError = message.messageError ? MessageError.toJSON(message.messageError) : void 0);
    return obj;
  },
  create(base) {
    return BulkMessageResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseBulkMessageResponse();
    message.message = object.message !== void 0 && object.message !== null ? Message.fromPartial(object.message) : void 0;
    message.messageError = object.messageError !== void 0 && object.messageError !== null ? MessageError.fromPartial(object.messageError) : void 0;
    return message;
  }
};
function createBaseSubmitBulkMessagesResponse() {
  return { messages: [] };
}
var SubmitBulkMessagesResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.messages) {
      BulkMessageResponse.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSubmitBulkMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.messages.push(BulkMessageResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => BulkMessageResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? BulkMessageResponse.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    return obj;
  },
  create(base) {
    return SubmitBulkMessagesResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSubmitBulkMessagesResponse();
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => BulkMessageResponse.fromPartial(e))) || [];
    return message;
  }
};
function createBaseTrieNodeMetadataRequest() {
  return { shardId: 0, prefix: new Uint8Array() };
}
var TrieNodeMetadataRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    if (message.prefix.length !== 0) {
      writer.uint32(18).bytes(message.prefix);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrieNodeMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.shardId = reader.uint32();
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.prefix = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      shardId: isSet10(object.shardId) ? Number(object.shardId) : 0,
      prefix: isSet10(object.prefix) ? bytesFromBase649(object.prefix) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.shardId !== void 0 && (obj.shardId = Math.round(message.shardId));
    message.prefix !== void 0 && (obj.prefix = base64FromBytes9(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    return obj;
  },
  create(base) {
    return TrieNodeMetadataRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTrieNodeMetadataRequest();
    message.shardId = (_a = object.shardId) != null ? _a : 0;
    message.prefix = (_b = object.prefix) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseTrieNodeMetadataResponse() {
  return { prefix: new Uint8Array(), numMessages: 0, hash: "", children: [] };
}
var TrieNodeMetadataResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.prefix.length !== 0) {
      writer.uint32(10).bytes(message.prefix);
    }
    if (message.numMessages !== 0) {
      writer.uint32(16).uint64(message.numMessages);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    for (const v of message.children) {
      TrieNodeMetadataResponse.encode(v, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTrieNodeMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.prefix = reader.bytes();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.numMessages = longToNumber8(reader.uint64());
          continue;
        case 3:
          if (tag != 26) {
            break;
          }
          message.hash = reader.string();
          continue;
        case 4:
          if (tag != 34) {
            break;
          }
          message.children.push(TrieNodeMetadataResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      prefix: isSet10(object.prefix) ? bytesFromBase649(object.prefix) : new Uint8Array(),
      numMessages: isSet10(object.numMessages) ? Number(object.numMessages) : 0,
      hash: isSet10(object.hash) ? String(object.hash) : "",
      children: Array.isArray(object == null ? void 0 : object.children) ? object.children.map((e) => TrieNodeMetadataResponse.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.prefix !== void 0 && (obj.prefix = base64FromBytes9(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
    message.numMessages !== void 0 && (obj.numMessages = Math.round(message.numMessages));
    message.hash !== void 0 && (obj.hash = message.hash);
    if (message.children) {
      obj.children = message.children.map((e) => e ? TrieNodeMetadataResponse.toJSON(e) : void 0);
    } else {
      obj.children = [];
    }
    return obj;
  },
  create(base) {
    return TrieNodeMetadataResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseTrieNodeMetadataResponse();
    message.prefix = (_a = object.prefix) != null ? _a : new Uint8Array();
    message.numMessages = (_b = object.numMessages) != null ? _b : 0;
    message.hash = (_c = object.hash) != null ? _c : "";
    message.children = ((_d = object.children) == null ? void 0 : _d.map((e) => TrieNodeMetadataResponse.fromPartial(e))) || [];
    return message;
  }
};
function createBaseEventsRequest() {
  return {
    startId: 0,
    shardIndex: void 0,
    stopId: void 0,
    pageSize: void 0,
    pageToken: void 0,
    reverse: void 0
  };
}
var EventsRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.startId !== 0) {
      writer.uint32(8).uint64(message.startId);
    }
    if (message.shardIndex !== void 0) {
      writer.uint32(16).uint32(message.shardIndex);
    }
    if (message.stopId !== void 0) {
      writer.uint32(24).uint64(message.stopId);
    }
    if (message.pageSize !== void 0) {
      writer.uint32(32).uint32(message.pageSize);
    }
    if (message.pageToken !== void 0) {
      writer.uint32(42).bytes(message.pageToken);
    }
    if (message.reverse !== void 0) {
      writer.uint32(48).bool(message.reverse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.startId = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.shardIndex = reader.uint32();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.stopId = longToNumber8(reader.uint64());
          continue;
        case 4:
          if (tag != 32) {
            break;
          }
          message.pageSize = reader.uint32();
          continue;
        case 5:
          if (tag != 42) {
            break;
          }
          message.pageToken = reader.bytes();
          continue;
        case 6:
          if (tag != 48) {
            break;
          }
          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      startId: isSet10(object.startId) ? Number(object.startId) : 0,
      shardIndex: isSet10(object.shardIndex) ? Number(object.shardIndex) : void 0,
      stopId: isSet10(object.stopId) ? Number(object.stopId) : void 0,
      pageSize: isSet10(object.pageSize) ? Number(object.pageSize) : void 0,
      pageToken: isSet10(object.pageToken) ? bytesFromBase649(object.pageToken) : void 0,
      reverse: isSet10(object.reverse) ? Boolean(object.reverse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.startId !== void 0 && (obj.startId = Math.round(message.startId));
    message.shardIndex !== void 0 && (obj.shardIndex = Math.round(message.shardIndex));
    message.stopId !== void 0 && (obj.stopId = Math.round(message.stopId));
    message.pageSize !== void 0 && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== void 0 && (obj.pageToken = message.pageToken !== void 0 ? base64FromBytes9(message.pageToken) : void 0);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  create(base) {
    return EventsRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseEventsRequest();
    message.startId = (_a = object.startId) != null ? _a : 0;
    message.shardIndex = (_b = object.shardIndex) != null ? _b : void 0;
    message.stopId = (_c = object.stopId) != null ? _c : void 0;
    message.pageSize = (_d = object.pageSize) != null ? _d : void 0;
    message.pageToken = (_e = object.pageToken) != null ? _e : void 0;
    message.reverse = (_f = object.reverse) != null ? _f : void 0;
    return message;
  }
};
function createBaseEventsResponse() {
  return { events: [], nextPageToken: void 0 };
}
var EventsResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.events) {
      HubEvent.encode(v, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== void 0) {
      writer.uint32(18).bytes(message.nextPageToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.events.push(HubEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.nextPageToken = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: Array.isArray(object == null ? void 0 : object.events) ? object.events.map((e) => HubEvent.fromJSON(e)) : [],
      nextPageToken: isSet10(object.nextPageToken) ? bytesFromBase649(object.nextPageToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events) {
      obj.events = message.events.map((e) => e ? HubEvent.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    message.nextPageToken !== void 0 && (obj.nextPageToken = message.nextPageToken !== void 0 ? base64FromBytes9(message.nextPageToken) : void 0);
    return obj;
  },
  create(base) {
    return EventsResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseEventsResponse();
    message.events = ((_a = object.events) == null ? void 0 : _a.map((e) => HubEvent.fromPartial(e))) || [];
    message.nextPageToken = (_b = object.nextPageToken) != null ? _b : void 0;
    return message;
  }
};
function createBaseFidAddressTypeRequest() {
  return { fid: 0, address: new Uint8Array() };
}
var FidAddressTypeRequest = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.fid !== 0) {
      writer.uint32(8).uint64(message.fid);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidAddressTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.fid = longToNumber8(reader.uint64());
          continue;
        case 2:
          if (tag != 18) {
            break;
          }
          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fid: isSet10(object.fid) ? Number(object.fid) : 0,
      address: isSet10(object.address) ? bytesFromBase649(object.address) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.fid !== void 0 && (obj.fid = Math.round(message.fid));
    message.address !== void 0 && (obj.address = base64FromBytes9(message.address !== void 0 ? message.address : new Uint8Array()));
    return obj;
  },
  create(base) {
    return FidAddressTypeRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFidAddressTypeRequest();
    message.fid = (_a = object.fid) != null ? _a : 0;
    message.address = (_b = object.address) != null ? _b : new Uint8Array();
    return message;
  }
};
function createBaseFidAddressTypeResponse() {
  return { isCustody: false, isAuth: false, isVerified: false };
}
var FidAddressTypeResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    if (message.isCustody === true) {
      writer.uint32(8).bool(message.isCustody);
    }
    if (message.isAuth === true) {
      writer.uint32(16).bool(message.isAuth);
    }
    if (message.isVerified === true) {
      writer.uint32(24).bool(message.isVerified);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFidAddressTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 8) {
            break;
          }
          message.isCustody = reader.bool();
          continue;
        case 2:
          if (tag != 16) {
            break;
          }
          message.isAuth = reader.bool();
          continue;
        case 3:
          if (tag != 24) {
            break;
          }
          message.isVerified = reader.bool();
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      isCustody: isSet10(object.isCustody) ? Boolean(object.isCustody) : false,
      isAuth: isSet10(object.isAuth) ? Boolean(object.isAuth) : false,
      isVerified: isSet10(object.isVerified) ? Boolean(object.isVerified) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.isCustody !== void 0 && (obj.isCustody = message.isCustody);
    message.isAuth !== void 0 && (obj.isAuth = message.isAuth);
    message.isVerified !== void 0 && (obj.isVerified = message.isVerified);
    return obj;
  },
  create(base) {
    return FidAddressTypeResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFidAddressTypeResponse();
    message.isCustody = (_a = object.isCustody) != null ? _a : false;
    message.isAuth = (_b = object.isAuth) != null ? _b : false;
    message.isVerified = (_c = object.isVerified) != null ? _c : false;
    return message;
  }
};
function createBaseGetConnectedPeersRequest() {
  return {};
}
var GetConnectedPeersRequest = {
  encode(_, writer = import_minimal10.default.Writer.create()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return GetConnectedPeersRequest.fromPartial(base != null ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetConnectedPeersRequest();
    return message;
  }
};
function createBaseGetConnectedPeersResponse() {
  return { contacts: [] };
}
var GetConnectedPeersResponse = {
  encode(message, writer = import_minimal10.default.Writer.create()) {
    for (const v of message.contacts) {
      ContactInfoBody.encode(v, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof import_minimal10.default.Reader ? input : import_minimal10.default.Reader.create(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConnectedPeersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag != 10) {
            break;
          }
          message.contacts.push(ContactInfoBody.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) == 4 || tag == 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contacts: Array.isArray(object == null ? void 0 : object.contacts) ? object.contacts.map((e) => ContactInfoBody.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contacts) {
      obj.contacts = message.contacts.map((e) => e ? ContactInfoBody.toJSON(e) : void 0);
    } else {
      obj.contacts = [];
    }
    return obj;
  },
  create(base) {
    return GetConnectedPeersResponse.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConnectedPeersResponse();
    message.contacts = ((_a = object.contacts) == null ? void 0 : _a.map((e) => ContactInfoBody.fromPartial(e))) || [];
    return message;
  }
};
var tsProtoGlobalThis10 = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();
function bytesFromBase649(b64) {
  if (tsProtoGlobalThis10.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis10.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis10.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes9(arr) {
  if (tsProtoGlobalThis10.Buffer) {
    return tsProtoGlobalThis10.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis10.btoa(bin.join(""));
  }
}
function longToNumber8(long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis10.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}
if (import_minimal10.default.util.Long !== import_long8.default) {
  import_minimal10.default.util.Long = import_long8.default;
  import_minimal10.default.configure();
}
function isSet10(value) {
  return value !== null && value !== void 0;
}

// src/protobufs/typeguards.ts
init_cjs_shims();
var isCastAddData = (data) => {
  return data.type === 1 /* CAST_ADD */ && typeof data.castAddBody !== "undefined";
};
var isCastAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isCastAddData(message.data);
};
var isCastRemoveData = (data) => {
  return data.type === 2 /* CAST_REMOVE */ && typeof data.castRemoveBody !== "undefined";
};
var isCastRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isCastRemoveData(message.data);
};
var isLinkAddData = (data) => {
  return data.type === 5 /* LINK_ADD */ && typeof data.linkBody !== "undefined";
};
var isLinkCompactStateMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && message.data.type === 14 /* LINK_COMPACT_STATE */ && message.data.linkCompactStateBody !== void 0;
};
var isLinkAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isLinkAddData(message.data);
};
var isLinkRemoveData = (data) => {
  return data.type === 6 /* LINK_REMOVE */ && typeof data.linkBody !== "undefined";
};
var isLinkRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isLinkRemoveData(message.data);
};
var isReactionAddData = (data) => {
  return data.type === 3 /* REACTION_ADD */ && typeof data.reactionBody !== "undefined";
};
var isReactionAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isReactionAddData(message.data);
};
var isReactionRemoveData = (data) => {
  return data.type === 4 /* REACTION_REMOVE */ && typeof data.reactionBody !== "undefined";
};
var isReactionRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isReactionRemoveData(message.data);
};
var isVerificationAddAddressData = (data) => {
  return data.type === 7 /* VERIFICATION_ADD_ETH_ADDRESS */ && typeof data.verificationAddAddressBody !== "undefined" && (data.verificationAddAddressBody.protocol === 0 /* ETHEREUM */ || data.verificationAddAddressBody.protocol === 1 /* SOLANA */);
};
var isVerificationAddAddressMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isVerificationAddAddressData(message.data);
};
var isVerificationRemoveData = (data) => {
  return data.type === 8 /* VERIFICATION_REMOVE */ && typeof data.verificationRemoveBody !== "undefined" && (data.verificationRemoveBody.protocol === 0 /* ETHEREUM */ || data.verificationRemoveBody.protocol === 1 /* SOLANA */);
};
var isVerificationRemoveMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isVerificationRemoveData(message.data);
};
var isUserDataAddData = (data) => {
  return data.type === 11 /* USER_DATA_ADD */ && typeof data.userDataBody !== "undefined";
};
var isUserDataAddMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isUserDataAddData(message.data);
};
var isUsernameProofData = (data) => {
  return data.type === 12 /* USERNAME_PROOF */ && typeof data.usernameProofBody !== "undefined";
};
var isUsernameProofMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isUsernameProofData(message.data);
};
var isFrameActionData = (data) => {
  return data.type === 13 /* FRAME_ACTION */ && typeof data.frameActionBody !== "undefined";
};
var isFrameActionMessage = (message) => {
  return message.signatureScheme === 1 /* ED25519 */ && typeof message.data !== "undefined" && isFrameActionData(message.data);
};
var isSignerOnChainEvent = (event) => {
  return event.type === 1 /* EVENT_TYPE_SIGNER */ && typeof event.signerEventBody !== "undefined";
};
var isSignerMigratedOnChainEvent = (event) => {
  return event.type === 2 /* EVENT_TYPE_SIGNER_MIGRATED */ && typeof event.signerMigratedEventBody !== "undefined";
};
var isIdRegisterOnChainEvent = (event) => {
  return event.type === 3 /* EVENT_TYPE_ID_REGISTER */ && typeof event.idRegisterEventBody !== "undefined";
};
var isStorageRentOnChainEvent = (event) => {
  return event.type === 4 /* EVENT_TYPE_STORAGE_RENT */ && typeof event.storageRentEventBody !== "undefined";
};
var isTierPurchaseOnChainEvent = (event) => {
  return event.type === 5 /* EVENT_TYPE_TIER_PURCHASE */ && typeof event.tierPurchaseEventBody !== "undefined";
};
var isMergeMessageHubEvent = (event) => {
  return event.type === 1 /* MERGE_MESSAGE */ && typeof event.mergeMessageBody !== "undefined" && typeof event.mergeMessageBody.message !== "undefined";
};
var isRevokeMessageHubEvent = (event) => {
  return event.type === 3 /* REVOKE_MESSAGE */ && typeof event.revokeMessageBody !== "undefined" && typeof event.revokeMessageBody.message !== "undefined";
};
var isPruneMessageHubEvent = (event) => {
  return event.type === 2 /* PRUNE_MESSAGE */ && typeof event.pruneMessageBody !== "undefined" && typeof event.pruneMessageBody.message !== "undefined";
};
var isMergeFailureHubEvent = (event) => {
  return event.type === 10 /* MERGE_FAILURE */ && typeof event.mergeFailure !== "undefined" && typeof event.mergeFailure.message !== "undefined";
};
var isMergeOnChainHubEvent = (event) => {
  return event.type === 9 /* MERGE_ON_CHAIN_EVENT */ && typeof event.mergeOnChainEventBody !== "undefined" && typeof event.mergeOnChainEventBody.onChainEvent !== "undefined";
};
var isMergeUsernameProofHubEvent = (event) => {
  return event.type === 6 /* MERGE_USERNAME_PROOF */ && typeof event.mergeUsernameProofBody !== "undefined" && (typeof event.mergeUsernameProofBody.usernameProof !== "undefined" || typeof event.mergeUsernameProofBody.deletedUsernameProof !== "undefined");
};
var isBlockConfirmedHubEvent = (event) => {
  return event.type === 11 /* BLOCK_CONFIRMED */ && typeof event.blockConfirmedBody !== "undefined";
};

// src/protobufs/types.ts
init_cjs_shims();

// src/builders.ts
init_cjs_shims();
var import_blake32 = require("@noble/hashes/blake3");
var import_neverthrow7 = require("neverthrow");

// src/time.ts
init_cjs_shims();
var import_neverthrow = require("neverthrow");

// src/errors.ts
init_cjs_shims();
var isHubError = (e) => {
  return typeof e.errCode !== "undefined";
};
var HubError = class extends Error {
  /**
   * @param errCode - the HubError code for this message
   * @param context - a message, another Error, or a HubErrorOpts
   */
  constructor(errCode, context) {
    var _a;
    let parsedContext;
    if (typeof context === "string") {
      parsedContext = { message: context };
    } else if (context instanceof Error) {
      parsedContext = { cause: context, message: context.message };
    } else {
      parsedContext = context;
    }
    if (!parsedContext.message) {
      parsedContext.message = ((_a = parsedContext.cause) == null ? void 0 : _a.message) || "";
    }
    super(parsedContext.message, { cause: parsedContext.cause });
    /* Hub classification of error types */
    __publicField(this, "errCode");
    /* Indicates if error message can be presented to the user */
    __publicField(this, "presentable", false);
    this.name = "HubError";
    this.errCode = errCode;
  }
};

// src/time.ts
var FARCASTER_EPOCH = 16094592e5;
var getFarcasterTime = () => {
  return toFarcasterTime(Date.now());
};
var toFarcasterTime = (time) => {
  if (time < FARCASTER_EPOCH) {
    return (0, import_neverthrow.err)(new HubError("bad_request.invalid_param", "time must be after Farcaster epoch (01/01/2021)"));
  }
  const secondsSinceEpoch = Math.round((time - FARCASTER_EPOCH) / 1e3);
  if (secondsSinceEpoch > 2 ** 32 - 1) {
    return (0, import_neverthrow.err)(new HubError("bad_request.invalid_param", "time too far in future"));
  }
  return (0, import_neverthrow.ok)(secondsSinceEpoch);
};
var fromFarcasterTime = (time) => {
  return (0, import_neverthrow.ok)(time * 1e3 + FARCASTER_EPOCH);
};
var SEQUENCE_BITS = 12;
var extractEventTimestamp = (eventId) => {
  const binaryEventId = eventId.toString(2);
  const binaryTimestamp = binaryEventId.slice(0, binaryEventId.length - SEQUENCE_BITS);
  return parseInt(binaryTimestamp, 2) + FARCASTER_EPOCH;
};
var extractTimestampFromEvent = (event) => {
  return event.timestamp * 1e3 + FARCASTER_EPOCH;
};
var makeEventId = (timestamp, seq = 0) => {
  const binaryTimestamp = (timestamp - FARCASTER_EPOCH).toString(2);
  let binarySeq = seq.toString(2);
  if (binarySeq.length) {
    while (binarySeq.length < SEQUENCE_BITS) {
      binarySeq = `0${binarySeq}`;
    }
  }
  return parseInt(binaryTimestamp + binarySeq, 2);
};

// src/validations.ts
var validations_exports = {};
__export(validations_exports, {
  ALLOWED_CLOCK_SKEW_SECONDS: () => ALLOWED_CLOCK_SKEW_SECONDS,
  EMBEDS_V1_CUTOFF: () => EMBEDS_V1_CUTOFF,
  FNAME_REGEX: () => FNAME_REGEX,
  GITHUB_REGEX: () => GITHUB_REGEX,
  HEX_REGEX: () => HEX_REGEX,
  TWITTER_REGEX: () => TWITTER_REGEX,
  USERNAME_MAX_LENGTH: () => USERNAME_MAX_LENGTH,
  createMessageHash: () => createMessageHash,
  signMessageHash: () => signMessageHash2,
  validateCastAddBody: () => validateCastAddBody,
  validateCastId: () => validateCastId,
  validateCastRemoveBody: () => validateCastRemoveBody,
  validateEd25519PublicKey: () => validateEd25519PublicKey,
  validateEmbed: () => validateEmbed,
  validateEnsName: () => validateEnsName,
  validateEthAddress: () => validateEthAddress,
  validateEthBlockHash: () => validateEthBlockHash,
  validateFarcasterTime: () => validateFarcasterTime,
  validateFid: () => validateFid,
  validateFname: () => validateFname,
  validateFrameActionBody: () => validateFrameActionBody,
  validateGithubUsername: () => validateGithubUsername,
  validateLinkBody: () => validateLinkBody,
  validateLinkCompactStateBody: () => validateLinkCompactStateBody,
  validateLinkType: () => validateLinkType,
  validateMessage: () => validateMessage,
  validateMessageData: () => validateMessageData,
  validateMessageHash: () => validateMessageHash,
  validateMessageType: () => validateMessageType,
  validateNetwork: () => validateNetwork,
  validateParent: () => validateParent,
  validateReactionBody: () => validateReactionBody,
  validateReactionType: () => validateReactionType,
  validateSolAddress: () => validateSolAddress,
  validateSolBlockHash: () => validateSolBlockHash,
  validateTarget: () => validateTarget,
  validateTwitterUsername: () => validateTwitterUsername,
  validateUrl: () => validateUrl,
  validateUserDataAddBody: () => validateUserDataAddBody,
  validateUserDataType: () => validateUserDataType,
  validateUserLocation: () => validateUserLocation,
  validateUsernameProofBody: () => validateUsernameProofBody,
  validateVerificationAddAddressBody: () => validateVerificationAddAddressBody,
  validateVerificationAddEthAddressBody: () => validateVerificationAddEthAddressBody,
  validateVerificationAddEthAddressSignature: () => validateVerificationAddEthAddressSignature,
  validateVerificationAddSolAddressBody: () => validateVerificationAddSolAddressBody,
  validateVerificationAddSolAddressSignature: () => validateVerificationAddSolAddressSignature,
  validateVerificationRemoveBody: () => validateVerificationRemoveBody,
  verifySignedMessageHash: () => verifySignedMessageHash
});
init_cjs_shims();
var import_blake3 = require("@noble/hashes/blake3");
var import_neverthrow6 = require("neverthrow");

// src/bytes.ts
init_cjs_shims();
var import_neverthrow2 = require("neverthrow");
var import_viem = require("viem");
var import_bs58 = __toESM(require("bs58"));
var bytesCompare = (a, b) => {
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.length < b.length) {
    return -1;
  } else if (a.length > b.length) {
    return 1;
  }
  return 0;
};
var bytesIncrement = (inputBytes) => {
  const bytes = new Uint8Array(inputBytes);
  let i = bytes.length - 1;
  while (i >= 0) {
    if (bytes[i] < 255) {
      bytes[i] = bytes[i] + 1;
      return (0, import_neverthrow2.ok)(bytes);
    } else {
      bytes[i] = 0;
    }
    i = i - 1;
  }
  return (0, import_neverthrow2.ok)(new Uint8Array([1, ...bytes]));
};
var bytesDecrement = (inputBytes) => {
  const bytes = new Uint8Array(inputBytes);
  let i = bytes.length - 1;
  while (i >= 0) {
    if (bytes[i] > 0) {
      bytes[i] = bytes[i] - 1;
      return (0, import_neverthrow2.ok)(bytes);
    } else {
      if (i === 0) {
        return (0, import_neverthrow2.err)(new HubError("bad_request.invalid_param", "Cannot decrement zero"));
      }
      bytes[i] = 255;
    }
    i = i - 1;
  }
  return (0, import_neverthrow2.ok)(bytes);
};
var bytesToHexString = (bytes) => {
  return import_neverthrow2.Result.fromThrowable(
    (bytes2) => (0, import_viem.bytesToHex)(bytes2),
    (e) => new HubError("unknown", e)
  )(bytes);
};
var hexStringToBytes = (hex) => {
  return import_neverthrow2.Result.fromThrowable(
    (hex2) => (0, import_viem.hexToBytes)(hex2.startsWith("0x") ? hex2 : `0x${hex2}`),
    (e) => new HubError("unknown", e)
  )(hex);
};
var bytesToUtf8String = (bytes) => {
  const decoder = new TextDecoder(void 0, { fatal: true });
  return (0, import_neverthrow2.ok)(decoder.decode(bytes));
};
var encoder = new TextEncoder();
var utf8StringToBytes = (utf8) => {
  return (0, import_neverthrow2.ok)(encoder.encode(utf8));
};
var base58ToBytes = (bs58) => {
  return import_neverthrow2.Result.fromThrowable(
    (str) => import_bs58.default.decode(str),
    (e) => new HubError("unknown", e)
  )(bs58);
};
var bytesToBase58 = (bytes) => {
  return import_neverthrow2.Result.fromThrowable(
    (b) => import_bs58.default.encode(b),
    (e) => new HubError("unknown", e)
  )(bytes);
};
var bigIntToBytes = (value) => {
  let hexValue = value.toString(16);
  hexValue = hexValue.length % 2 === 0 ? hexValue : `0${hexValue}`;
  return hexStringToBytes(hexValue);
};
var bytesToBigInt = (bytes) => {
  return bytesToHexString(bytes).map((hexString) => BigInt(hexString));
};
var bytesStartsWith = (haystack, needle) => {
  if (needle.length > haystack.length) {
    return false;
  }
  for (let i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
};

// src/crypto/index.ts
init_cjs_shims();

// src/crypto/ed25519.ts
var ed25519_exports = {};
__export(ed25519_exports, {
  getPublicKey: () => getPublicKey,
  signMessageHash: () => signMessageHash,
  verifyMessageHashSignature: () => verifyMessageHashSignature
});
init_cjs_shims();
var import_ed25519 = require("@noble/curves/ed25519");
var import_neverthrow3 = require("neverthrow");
var safeGetPublicKey = import_neverthrow3.Result.fromThrowable(import_ed25519.ed25519.getPublicKey, (err10) => new HubError("bad_request", err10));
var safeSign = import_neverthrow3.Result.fromThrowable(import_ed25519.ed25519.sign, (err10) => new HubError("bad_request", err10));
var safeVerify = import_neverthrow3.Result.fromThrowable(import_ed25519.ed25519.verify, (err10) => new HubError("bad_request", err10));
var getPublicKey = async (privateKey) => {
  return safeGetPublicKey(privateKey);
};
var signMessageHash = async (hash, privateKey) => {
  return safeSign(hash, privateKey);
};
var verifyMessageHashSignature = async (signature, hash, publicKey) => {
  return safeVerify(signature, hash, publicKey);
};

// src/crypto/eip712.ts
var eip712_exports = {};
__export(eip712_exports, {
  EIP_712_FARCASTER_DOMAIN: () => EIP_712_FARCASTER_DOMAIN,
  EIP_712_FARCASTER_MESSAGE_DATA: () => EIP_712_FARCASTER_MESSAGE_DATA,
  EIP_712_FARCASTER_VERIFICATION_CLAIM: () => EIP_712_FARCASTER_VERIFICATION_CLAIM,
  EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS: () => EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS,
  EIP_712_USERNAME_DOMAIN: () => EIP_712_USERNAME_DOMAIN,
  EIP_712_USERNAME_PROOF: () => EIP_712_USERNAME_PROOF,
  MESSAGE_DATA_EIP_712_TYPES: () => MESSAGE_DATA_EIP_712_TYPES,
  USERNAME_PROOF_EIP_712_TYPES: () => USERNAME_PROOF_EIP_712_TYPES,
  verifyMessageHashSignature: () => verifyMessageHashSignature2,
  verifyUserNameProofClaim: () => verifyUserNameProofClaim,
  verifyVerificationClaimContractSignature: () => verifyVerificationClaimContractSignature,
  verifyVerificationClaimEOASignature: () => verifyVerificationClaimEOASignature,
  verifyVerificationEthAddressClaimSignature: () => verifyVerificationEthAddressClaimSignature
});
init_cjs_shims();
var import_viem3 = require("viem");
var import_neverthrow4 = require("neverthrow");

// src/eth/clients.ts
var clients_exports = {};
__export(clients_exports, {
  defaultL1PublicClient: () => defaultL1PublicClient,
  defaultL1PublicTestClient: () => defaultL1PublicTestClient,
  defaultL2PublicClient: () => defaultL2PublicClient,
  defaultL2PublicTestClient: () => defaultL2PublicTestClient,
  defaultPublicClients: () => defaultPublicClients
});
init_cjs_shims();
var import_viem2 = require("viem");
var import_chains = require("viem/chains");
var defaultL1PublicClient = (0, import_viem2.createPublicClient)({
  chain: import_chains.mainnet,
  transport: (0, import_viem2.http)()
});
var defaultL2PublicClient = (0, import_viem2.createPublicClient)({
  chain: import_chains.optimism,
  transport: (0, import_viem2.http)()
});
var defaultL1PublicTestClient = (0, import_viem2.createPublicClient)({
  chain: import_chains.goerli,
  transport: (0, import_viem2.http)()
});
var defaultL2PublicTestClient = (0, import_viem2.createPublicClient)({
  chain: import_chains.optimismGoerli,
  transport: (0, import_viem2.http)()
});
var defaultPublicClients = {
  [import_chains.mainnet.id]: defaultL1PublicClient,
  [import_chains.optimism.id]: defaultL2PublicClient,
  [import_chains.goerli.id]: defaultL1PublicTestClient,
  [import_chains.optimismGoerli.id]: defaultL2PublicTestClient
};

// src/eth/chains.ts
var chains_exports = {};
__export(chains_exports, {
  CHAIN_IDS: () => CHAIN_IDS
});
init_cjs_shims();
var import_chains2 = require("viem/chains");
var CHAIN_IDS = [import_chains2.mainnet.id, import_chains2.goerli.id, import_chains2.optimism.id, import_chains2.optimismGoerli.id];

// src/crypto/eip712.ts
var EIP_712_FARCASTER_DOMAIN = {
  name: "Farcaster Verify Ethereum Address",
  version: "2.0.0",
  // fixed salt to minimize collisions
  salt: "0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558"
};
var EIP_712_FARCASTER_VERIFICATION_CLAIM = [
  {
    name: "fid",
    type: "uint256"
  },
  {
    name: "address",
    type: "address"
  },
  {
    name: "blockHash",
    type: "bytes32"
  },
  {
    name: "network",
    type: "uint8"
  }
];
var EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS = [...CHAIN_IDS, 0];
var EIP_712_FARCASTER_MESSAGE_DATA = [
  {
    name: "hash",
    type: "bytes"
  }
];
var EIP_712_USERNAME_DOMAIN = {
  name: "Farcaster name verification",
  version: "1",
  chainId: 1,
  verifyingContract: "0xe3be01d99baa8db9905b33a3ca391238234b79d1"
  // name registry contract, will be the farcaster ENS CCIP contract later
};
var EIP_712_USERNAME_PROOF = [
  { name: "name", type: "string" },
  { name: "timestamp", type: "uint256" },
  { name: "owner", type: "address" }
];
var USERNAME_PROOF_EIP_712_TYPES = {
  domain: EIP_712_USERNAME_DOMAIN,
  types: { UserNameProof: EIP_712_USERNAME_PROOF }
};
var MESSAGE_DATA_EIP_712_TYPES = {
  domain: EIP_712_FARCASTER_DOMAIN,
  types: { MessageData: EIP_712_FARCASTER_MESSAGE_DATA }
};
var verifyVerificationClaimEOASignature = async (claim, signature, address, chainId) => {
  if (chainId !== 0) {
    return import_neverthrow4.ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid chain ID")
    );
  }
  return import_neverthrow4.ResultAsync.fromPromise(
    (0, import_viem3.verifyTypedData)({
      address: (0, import_viem3.bytesToHex)(address),
      domain: EIP_712_FARCASTER_DOMAIN,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
};
var verifyVerificationClaimContractSignature = async (claim, signature, address, chainId, publicClients = defaultPublicClients) => {
  const client = publicClients[chainId];
  if (!client) {
    return import_neverthrow4.ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", `RPC client not provided for chainId ${chainId}`)
    );
  }
  const valid = await import_neverthrow4.ResultAsync.fromPromise(
    client.verifyTypedData({
      address: (0, import_viem3.bytesToHex)(address),
      domain: { ...EIP_712_FARCASTER_DOMAIN, chainId },
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim,
      signature
    }),
    (e) => new HubError("unavailable.network_failure", e)
  );
  return valid;
};
var verifyVerificationEthAddressClaimSignature = async (claim, signature, address, verificationType = 0, chainId = 0, publicClients = defaultPublicClients) => {
  if (!EIP_712_FARCASTER_VERIFICATION_CLAIM_CHAIN_IDS.includes(chainId)) {
    return import_neverthrow4.ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid chain ID")
    );
  }
  if (verificationType === 0) {
    return verifyVerificationClaimEOASignature(claim, signature, address, chainId);
  } else if (verificationType === 1) {
    return verifyVerificationClaimContractSignature(claim, signature, address, chainId, publicClients);
  } else {
    return import_neverthrow4.ResultAsync.fromPromise(
      Promise.reject(),
      () => new HubError("bad_request.invalid_param", "Invalid verification type")
    );
  }
};
var verifyUserNameProofClaim = async (nameProof, signature, address) => {
  const valid = await import_neverthrow4.ResultAsync.fromPromise(
    (0, import_viem3.verifyTypedData)({
      address: (0, import_viem3.bytesToHex)(address),
      domain: EIP_712_USERNAME_DOMAIN,
      types: { UserNameProof: EIP_712_USERNAME_PROOF },
      primaryType: "UserNameProof",
      message: nameProof,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyMessageHashSignature2 = async (hash, signature, address) => {
  const valid = await import_neverthrow4.ResultAsync.fromPromise(
    (0, import_viem3.verifyTypedData)({
      address: (0, import_viem3.bytesToHex)(address),
      domain: EIP_712_FARCASTER_DOMAIN,
      types: { MessageData: EIP_712_FARCASTER_MESSAGE_DATA },
      primaryType: "MessageData",
      message: { hash: (0, import_viem3.bytesToHex)(hash) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/verifications.ts
init_cjs_shims();
var import_neverthrow5 = require("neverthrow");
var makeVerificationAddressClaim = (fid, address, network, blockHash, protocol) => {
  switch (protocol) {
    case 0 /* ETHEREUM */: {
      const ethAddressHex = validateEthAddress(address).andThen(
        (validatedEthAddress) => bytesToHexString(validatedEthAddress)
      );
      if (ethAddressHex.isErr()) {
        return (0, import_neverthrow5.err)(ethAddressHex.error);
      }
      const blockHashHex = validateEthBlockHash(blockHash).andThen(
        (validatedBlockHash) => bytesToHexString(validatedBlockHash)
      );
      if (blockHashHex.isErr()) {
        return (0, import_neverthrow5.err)(blockHashHex.error);
      }
      return (0, import_neverthrow5.ok)({
        fid: BigInt(fid),
        address: ethAddressHex.value,
        network,
        blockHash: blockHashHex.value,
        protocol: 0 /* ETHEREUM */
      });
    }
    case 1 /* SOLANA */: {
      const solAddress = validateSolAddress(address).andThen(
        (validatedSolAddress) => bytesToBase58(validatedSolAddress)
      );
      if (solAddress.isErr()) {
        return (0, import_neverthrow5.err)(solAddress.error);
      }
      const blockHashSol = validateSolBlockHash(blockHash).andThen(
        (validatedBlockHash) => bytesToBase58(validatedBlockHash)
      );
      if (blockHashSol.isErr()) {
        return (0, import_neverthrow5.err)(blockHashSol.error);
      }
      return (0, import_neverthrow5.ok)({
        fid: BigInt(fid),
        network,
        address: solAddress.value,
        blockHash: blockHashSol.value,
        protocol: 1 /* SOLANA */
      });
    }
    default:
      return (0, import_neverthrow5.err)(new HubError("bad_request.invalid_param", `Invalid protocol: ${protocol}`));
  }
};
var recreateSolanaClaimMessage = (claim, pubkey) => {
  const messageContent = `fid: ${claim.fid} address: ${claim.address} network: ${claim.network} blockHash: ${claim.blockHash} protocol: ${claim.protocol}`;
  return Buffer.from(utf8StringToBytes(messageContent)._unsafeUnwrap());
};

// src/validations.ts
var import_ens = require("viem/ens");
var ALLOWED_CLOCK_SKEW_SECONDS = 10 * 60;
var FNAME_REGEX = /^[a-z0-9][a-z0-9-]{0,15}$/;
var HEX_REGEX = /^(0x)?[0-9A-Fa-f]+$/;
var TWITTER_REGEX = /^[a-z0-9_]{0,15}$/;
var GITHUB_REGEX = /^[a-z\d](?:[a-z\d]|-(?!-)){0,38}$/i;
var USERNAME_MAX_LENGTH = 25;
var EMBEDS_V1_CUTOFF = 73612800;
var pureJSValidationMethods = {
  ed25519_verify: async (s, m, p) => (await ed25519_exports.verifyMessageHashSignature(s, m, p)).unwrapOr(false),
  ed25519_signMessageHash: async (h, s) => (await ed25519_exports.signMessageHash(h, s)).unwrapOr(new Uint8Array([])),
  blake3_20: (message) => (0, import_blake3.blake3)(message, { dkLen: 20 })
};
var createMessageHash = async (message, hashScheme, validationMethods = pureJSValidationMethods) => {
  if (!message || message.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (hashScheme !== 1 /* BLAKE3 */) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "unsupported hash scheme"));
  }
  return (0, import_neverthrow6.ok)(validationMethods.blake3_20(message));
};
var signMessageHash2 = async (hash, signingKey, validationMethods = pureJSValidationMethods) => {
  if (!hash || hash.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (!signingKey || signingKey.length !== 64) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "signingKey is invalid"));
  }
  return (0, import_neverthrow6.ok)(await validationMethods.ed25519_signMessageHash(hash, signingKey));
};
var verifySignedMessageHash = async (hash, signature, signer, validationMethods = pureJSValidationMethods) => {
  if (!hash || hash.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (!signature || signature.length !== 64) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "signature is invalid"));
  }
  if (!signer || signer.length !== 32) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "signer is invalid"));
  }
  return (0, import_neverthrow6.ok)(await validationMethods.ed25519_verify(signature, hash, signer));
};
var validateMessageHash = (hash) => {
  if (!hash || hash.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  if (hash.length !== 20) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash must be 20 bytes"));
  }
  return (0, import_neverthrow6.ok)(hash);
};
var validateNumber = (value) => {
  const number = parseFloat(value);
  if (Number.isNaN(number)) {
    return (0, import_neverthrow6.err)(void 0);
  }
  return (0, import_neverthrow6.ok)(number);
};
var validateLatitude = (value) => {
  const number = validateNumber(value);
  if (number.isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Latitude is not a valid number"));
  }
  if (number.value < -90 || number.value > 90) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Latitude value outside valid range"));
  }
  return (0, import_neverthrow6.ok)(value);
};
var validateLongitude = (value) => {
  const number = validateNumber(value);
  if (number.isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Longitude is not a valid number"));
  }
  if (number.value < -180 || number.value > 180) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Longitude value outside valid range"));
  }
  return (0, import_neverthrow6.ok)(value);
};
var validateUserLocation = (location) => {
  if (location === "") {
    return (0, import_neverthrow6.ok)(location);
  }
  const result = location.match(/^geo:(-?\d{1,2}\.\d{2}),(-?\d{1,3}\.\d{2})$/);
  if (result === null || result[0] !== location) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Invalid location string"));
  }
  if (result[1] === void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Location missing latitude"));
  }
  const latitude = validateLatitude(result[1]);
  if (latitude.isErr()) {
    return (0, import_neverthrow6.err)(latitude.error);
  }
  if (result[2] === void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Location missing longitude"));
  }
  const longitude = validateLongitude(result[2]);
  if (longitude.isErr()) {
    return (0, import_neverthrow6.err)(longitude.error);
  }
  return (0, import_neverthrow6.ok)(location);
};
var validateCastId = (castId) => {
  if (!castId) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "castId is missing"));
  }
  return import_neverthrow6.Result.combineWithAllErrors([validateFid(castId.fid), validateMessageHash(castId.hash)]).map(() => castId).mapErr(
    (errs) => new HubError("bad_request.validation_failure", errs.map((e) => e.message).join(", "))
  );
};
var validateFid = (fid) => {
  if (typeof fid !== "number" || fid === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "fid is missing"));
  }
  if (fid < 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "fid must be positive"));
  }
  if (!Number.isInteger(fid)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "fid must be an integer"));
  }
  return (0, import_neverthrow6.ok)(fid);
};
var validateSolAddress = (address) => {
  if (!address || address.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "solana address is missing"));
  }
  if (address.length !== 32) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "solana address must be 32 bytes"));
  }
  return (0, import_neverthrow6.ok)(address);
};
var validateSolBlockHash = (blockHash) => {
  if (!blockHash || blockHash.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "blockHash is missing"));
  }
  if (blockHash.length !== 32) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  return (0, import_neverthrow6.ok)(blockHash);
};
var validateEthAddress = (address) => {
  if (!address || address.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Ethereum address is missing"));
  }
  if (address.length !== 20) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "Ethereum address must be 20 bytes"));
  }
  return (0, import_neverthrow6.ok)(address);
};
var validateEthBlockHash = (blockHash) => {
  if (!blockHash || blockHash.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "blockHash is missing"));
  }
  if (blockHash.length !== 32) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  return (0, import_neverthrow6.ok)(blockHash);
};
var validateEd25519PublicKey = (publicKey) => {
  if (!publicKey || publicKey.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "publicKey is missing"));
  }
  if (publicKey.length !== 32) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "publicKey must be 32 bytes"));
  }
  return (0, import_neverthrow6.ok)(publicKey);
};
var validateFarcasterTime = (farcasterTime) => {
  const unixTime = fromFarcasterTime(farcasterTime);
  if (unixTime.isErr()) {
    return (0, import_neverthrow6.err)(unixTime.error);
  }
  const rtFarcasterTime = toFarcasterTime(unixTime.value);
  if (rtFarcasterTime.isErr()) {
    return (0, import_neverthrow6.err)(rtFarcasterTime.error);
  }
  return (0, import_neverthrow6.ok)(rtFarcasterTime.value);
};
var validateMessage = async (message, validationMethods = pureJSValidationMethods, publicClients = defaultPublicClients) => {
  if (!message.data && !message.dataBytes) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "data is missing"));
  }
  const data = message.data || MessageData.decode(Buffer.from(message.dataBytes));
  const validData = await validateMessageData(data, publicClients);
  if (validData.isErr()) {
    return (0, import_neverthrow6.err)(validData.error);
  }
  const hash = message.hash;
  if (!hash) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "hash is missing"));
  }
  let computedHash;
  if (message.dataBytes && message.dataBytes.length > 0) {
    if (message.dataBytes.length > 65536) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "dataBytes > 2048 bytes"));
    }
    computedHash = validationMethods.blake3_20(message.dataBytes);
  } else {
    computedHash = validationMethods.blake3_20(MessageData.encode(data).finish());
  }
  if (message.hashScheme === 1 /* BLAKE3 */) {
    if (bytesCompare(hash, computedHash) !== 0) {
      return (0, import_neverthrow6.err)(
        new HubError("bad_request.validation_failure", `invalid hash. Expected=${hash}, computed=${computedHash}`)
      );
    }
  } else {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid hashScheme"));
  }
  const signature = message.signature;
  if (!signature) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "signature is missing"));
  }
  const signer = message.signer;
  if (!signer) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "signer is missing"));
  }
  if (message.signatureScheme === 1 /* ED25519 */) {
    const signatureIsValid = await validationMethods.ed25519_verify(signature, hash, signer);
    if (!signatureIsValid) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid signature"));
    }
  } else {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid signatureScheme"));
  }
  return (0, import_neverthrow6.ok)(message);
};
var validateMessageData = async (data, publicClients = defaultPublicClients) => {
  const validFid = validateFid(data.fid);
  if (validFid.isErr()) {
    return (0, import_neverthrow6.err)(validFid.error);
  }
  const farcasterTime = getFarcasterTime();
  if (farcasterTime.isErr()) {
    return (0, import_neverthrow6.err)(farcasterTime.error);
  }
  if (data.timestamp - farcasterTime.value > ALLOWED_CLOCK_SKEW_SECONDS) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "timestamp more than 10 mins in the future"));
  }
  const validNetwork = validateNetwork(data.network);
  if (validNetwork.isErr()) {
    return (0, import_neverthrow6.err)(validNetwork.error);
  }
  const validType = validateMessageType(data.type);
  if (validType.isErr()) {
    return (0, import_neverthrow6.err)(validType.error);
  }
  const bodySet = Object.keys(data).filter((k) => k.endsWith("Body")).map((k) => data[k] !== void 0 ? 1 : 0).reduce((s, c) => s + c, 0);
  if (bodySet !== 1) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "only one body can be set"));
  }
  let bodyResult;
  if (validType.value === 1 /* CAST_ADD */ && !!data.castAddBody) {
    const allowEmbedsDeprecated = data.timestamp < EMBEDS_V1_CUTOFF;
    bodyResult = validateCastAddBody(data.castAddBody, allowEmbedsDeprecated);
  } else if (validType.value === 2 /* CAST_REMOVE */ && !!data.castRemoveBody) {
    bodyResult = validateCastRemoveBody(data.castRemoveBody);
  } else if ((validType.value === 3 /* REACTION_ADD */ || validType.value === 4 /* REACTION_REMOVE */) && !!data.reactionBody) {
    bodyResult = validateReactionBody(data.reactionBody);
  } else if (validType.value === 14 /* LINK_COMPACT_STATE */ && !!data.linkCompactStateBody) {
    bodyResult = validateLinkCompactStateBody(data.linkCompactStateBody);
  } else if ((validType.value === 5 /* LINK_ADD */ || validType.value === 6 /* LINK_REMOVE */) && !!data.linkBody) {
    bodyResult = validateLinkBody(data.linkBody);
  } else if (validType.value === 11 /* USER_DATA_ADD */ && !!data.userDataBody) {
    bodyResult = validateUserDataAddBody(data.userDataBody);
  } else if (validType.value === 7 /* VERIFICATION_ADD_ETH_ADDRESS */ && !!data.verificationAddAddressBody) {
    bodyResult = await validateVerificationAddAddressBody(
      data.verificationAddAddressBody,
      validFid.value,
      validNetwork.value,
      publicClients
    );
  } else if (validType.value === 8 /* VERIFICATION_REMOVE */ && !!data.verificationRemoveBody) {
    bodyResult = validateVerificationRemoveBody(data.verificationRemoveBody);
  } else if (validType.value === 12 /* USERNAME_PROOF */ && !!data.usernameProofBody) {
    bodyResult = validateUsernameProofBody(data.usernameProofBody, data);
  } else if (validType.value === 13 /* FRAME_ACTION */ && !!data.frameActionBody) {
    bodyResult = validateFrameActionBody(data.frameActionBody);
  } else {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "bodyType is invalid"));
  }
  if (bodyResult.isErr()) {
    return (0, import_neverthrow6.err)(bodyResult.error);
  }
  return (0, import_neverthrow6.ok)(data);
};
var validateVerificationAddSolAddressSignature = async (body, fid, network) => {
  if (body.claimSignature.length !== 64) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "claimSignature != 64 bytes"));
  }
  const reconstructedClaim = makeVerificationAddressClaim(fid, body.address, network, body.blockHash, body.protocol);
  if (reconstructedClaim.isErr()) {
    return (0, import_neverthrow6.err)(reconstructedClaim.error);
  }
  const fullMessage = recreateSolanaClaimMessage(
    reconstructedClaim.value,
    body.address
  );
  const verificationResult = await pureJSValidationMethods.ed25519_verify(
    body.claimSignature,
    fullMessage,
    body.address
  );
  if (!verificationResult) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid claimSignature"));
  }
  return (0, import_neverthrow6.ok)(body.claimSignature);
};
var validateVerificationAddEthAddressSignature = async (body, fid, network, publicClients = defaultPublicClients) => {
  if (body.claimSignature.length > 2048) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "claimSignature > 2048 bytes"));
  }
  const reconstructedClaim = makeVerificationAddressClaim(
    fid,
    body.address,
    network,
    body.blockHash,
    0 /* ETHEREUM */
  );
  if (reconstructedClaim.isErr()) {
    return (0, import_neverthrow6.err)(reconstructedClaim.error);
  }
  const verificationResult = await eip712_exports.verifyVerificationEthAddressClaimSignature(
    reconstructedClaim.value,
    body.claimSignature,
    body.address,
    body.verificationType,
    body.chainId,
    publicClients
  );
  if (verificationResult.isErr()) {
    return (0, import_neverthrow6.err)(verificationResult.error);
  }
  if (!verificationResult.value) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid claimSignature"));
  }
  return (0, import_neverthrow6.ok)(body.claimSignature);
};
var validateUrl = (url) => {
  if (typeof url !== "string") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "url must be a string"));
  }
  const urlBytesResult = utf8StringToBytes(url);
  if (urlBytesResult.isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "url must be encodable as utf8"));
  }
  const urlBytes = urlBytesResult.value;
  if (urlBytes.length < 1) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "url < 1 byte"));
  }
  if (urlBytes.length > 256) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "url > 256 bytes"));
  }
  return (0, import_neverthrow6.ok)(url);
};
var validateParent = (parent) => {
  if (typeof parent === "string") {
    return validateUrl(parent);
  } else {
    return validateCastId(parent);
  }
};
var validateEmbed = (embed) => {
  if (embed.url !== void 0 && embed.castId !== void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cannot use both url and castId"));
  }
  if (embed.url !== void 0) {
    return validateUrl(embed.url).map(() => embed);
  } else if (embed.castId !== void 0) {
    return validateCastId(embed.castId).map(() => embed);
  } else {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "embed must have either url or castId"));
  }
};
var validateCastAddBody = (body, allowEmbedsDeprecated = false) => {
  var _a;
  const text = body.text;
  if (text === void 0 || text === null) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text is missing"));
  }
  const textUtf8BytesResult = utf8StringToBytes(text);
  if (textUtf8BytesResult.isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "text must be encodable as utf8"));
  }
  const textBytes = textUtf8BytesResult.value;
  if (body.type === 0 /* CAST */ && textBytes.length > 320) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text > 320 bytes"));
  }
  if (body.type === 1 /* LONG_CAST */ && textBytes.length > 1024) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text > 1024 bytes for long cast"));
  }
  if (body.type === 1 /* LONG_CAST */ && textBytes.length <= 320) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text too short for long cast"));
  }
  if (body.type === 2 /* TEN_K_CAST */ && textBytes.length > 1e4) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text > 10,000 bytes for 10k cast"));
  }
  if (body.type === 2 /* TEN_K_CAST */ && textBytes.length <= 1024) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "text too short for 10k cast"));
  }
  if (body.type !== 0 /* CAST */ && body.type !== 1 /* LONG_CAST */ && body.type !== 2 /* TEN_K_CAST */) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid cast type"));
  }
  if (body.embeds.length > 4) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "embeds > 4"));
  }
  if (allowEmbedsDeprecated && body.embedsDeprecated.length > 2) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "string embeds > 2"));
  }
  if (!allowEmbedsDeprecated && body.embedsDeprecated.length > 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "string embeds have been deprecated"));
  }
  if (body.mentions.length > 10) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "mentions > 10"));
  }
  if (body.mentions.length !== body.mentionsPositions.length) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "mentions and mentionsPositions must match"));
  }
  if (body.embeds.length > 0 && body.embedsDeprecated.length > 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cannot use both embeds and string embeds"));
  }
  if (body.parentUrl !== void 0 && body.parentCastId !== void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cannot use both parentUrl and parentCastId"));
  }
  if (body.text.length === 0 && body.embeds.length === 0 && body.embedsDeprecated.length === 0 && body.mentions.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cast is empty"));
  }
  for (let i = 0; i < body.embeds.length; i++) {
    const embed = body.embeds[i];
    if (embed === void 0) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "embed is missing"));
    }
    const embedIsValid = validateEmbed(embed);
    if (embedIsValid.isErr()) {
      return (0, import_neverthrow6.err)(embedIsValid.error);
    }
  }
  for (let i = 0; i < body.embedsDeprecated.length; i++) {
    const embed = body.embedsDeprecated[i];
    if (embed === void 0) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "string embed is missing"));
    }
    const embedIsValid = validateUrl(embed);
    if (embedIsValid.isErr()) {
      return (0, import_neverthrow6.err)(embedIsValid.error);
    }
  }
  for (let i = 0; i < body.mentions.length; i++) {
    const mention = validateFid(body.mentions[i]);
    if (mention.isErr()) {
      return (0, import_neverthrow6.err)(mention.error);
    }
    const position = body.mentionsPositions[i];
    if (typeof position !== "number" || !Number.isInteger(position)) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "mentionsPositions must be integers"));
    }
    if (position < 0 || position > textBytes.length) {
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "mentionsPositions must be a position in text"));
    }
    if (i > 0) {
      const prevPosition = body.mentionsPositions[i - 1];
      if (position < prevPosition) {
        return (0, import_neverthrow6.err)(
          new HubError("bad_request.validation_failure", "mentionsPositions must be sorted in ascending order")
        );
      }
    }
  }
  if (body.parentCastId !== void 0 && body.parentUrl !== void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cannot use both parentUrl and parentCastId"));
  }
  const parent = (_a = body.parentCastId) != null ? _a : body.parentUrl;
  if (parent !== void 0) {
    const validParent = validateParent(parent);
    if (validParent.isErr()) {
      return (0, import_neverthrow6.err)(validParent.error);
    }
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateCastRemoveBody = (body) => {
  return validateMessageHash(body.targetHash).map(() => body);
};
var validateLinkType = (type) => {
  const typeBuffer = Buffer.from(type);
  if (type.length === 0 || typeBuffer.length > 8) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "type must be between 1-8 bytes"));
  }
  return (0, import_neverthrow6.ok)(type);
};
var validateReactionType = (type) => {
  if (!Object.values(ReactionType).includes(type)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid reaction type"));
  }
  return (0, import_neverthrow6.ok)(type);
};
var validateTarget = (target) => {
  if (typeof target === "string") {
    return validateUrl(target);
  } else if (typeof target === "number") {
    return validateFid(target);
  } else {
    return validateCastId(target);
  }
};
var validateMessageType = (type) => {
  if (!Object.values(MessageType).includes(type)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid message type"));
  }
  return (0, import_neverthrow6.ok)(type);
};
var validateNetwork = (network) => {
  if (!Object.values(FarcasterNetwork).includes(network)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid network"));
  }
  return (0, import_neverthrow6.ok)(network);
};
var validateLinkCompactStateBody = (body) => {
  const validatedType = validateLinkType(body.type);
  if (validatedType.isErr()) {
    return (0, import_neverthrow6.err)(validatedType.error);
  }
  const targetFids = body.targetFids;
  if (targetFids === void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "targets is missing"));
  }
  for (const targetFid of targetFids) {
    const validFid = validateFid(targetFid);
    if (validFid.isErr()) {
      return (0, import_neverthrow6.err)(validFid.error);
    }
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateLinkBody = (body) => {
  const validatedType = validateLinkType(body.type);
  if (validatedType.isErr()) {
    return (0, import_neverthrow6.err)(validatedType.error);
  }
  const target = body.targetFid;
  if (target === void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "target is missing"));
  }
  return validateTarget(target).map(() => body);
};
var validateReactionBody = (body) => {
  var _a;
  const validatedType = validateReactionType(body.type);
  if (validatedType.isErr()) {
    return (0, import_neverthrow6.err)(validatedType.error);
  }
  if (body.targetCastId !== void 0 && body.targetUrl !== void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "cannot use both targetUrl and targetCastId"));
  }
  const target = (_a = body.targetCastId) != null ? _a : body.targetUrl;
  if (target === void 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "target is missing"));
  }
  return validateTarget(target).map(() => body);
};
var validateVerificationAddAddressBody = async (body, fid, network, publicClients) => {
  switch (body.protocol) {
    case 0 /* ETHEREUM */:
      return await validateVerificationAddEthAddressBody(body, fid, network, publicClients);
    case 1 /* SOLANA */: {
      return validateVerificationAddSolAddressBody(body, fid, network);
    }
    default:
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
};
var validateVerificationAddEthAddressBody = async (body, fid, network, publicClients) => {
  const validAddress = validateEthAddress(body.address);
  if (validAddress.isErr()) {
    return (0, import_neverthrow6.err)(validAddress.error);
  }
  const validBlockHash = validateEthBlockHash(body.blockHash);
  if (validBlockHash.isErr()) {
    return (0, import_neverthrow6.err)(validBlockHash.error);
  }
  const validSignature = await validateVerificationAddEthAddressSignature(body, fid, network, publicClients);
  if (validSignature.isErr()) {
    return (0, import_neverthrow6.err)(validSignature.error);
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateVerificationAddSolAddressBody = async (body, fid, network) => {
  if (body.protocol !== 1 /* SOLANA */) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
  if (validateSolAddress(body.address).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "solana address must be 32 bytes"));
  }
  if (validateSolBlockHash(body.blockHash).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "blockHash must be 32 bytes"));
  }
  const isVerified = await validateVerificationAddSolAddressSignature(body, fid, network);
  if (isVerified.isErr()) {
    return (0, import_neverthrow6.err)(isVerified.error);
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateVerificationRemoveBody = (body) => {
  switch (body.protocol) {
    case 0 /* ETHEREUM */:
      return validateEthAddress(body.address).map(() => body);
    case 1 /* SOLANA */:
      return validateSolAddress(body.address).map(() => body);
    default:
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid verification protocol"));
  }
};
var validateUsernameProofBody = (body, data) => {
  if (!(body.type === 2 /* USERNAME_TYPE_ENS_L1 */ || body.type === 3 /* USERNAME_TYPE_BASENAME */)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `invalid username type: ${body.type}`));
  }
  const validateName = validateEnsName(body.name);
  if (validateName.isErr()) {
    return (0, import_neverthrow6.err)(validateName.error);
  }
  if (body.fid !== data.fid) {
    return (0, import_neverthrow6.err)(
      new HubError("bad_request.validation_failure", "fid in username proof does not match fid in message data")
    );
  }
  const proofFarcasterTimestamp = toFarcasterTime(body.timestamp * 1e3);
  if (proofFarcasterTimestamp.isErr()) {
    return (0, import_neverthrow6.err)(proofFarcasterTimestamp.error);
  }
  if (proofFarcasterTimestamp.value !== data.timestamp) {
    return (0, import_neverthrow6.err)(
      new HubError(
        "bad_request.validation_failure",
        "timestamp in username proof does not match timestamp in message data"
      )
    );
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateFrameActionBody = (body) => {
  if (body.buttonIndex > 5) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid button index"));
  }
  if (validateBytesAsString(body.url, 1024, true).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid url"));
  }
  if (validateBytesAsString(body.inputText, 256).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid input text"));
  }
  if (validateBytesAsString(body.state, 4096).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid state"));
  }
  if (validateBytesAsString(body.transactionId, 256).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid transaction ID"));
  }
  if (validateBytesAsString(body.address, 64).isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid address"));
  }
  if (body.castId !== void 0) {
    const result = validateCastId(body.castId);
    if (result.isErr()) {
      return (0, import_neverthrow6.err)(result.error);
    }
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateBytesAsString = (byteArray, maxLength, required = false) => {
  if (required && byteArray.length === 0) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "value is required"));
  }
  if (byteArray.length > maxLength) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "value is too long"));
  }
  return (0, import_neverthrow6.ok)(byteArray);
};
var validateUserDataType = (type) => {
  if (!Object.values(UserDataType).includes(type) || type === 0 /* NONE */ || type === 0 /* NONE */) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid user data type"));
  }
  return (0, import_neverthrow6.ok)(type);
};
var validateUserDataAddBody = (body) => {
  const { type, value } = body;
  const textUtf8BytesResult = utf8StringToBytes(value);
  if (textUtf8BytesResult.isErr()) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.invalid_param", "value cannot be encoded as utf8"));
  }
  const valueBytes = textUtf8BytesResult.value;
  switch (type) {
    case 1 /* PFP */:
      if (valueBytes.length > 256) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "pfp value > 256"));
      }
      break;
    case 2 /* DISPLAY */:
      if (valueBytes.length > 32) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "display value > 32"));
      }
      break;
    case 3 /* BIO */:
      if (valueBytes.length > 256) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "bio value > 256"));
      }
      break;
    case 5 /* URL */:
      if (valueBytes.length > 256) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "url value > 256"));
      }
      break;
    case 6 /* USERNAME */: {
      if (value !== "") {
        const validatedFname = validateFname(value);
        const validatedEnsName = validateEnsName(value);
        if (validatedFname.isErr() && validatedEnsName.isErr()) {
          return (0, import_neverthrow6.err)(validatedFname.error);
        }
      }
      break;
    }
    case 7 /* LOCATION */: {
      const validatedUserLocation = validateUserLocation(value);
      if (validatedUserLocation.isErr()) {
        return (0, import_neverthrow6.err)(validatedUserLocation.error);
      }
      break;
    }
    case 8 /* TWITTER */: {
      if (value !== "") {
        const validatedTwitterUsername = validateTwitterUsername(value);
        if (validatedTwitterUsername.isErr()) {
          return (0, import_neverthrow6.err)(validatedTwitterUsername.error);
        }
      }
      break;
    }
    case 9 /* GITHUB */: {
      if (value !== "") {
        const validatedGithubUsername = validateGithubUsername(value);
        if (validatedGithubUsername.isErr()) {
          return (0, import_neverthrow6.err)(validatedGithubUsername.error);
        }
      }
      break;
    }
    case 11 /* USER_DATA_PRIMARY_ADDRESS_ETHEREUM */: {
      if (valueBytes.length > 42) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid length for eth address"));
      }
      break;
    }
    case 12 /* USER_DATA_PRIMARY_ADDRESS_SOLANA */: {
      if (valueBytes.length > 44) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid length for sol address"));
      }
      break;
    }
    case 10 /* BANNER */: {
      if (valueBytes.length > 256) {
        return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "banner value > 256"));
      }
      break;
    }
    default:
      return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "invalid user data type"));
  }
  return (0, import_neverthrow6.ok)(body);
};
var validateFname = (fnameP) => {
  if (fnameP === void 0 || fnameP === null || fnameP === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "fname is missing"));
  }
  let fname;
  if (fnameP instanceof Uint8Array) {
    const fromBytes = bytesToUtf8String(fnameP);
    if (fromBytes.isErr()) {
      return (0, import_neverthrow6.err)(fromBytes.error);
    }
    fname = fromBytes.value;
  } else {
    fname = fnameP;
  }
  if (fname === void 0 || fname === null || fname === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "fname is missing"));
  }
  if (fname.length > 16) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `fname "${fname}" > 16 characters`));
  }
  const hasValidChars = FNAME_REGEX.test(fname);
  if (hasValidChars === false) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `fname "${fname}" doesn't match ${FNAME_REGEX}`));
  }
  return (0, import_neverthrow6.ok)(fnameP);
};
var validateEnsName = (ensNameP) => {
  if (ensNameP === void 0 || ensNameP === null || ensNameP === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "ensName is missing"));
  }
  let ensName;
  if (ensNameP instanceof Uint8Array) {
    const fromBytes = bytesToUtf8String(ensNameP);
    if (fromBytes.isErr()) {
      return (0, import_neverthrow6.err)(fromBytes.error);
    }
    ensName = fromBytes.value;
  } else {
    ensName = ensNameP;
  }
  if (ensName === void 0 || ensName === null || ensName === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "ensName is missing"));
  }
  try {
    (0, import_ens.normalize)(ensName);
  } catch (e) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" is not a valid ENS name`));
  }
  if (!ensName.endsWith(".eth")) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" doesn't end with .eth`));
  }
  const nameParts = ensName.split(".");
  if (nameParts[0] === void 0 || !(nameParts.length === 2 || nameParts.length === 3)) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" unsupported subdomain`));
  }
  if (nameParts.length === 3 && nameParts[1] !== "base") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" unsupported subdomain`));
  }
  if (ensName.length > USERNAME_MAX_LENGTH) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" > 20 characters`));
  }
  const hasValidChars = FNAME_REGEX.test(nameParts[0]);
  if (!hasValidChars) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `ensName "${ensName}" doesn't match ${FNAME_REGEX}`));
  }
  return (0, import_neverthrow6.ok)(ensNameP);
};
var validateTwitterUsername = (username) => {
  if (username === void 0 || username === null || username === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "username is missing"));
  }
  let twitterUsername;
  if (username instanceof Uint8Array) {
    const fromBytes = bytesToUtf8String(username);
    if (fromBytes.isErr()) {
      return (0, import_neverthrow6.err)(fromBytes.error);
    }
    twitterUsername = fromBytes.value;
  } else {
    twitterUsername = username;
  }
  if (twitterUsername === void 0 || twitterUsername === null || twitterUsername === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "username is missing"));
  }
  if (twitterUsername.length > 15) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `username "${twitterUsername}" > 15 characters`));
  }
  const hasValidChars = TWITTER_REGEX.test(twitterUsername);
  if (hasValidChars === false) {
    return (0, import_neverthrow6.err)(
      new HubError("bad_request.validation_failure", `username "${twitterUsername}" doesn't match ${TWITTER_REGEX}`)
    );
  }
  return (0, import_neverthrow6.ok)(username);
};
var validateGithubUsername = (username) => {
  if (username === void 0 || username === null || username === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "username is missing"));
  }
  let githubUsername;
  if (username instanceof Uint8Array) {
    const fromBytes = bytesToUtf8String(username);
    if (fromBytes.isErr()) {
      return (0, import_neverthrow6.err)(fromBytes.error);
    }
    githubUsername = fromBytes.value;
  } else {
    githubUsername = username;
  }
  if (githubUsername === void 0 || githubUsername === null || githubUsername === "") {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", "username is missing"));
  }
  if (githubUsername.length > 38) {
    return (0, import_neverthrow6.err)(new HubError("bad_request.validation_failure", `username "${githubUsername}" > 38 characters`));
  }
  const hasValidChars = GITHUB_REGEX.test(githubUsername);
  if (hasValidChars === false) {
    return (0, import_neverthrow6.err)(
      new HubError("bad_request.validation_failure", `username "${githubUsername}" doesn't match ${GITHUB_REGEX}`)
    );
  }
  return (0, import_neverthrow6.ok)(username);
};

// src/builders.ts
var makeMessageData = async (bodyOptions, messageType, dataOptions, publicClients = defaultPublicClients) => {
  if (!dataOptions.timestamp) {
    getFarcasterTime().map((timestamp) => {
      dataOptions.timestamp = timestamp;
    });
  }
  const data = MessageData.create({
    ...bodyOptions,
    type: messageType,
    ...dataOptions
  });
  return validateMessageData(data, publicClients);
};
var makeMessage = async (messageData, signer) => {
  const dataBytes = MessageData.encode(messageData).finish();
  const hash = (0, import_blake32.blake3)(dataBytes, { dkLen: 20 });
  const signature = await signer.signMessageHash(hash);
  if (signature.isErr())
    return (0, import_neverthrow7.err)(signature.error);
  const signerKey = await signer.getSignerKey();
  if (signerKey.isErr())
    return (0, import_neverthrow7.err)(signerKey.error);
  const message = Message.create({
    data: messageData,
    dataBytes,
    // Messages for snapchain must use dataBytes because of serialization differences between js and rust
    hash,
    hashScheme: 1 /* BLAKE3 */,
    signature: signature.value,
    signatureScheme: signer.scheme,
    signer: signerKey.value
  });
  return (0, import_neverthrow7.ok)(message);
};
var makeMessageHash = async (messageData) => {
  const dataBytes = MessageData.encode(messageData).finish();
  return (0, import_neverthrow7.ok)((0, import_blake32.blake3)(dataBytes, { dkLen: 20 }));
};
var makeMessageWithSignature = async (messageData, signerOptions) => {
  const dataBytes = MessageData.encode(messageData).finish();
  const hash = (0, import_blake32.blake3)(dataBytes, { dkLen: 20 });
  const message = Message.create({
    data: messageData,
    dataBytes,
    hash,
    hashScheme: 1 /* BLAKE3 */,
    ...signerOptions
  });
  return validateMessage(message);
};
var makeCastAdd = async (body, dataOptions, signer) => {
  const data = await makeCastAddData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeCastRemove = async (body, dataOptions, signer) => {
  const data = await makeCastRemoveData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeCastAddData = async (body, dataOptions) => {
  return makeMessageData({ castAddBody: body }, 1 /* CAST_ADD */, dataOptions);
};
var makeCastRemoveData = (body, dataOptions) => {
  return makeMessageData({ castRemoveBody: body }, 2 /* CAST_REMOVE */, dataOptions);
};
var makeLinkAdd = async (body, dataOptions, signer) => {
  const data = await makeLinkAddData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkCompactState = async (body, dataOptions, signer) => {
  const data = await makeLinkCompactStateData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkRemove = async (body, dataOptions, signer) => {
  const data = await makeLinkRemoveData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeLinkAddData = (body, dataOptions) => {
  return makeMessageData({ linkBody: body }, 5 /* LINK_ADD */, dataOptions);
};
var makeLinkCompactStateData = (body, dataOptions) => {
  return makeMessageData({ linkCompactStateBody: body }, 14 /* LINK_COMPACT_STATE */, dataOptions);
};
var makeLinkRemoveData = (body, dataOptions) => {
  return makeMessageData({ linkBody: body }, 6 /* LINK_REMOVE */, dataOptions);
};
var makeReactionAdd = async (body, dataOptions, signer) => {
  const data = await makeReactionAddData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeReactionRemove = async (body, dataOptions, signer) => {
  const data = await makeReactionRemoveData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeReactionAddData = (body, dataOptions) => {
  return makeMessageData({ reactionBody: body }, 3 /* REACTION_ADD */, dataOptions);
};
var makeReactionRemoveData = (body, dataOptions) => {
  return makeMessageData({ reactionBody: body }, 4 /* REACTION_REMOVE */, dataOptions);
};
var makeVerificationAddEthAddress = async (body, dataOptions, signer, publicClients = defaultPublicClients) => {
  const data = await makeVerificationAddEthAddressData(body, dataOptions, publicClients);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeVerificationRemove = async (body, dataOptions, signer) => {
  const data = await makeVerificationRemoveData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeVerificationAddEthAddressData = (body, dataOptions, publicClients = defaultPublicClients) => {
  return makeMessageData(
    { verificationAddAddressBody: body },
    7 /* VERIFICATION_ADD_ETH_ADDRESS */,
    dataOptions,
    publicClients
  );
};
var makeVerificationRemoveData = (body, dataOptions) => {
  return makeMessageData({ verificationRemoveBody: body }, 8 /* VERIFICATION_REMOVE */, dataOptions);
};
var makeUserDataAdd = async (body, dataOptions, signer) => {
  const data = await makeUserDataAddData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeUserDataAddData = (body, dataOptions) => {
  return makeMessageData({ userDataBody: body }, 11 /* USER_DATA_ADD */, dataOptions);
};
var makeUsernameProof = async (body, dataOptions, signer) => {
  const data = await makeUsernameProofData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeUsernameProofData = (body, dataOptions) => {
  return makeMessageData({ usernameProofBody: body }, 12 /* USERNAME_PROOF */, dataOptions);
};
var makeFrameAction = async (body, dataOptions, signer) => {
  const data = await makeFrameActionData(body, dataOptions);
  if (data.isErr()) {
    return (0, import_neverthrow7.err)(data.error);
  }
  return makeMessage(data.value, signer);
};
var makeFrameActionData = (body, dataOptions) => {
  return makeMessageData({ frameActionBody: body }, 13 /* FRAME_ACTION */, dataOptions);
};

// src/eth/index.ts
init_cjs_shims();

// src/eth/contracts/index.ts
init_cjs_shims();

// src/eth/contracts/bundler.ts
init_cjs_shims();
var BUNDLER_ADDRESS = "0x00000000FC04c910A0b5feA33b03E0447AD0B0aA";

// src/eth/contracts/idGateway.ts
init_cjs_shims();
var import_neverthrow8 = require("neverthrow");
var import_viem4 = require("viem");
var ID_GATEWAY_ADDRESS = "0x00000000Fc25870C6eD6b6c7E41Fb078b7656f69";
var ID_GATEWAY_EIP_712_DOMAIN = {
  name: "Farcaster IdGateway",
  version: "1",
  chainId: 10,
  verifyingContract: ID_GATEWAY_ADDRESS
};
var ID_GATEWAY_REGISTER_TYPE = [
  { name: "to", type: "address" },
  { name: "recovery", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_GATEWAY_EIP_712_TYPES = {
  domain: ID_GATEWAY_EIP_712_DOMAIN,
  types: { Register: ID_GATEWAY_REGISTER_TYPE }
};
var verifyRegister = async (message, signature, address) => {
  const valid = await import_neverthrow8.ResultAsync.fromPromise(
    (0, import_viem4.verifyTypedData)({
      address: (0, import_viem4.bytesToHex)(address),
      domain: ID_GATEWAY_EIP_712_DOMAIN,
      types: { Register: ID_GATEWAY_REGISTER_TYPE },
      primaryType: "Register",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/idRegistry.ts
init_cjs_shims();
var import_neverthrow9 = require("neverthrow");
var import_viem5 = require("viem");
var ID_REGISTRY_ADDRESS = "0x00000000Fc6c5F01Fc30151999387Bb99A9f489b";
var ID_REGISTRY_EIP_712_DOMAIN = {
  name: "Farcaster IdRegistry",
  version: "1",
  chainId: 10,
  verifyingContract: ID_REGISTRY_ADDRESS
};
var ID_REGISTRY_TRANSFER_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "to", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "to", type: "address" },
  { name: "recovery", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE = [
  { name: "fid", type: "uint256" },
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var ID_REGISTRY_EIP_712_TYPES = {
  domain: ID_REGISTRY_EIP_712_DOMAIN,
  types: {
    Transfer: ID_REGISTRY_TRANSFER_TYPE,
    TransferAndChangeRecovery: ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE,
    ChangeRecoveryAddress: ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE
  }
};
var verifyTransfer = async (message, signature, address) => {
  const valid = await import_neverthrow9.ResultAsync.fromPromise(
    (0, import_viem5.verifyTypedData)({
      address: (0, import_viem5.bytesToHex)(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { Transfer: ID_REGISTRY_TRANSFER_TYPE },
      primaryType: "Transfer",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyTransferAndChangeRecovery = async (message, signature, address) => {
  const valid = await import_neverthrow9.ResultAsync.fromPromise(
    (0, import_viem5.verifyTypedData)({
      address: (0, import_viem5.bytesToHex)(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { TransferAndChangeRecovery: ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE },
      primaryType: "TransferAndChangeRecovery",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};
var verifyChangeRecoveryAddress = async (message, signature, address) => {
  const valid = await import_neverthrow9.ResultAsync.fromPromise(
    (0, import_viem5.verifyTypedData)({
      address: (0, import_viem5.bytesToHex)(address),
      domain: ID_REGISTRY_EIP_712_DOMAIN,
      types: { ChangeRecoveryAddress: ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE },
      primaryType: "ChangeRecoveryAddress",
      message,
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/keyGateway.ts
init_cjs_shims();
var import_neverthrow10 = require("neverthrow");
var import_viem6 = require("viem");
var KEY_GATEWAY_ADDRESS = "0x00000000fC56947c7E7183f8Ca4B62398CaAdf0B";
var KEY_GATEWAY_EIP_712_DOMAIN = {
  name: "Farcaster KeyGateway",
  version: "1",
  chainId: 10,
  verifyingContract: KEY_GATEWAY_ADDRESS
};
var KEY_GATEWAY_ADD_TYPE = [
  { name: "owner", type: "address" },
  { name: "keyType", type: "uint32" },
  { name: "key", type: "bytes" },
  { name: "metadataType", type: "uint8" },
  { name: "metadata", type: "bytes" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var KEY_GATEWAY_EIP_712_TYPES = {
  domain: KEY_GATEWAY_EIP_712_DOMAIN,
  types: { Add: KEY_GATEWAY_ADD_TYPE }
};
var verifyAdd = async (message, signature, address) => {
  const valid = await import_neverthrow10.ResultAsync.fromPromise(
    (0, import_viem6.verifyTypedData)({
      address: (0, import_viem6.bytesToHex)(address),
      domain: KEY_GATEWAY_EIP_712_DOMAIN,
      types: { Add: KEY_GATEWAY_ADD_TYPE },
      primaryType: "Add",
      message: { ...message, key: (0, import_viem6.bytesToHex)(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/keyRegistry.ts
init_cjs_shims();
var import_neverthrow11 = require("neverthrow");
var import_viem7 = require("viem");
var KEY_REGISTRY_ADDRESS = "0x00000000fc1237824fb747abde0ff18990e59b7e";
var KEY_REGISTRY_EIP_712_DOMAIN = {
  name: "Farcaster KeyRegistry",
  version: "1",
  chainId: 10,
  verifyingContract: KEY_REGISTRY_ADDRESS
};
var KEY_REGISTRY_REMOVE_TYPE = [
  { name: "owner", type: "address" },
  { name: "key", type: "bytes" },
  { name: "nonce", type: "uint256" },
  { name: "deadline", type: "uint256" }
];
var KEY_REGISTRY_EIP_712_TYPES = {
  domain: KEY_REGISTRY_EIP_712_DOMAIN,
  types: { Remove: KEY_REGISTRY_REMOVE_TYPE }
};
var verifyRemove = async (message, signature, address) => {
  const valid = await import_neverthrow11.ResultAsync.fromPromise(
    (0, import_viem7.verifyTypedData)({
      address: (0, import_viem7.bytesToHex)(address),
      domain: KEY_REGISTRY_EIP_712_DOMAIN,
      types: { Remove: KEY_REGISTRY_REMOVE_TYPE },
      primaryType: "Remove",
      message: { ...message, key: (0, import_viem7.bytesToHex)(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/signedKeyRequestValidator.ts
init_cjs_shims();
var import_neverthrow12 = require("neverthrow");
var import_viem8 = require("viem");
var SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS = "0x00000000FC700472606ED4fA22623Acf62c60553";
var SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN = {
  name: "Farcaster SignedKeyRequestValidator",
  version: "1",
  chainId: 10,
  verifyingContract: SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS
};
var SIGNED_KEY_REQUEST_TYPE = [
  { name: "requestFid", type: "uint256" },
  { name: "key", type: "bytes" },
  { name: "deadline", type: "uint256" }
];
var SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES = {
  domain: SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
  types: { SignedKeyRequest: SIGNED_KEY_REQUEST_TYPE }
};
var verifyKeyRequest = async (message, signature, address) => {
  const valid = await import_neverthrow12.ResultAsync.fromPromise(
    (0, import_viem8.verifyTypedData)({
      address: (0, import_viem8.bytesToHex)(address),
      domain: SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
      types: { SignedKeyRequest: SIGNED_KEY_REQUEST_TYPE },
      primaryType: "SignedKeyRequest",
      message: { ...message, key: (0, import_viem8.bytesToHex)(message.key) },
      signature
    }),
    (e) => new HubError("unknown", e)
  );
  return valid;
};

// src/eth/contracts/storageRegistry.ts
init_cjs_shims();
var STORAGE_REGISTRY_ADDRESS = "0x00000000fcCe7f938e7aE6D3c335bD6a1a7c593D";

// src/eth/contracts/abis/index.ts
init_cjs_shims();

// src/eth/contracts/abis/bundler.ts
init_cjs_shims();
var bundlerABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idGateway",
        type: "address"
      },
      {
        internalType: "address",
        name: "_keyGateway",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idGateway",
    outputs: [
      {
        internalType: "contract IIdGateway",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyGateway",
    outputs: [
      {
        internalType: "contract IKeyGateway",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "address",
            name: "recovery",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "sig",
            type: "bytes"
          }
        ],
        internalType: "struct IBundler.RegistrationParams",
        name: "registerParams",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint32",
            name: "keyType",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "key",
            type: "bytes"
          },
          {
            internalType: "uint8",
            name: "metadataType",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "metadata",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "sig",
            type: "bytes"
          }
        ],
        internalType: "struct IBundler.SignerParams[]",
        name: "signerParams",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/eth/contracts/abis/idGateway.ts
init_cjs_shims();
var idGatewayABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_storageRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldStorageRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newStorageRegistry",
        type: "address"
      }
    ],
    name: "SetStorageRegistry",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "REGISTER_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IIdRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "registerFor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "extraStorage",
        type: "uint256"
      }
    ],
    name: "registerFor",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_storageRegistry",
        type: "address"
      }
    ],
    name: "setStorageRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "storageRegistry",
    outputs: [
      {
        internalType: "contract IStorageRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/eth/contracts/abis/idRegistry.ts
init_cjs_shims();
var idRegistryABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyMigrated",
    type: "error"
  },
  {
    inputs: [],
    name: "GatewayFrozen",
    type: "error"
  },
  {
    inputs: [],
    name: "HasId",
    type: "error"
  },
  {
    inputs: [],
    name: "HasNoId",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyMigrator",
    type: "error"
  },
  {
    inputs: [],
    name: "PermissionRevoked",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "AdminReset",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "ChangeRecoveryAddress",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "idGateway",
        type: "address"
      }
    ],
    name: "FreezeIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "migratedAt",
        type: "uint256"
      }
    ],
    name: "Migrated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Recover",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "Register",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldCounter",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newCounter",
        type: "uint256"
      }
    ],
    name: "SetIdCounter",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdGateway",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdGateway",
        type: "address"
      }
    ],
    name: "SetIdGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldMigrator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newMigrator",
        type: "address"
      }
    ],
    name: "SetMigrator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "CHANGE_RECOVERY_ADDRESS_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_AND_CHANGE_RECOVERY_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          },
          {
            internalType: "address",
            name: "recovery",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterData[]",
        name: "ids",
        type: "tuple[]"
      }
    ],
    name: "bulkRegisterIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint24",
            name: "fid",
            type: "uint24"
          },
          {
            internalType: "address",
            name: "custody",
            type: "address"
          }
        ],
        internalType: "struct IIdRegistry.BulkRegisterDefaultRecoveryData[]",
        name: "ids",
        type: "tuple[]"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "bulkRegisterIdsWithDefaultRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint24[]",
        name: "ids",
        type: "uint24[]"
      }
    ],
    name: "bulkResetIds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "changeRecoveryAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "changeRecoveryAddressFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "custodyOf",
    outputs: [
      {
        internalType: "address",
        name: "custody",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "freezeIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "gatewayFrozen",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gracePeriod",
    outputs: [
      {
        internalType: "uint24",
        name: "",
        type: "uint24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idGateway",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "idOf",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isMigrated",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "migratedAt",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "recover",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "recoveryDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "recoverySig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "recoverFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    name: "recoveryOf",
    outputs: [
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      }
    ],
    name: "register",
    outputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_counter",
        type: "uint256"
      }
    ],
    name: "setIdCounter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idGateway",
        type: "address"
      }
    ],
    name: "setIdGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      }
    ],
    name: "setMigrator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecovery",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "address",
        name: "recovery",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferAndChangeRecoveryFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fromDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "fromSig",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "toDeadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "toSig",
        type: "bytes"
      }
    ],
    name: "transferFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "custodyAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "digest",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "verifyFidSignature",
    outputs: [
      {
        internalType: "bool",
        name: "isValid",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/keyGateway.ts
init_cjs_shims();
var keyGatewayABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_keyRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "ADD_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "addFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyRegistry",
    outputs: [
      {
        internalType: "contract IKeyRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/eth/contracts/abis/keyRegistry.ts
init_cjs_shims();
var keyRegistryABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_maxKeysPerFid",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyMigrated",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsMaximum",
    type: "error"
  },
  {
    inputs: [],
    name: "GatewayFrozen",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidKeyType",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMaxKeys",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadata",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMetadataType",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidState",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyGuardian",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyMigrator",
    type: "error"
  },
  {
    inputs: [],
    name: "PermissionRevoked",
    type: "error"
  },
  {
    inputs: [],
    name: "SignatureExpired",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      }
    ],
    name: "ValidatorNotFound",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Add",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      }
    ],
    name: "AdminReset",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "keyGateway",
        type: "address"
      }
    ],
    name: "FreezeKeyGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "migratedAt",
        type: "uint256"
      }
    ],
    name: "Migrated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "keyBytes",
        type: "bytes"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "Remove",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdRegistry",
        type: "address"
      }
    ],
    name: "SetIdRegistry",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldKeyGateway",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newKeyGateway",
        type: "address"
      }
    ],
    name: "SetKeyGateway",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMax",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMax",
        type: "uint256"
      }
    ],
    name: "SetMaxKeysPerFid",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldMigrator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newMigrator",
        type: "address"
      }
    ],
    name: "SetMigrator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "address",
        name: "oldValidator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newValidator",
        type: "address"
      }
    ],
    name: "SetValidator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "REMOVE_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      }
    ],
    name: "add",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "addGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "fid",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "bytes",
                name: "key",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "metadata",
                type: "bytes"
              }
            ],
            internalType: "struct IKeyRegistry.BulkAddKey[]",
            name: "keys",
            type: "tuple[]"
          }
        ],
        internalType: "struct IKeyRegistry.BulkAddData[]",
        name: "items",
        type: "tuple[]"
      }
    ],
    name: "bulkAddKeysForMigration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "fid",
            type: "uint256"
          },
          {
            internalType: "bytes[]",
            name: "keys",
            type: "bytes[]"
          }
        ],
        internalType: "struct IKeyRegistry.BulkResetData[]",
        name: "items",
        type: "tuple[]"
      }
    ],
    name: "bulkResetKeysForMigration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "freezeKeyGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "gatewayFrozen",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gracePeriod",
    outputs: [
      {
        internalType: "uint24",
        name: "",
        type: "uint24"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "guardians",
    outputs: [
      {
        internalType: "bool",
        name: "isGuardian",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IdRegistryLike",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isMigrated",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "keyAt",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "keyDataOf",
    outputs: [
      {
        components: [
          {
            internalType: "enum IKeyRegistry.KeyState",
            name: "state",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "keyType",
            type: "uint32"
          }
        ],
        internalType: "struct IKeyRegistry.KeyData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "keyGateway",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "keys",
    outputs: [
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      }
    ],
    name: "keysOf",
    outputs: [
      {
        internalType: "bytes[]",
        name: "",
        type: "bytes[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "startIdx",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "batchSize",
        type: "uint256"
      }
    ],
    name: "keysOf",
    outputs: [
      {
        internalType: "bytes[]",
        name: "page",
        type: "bytes[]"
      },
      {
        internalType: "uint256",
        name: "nextIdx",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxKeysPerFid",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "migratedAt",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "migrator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      }
    ],
    name: "remove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fidOwner",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "sig",
        type: "bytes"
      }
    ],
    name: "removeFor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "removeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      }
    ],
    name: "setIdRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_keyGateway",
        type: "address"
      }
    ],
    name: "setKeyGateway",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_maxKeysPerFid",
        type: "uint256"
      }
    ],
    name: "setMaxKeysPerFid",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_migrator",
        type: "address"
      }
    ],
    name: "setMigrator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      },
      {
        internalType: "contract IMetadataValidator",
        name: "validator",
        type: "address"
      }
    ],
    name: "setValidator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "enum IKeyRegistry.KeyState",
        name: "state",
        type: "uint8"
      }
    ],
    name: "totalKeys",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "useNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "keyType",
        type: "uint32"
      },
      {
        internalType: "uint8",
        name: "metadataType",
        type: "uint8"
      }
    ],
    name: "validators",
    outputs: [
      {
        internalType: "contract IMetadataValidator",
        name: "validator",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/signedKeyRequestValidator.ts
init_cjs_shims();
var signedKeyRequestValidatorABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldIdRegistry",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newIdRegistry",
        type: "address"
      }
    ],
    name: "SetIdRegistry",
    type: "event"
  },
  {
    inputs: [],
    name: "METADATA_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparatorV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "requestFid",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "requestSigner",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct SignedKeyRequestValidator.SignedKeyRequestMetadata",
        name: "metadata",
        type: "tuple"
      }
    ],
    name: "encodeMetadata",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "structHash",
        type: "bytes32"
      }
    ],
    name: "hashTypedDataV4",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "idRegistry",
    outputs: [
      {
        internalType: "contract IdRegistryLike",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_idRegistry",
        type: "address"
      }
    ],
    name: "setIdRegistry",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "key",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "signedKeyRequestBytes",
        type: "bytes"
      }
    ],
    name: "validate",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/eth/contracts/abis/storageRegistry.ts
init_cjs_shims();
var storageRegistryABI = [
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "_priceFeed",
        type: "address"
      },
      {
        internalType: "contract AggregatorV3Interface",
        name: "_uptimeFeed",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_initialUsdUnitPrice",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_initialMaxUnits",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_initialVault",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialRoleAdmin",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOwner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialOperator",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialTreasurer",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "CallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "ContractDeprecated",
    type: "error"
  },
  {
    inputs: [],
    name: "ExceedsCapacity",
    type: "error"
  },
  {
    inputs: [],
    name: "GracePeriodNotOver",
    type: "error"
  },
  {
    inputs: [],
    name: "IncompleteRound",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidAmount",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidBatchInput",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidDeprecationTimestamp",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidFixedPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMaxAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMinAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayment",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPrice",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidRangeInput",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidRoundTimestamp",
    type: "error"
  },
  {
    inputs: [],
    name: "NotOperator",
    type: "error"
  },
  {
    inputs: [],
    name: "NotOwner",
    type: "error"
  },
  {
    inputs: [],
    name: "NotTreasurer",
    type: "error"
  },
  {
    inputs: [],
    name: "PriceOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "SequencerDown",
    type: "error"
  },
  {
    inputs: [],
    name: "StaleAnswer",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "Rent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldDuration",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newDuration",
        type: "uint256"
      }
    ],
    name: "SetCacheDuration",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newTimestamp",
        type: "uint256"
      }
    ],
    name: "SetDeprecationTimestamp",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetFixedEthUsdPrice",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPeriod",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPeriod",
        type: "uint256"
      }
    ],
    name: "SetGracePeriod",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldAge",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newAge",
        type: "uint256"
      }
    ],
    name: "SetMaxAge",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetMaxAnswer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMax",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMax",
        type: "uint256"
      }
    ],
    name: "SetMaxUnits",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetMinAnswer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPrice",
        type: "uint256"
      }
    ],
    name: "SetPrice",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldFeed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newFeed",
        type: "address"
      }
    ],
    name: "SetPriceFeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldFeed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newFeed",
        type: "address"
      }
    ],
    name: "SetUptimeFeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldVault",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newVault",
        type: "address"
      }
    ],
    name: "SetVault",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "VERSION",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "fids",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "batchCredit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "fids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "units",
        type: "uint256[]"
      }
    ],
    name: "batchRent",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "start",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "end",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "continuousCredit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "credit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "deprecationTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ethUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "fixedEthUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastPriceFeedUpdateBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastPriceFeedUpdateTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxUnits",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "prevEthUsdPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeed",
    outputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedCacheDuration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMaxAge",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMaxAnswer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "priceFeedMinAnswer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "refreshPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fid",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "units",
        type: "uint256"
      }
    ],
    name: "rent",
    outputs: [
      {
        internalType: "uint256",
        name: "overpayment",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "rentedUnits",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "duration",
        type: "uint256"
      }
    ],
    name: "setCacheDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    name: "setDeprecationTimestamp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "fixedPrice",
        type: "uint256"
      }
    ],
    name: "setFixedEthUsdPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "period",
        type: "uint256"
      }
    ],
    name: "setGracePeriod",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "age",
        type: "uint256"
      }
    ],
    name: "setMaxAge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxPrice",
        type: "uint256"
      }
    ],
    name: "setMaxAnswer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "setMaxUnits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minPrice",
        type: "uint256"
      }
    ],
    name: "setMinAnswer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "usdPrice",
        type: "uint256"
      }
    ],
    name: "setPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "feed",
        type: "address"
      }
    ],
    name: "setPriceFeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "feed",
        type: "address"
      }
    ],
    name: "setUptimeFeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vaultAddr",
        type: "address"
      }
    ],
    name: "setVault",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unitPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "uptimeFeed",
    outputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "uptimeFeedGracePeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "usdUnitPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "vault",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/factories.ts
init_cjs_shims();
var import_faker = require("@faker-js/faker");

// ../../node_modules/@farcaster/fishery/dist/fishery.mjs
init_cjs_shims();
var import_lodash = __toESM(require_lodash(), 1);
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
var merge = import_lodash.default;
var mergeCustomizer = function(objValue, srcVal, key, object) {
  if (Array.isArray(srcVal) || ArrayBuffer.isView(srcVal)) {
    return srcVal;
  } else if (srcVal === void 0) {
    object[key] = srcVal;
  }
};
var FactoryBuilder = (
  /** @class */
  function() {
    function FactoryBuilder2(generator, sequence, params, transientParams, associations, afterBuilds, afterCreates, onCreate) {
      var _this = this;
      this.generator = generator;
      this.sequence = sequence;
      this.params = params;
      this.transientParams = transientParams;
      this.associations = associations;
      this.afterBuilds = afterBuilds;
      this.afterCreates = afterCreates;
      this.onCreate = onCreate;
      this.setAfterBuild = function(hook) {
        _this.afterBuilds = __spreadArrays([hook], _this.afterBuilds);
      };
      this.setAfterCreate = function(hook) {
        _this.afterCreates = __spreadArrays([hook], _this.afterCreates);
      };
      this.setOnCreate = function(hook) {
        if (!_this.onCreate) {
          _this.onCreate = hook;
        }
      };
    }
    FactoryBuilder2.prototype.build = function() {
      var generatorOptions = {
        sequence: this.sequence,
        afterBuild: this.setAfterBuild,
        afterCreate: this.setAfterCreate,
        onCreate: this.setOnCreate,
        params: this.params,
        associations: this.associations,
        transientParams: this.transientParams
      };
      var object = this._mergeParamsOntoObject(this.generator(generatorOptions));
      this._callAfterBuilds(object);
      return object;
    };
    FactoryBuilder2.prototype.create = function() {
      return __awaiter(this, void 0, void 0, function() {
        var object, created;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              object = this.build();
              return [4, this._callOnCreate(object)];
            case 1:
              created = _a.sent();
              return [2, this._callAfterCreates(created)];
          }
        });
      });
    };
    FactoryBuilder2.prototype._mergeParamsOntoObject = function(object) {
      if (typeof object !== "object") {
        return object;
      }
      var targetObject = object;
      if (Object.getPrototypeOf(object) === Object.prototype) {
        targetObject = {};
      } else if (Array.isArray(object)) {
        targetObject = [];
      }
      return merge(targetObject, object, this.params, this.associations, mergeCustomizer);
    };
    FactoryBuilder2.prototype._callAfterBuilds = function(object) {
      this.afterBuilds.forEach(function(afterBuild) {
        if (typeof afterBuild === "function") {
          afterBuild(object);
        } else {
          throw new Error('"afterBuild" must be a function');
        }
      });
    };
    FactoryBuilder2.prototype._callOnCreate = function(object) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          if (!this.onCreate) {
            throw new Error("Attempted to call `create`, but no onCreate defined");
          }
          return [2, this.onCreate(object)];
        });
      });
    };
    FactoryBuilder2.prototype._callAfterCreates = function(object) {
      return __awaiter(this, void 0, void 0, function() {
        var created, _i, _a, afterCreate;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              created = object;
              _i = 0, _a = this.afterCreates;
              _b.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 5];
              afterCreate = _a[_i];
              if (!(typeof afterCreate === "function"))
                return [3, 3];
              return [4, afterCreate(created)];
            case 2:
              created = _b.sent();
              return [3, 4];
            case 3:
              throw new Error('"afterCreate" must be a function');
            case 4:
              _i++;
              return [3, 1];
            case 5:
              return [2, created];
          }
        });
      });
    };
    return FactoryBuilder2;
  }()
);
var SEQUENCE_START_VALUE = 1;
var Factory = (
  /** @class */
  function() {
    function Factory2(generator) {
      this.generator = generator;
      this.id = { value: SEQUENCE_START_VALUE };
      this._afterBuilds = [];
      this._afterCreates = [];
    }
    Factory2.define = function(generator) {
      return new this(generator);
    };
    Factory2.prototype.build = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return this.builder(params, options).build();
    };
    Factory2.prototype.buildList = function(number, params, options) {
      if (options === void 0) {
        options = {};
      }
      var list = [];
      for (var i = 0; i < number; i++) {
        list.push(this.build(params, options));
      }
      return list;
    };
    Factory2.prototype.create = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, this.builder(params, options).create()];
        });
      });
    };
    Factory2.prototype.createList = function(number, params, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var list, i;
        return __generator(this, function(_a) {
          list = [];
          for (i = 0; i < number; i++) {
            list.push(this.create(params, options));
          }
          return [2, Promise.all(list)];
        });
      });
    };
    Factory2.prototype.afterBuild = function(afterBuildFn) {
      var factory = this.clone();
      factory._afterBuilds.push(afterBuildFn);
      return factory;
    };
    Factory2.prototype.onCreate = function(onCreateFn) {
      var factory = this.clone();
      factory._onCreate = onCreateFn;
      return factory;
    };
    Factory2.prototype.afterCreate = function(afterCreateFn) {
      var factory = this.clone();
      factory._afterCreates.push(afterCreateFn);
      return factory;
    };
    Factory2.prototype.associations = function(associations) {
      var factory = this.clone();
      factory._associations = __assign(__assign({}, this._associations), associations);
      return factory;
    };
    Factory2.prototype.params = function(params) {
      var factory = this.clone();
      factory._params = merge({}, this._params, params, mergeCustomizer);
      return factory;
    };
    Factory2.prototype.transient = function(transient) {
      var factory = this.clone();
      factory._transient = __assign(__assign({}, this._transient), transient);
      return factory;
    };
    Factory2.prototype.rewindSequence = function() {
      this.id.value = SEQUENCE_START_VALUE;
    };
    Factory2.prototype.clone = function() {
      var copy = new this.constructor(this.generator);
      Object.assign(copy, this);
      copy._afterCreates = __spreadArrays(this._afterCreates);
      copy._afterBuilds = __spreadArrays(this._afterBuilds);
      return copy;
    };
    Factory2.prototype.sequence = function() {
      return this.id.value++;
    };
    Factory2.prototype.builder = function(params, options) {
      if (options === void 0) {
        options = {};
      }
      return new FactoryBuilder(this.generator, this.sequence(), merge({}, this._params, params, mergeCustomizer), __assign(__assign({}, this._transient), options.transient), __assign(__assign({}, this._associations), options.associations), this._afterBuilds, this._afterCreates, this._onCreate);
    };
    return Factory2;
  }()
);

// src/factories.ts
var import_ed255193 = require("@noble/curves/ed25519");
var import_blake33 = require("@noble/hashes/blake3");
var import_accounts = require("viem/accounts");
var import_utils4 = require("@noble/hashes/utils");

// src/signers/index.ts
init_cjs_shims();

// src/signers/ed25519Signer.ts
init_cjs_shims();
var Ed25519Signer = class {
  constructor() {
    /** Signature scheme as defined in protobufs */
    __publicField(this, "scheme", 1 /* ED25519 */);
  }
};

// src/signers/eip712Signer.ts
init_cjs_shims();
var Eip712Signer = class {
  constructor() {
    /** Signature scheme as defined in protobufs */
    __publicField(this, "scheme", 2 /* EIP712 */);
  }
};

// src/signers/ethersEip712Signer.ts
init_cjs_shims();
var import_neverthrow13 = require("neverthrow");
var import_viem9 = require("viem");
var EthersEip712Signer = class extends Eip712Signer {
  constructor(signer) {
    super();
    __publicField(this, "_ethersSigner");
    this._ethersSigner = signer;
  }
  async getSignerKey() {
    return import_neverthrow13.ResultAsync.fromPromise(this._ethersSigner.getAddress(), (e) => new HubError("unknown", e)).andThen(
      hexStringToBytes
    );
  }
  async signMessageHash(hash) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        EIP_712_FARCASTER_DOMAIN,
        { MessageData: [...EIP_712_FARCASTER_MESSAGE_DATA] },
        { hash }
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(domain, { VerificationClaim: [...EIP_712_FARCASTER_VERIFICATION_CLAIM] }, claim),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signUserNameProofClaim(userNameProof) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        EIP_712_USERNAME_DOMAIN,
        { UserNameProof: [...EIP_712_USERNAME_PROOF] },
        userNameProof
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRegister(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(ID_GATEWAY_EIP_712_DOMAIN, { Register: [...ID_GATEWAY_REGISTER_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransfer(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { Transfer: [...ID_REGISTRY_TRANSFER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransferAndChangeRecovery(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { TransferAndChangeRecovery: [...ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signChangeRecoveryAddress(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { ChangeRecoveryAddress: [...ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signAdd(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(KEY_GATEWAY_EIP_712_DOMAIN, { Add: [...KEY_GATEWAY_ADD_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRemove(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(KEY_REGISTRY_EIP_712_DOMAIN, { Remove: [...KEY_REGISTRY_REMOVE_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signKeyRequest(message) {
    const hexSignature = await import_neverthrow13.ResultAsync.fromPromise(
      this._ethersSigner.signTypedData(
        SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
        { SignedKeyRequest: [...SIGNED_KEY_REQUEST_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return (0, import_neverthrow13.err)(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return (0, import_neverthrow13.err)(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return (0, import_neverthrow13.err)(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return (0, import_neverthrow13.err)(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = (0, import_viem9.encodeAbiParameters)(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
};

// src/signers/ethersV5Eip712Signer.ts
init_cjs_shims();
var import_neverthrow14 = require("neverthrow");
var import_viem10 = require("viem");
var EthersV5Eip712Signer = class extends Eip712Signer {
  constructor(typedDataSigner) {
    super();
    __publicField(this, "_typedDataSigner");
    this._typedDataSigner = typedDataSigner;
  }
  async getSignerKey() {
    return import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner.getAddress(),
      (e) => new HubError("unknown", e)
    ).andThen(hexStringToBytes);
  }
  async signMessageHash(hash) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        eip712_exports.EIP_712_FARCASTER_DOMAIN,
        { MessageData: [...eip712_exports.EIP_712_FARCASTER_MESSAGE_DATA] },
        { hash }
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? eip712_exports.EIP_712_FARCASTER_DOMAIN : { ...eip712_exports.EIP_712_FARCASTER_DOMAIN, chainId };
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        domain,
        { VerificationClaim: [...eip712_exports.EIP_712_FARCASTER_VERIFICATION_CLAIM] },
        claim
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signUserNameProofClaim(usernameProof) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        eip712_exports.EIP_712_USERNAME_DOMAIN,
        { UserNameProof: [...eip712_exports.EIP_712_USERNAME_PROOF] },
        usernameProof
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRegister(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_GATEWAY_EIP_712_DOMAIN,
        { Register: [...ID_GATEWAY_REGISTER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransfer(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { Transfer: [...ID_REGISTRY_TRANSFER_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signTransferAndChangeRecovery(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { TransferAndChangeRecovery: [...ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signChangeRecoveryAddress(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        ID_REGISTRY_EIP_712_DOMAIN,
        { ChangeRecoveryAddress: [...ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signAdd(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(KEY_GATEWAY_EIP_712_DOMAIN, { Add: [...KEY_GATEWAY_ADD_TYPE] }, message),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signRemove(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        KEY_REGISTRY_EIP_712_DOMAIN,
        { Remove: [...KEY_REGISTRY_REMOVE_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async signKeyRequest(message) {
    const hexSignature = await import_neverthrow14.ResultAsync.fromPromise(
      this._typedDataSigner._signTypedData(
        SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
        { SignedKeyRequest: [...SIGNED_KEY_REQUEST_TYPE] },
        message
      ),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return (0, import_neverthrow14.err)(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return (0, import_neverthrow14.err)(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return (0, import_neverthrow14.err)(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return (0, import_neverthrow14.err)(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = (0, import_viem10.encodeAbiParameters)(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
};

// src/signers/nobleEd25519Signer.ts
init_cjs_shims();
var import_neverthrow15 = require("neverthrow");
var import_ed255192 = require("@noble/curves/ed25519");
var NobleEd25519Signer = class extends Ed25519Signer {
  constructor(privateKey) {
    super();
    __publicField(this, "_privateKey");
    this._privateKey = privateKey;
  }
  async getSignerKey() {
    return (0, import_neverthrow15.ok)(import_ed255192.ed25519.getPublicKey(this._privateKey));
  }
  async signMessageHash(hash) {
    return (0, import_neverthrow15.ok)(import_ed255192.ed25519.sign(hash, this._privateKey));
  }
};

// src/signers/viemLocalEip712Signer.ts
init_cjs_shims();
var import_neverthrow16 = require("neverthrow");
var import_utils = require("viem/utils");
var ViemLocalEip712Signer = class extends Eip712Signer {
  constructor(viemLocalAccount) {
    super();
    __publicField(this, "_viemLocalAccount");
    this._viemLocalAccount = viemLocalAccount;
  }
  async getSignerKey() {
    return import_neverthrow16.ResultAsync.fromPromise(
      Promise.resolve(this._viemLocalAccount.address),
      (e) => new HubError("unknown", e)
    ).andThen(hexStringToBytes);
  }
  async signMessageHash(hash) {
    return this._signTypedData({
      ...MESSAGE_DATA_EIP_712_TYPES,
      primaryType: "MessageData",
      message: {
        hash: (0, import_utils.bytesToHex)(hash)
      }
    });
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    return this._signTypedData({
      domain,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim
    });
  }
  async signUserNameProofClaim(userNameProof) {
    return this._signTypedData({
      ...USERNAME_PROOF_EIP_712_TYPES,
      primaryType: "UserNameProof",
      message: userNameProof
    });
  }
  async signRegister(message) {
    return this._signTypedData({
      ...ID_GATEWAY_EIP_712_TYPES,
      primaryType: "Register",
      message
    });
  }
  async signTransfer(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "Transfer",
      message
    });
  }
  async signTransferAndChangeRecovery(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "TransferAndChangeRecovery",
      message
    });
  }
  async signChangeRecoveryAddress(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "ChangeRecoveryAddress",
      message
    });
  }
  async signAdd(message) {
    return this._signTypedData({
      ...KEY_GATEWAY_EIP_712_TYPES,
      primaryType: "Add",
      message: { ...message, key: (0, import_utils.bytesToHex)(message.key) }
    });
  }
  async signRemove(message) {
    return this._signTypedData({
      ...KEY_REGISTRY_EIP_712_TYPES,
      primaryType: "Remove",
      message: { ...message, key: (0, import_utils.bytesToHex)(message.key) }
    });
  }
  async signKeyRequest(message) {
    return this._signTypedData({
      ...SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
      primaryType: "SignedKeyRequest",
      message: { ...message, key: (0, import_utils.bytesToHex)(message.key) }
    });
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return (0, import_neverthrow16.err)(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return (0, import_neverthrow16.err)(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return (0, import_neverthrow16.err)(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return (0, import_neverthrow16.err)(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = (0, import_utils.encodeAbiParameters)(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
  async _signTypedData(params) {
    const hexSignature = await import_neverthrow16.ResultAsync.fromPromise(
      this._viemLocalAccount.signTypedData(params),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
};

// src/signers/viemWalletEip712Signer.ts
init_cjs_shims();
var import_neverthrow17 = require("neverthrow");
var import_utils2 = require("viem/utils");
var import_actions = require("viem/actions");
var ViemWalletEip712Signer = class extends Eip712Signer {
  constructor(viemWalletClient) {
    super();
    __publicField(this, "_viemWalletClient");
    this._viemWalletClient = viemWalletClient;
  }
  async getSignerKey() {
    var _a;
    const address = (_a = this._viemWalletClient.account) == null ? void 0 : _a.address;
    if (!address) {
      return (0, import_neverthrow17.err)(new HubError("unavailable", "wallet not connected"));
    }
    return import_neverthrow17.ResultAsync.fromPromise(Promise.resolve(address), (e) => new HubError("unknown", e)).andThen(
      hexStringToBytes
    );
  }
  async signMessageHash(hash) {
    return this._signTypedData({
      ...MESSAGE_DATA_EIP_712_TYPES,
      primaryType: "MessageData",
      message: {
        hash: (0, import_utils2.bytesToHex)(hash)
      }
    });
  }
  async signVerificationEthAddressClaim(claim, chainId = 0) {
    const domain = chainId === 0 ? EIP_712_FARCASTER_DOMAIN : { ...EIP_712_FARCASTER_DOMAIN, chainId };
    return this._signTypedData({
      domain,
      types: { VerificationClaim: EIP_712_FARCASTER_VERIFICATION_CLAIM },
      primaryType: "VerificationClaim",
      message: claim
    });
  }
  async signUserNameProofClaim(userNameProof) {
    return this._signTypedData({
      ...USERNAME_PROOF_EIP_712_TYPES,
      primaryType: "UserNameProof",
      message: userNameProof
    });
  }
  async signRegister(message) {
    return this._signTypedData({
      ...ID_GATEWAY_EIP_712_TYPES,
      primaryType: "Register",
      message
    });
  }
  async signTransfer(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "Transfer",
      message
    });
  }
  async signTransferAndChangeRecovery(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "TransferAndChangeRecovery",
      message
    });
  }
  async signChangeRecoveryAddress(message) {
    return this._signTypedData({
      ...ID_REGISTRY_EIP_712_TYPES,
      primaryType: "ChangeRecoveryAddress",
      message
    });
  }
  async signAdd(message) {
    return this._signTypedData({
      ...KEY_GATEWAY_EIP_712_TYPES,
      primaryType: "Add",
      message: { ...message, key: (0, import_utils2.bytesToHex)(message.key) }
    });
  }
  async signRemove(message) {
    return this._signTypedData({
      ...KEY_REGISTRY_EIP_712_TYPES,
      primaryType: "Remove",
      message: { ...message, key: (0, import_utils2.bytesToHex)(message.key) }
    });
  }
  async signKeyRequest(message) {
    return this._signTypedData({
      ...SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
      primaryType: "SignedKeyRequest",
      message: { ...message, key: (0, import_utils2.bytesToHex)(message.key) }
    });
  }
  async getSignedKeyRequestMetadata(message) {
    const signatureBytes = await this.signKeyRequest(message);
    if (signatureBytes.isErr()) {
      return (0, import_neverthrow17.err)(signatureBytes.error);
    }
    const signature = bytesToHexString(signatureBytes.value);
    if (signature.isErr()) {
      return (0, import_neverthrow17.err)(signature.error);
    }
    const signerAddressBytes = await this.getSignerKey();
    if (signerAddressBytes.isErr()) {
      return (0, import_neverthrow17.err)(signerAddressBytes.error);
    }
    const signerAddress = bytesToHexString(signerAddressBytes.value);
    if (signerAddress.isErr()) {
      return (0, import_neverthrow17.err)(signerAddress.error);
    }
    const metadataStruct = {
      requestFid: message.requestFid,
      requestSigner: signerAddress.value,
      signature: signature.value,
      deadline: message.deadline
    };
    const encodedStruct = (0, import_utils2.encodeAbiParameters)(
      [
        {
          components: [
            {
              name: "requestFid",
              type: "uint256"
            },
            {
              name: "requestSigner",
              type: "address"
            },
            {
              name: "signature",
              type: "bytes"
            },
            {
              name: "deadline",
              type: "uint256"
            }
          ],
          name: "SignedKeyRequestMetadata",
          type: "tuple"
        }
      ],
      [metadataStruct]
    );
    return hexStringToBytes(encodedStruct);
  }
  async _signTypedData(params) {
    const account = this._viemWalletClient.account;
    if (!account) {
      return (0, import_neverthrow17.err)(new HubError("unavailable", "wallet not connected"));
    }
    const hexSignature = await import_neverthrow17.ResultAsync.fromPromise(
      (0, import_actions.signTypedData)(this._viemWalletClient, { ...params, account }),
      (e) => new HubError("bad_request.invalid_param", e)
    );
    return hexSignature.andThen((hex) => hexStringToBytes(hex));
  }
};

// src/signers/signer.ts
init_cjs_shims();

// src/factories.ts
var import_viem11 = require("viem");

// ../../node_modules/ethers/lib.esm/ethers.js
init_cjs_shims();

// ../../node_modules/ethers/lib.esm/_version.js
init_cjs_shims();
var version = "6.6.1";

// ../../node_modules/ethers/lib.esm/utils/index.js
init_cjs_shims();

// ../../node_modules/ethers/lib.esm/utils/errors.js
init_cjs_shims();

// ../../node_modules/ethers/lib.esm/utils/properties.js
init_cjs_shims();
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/ethers/lib.esm/utils/errors.js
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function makeError(message, code, info) {
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);

// ../../node_modules/ethers/lib.esm/utils/maths.js
init_cjs_shims();
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
var Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}

// src/factories.ts
var FidFactory = Factory.define(() => {
  return import_faker.faker.datatype.number({ min: 1 });
});
var BytesFactory = Factory.define(({ transientParams }) => {
  var _a;
  const length = (_a = transientParams.length) != null ? _a : import_faker.faker.datatype.number({ max: 64, min: 1 });
  return (0, import_utils4.randomBytes)(length);
});
var MessageHashFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 20 } });
});
var FnameFactory = Factory.define(() => {
  const length = import_faker.faker.datatype.number({ min: 1, max: 16 });
  const bytes = new Uint8Array(length);
  bytes.set(
    [
      import_faker.faker.helpers.arrayElement([
        import_faker.faker.datatype.number({ min: 48, max: 57 }),
        import_faker.faker.datatype.number({ min: 97, max: 122 })
      ])
    ],
    0
  );
  for (let i = 1; i < length; i++) {
    bytes.set(
      [
        import_faker.faker.helpers.arrayElement([
          45,
          import_faker.faker.datatype.number({ min: 48, max: 57 }),
          import_faker.faker.datatype.number({ min: 97, max: 122 })
        ])
      ],
      i
    );
  }
  return bytes;
});
var EnsNameFactory = Factory.define(() => {
  const ensName = import_faker.faker.random.alphaNumeric(import_faker.faker.datatype.number({ min: 3, max: 16 }));
  return utf8StringToBytes(ensName.concat(".eth"))._unsafeUnwrap();
});
var BlockHashFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 32 } });
});
var EthAddressFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 20 } });
});
var SolAddressFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 32 } });
});
var TransactionHashFactory = Factory.define(() => {
  return BytesFactory.build(void 0, { transient: { length: 32 } });
});
var Ed25519PrivateKeyFactory = Factory.define(() => {
  return import_ed255193.ed25519.utils.randomPrivateKey();
});
var Ed25519PublicKeyFactory = Factory.define(() => {
  const privateKey = Ed25519PrivateKeyFactory.build();
  return import_ed255193.ed25519.getPublicKey(privateKey);
});
var Ed25519SignerFactory = Factory.define(() => {
  return new NobleEd25519Signer(Ed25519PrivateKeyFactory.build());
});
var Ed25519SignatureFactory = Factory.define(() => {
  return BytesFactory.build({}, { transient: { length: 64 } });
});
var Eip712SignerFactory = Factory.define(({ transientParams }) => {
  var _a;
  const account = (_a = transientParams.account) != null ? _a : (0, import_accounts.privateKeyToAccount)((0, import_accounts.generatePrivateKey)());
  return new ViemLocalEip712Signer(account);
});
var Eip712SignatureFactory = Factory.define(() => {
  return BytesFactory.build(void 0, { transient: { length: 65 } });
});
var CastIdFactory = Factory.define(() => {
  return CastId.create({
    fid: FidFactory.build(),
    hash: MessageHashFactory.build()
  });
});
var FarcasterNetworkFactory = Factory.define(() => {
  return import_faker.faker.helpers.arrayElement([
    3 /* DEVNET */,
    1 /* MAINNET */,
    2 /* TESTNET */
  ]);
});
var ReactionTypeFactory = Factory.define(() => {
  return import_faker.faker.helpers.arrayElement([1 /* LIKE */, 2 /* RECAST */]);
});
var UserDataTypeFactory = Factory.define(() => {
  return import_faker.faker.helpers.arrayElement([
    3 /* BIO */,
    2 /* DISPLAY */,
    6 /* USERNAME */,
    1 /* PFP */,
    5 /* URL */
  ]);
});
var MessageTypeFactory = Factory.define(() => {
  return import_faker.faker.helpers.arrayElement([
    1 /* CAST_ADD */,
    2 /* CAST_REMOVE */,
    3 /* REACTION_ADD */,
    4 /* REACTION_REMOVE */,
    11 /* USER_DATA_ADD */,
    7 /* VERIFICATION_ADD_ETH_ADDRESS */,
    8 /* VERIFICATION_REMOVE */
  ]);
});
var MessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate(async (message) => {
      var _a;
      if (!message.data) {
        return message;
      }
      const dataBytes = MessageData.encode(message.data).finish();
      if (message.hash.length === 0) {
        message.hash = (0, import_blake33.blake3)(dataBytes, { dkLen: 20 });
      }
      const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
      if (message.signature.length === 0) {
        message.signature = (await signer.signMessageHash(message.hash))._unsafeUnwrap();
      }
      if (!message.signatureScheme) {
        message.signatureScheme = signer.scheme;
      }
      if (message.signer.length === 0) {
        message.signer = (await signer.getSignerKey())._unsafeUnwrap();
      }
      return message;
    });
    return Message.create({
      data: CastAddDataFactory.build(),
      hashScheme: 1 /* BLAKE3 */
    });
  }
);
var MessageDataFactory = Factory.define(() => {
  return MessageData.create({
    fid: FidFactory.build(),
    timestamp: getFarcasterTime()._unsafeUnwrap(),
    network: 2 /* TESTNET */
  });
});
var CastIdEmbedFactory = Factory.define(() => {
  return Embed.create({ castId: CastIdFactory.build() });
});
var UrlEmbedFactory = Factory.define(() => {
  return Embed.create({ url: import_faker.faker.internet.url() });
});
var EmbedFactory = Factory.define(() => {
  return import_faker.faker.helpers.arrayElement([CastIdEmbedFactory.build(), UrlEmbedFactory.build()]);
});
var CastAddBodyFactory = Factory.define(() => {
  const text = import_faker.faker.lorem.sentence(12);
  return CastAddBody.create({
    embeds: [EmbedFactory.build(), EmbedFactory.build()],
    mentions: [FidFactory.build(), FidFactory.build(), FidFactory.build()],
    mentionsPositions: [0, Math.floor(text.length / 2), text.length],
    // Hack to avoid duplicates
    parentCastId: CastIdFactory.build(),
    text
  });
});
var CastAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    castAddBody: CastAddBodyFactory.build(),
    type: 1 /* CAST_ADD */
  });
});
var CastAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: CastAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var CastRemoveBodyFactory = Factory.define(() => {
  return CastRemoveBody.create({
    targetHash: MessageHashFactory.build()
  });
});
var CastRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    castRemoveBody: CastRemoveBodyFactory.build(),
    type: 2 /* CAST_REMOVE */
  });
});
var CastRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: CastRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkCompactStateBodyFactory = Factory.define(() => {
  return LinkCompactStateBody.create({
    targetFids: [FidFactory.build()],
    type: "follow"
  });
});
var LinkBodyFactory = Factory.define(() => {
  return LinkBody.create({
    targetFid: FidFactory.build(),
    type: "follow"
  });
});
var LinkCompactStateAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkCompactStateBody: LinkCompactStateBodyFactory.build(),
    type: 14 /* LINK_COMPACT_STATE */
  });
});
var LinkAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkBody: LinkBodyFactory.build(),
    type: 5 /* LINK_ADD */
  });
});
var LinkCompactStateMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, {
        transient: transientParams
      });
    });
    return MessageFactory.build(
      { data: LinkCompactStateAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: LinkAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var LinkRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    linkBody: LinkBodyFactory.build(),
    type: 6 /* LINK_REMOVE */
  });
});
var LinkRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: LinkRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var ReactionBodyFactory = Factory.define(() => {
  return ReactionBody.create({
    targetCastId: CastIdFactory.build(),
    type: ReactionTypeFactory.build()
  });
});
var ReactionAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    reactionBody: ReactionBodyFactory.build(),
    type: 3 /* REACTION_ADD */
  });
});
var ReactionAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: ReactionAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var ReactionRemoveDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    reactionBody: ReactionBodyFactory.build(),
    type: 4 /* REACTION_REMOVE */
  });
});
var ReactionRemoveMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: ReactionRemoveDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var VerificationSolAddressClaimFactory = Factory.define(() => {
  const address = bytesToBase58(SolAddressFactory.build())._unsafeUnwrap();
  const blockHash = bytesToBase58(BlockHashFactory.build())._unsafeUnwrap();
  if (base58ToBytes(address)._unsafeUnwrap().length !== 32) {
    throw new Error(`Bad address: ${address}`);
  }
  return {
    fid: BigInt(FidFactory.build()),
    address,
    network: FarcasterNetworkFactory.build(),
    blockHash,
    protocol: 1 /* SOLANA */
  };
});
var VerificationEthAddressClaimFactory = Factory.define(() => {
  const address = bytesToHexString(EthAddressFactory.build())._unsafeUnwrap();
  const blockHash = bytesToHexString(BlockHashFactory.build())._unsafeUnwrap();
  return {
    fid: BigInt(FidFactory.build()),
    address,
    network: FarcasterNetworkFactory.build(),
    blockHash,
    protocol: 0 /* ETHEREUM */
  };
});
var VerificationAddAddressBodyFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (body) => {
    var _a, _b, _c, _d, _e, _f;
    switch (transientParams.protocol) {
      case 0 /* ETHEREUM */: {
        const ethSigner = (_a = transientParams.signer) != null ? _a : Eip712SignerFactory.build();
        if (!transientParams.contractSignature) {
          body.address = (await ethSigner.getSignerKey())._unsafeUnwrap();
        }
        if (body.claimSignature.length === 0) {
          const fid = (_b = transientParams.fid) != null ? _b : FidFactory.build();
          const network = (_c = transientParams.network) != null ? _c : FarcasterNetworkFactory.build();
          const blockHash = bytesToHexString(body.blockHash);
          const claim = VerificationEthAddressClaimFactory.build({
            fid: BigInt(fid),
            network,
            blockHash: blockHash.isOk() ? blockHash.value : "0x",
            address: bytesToHexString(body.address)._unsafeUnwrap(),
            protocol: 0 /* ETHEREUM */
          });
          body.claimSignature = (await ethSigner.signVerificationEthAddressClaim(claim, body.chainId))._unsafeUnwrap();
        }
        body.protocol = 0 /* ETHEREUM */;
        return body;
      }
      case 1 /* SOLANA */: {
        const solSigner = (_d = transientParams.signer) != null ? _d : Ed25519SignerFactory.build();
        body.address = (await solSigner.getSignerKey())._unsafeUnwrap();
        if (body.claimSignature.length === 0) {
          const fid = (_e = transientParams.fid) != null ? _e : FidFactory.build();
          const network = (_f = transientParams.network) != null ? _f : FarcasterNetworkFactory.build();
          const blockHash = body.blockHash;
          const claim = VerificationSolAddressClaimFactory.build({
            fid: toBigInt(fid),
            network,
            blockHash: bytesToBase58(blockHash)._unsafeUnwrap(),
            address: bytesToBase58(body.address)._unsafeUnwrap(),
            protocol: 1 /* SOLANA */
          });
          const fullMessage = recreateSolanaClaimMessage(claim, body.address);
          body.claimSignature = (0, import_viem11.hexToBytes)((0, import_viem11.bytesToHex)((await solSigner.signMessageHash(fullMessage))._unsafeUnwrap()));
        }
        body.protocol = 1 /* SOLANA */;
        return body;
      }
      default:
        throw new Error(`Unsupported protocol [found: ${transientParams.protocol}]`);
    }
  });
  return VerificationAddAddressBody.create({
    address: EthAddressFactory.build(),
    blockHash: BlockHashFactory.build()
  });
});
var VerificationAddSolAddressDataFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (data) => {
    const body = data.verificationAddAddressBody;
    if (body.claimSignature.length === 0) {
      data.verificationAddAddressBody = await VerificationAddAddressBodyFactory.create(body, {
        transient: {
          fid: data.fid,
          network: data.network,
          signer: transientParams.signer,
          protocol: 1 /* SOLANA */
        }
      });
    }
    return data;
  });
  return MessageDataFactory.build({
    // verificationAddEthAddressBody will not be valid until onCreate
    verificationAddAddressBody: VerificationAddAddressBodyFactory.build(
      { protocol: 1 /* SOLANA */ },
      { transient: { protocol: 1 /* SOLANA */ } }
    ),
    type: 7 /* VERIFICATION_ADD_ETH_ADDRESS */
  });
});
var VerificationAddSolAddressMessageFactory = Factory.define(({ onCreate, transientParams, params }) => {
  var _a;
  const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
  onCreate(async (message) => {
    message.data = await VerificationAddSolAddressDataFactory.create(message.data, {
      transient: { signer: transientParams.signer }
    });
    return MessageFactory.create(message, {
      transient: { signer }
    });
  });
  return MessageFactory.build(
    {
      data: VerificationAddSolAddressDataFactory.build(params.data, {
        transient: { signer: transientParams.signer }
      })
    },
    { transient: { signer } }
  );
});
var VerificationAddEthAddressDataFactory = Factory.define(({ onCreate, transientParams }) => {
  onCreate(async (data) => {
    const body = data.verificationAddAddressBody;
    if (body.claimSignature.length === 0) {
      data.verificationAddAddressBody = await VerificationAddAddressBodyFactory.create(body, {
        transient: {
          fid: data.fid,
          network: data.network,
          signer: transientParams.signer,
          protocol: 0 /* ETHEREUM */
        }
      });
    }
    return data;
  });
  return MessageDataFactory.build({
    // verificationAddEthAddressBody will not be valid until onCreate
    verificationAddAddressBody: VerificationAddAddressBodyFactory.build({ protocol: 0 /* ETHEREUM */ }),
    type: 7 /* VERIFICATION_ADD_ETH_ADDRESS */
  });
});
var VerificationAddEthAddressMessageFactory = Factory.define(({ onCreate, transientParams, params }) => {
  var _a;
  const signer = (_a = transientParams.signer) != null ? _a : Ed25519SignerFactory.build();
  onCreate(async (message) => {
    message.data = await VerificationAddEthAddressDataFactory.create(message.data, {
      transient: { signer: transientParams.ethSigner }
    });
    return MessageFactory.create(message, {
      transient: { signer }
    });
  });
  return MessageFactory.build(
    {
      data: VerificationAddEthAddressDataFactory.build(params.data, {
        transient: { signer: transientParams.ethSigner }
      })
    },
    { transient: { signer } }
  );
});
var VerificationRemoveBodyFactory = Factory.define(({ params }) => {
  switch (params.protocol) {
    case 0 /* ETHEREUM */:
      return VerificationRemoveBody.create({
        address: EthAddressFactory.build(),
        protocol: 0 /* ETHEREUM */
      });
    case 1 /* SOLANA */:
      return VerificationRemoveBody.create({
        address: SolAddressFactory.build(),
        protocol: 1 /* SOLANA */
      });
    default:
      throw new Error(`Unsupported protocol [found: ${params.protocol}]`);
  }
});
var VerificationRemoveDataFactory = MessageDataFactory.params({
  verificationRemoveBody: VerificationRemoveBodyFactory.build({ protocol: 0 /* ETHEREUM */ }),
  type: 8 /* VERIFICATION_REMOVE */
});
var VerificationRemoveMessageFactory = MessageFactory.params({
  data: VerificationRemoveDataFactory.build(),
  signatureScheme: 1 /* ED25519 */
});
var UserDataBodyFactory = Factory.define(() => {
  return UserDataBody.create({
    type: UserDataTypeFactory.build(),
    value: import_faker.faker.random.alphaNumeric(16)
    // 16 chars to stay within range for all UserDataAdd types
  });
});
var UserDataAddDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    userDataBody: UserDataBodyFactory.build(),
    type: 11 /* USER_DATA_ADD */
  });
});
var UserDataAddMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: UserDataAddDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var UsernameProofDataFactory = Factory.define(() => {
  const proofBody = UserNameProofFactory.build({
    type: 2 /* USERNAME_TYPE_ENS_L1 */,
    name: EnsNameFactory.build()
  });
  return MessageDataFactory.build({
    usernameProofBody: proofBody,
    type: 12 /* USERNAME_PROOF */,
    // Proof timestamp is in Unix seconds
    timestamp: toFarcasterTime(proofBody.timestamp * 1e3)._unsafeUnwrap(),
    fid: proofBody.fid
  });
});
var UsernameProofMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: UsernameProofDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var FrameActionBodyFactory = Factory.define(() => {
  return FrameActionBody.create({
    url: Buffer.from(import_faker.faker.internet.url()),
    buttonIndex: import_faker.faker.datatype.number({ min: 1, max: 4 }),
    castId: CastIdFactory.build()
  });
});
var FrameActionDataFactory = Factory.define(() => {
  return MessageDataFactory.build({
    frameActionBody: FrameActionBodyFactory.build(),
    type: 13 /* FRAME_ACTION */
  });
});
var FrameActionMessageFactory = Factory.define(
  ({ onCreate, transientParams }) => {
    onCreate((message) => {
      return MessageFactory.create(message, { transient: transientParams });
    });
    return MessageFactory.build(
      { data: FrameActionDataFactory.build(), signatureScheme: 1 /* ED25519 */ },
      { transient: transientParams }
    );
  }
);
var OnChainEventFactory = Factory.define(() => {
  return OnChainEvent.create({
    type: 1 /* EVENT_TYPE_SIGNER */,
    chainId: 1,
    fid: FidFactory.build(),
    blockNumber: import_faker.faker.datatype.number({ min: 1, max: 1e5 }),
    blockHash: BlockHashFactory.build(),
    blockTimestamp: Math.floor(import_faker.faker.datatype.datetime({ min: FARCASTER_EPOCH, max: Date.now() }).getTime() / 1e3),
    transactionHash: TransactionHashFactory.build(),
    logIndex: import_faker.faker.datatype.number({ min: 0, max: 1e3 })
  });
});
var UserNameProofFactory = Factory.define(() => {
  return UserNameProof.create({
    timestamp: Math.floor(Date.now() / 1e3),
    signature: Eip712SignatureFactory.build(),
    owner: EthAddressFactory.build(),
    name: FnameFactory.build(),
    fid: FidFactory.build(),
    type: 1 /* USERNAME_TYPE_FNAME */
  });
});
var SignerEventBodyFactory = Factory.define(() => {
  return SignerEventBody.create({
    key: Ed25519PublicKeyFactory.build(),
    eventType: 1 /* ADD */,
    keyType: 1,
    metadataType: 1
  });
});
var SignerOnChainEventFactory = Factory.define(({ transientParams }) => {
  return OnChainEventFactory.build({
    type: 1 /* EVENT_TYPE_SIGNER */,
    signerEventBody: transientParams.signer ? SignerEventBodyFactory.build({ key: transientParams.signer }) : SignerEventBodyFactory.build()
  });
});
var IdRegisterEventBodyFactory = Factory.define(() => {
  return IdRegisterEventBody.create({
    eventType: 1 /* REGISTER */,
    from: EthAddressFactory.build()
  });
});
var IdRegisterOnChainEventFactory = Factory.define(
  ({ transientParams }) => {
    return OnChainEventFactory.build({
      type: 3 /* EVENT_TYPE_ID_REGISTER */,
      idRegisterEventBody: transientParams.to ? IdRegisterEventBodyFactory.build({ to: transientParams.to }) : IdRegisterEventBodyFactory.build()
    });
  }
);
var SignerMigratedOnChainEventFactory = Factory.define(() => {
  return OnChainEventFactory.build({
    type: 2 /* EVENT_TYPE_SIGNER_MIGRATED */,
    fid: 0,
    signerMigratedEventBody: SignerMigratedEventBody.create({
      migratedAt: Math.floor(Date.now() / 1e3) + 48 * 60 * 60
      // Default to 48 hours in the future so pruning is not enabled
    })
  });
});
var StorageRentEventBodyFactory = Factory.define(() => {
  return StorageRentEventBody.create({
    payer: EthAddressFactory.build(),
    units: import_faker.faker.datatype.number({ min: 1, max: 10 }),
    expiry: getFarcasterTime()._unsafeUnwrap() + 60 * 60 * 24 * 365
    // a year
  });
});
var StorageRentOnChainEventFactory = Factory.define(
  ({ transientParams }) => {
    const oneYearAgo = /* @__PURE__ */ new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const yesterday = /* @__PURE__ */ new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const randomDate = import_faker.faker.date.between(oneYearAgo, yesterday);
    const randomDateInSeconds = Math.floor(randomDate.getTime() / 1e3);
    return OnChainEventFactory.build({
      type: 4 /* EVENT_TYPE_STORAGE_RENT */,
      blockTimestamp: randomDateInSeconds,
      storageRentEventBody: transientParams.units ? StorageRentEventBodyFactory.build({ units: transientParams.units }) : StorageRentEventBodyFactory.build()
    });
  }
);
var Factories = {
  Fid: FidFactory,
  Fname: FnameFactory,
  Bytes: BytesFactory,
  MessageHash: MessageHashFactory,
  BlockHash: BlockHashFactory,
  EthAddress: EthAddressFactory,
  SolAddress: SolAddressFactory,
  EnsName: EnsNameFactory,
  TransactionHash: TransactionHashFactory,
  Ed25519PrivateKey: Ed25519PrivateKeyFactory,
  Ed25519PublicKey: Ed25519PublicKeyFactory,
  Ed25519Signer: Ed25519SignerFactory,
  Ed25519Signature: Ed25519SignatureFactory,
  Eip712Signer: Eip712SignerFactory,
  Eip712Signature: Eip712SignatureFactory,
  CastId: CastIdFactory,
  FarcasterNetwork: FarcasterNetworkFactory,
  ReactionType: ReactionTypeFactory,
  MessageType: MessageTypeFactory,
  MessageData: MessageDataFactory,
  Message: MessageFactory,
  CastIdEmbed: CastIdEmbedFactory,
  UrlEmbed: UrlEmbedFactory,
  Embed: EmbedFactory,
  CastAddBody: CastAddBodyFactory,
  CastAddData: CastAddDataFactory,
  CastAddMessage: CastAddMessageFactory,
  CastRemoveBody: CastRemoveBodyFactory,
  CastRemoveData: CastRemoveDataFactory,
  CastRemoveMessage: CastRemoveMessageFactory,
  FrameActionBody: FrameActionBodyFactory,
  FrameActionData: FrameActionDataFactory,
  FrameActionMessage: FrameActionMessageFactory,
  LinkBody: LinkBodyFactory,
  LinkAddData: LinkAddDataFactory,
  LinkAddMessage: LinkAddMessageFactory,
  LinkRemoveData: LinkRemoveDataFactory,
  LinkRemoveMessage: LinkRemoveMessageFactory,
  LinkCompactStateMessage: LinkCompactStateMessageFactory,
  ReactionBody: ReactionBodyFactory,
  ReactionAddData: ReactionAddDataFactory,
  ReactionAddMessage: ReactionAddMessageFactory,
  ReactionRemoveData: ReactionRemoveDataFactory,
  ReactionRemoveMessage: ReactionRemoveMessageFactory,
  VerificationEthAddressClaim: VerificationEthAddressClaimFactory,
  VerificationAddAddressBody: VerificationAddAddressBodyFactory,
  VerificationAddEthAddressData: VerificationAddEthAddressDataFactory,
  VerificationAddEthAddressMessage: VerificationAddEthAddressMessageFactory,
  VerificationSolAddressClaim: VerificationSolAddressClaimFactory,
  VerificationAddSolAddressData: VerificationAddSolAddressDataFactory,
  VerificationAddSolAddressMessage: VerificationAddSolAddressMessageFactory,
  VerificationRemoveBody: VerificationRemoveBodyFactory,
  VerificationRemoveData: VerificationRemoveDataFactory,
  VerificationRemoveMessage: VerificationRemoveMessageFactory,
  UserDataBody: UserDataBodyFactory,
  UserDataAddData: UserDataAddDataFactory,
  UserDataAddMessage: UserDataAddMessageFactory,
  UserNameProof: UserNameProofFactory,
  UsernameProofData: UsernameProofDataFactory,
  UsernameProofMessage: UsernameProofMessageFactory,
  OnChainEvent: OnChainEventFactory,
  SignerEventBody: SignerEventBodyFactory,
  SignerOnChainEvent: SignerOnChainEventFactory,
  IdRegistryOnChainEvent: IdRegisterOnChainEventFactory,
  IdRegistryEventBody: IdRegisterEventBodyFactory,
  SignerMigratedOnChainEvent: SignerMigratedOnChainEventFactory,
  StorageRentEventBody: StorageRentEventBodyFactory,
  StorageRentOnChainEvent: StorageRentOnChainEventFactory
};

// src/userNameProof.ts
init_cjs_shims();
var makeUserNameProofClaim = ({
  name,
  owner,
  timestamp
}) => {
  return {
    name,
    owner,
    timestamp: BigInt(timestamp)
  };
};

// src/limits.ts
init_cjs_shims();
var LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP = 1724889600;
var UNIT_TYPE_2024__CUTOFF_TIMESTAMP = 1752685200;
var ONE_YEAR_IN_SECONDS = 365 * 24 * 60 * 60;
var STORAGE_UNIT_DEFAULTS = {
  [1 /* CASTS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 5e3,
    [1 /* UNIT_TYPE_2024 */]: 2e3,
    [2 /* UNIT_TYPE_2025 */]: 100
  },
  [2 /* LINKS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 2500,
    [1 /* UNIT_TYPE_2024 */]: 1e3,
    [2 /* UNIT_TYPE_2025 */]: 200
  },
  [3 /* REACTIONS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 2500,
    [1 /* UNIT_TYPE_2024 */]: 1e3,
    [2 /* UNIT_TYPE_2025 */]: 200
  },
  [4 /* USER_DATA */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 50,
    [1 /* UNIT_TYPE_2024 */]: 50,
    [2 /* UNIT_TYPE_2025 */]: 25
  },
  [6 /* USERNAME_PROOFS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 5,
    [1 /* UNIT_TYPE_2024 */]: 5,
    [2 /* UNIT_TYPE_2025 */]: 2
  },
  [5 /* VERIFICATIONS */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 25,
    [1 /* UNIT_TYPE_2024 */]: 25,
    [2 /* UNIT_TYPE_2025 */]: 5
  },
  [0 /* NONE */]: {
    [0 /* UNIT_TYPE_LEGACY */]: 0,
    [1 /* UNIT_TYPE_2024 */]: 0,
    [2 /* UNIT_TYPE_2025 */]: 0
  }
};
var getStoreLimits = (unit_details) => [
  {
    storeType: 1 /* CASTS */,
    limit: getStoreLimit(1 /* CASTS */, unit_details)
  },
  {
    storeType: 2 /* LINKS */,
    limit: getStoreLimit(2 /* LINKS */, unit_details)
  },
  {
    storeType: 3 /* REACTIONS */,
    limit: getStoreLimit(3 /* REACTIONS */, unit_details)
  },
  {
    storeType: 4 /* USER_DATA */,
    limit: getStoreLimit(4 /* USER_DATA */, unit_details)
  },
  {
    storeType: 6 /* USERNAME_PROOFS */,
    limit: getStoreLimit(6 /* USERNAME_PROOFS */, unit_details)
  },
  {
    storeType: 5 /* VERIFICATIONS */,
    limit: getStoreLimit(5 /* VERIFICATIONS */, unit_details)
  }
];
var getStoreLimit = (storeType, unit_details) => {
  let limit = 0;
  for (const unit of unit_details) {
    limit += getDefaultStoreLimit(storeType, unit.unitType) * unit.unitSize;
  }
  return limit;
};
var getDefaultStoreLimit = (storeType, unit_type) => {
  return STORAGE_UNIT_DEFAULTS[storeType][unit_type];
};
var getStorageUnitType = (event) => {
  if (event.blockTimestamp < LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP) {
    return 0 /* UNIT_TYPE_LEGACY */;
  } else if (event.blockTimestamp < UNIT_TYPE_2024__CUTOFF_TIMESTAMP) {
    return 1 /* UNIT_TYPE_2024 */;
  } else {
    return 2 /* UNIT_TYPE_2025 */;
  }
};
var getStorageUnitExpiry = (event) => {
  return getStorageExpiryTimestampFromBlockTimestamp(event.blockTimestamp);
};
var getStorageExpiryTimestampFromBlockTimestamp = (blockTimestamp) => {
  if (blockTimestamp < LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP) {
    return blockTimestamp + ONE_YEAR_IN_SECONDS * 3;
  } else if (blockTimestamp < UNIT_TYPE_2024__CUTOFF_TIMESTAMP) {
    return blockTimestamp + ONE_YEAR_IN_SECONDS * 2;
  } else {
    return blockTimestamp + ONE_YEAR_IN_SECONDS;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BUNDLER_ADDRESS,
  BlockConfirmedBody,
  BlockConfirmedBody_EventCountsByTypeEntry,
  BlocksRequest,
  BulkMessageResponse,
  CastAddBody,
  CastId,
  CastRemoveBody,
  CastType,
  CastsByParentRequest,
  ContactInfo,
  ContactInfoBody,
  DbStats,
  DbTrieNode,
  DbTrieNode_ChildHashesEntry,
  Ed25519Signer,
  Eip712Signer,
  Embed,
  EthersEip712Signer,
  EthersV5Eip712Signer,
  EventRequest,
  EventsRequest,
  EventsResponse,
  FARCASTER_EPOCH,
  Factories,
  FarcasterNetwork,
  FidAddressTypeRequest,
  FidAddressTypeResponse,
  FidRequest,
  FidTimestampRequest,
  FidsRequest,
  FidsResponse,
  FrameActionBody,
  GetConnectedPeersRequest,
  GetConnectedPeersResponse,
  GetInfoRequest,
  GetInfoResponse,
  GossipMessage,
  HashScheme,
  HubError,
  HubEvent,
  HubEventType,
  HubState,
  ID_GATEWAY_ADDRESS,
  ID_GATEWAY_EIP_712_DOMAIN,
  ID_GATEWAY_EIP_712_TYPES,
  ID_GATEWAY_REGISTER_TYPE,
  ID_REGISTRY_ADDRESS,
  ID_REGISTRY_CHANGE_RECOVERY_ADDRESS_TYPE,
  ID_REGISTRY_EIP_712_DOMAIN,
  ID_REGISTRY_EIP_712_TYPES,
  ID_REGISTRY_TRANSFER_AND_CHANGE_RECOVERY_TYPE,
  ID_REGISTRY_TRANSFER_TYPE,
  IdRegisterEventBody,
  IdRegisterEventType,
  IdRegistryEventByAddressRequest,
  KEY_GATEWAY_ADDRESS,
  KEY_GATEWAY_ADD_TYPE,
  KEY_GATEWAY_EIP_712_DOMAIN,
  KEY_GATEWAY_EIP_712_TYPES,
  KEY_REGISTRY_ADDRESS,
  KEY_REGISTRY_EIP_712_DOMAIN,
  KEY_REGISTRY_EIP_712_TYPES,
  KEY_REGISTRY_REMOVE_TYPE,
  LEGACY_STORAGE_UNIT_CUTOFF_TIMESTAMP,
  LinkBody,
  LinkCompactStateBody,
  LinkRequest,
  LinksByFidRequest,
  LinksByTargetRequest,
  MergeFailureBody,
  MergeMessageBody,
  MergeOnChainEventBody,
  MergeUserNameProofBody,
  Message,
  MessageData,
  MessageError,
  MessageType,
  MessagesResponse,
  NobleEd25519Signer,
  OnChainEvent,
  OnChainEventRequest,
  OnChainEventResponse,
  OnChainEventType,
  Protocol,
  PruneMessageBody,
  ReactionBody,
  ReactionRequest,
  ReactionType,
  ReactionsByFidRequest,
  ReactionsByTargetRequest,
  RevokeMessageBody,
  RevokeMessagesBySignerJobPayload,
  SIGNED_KEY_REQUEST_TYPE,
  SIGNED_KEY_REQUEST_VALIDATOR_ADDRESS,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,
  SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_TYPES,
  STORAGE_REGISTRY_ADDRESS,
  ShardChunksRequest,
  ShardChunksResponse,
  ShardInfo,
  SignatureScheme,
  SignerEventBody,
  SignerEventType,
  SignerMigratedEventBody,
  SignerRequest,
  StorageLimit,
  StorageLimitsResponse,
  StorageRentEventBody,
  StorageUnitDetails,
  StorageUnitType,
  StoreType,
  SubmitBulkMessagesRequest,
  SubmitBulkMessagesResponse,
  SubscribeRequest,
  TierDetails,
  TierPurchaseBody,
  TierType,
  TrieNodeMetadataRequest,
  TrieNodeMetadataResponse,
  UNIT_TYPE_2024__CUTOFF_TIMESTAMP,
  UpdateNameRegistryEventExpiryJobPayload,
  UserDataBody,
  UserDataRequest,
  UserDataType,
  UserNameProof,
  UserNameType,
  UsernameProofRequest,
  UsernameProofsResponse,
  ValidateOrRevokeJobState,
  ValidationResponse,
  VerificationAddAddressBody,
  VerificationRemoveBody,
  VerificationRequest,
  ViemLocalEip712Signer,
  ViemWalletEip712Signer,
  base58ToBytes,
  bigIntToBytes,
  bundlerABI,
  bytesCompare,
  bytesDecrement,
  bytesIncrement,
  bytesStartsWith,
  bytesToBase58,
  bytesToBigInt,
  bytesToHexString,
  bytesToUtf8String,
  castTypeFromJSON,
  castTypeToJSON,
  chains,
  clients,
  ed25519,
  eip712,
  extractEventTimestamp,
  extractTimestampFromEvent,
  farcasterNetworkFromJSON,
  farcasterNetworkToJSON,
  fromFarcasterTime,
  getDefaultStoreLimit,
  getFarcasterTime,
  getStorageExpiryTimestampFromBlockTimestamp,
  getStorageUnitExpiry,
  getStorageUnitType,
  getStoreLimit,
  getStoreLimits,
  hashSchemeFromJSON,
  hashSchemeToJSON,
  hexStringToBytes,
  hubEventTypeFromJSON,
  hubEventTypeToJSON,
  idGatewayABI,
  idRegisterEventTypeFromJSON,
  idRegisterEventTypeToJSON,
  idRegistryABI,
  isBlockConfirmedHubEvent,
  isCastAddData,
  isCastAddMessage,
  isCastRemoveData,
  isCastRemoveMessage,
  isFrameActionData,
  isFrameActionMessage,
  isHubError,
  isIdRegisterOnChainEvent,
  isLinkAddData,
  isLinkAddMessage,
  isLinkCompactStateMessage,
  isLinkRemoveData,
  isLinkRemoveMessage,
  isMergeFailureHubEvent,
  isMergeMessageHubEvent,
  isMergeOnChainHubEvent,
  isMergeUsernameProofHubEvent,
  isPruneMessageHubEvent,
  isReactionAddData,
  isReactionAddMessage,
  isReactionRemoveData,
  isReactionRemoveMessage,
  isRevokeMessageHubEvent,
  isSignerMigratedOnChainEvent,
  isSignerOnChainEvent,
  isStorageRentOnChainEvent,
  isTierPurchaseOnChainEvent,
  isUserDataAddData,
  isUserDataAddMessage,
  isUsernameProofData,
  isUsernameProofMessage,
  isVerificationAddAddressData,
  isVerificationAddAddressMessage,
  isVerificationRemoveData,
  isVerificationRemoveMessage,
  keyGatewayABI,
  keyRegistryABI,
  makeCastAdd,
  makeCastAddData,
  makeCastRemove,
  makeCastRemoveData,
  makeEventId,
  makeFrameAction,
  makeFrameActionData,
  makeLinkAdd,
  makeLinkAddData,
  makeLinkCompactState,
  makeLinkCompactStateData,
  makeLinkRemove,
  makeLinkRemoveData,
  makeMessage,
  makeMessageHash,
  makeMessageWithSignature,
  makeReactionAdd,
  makeReactionAddData,
  makeReactionRemove,
  makeReactionRemoveData,
  makeUserDataAdd,
  makeUserDataAddData,
  makeUserNameProofClaim,
  makeUsernameProof,
  makeUsernameProofData,
  makeVerificationAddEthAddress,
  makeVerificationAddEthAddressData,
  makeVerificationAddressClaim,
  makeVerificationRemove,
  makeVerificationRemoveData,
  messageTypeFromJSON,
  messageTypeToJSON,
  onChainEventTypeFromJSON,
  onChainEventTypeToJSON,
  protocolFromJSON,
  protocolToJSON,
  reactionTypeFromJSON,
  reactionTypeToJSON,
  recreateSolanaClaimMessage,
  signatureSchemeFromJSON,
  signatureSchemeToJSON,
  signedKeyRequestValidatorABI,
  signerEventTypeFromJSON,
  signerEventTypeToJSON,
  storageRegistryABI,
  storageUnitTypeFromJSON,
  storageUnitTypeToJSON,
  storeTypeFromJSON,
  storeTypeToJSON,
  tierTypeFromJSON,
  tierTypeToJSON,
  toFarcasterTime,
  userDataTypeFromJSON,
  userDataTypeToJSON,
  userNameTypeFromJSON,
  userNameTypeToJSON,
  utf8StringToBytes,
  validations,
  verifyAdd,
  verifyChangeRecoveryAddress,
  verifyKeyRequest,
  verifyRegister,
  verifyRemove,
  verifyTransfer,
  verifyTransferAndChangeRecovery
});
/*! Bundled license information:

@farcaster/fishery/dist/fishery.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
