import { getTypesForEIP712Domain, SwitchChainError, serializeTypedData, UserRejectedRequestError, validateTypedData, } from "viem";
import { trackTransaction } from "../../analytics/track/transaction.js";
import { getCachedChain, getRpcUrlForChain } from "../../chains/utils.js";
import { getAddress } from "../../utils/address.js";
import { numberToHex, stringToHex, uint8ArrayToHex, } from "../../utils/encoding/hex.js";
import { stringify } from "../../utils/json.js";
import { parseTypedData } from "../../utils/signatures/helpers/parse-typed-data.js";
import { getSavedConnectParamsFromStorage, saveConnectParamsToStorage, } from "../../utils/storage/walletStorage.js";
import { formatWalletConnectUrl } from "../../utils/url.js";
import { getWalletInfo } from "../__generated__/getWalletInfo.js";
import { getDefaultAppMetadata } from "../utils/defaultDappMetadata.js";
import { normalizeChainId } from "../utils/normalizeChainId.js";
import { DEFAULT_PROJECT_ID, NAMESPACE } from "./constants.js";
let cachedProvider = null;
const storageKeys = {
    lastUsedChainId: "tw.wc.lastUsedChainId",
    requestedChains: "tw.wc.requestedChains",
};
/**
 * Checks if the provided wallet is a Wallet Connect wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a Wallet Connect wallet, false otherwise.
 */
export function isWalletConnect(wallet) {
    return wallet.id === "walletConnect";
}
/**
 * @internal
 */
export async function connectWC(options, emitter, walletId, storage, sessionHandler) {
    const provider = await initProvider(options, walletId, sessionHandler);
    const wcOptions = options.walletConnect;
    let { onDisplayUri } = wcOptions || {};
    const walletInfo = await getWalletInfo(walletId);
    // use default sessionHandler unless onDisplayUri is explicitly provided
    if (!onDisplayUri && sessionHandler) {
        const deeplinkHandler = (uri) => {
            const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;
            if (!appUrl) {
                // generic wc uri
                sessionHandler(uri);
                return;
            }
            const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;
            sessionHandler(fullUrl);
        };
        onDisplayUri = deeplinkHandler;
    }
    if (onDisplayUri) {
        provider.events.addListener("display_uri", onDisplayUri);
    }
    let optionalChains = wcOptions?.optionalChains;
    let chainToRequest = options.chain;
    // ignore the given options chains - and set the safe supported chains
    if (walletId === "global.safe") {
        optionalChains = chainsToRequestForSafe.map(getCachedChain);
        if (chainToRequest && !optionalChains.includes(chainToRequest)) {
            chainToRequest = undefined;
        }
    }
    // For UniversalProvider, we still need chain configuration for session management
    const { chains: chainsToRequest, rpcMap } = getChainsToRequest({
        chain: chainToRequest,
        client: options.client,
        optionalChains: optionalChains,
    });
    // For UniversalProvider, we need to connect with namespaces
    await provider.connect({
        ...(wcOptions?.pairingTopic
            ? { pairingTopic: wcOptions?.pairingTopic }
            : {}),
        namespaces: {
            [NAMESPACE]: {
                chains: chainsToRequest,
                events: ["chainChanged", "accountsChanged"],
                methods: [
                    "eth_sendTransaction",
                    "eth_signTransaction",
                    "eth_sign",
                    "personal_sign",
                    "eth_signTypedData",
                    "eth_signTypedData_v4",
                    "wallet_switchEthereumChain",
                    "wallet_addEthereumChain",
                ],
                rpcMap,
            },
        },
    });
    setRequestedChainsIds(chainsToRequest.map((x) => Number(x.split(":")[1])), storage);
    const currentChainId = chainsToRequest[0]?.split(":")[1] || 1;
    const providerChainId = normalizeChainId(currentChainId);
    const accounts = await provider.request({
        method: "eth_requestAccounts",
        params: [],
    }, `eip155:${providerChainId}`);
    const address = accounts[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : getCachedChain(providerChainId);
    if (options) {
        const savedParams = {
            chain: options.chain,
            optionalChains: options.walletConnect?.optionalChains,
            pairingTopic: options.walletConnect?.pairingTopic,
        };
        if (storage) {
            saveConnectParamsToStorage(storage, walletId, savedParams);
        }
    }
    if (onDisplayUri) {
        provider.events.removeListener("display_uri", onDisplayUri);
    }
    return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);
}
/**
 * Auto connect to already connected wallet connect session.
 * @internal
 */
export async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {
    const savedConnectParams = storage
        ? await getSavedConnectParamsFromStorage(storage, walletId)
        : null;
    const walletInfo = await getWalletInfo(walletId);
    const provider = await initProvider(savedConnectParams
        ? {
            chain: savedConnectParams.chain,
            client: options.client,
            walletConnect: {
                optionalChains: savedConnectParams.optionalChains,
                pairingTopic: savedConnectParams.pairingTopic,
            },
        }
        : {
            client: options.client,
            walletConnect: {},
        }, walletId, sessionHandler);
    if (!provider.session) {
        await provider.disconnect();
        throw new Error("No wallet connect session found on provider.");
    }
    // For UniversalProvider, get accounts from enable() method
    const namespaceAccounts = provider.session?.namespaces?.[NAMESPACE]?.accounts;
    const address = namespaceAccounts?.[0]?.split(":")[2];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    // For UniversalProvider, get chainId from the session namespaces or use default
    const currentChainId = options.chain?.id || 1;
    const providerChainId = normalizeChainId(currentChainId);
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : getCachedChain(providerChainId);
    return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);
}
// Connection utils -----------------------------------------------------------------------------------------------
async function initProvider(options, walletId, sessionRequestHandler) {
    if (cachedProvider) {
        return cachedProvider;
    }
    const walletInfo = await getWalletInfo(walletId);
    const wcOptions = options.walletConnect;
    const { UniversalProvider } = await import("@walletconnect/universal-provider");
    let optionalChains = wcOptions?.optionalChains;
    let chainToRequest = options.chain;
    // ignore the given options chains - and set the safe supported chains
    if (walletId === "global.safe") {
        optionalChains = chainsToRequestForSafe.map(getCachedChain);
        if (chainToRequest && !optionalChains.includes(chainToRequest)) {
            chainToRequest = undefined;
        }
    }
    const provider = await UniversalProvider.init({
        metadata: {
            description: wcOptions?.appMetadata?.description ||
                getDefaultAppMetadata().description,
            icons: [
                wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,
            ],
            name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,
            url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,
            redirect: {
                native: walletInfo.mobile.native || undefined,
                universal: walletInfo.mobile.universal || undefined,
            },
        },
        projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,
    });
    provider.events.setMaxListeners(Number.POSITIVE_INFINITY);
    if (walletId !== "walletConnect") {
        async function handleSessionRequest() {
            const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||
                walletInfo.mobile.native ||
                walletInfo.mobile.universal;
            if (sessionRequestHandler && walletLinkToOpen) {
                // TODO: propagate error when this fails
                await sessionRequestHandler(walletLinkToOpen);
            }
        }
        // For UniversalProvider, use different event handling
        provider.on("session_request_sent", handleSessionRequest);
        provider.events.addListener("disconnect", () => {
            provider.off("session_request_sent", handleSessionRequest);
            cachedProvider = null;
        });
    }
    cachedProvider = provider;
    return provider;
}
function createAccount({ provider, address, client, chain, sessionRequestHandler, walletInfo, }) {
    const account = {
        address: getAddress(address),
        async sendTransaction(tx) {
            const transactionHash = (await requestAndOpenWallet({
                provider,
                payload: {
                    method: "eth_sendTransaction",
                    params: [
                        {
                            data: tx.data,
                            from: getAddress(address),
                            gas: tx.gas ? numberToHex(tx.gas) : undefined,
                            to: tx.to,
                            value: tx.value ? numberToHex(tx.value) : undefined,
                        },
                    ],
                },
                chain: `eip155:${tx.chainId}`,
                walletInfo,
                sessionRequestHandler,
            }));
            trackTransaction({
                chainId: tx.chainId,
                client: client,
                contractAddress: tx.to ?? undefined,
                gasPrice: tx.gasPrice,
                transactionHash,
                walletAddress: getAddress(address),
                walletType: "walletConnect",
            });
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return stringToHex(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return uint8ArrayToHex(message.raw);
                }
                return message.raw;
            })();
            return requestAndOpenWallet({
                provider,
                payload: {
                    method: "personal_sign",
                    params: [messageToSign, this.address],
                },
                chain: `eip155:${chain.id}`,
                walletInfo,
                sessionRequestHandler,
            });
        },
        async signTypedData(_data) {
            const data = parseTypedData(_data);
            const { domain, message, primaryType } = data;
            const types = {
                EIP712Domain: getTypesForEIP712Domain({ domain }),
                ...data.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            validateTypedData({ domain, message, primaryType, types });
            const typedData = serializeTypedData({
                domain: domain ?? {},
                message,
                primaryType,
                types,
            });
            return await requestAndOpenWallet({
                provider,
                payload: {
                    method: "eth_signTypedData_v4",
                    params: [this.address, typedData],
                },
                chain: `eip155:${chain.id}`,
                walletInfo,
                sessionRequestHandler,
            });
        },
    };
    return account;
}
async function requestAndOpenWallet(args) {
    const { provider, payload, chain, walletInfo, sessionRequestHandler } = args;
    const resultPromise = provider.request(payload, chain);
    const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||
        walletInfo.mobile.native ||
        walletInfo.mobile.universal;
    if (sessionRequestHandler && walletLinkToOpen) {
        await sessionRequestHandler(walletLinkToOpen);
    }
    return resultPromise;
}
function onConnect(address, chain, provider, emitter, storage, client, walletInfo, sessionRequestHandler) {
    const account = createAccount({
        address,
        chain,
        client,
        provider,
        sessionRequestHandler,
        walletInfo,
    });
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
        await provider.disconnect();
        cachedProvider = null;
    }
    function onDisconnect() {
        setRequestedChainsIds([], storage);
        storage?.removeItem(storageKeys.lastUsedChainId);
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = createAccount({
                address: getAddress(accounts[0]),
                chain,
                client,
                provider,
                sessionRequestHandler,
                walletInfo,
            });
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = getCachedChain(normalizeChainId(newChainId));
        emitter.emit("chainChanged", newChain);
        storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));
    }
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    provider.on("session_delete", onDisconnect);
    return [
        account,
        chain,
        disconnect,
        (newChain) => switchChainWC(provider, newChain),
    ];
}
async function switchChainWC(provider, chain) {
    const chainId = chain.id;
    try {
        provider.setDefaultChain(`eip155:${chainId}`);
    }
    catch (error) {
        const message = typeof error === "string" ? error : error?.message;
        if (/user rejected request/i.test(message)) {
            throw new UserRejectedRequestError(error);
        }
        throw new SwitchChainError(error);
    }
}
/**
 * Set the requested chains to the storage.
 * @internal
 */
function setRequestedChainsIds(chains, storage) {
    storage?.setItem(storageKeys.requestedChains, stringify(chains));
}
function getChainsToRequest(options) {
    const rpcMap = {};
    const chainIds = [];
    if (options.chain) {
        rpcMap[options.chain.id] = getRpcUrlForChain({
            chain: options.chain,
            client: options.client,
        });
        chainIds.push(options.chain.id);
    }
    // limit optional chains to 10
    const optionalChains = (options?.optionalChains || []).slice(0, 10);
    for (const chain of optionalChains) {
        rpcMap[chain.id] = getRpcUrlForChain({
            chain: chain,
            client: options.client,
        });
        chainIds.push(chain.id);
    }
    if (!options.chain && optionalChains.length === 0) {
        rpcMap[1] = getCachedChain(1).rpc;
        chainIds.push(1);
    }
    return {
        chains: chainIds.map((x) => `eip155:${x}`),
        rpcMap,
    };
}
const chainsToRequestForSafe = [
    1, // Ethereum Mainnet
    11155111, // Sepolia Testnet
    42161, // Arbitrum One Mainnet
    43114, // Avalanche Mainnet
    8453, // Base Mainnet
    1313161554, // Aurora Mainnet
    84532, // Base Sepolia Testnet
    56, // Binance Smart Chain Mainnet
    42220, // Celo Mainnet
    100, // Gnosis Mainnet
    10, // Optimism Mainnet
    137, // Polygon Mainnet
    1101, // Polygon zkEVM Mainnet
    324, // zkSync Era mainnet
    534352, // Scroll mainnet
];
//# sourceMappingURL=controller.js.map