"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { trackPayEvent } from "../../../../analytics/track/pay.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../constants/addresses.js";
import { getToken } from "../../../../pay/convert/get-token.js";
import { checksumAddress, isAddress, } from "../../../../utils/address.js";
import { stringify } from "../../../../utils/json.js";
import { CustomThemeProvider } from "../../../core/design-system/CustomThemeProvider.js";
import { useConnectLocale } from "../ConnectWallet/locale/getConnectLocale.js";
import { EmbedContainer } from "../ConnectWallet/Modal/ConnectEmbed.js";
import { DynamicHeight } from "../components/DynamicHeight.js";
import { Spinner } from "../components/Spinner.js";
import { BridgeOrchestrator } from "./BridgeOrchestrator.js";
import { UnsupportedTokenScreen } from "./UnsupportedTokenScreen.js";
/**
 * Widget is a prebuilt UI for purchasing a specific token.
 *
 * @param props - Props of type [`BuyWidgetProps`](https://portal.thirdweb.com/references/typescript/v5/BuyWidgetProps) to configure the BuyWidget component.
 *
 * @example
 * ### Basic usage
 *
 * The `BuyWidget` component requires `client`, `chain`, and `amount` props to function.
 *
 * ```tsx
 * import { ethereum } from "thirdweb/chains";
 *
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="0.1" // in native tokens (ie. ETH)
 * />
 * ```
 *
 * ### Buy a specific token
 *
 * You can specify a token to purchase by passing the `tokenAddress` prop.
 *
 * ```tsx
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="100" // 100 USDC on mainnet
 *   tokenAddress="0xA0b86a33E6417E4df2057B2d3C6d9F7cc11b0a70"
 * />
 * ```
 *
 * ### Customize the supported tokens
 *
 * You can customize the supported tokens that users can pay with by passing a `supportedTokens` object to the `BuyWidget` component.
 *
 * ```tsx
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="0.1"
 *   // user will only be able to pay with these tokens
 *   supportedTokens={{
 *     [8453]: [
 *       {
 *         address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
 *         name: "USDC",
 *         symbol: "USDC",
 *       },
 *     ],
 *   }}
 * />
 * ```
 *
 *
 * ### Customize the UI
 *
 * You can customize the UI of the `BuyWidget` component by passing a custom theme object to the `theme` prop.
 *
 * ```tsx
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="0.1"
 *   theme={darkTheme({
 *     colors: {
 *       modalBg: "red",
 *     },
 *   })}
 * />
 * ```
 *
 * Refer to the [`Theme`](https://portal.thirdweb.com/references/typescript/v5/Theme) type for more details.
 *
 * ### Update the Title
 *
 * You can update the title of the widget by passing a `title` prop to the `BuyWidget` component.
 *
 * ```tsx
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="0.1"
 *   title="Buy ETH"
 * />
 * ```
 *
 * ### Configure the wallet connection
 *
 * You can customize the wallet connection flow by passing a `connectOptions` object to the `BuyWidget` component.
 *
 * ```tsx
 * <BuyWidget
 *   client={client}
 *   chain={ethereum}
 *   amount="0.1"
 *   connectOptions={{
 *     connectModal: {
 *       size: 'compact',
 *       title: "Sign in",
 *     }
 *   }}
 * />
 * ```
 *
 * Refer to the [`BuyWidgetConnectOptions`](https://portal.thirdweb.com/references/typescript/v5/BuyWidgetConnectOptions) type for more details.
 *
 * @bridge Widgets
 */
export function BuyWidget(props) {
    const localeQuery = useConnectLocale(props.locale || "en_US");
    const theme = props.theme || "dark";
    useQuery({
        queryFn: () => {
            trackPayEvent({
                client: props.client,
                event: "ub:ui:buy_widget:render",
                toChainId: props.chain.id,
                toToken: props.tokenAddress,
            });
            return true;
        },
        queryKey: ["buy_widget:render"],
    });
    const bridgeDataQuery = useQuery({
        queryFn: async () => {
            if (!props.tokenAddress ||
                (isAddress(props.tokenAddress) &&
                    checksumAddress(props.tokenAddress) ===
                        checksumAddress(NATIVE_TOKEN_ADDRESS))) {
                const ETH = await getToken(props.client, NATIVE_TOKEN_ADDRESS, props.chain.id).catch((err) => {
                    err.message.includes("not supported")
                        ? undefined
                        : Promise.reject(err);
                });
                if (!ETH) {
                    return {
                        chain: props.chain,
                        tokenAddress: props.tokenAddress || NATIVE_TOKEN_ADDRESS,
                        type: "unsupported_token",
                    };
                }
                return {
                    data: {
                        destinationToken: ETH,
                        initialAmount: props.amount,
                        metadata: {
                            description: props.description,
                            image: props.image,
                            title: props.title,
                        },
                        mode: "fund_wallet",
                        currency: props.currency || "USD",
                        buttonLabel: props.buttonLabel,
                    },
                    type: "success",
                };
            }
            const token = await getToken(props.client, props.tokenAddress, props.chain.id).catch((err) => {
                err.message.includes("not supported") ? undefined : Promise.reject(err);
            });
            if (!token) {
                return {
                    chain: props.chain,
                    tokenAddress: props.tokenAddress,
                    type: "unsupported_token",
                };
            }
            return {
                data: {
                    destinationToken: token,
                    initialAmount: props.amount,
                    metadata: {
                        description: props.description,
                        image: props.image,
                        title: props.title,
                    },
                    mode: "fund_wallet",
                    currency: props.currency || "USD",
                    buttonLabel: props.buttonLabel,
                },
                type: "success",
            };
        },
        queryKey: ["bridgeData", stringify(props)],
    });
    let content = null;
    if (!localeQuery.data || bridgeDataQuery.isLoading) {
        content = (_jsx("div", { style: {
                alignItems: "center",
                display: "flex",
                justifyContent: "center",
                minHeight: "350px",
            }, children: _jsx(Spinner, { color: "secondaryText", size: "xl" }) }));
    }
    else if (bridgeDataQuery.data?.type === "unsupported_token") {
        // Show unsupported token screen
        content = (_jsx(UnsupportedTokenScreen, { chain: bridgeDataQuery.data.chain, client: props.client, tokenAddress: props.tokenAddress }));
    }
    else if (bridgeDataQuery.data?.type === "success") {
        // Show normal bridge orchestrator
        content = (_jsx(BridgeOrchestrator, { supportedTokens: props.supportedTokens, client: props.client, connectLocale: localeQuery.data, connectOptions: props.connectOptions, onCancel: () => {
                props.onCancel?.();
            }, onComplete: () => {
                props.onSuccess?.();
            }, onError: (err) => {
                props.onError?.(err);
            }, paymentLinkId: props.paymentLinkId, paymentMethods: props.paymentMethods, presetOptions: props.presetOptions, purchaseData: props.purchaseData, receiverAddress: undefined, uiOptions: bridgeDataQuery.data.data, showThirdwebBranding: props.showThirdwebBranding }));
    }
    return (_jsx(CustomThemeProvider, { theme: theme, children: _jsx(EmbedContainer, { className: props.className, modalSize: "compact", style: props.style, children: _jsx(DynamicHeight, { children: content }) }) }));
}
//# sourceMappingURL=BuyWidget.js.map