"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo } from "react";
import { webLocalStorage } from "../../../../utils/storage/webStorage.js";
import { usePaymentMachine, } from "../../../core/machines/paymentMachine.js";
import { webWindowAdapter } from "../../adapters/WindowAdapter.js";
import en from "../ConnectWallet/locale/en.js";
import { Container } from "../components/basic.js";
import { ExecutingTxScreen } from "../TransactionButton/ExecutingScreen.js";
import { DirectPayment } from "./DirectPayment.js";
import { ErrorBanner } from "./ErrorBanner.js";
import { FundWallet } from "./FundWallet.js";
import { PaymentDetails } from "./payment-details/PaymentDetails.js";
import { PaymentSelection } from "./payment-selection/PaymentSelection.js";
import { SuccessScreen } from "./payment-success/SuccessScreen.js";
import { QuoteLoader } from "./QuoteLoader.js";
import { StepRunner } from "./StepRunner.js";
import { TransactionPayment } from "./TransactionPayment.js";
export function BridgeOrchestrator({ client, uiOptions, receiverAddress, onComplete, onError, onCancel, connectOptions, connectLocale, purchaseData, paymentLinkId, presetOptions, paymentMethods = ["crypto", "card"], showThirdwebBranding = true, supportedTokens, }) {
    // Initialize adapters
    const adapters = useMemo(() => ({
        storage: webLocalStorage,
        window: webWindowAdapter,
    }), []);
    // Create modified connect options with branding setting
    const modifiedConnectOptions = useMemo(() => {
        if (!connectOptions)
            return undefined;
        return {
            ...connectOptions,
            connectModal: {
                ...connectOptions.connectModal,
                showThirdwebBranding,
            },
        };
    }, [connectOptions, showThirdwebBranding]);
    // Use the payment machine hook
    const [state, send] = usePaymentMachine(adapters, uiOptions.mode);
    // Handle buy completion
    const handleBuyComplete = useCallback(() => {
        if (uiOptions.mode === "transaction") {
            send({ type: "CONTINUE_TO_TRANSACTION" });
        }
        else {
            onComplete?.();
            send({ type: "RESET" });
        }
    }, [onComplete, send, uiOptions.mode]);
    // Handle post-buy transaction completion
    const handlePostBuyTransactionComplete = useCallback(() => {
        onComplete?.();
        send({ type: "RESET" });
    }, [onComplete, send]);
    // Handle errors
    const handleError = useCallback((error) => {
        console.error(error);
        onError?.(error);
        send({ error, type: "ERROR_OCCURRED" });
    }, [onError, send]);
    // Handle payment method selection
    const handlePaymentMethodSelected = useCallback((paymentMethod) => {
        send({ paymentMethod, type: "PAYMENT_METHOD_SELECTED" });
    }, [send]);
    // Handle quote received
    const handleQuoteReceived = useCallback((quote, request) => {
        send({ quote, request, type: "QUOTE_RECEIVED" });
    }, [send]);
    // Handle route confirmation
    const handleRouteConfirmed = useCallback(() => {
        send({ type: "ROUTE_CONFIRMED" });
    }, [send]);
    // Handle execution complete
    const handleExecutionComplete = useCallback((completedStatuses) => {
        send({ completedStatuses, type: "EXECUTION_COMPLETE" });
    }, [send]);
    // Handle retry
    const handleRetry = useCallback(() => {
        send({ type: "RETRY" });
    }, [send]);
    // Handle requirements resolved from FundWallet and DirectPayment
    const handleRequirementsResolved = useCallback((amount, token, receiverAddress) => {
        send({
            destinationAmount: amount,
            destinationToken: token,
            receiverAddress,
            type: "DESTINATION_CONFIRMED",
        });
    }, [send]);
    return (_jsxs(Container, { flex: "column", fullHeight: true, children: [state.value === "error" && state.context.currentError && (_jsx(ErrorBanner, { client: client, error: state.context.currentError, onCancel: () => {
                    send({ type: "RESET" });
                    onCancel?.();
                }, onRetry: handleRetry })), state.value === "init" && uiOptions.mode === "fund_wallet" && (_jsx(FundWallet, { client: client, connectOptions: modifiedConnectOptions, onContinue: handleRequirementsResolved, presetOptions: presetOptions, receiverAddress: receiverAddress, showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "init" && uiOptions.mode === "direct_payment" && (_jsx(DirectPayment, { client: client, onContinue: handleRequirementsResolved, showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "init" && uiOptions.mode === "transaction" && (_jsx(TransactionPayment, { client: client, connectOptions: modifiedConnectOptions, onContinue: handleRequirementsResolved, onExecuteTransaction: () => send({ type: "CONTINUE_TO_TRANSACTION" }), showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "methodSelection" &&
                state.context.destinationToken &&
                state.context.destinationAmount &&
                state.context.receiverAddress && (_jsx(PaymentSelection, { client: client, connectLocale: connectLocale || en, connectOptions: modifiedConnectOptions, destinationAmount: state.context.destinationAmount, destinationToken: state.context.destinationToken, feePayer: uiOptions.mode === "direct_payment"
                    ? uiOptions.paymentInfo.feePayer
                    : undefined, includeDestinationToken: uiOptions.mode !== "fund_wallet", onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError, onPaymentMethodSelected: handlePaymentMethodSelected, paymentMethods: paymentMethods, receiverAddress: state.context.receiverAddress, currency: uiOptions.currency, supportedTokens: supportedTokens })), state.value === "quote" &&
                state.context.selectedPaymentMethod &&
                state.context.receiverAddress &&
                state.context.destinationToken &&
                state.context.destinationAmount && (_jsx(QuoteLoader, { amount: state.context.destinationAmount, client: client, destinationToken: state.context.destinationToken, onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError, onQuoteReceived: handleQuoteReceived, paymentLinkId: paymentLinkId, paymentMethod: state.context.selectedPaymentMethod, purchaseData: purchaseData, receiver: state.context.receiverAddress, uiOptions: uiOptions })), state.value === "preview" &&
                state.context.selectedPaymentMethod &&
                state.context.quote && (_jsx(PaymentDetails, { client: client, onBack: () => {
                    send({ type: "BACK" });
                }, onConfirm: handleRouteConfirmed, onError: handleError, paymentMethod: state.context.selectedPaymentMethod, preparedQuote: state.context.quote, uiOptions: uiOptions })), state.value === "execute" &&
                state.context.quote &&
                state.context.request &&
                state.context.selectedPaymentMethod?.payerWallet && (_jsx(StepRunner, { autoStart: true, client: client, onBack: () => {
                    send({ type: "BACK" });
                }, onCancel: onCancel, onComplete: handleExecutionComplete, request: state.context.request, wallet: state.context.selectedPaymentMethod?.payerWallet, windowAdapter: webWindowAdapter })), state.value === "success" &&
                state.context.quote &&
                state.context.completedStatuses && (_jsx(SuccessScreen, { client: client, completedStatuses: state.context.completedStatuses, onDone: handleBuyComplete, preparedQuote: state.context.quote, uiOptions: uiOptions, windowAdapter: webWindowAdapter, hasPaymentId: !!paymentLinkId })), state.value === "post-buy-transaction" &&
                uiOptions.mode === "transaction" &&
                uiOptions.transaction && (_jsx(ExecutingTxScreen, { closeModal: handlePostBuyTransactionComplete, onTxSent: () => {
                    // Do nothing
                }, tx: uiOptions.transaction, windowAdapter: webWindowAdapter }))] }));
}
//# sourceMappingURL=BridgeOrchestrator.js.map