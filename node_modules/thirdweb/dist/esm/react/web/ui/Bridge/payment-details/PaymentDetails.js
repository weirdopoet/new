"use client";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { useMemo } from "react";
import { trackPayEvent } from "../../../../../analytics/track/pay.js";
import { defineChain } from "../../../../../chains/utils.js";
import { useCustomTheme } from "../../../../core/design-system/CustomThemeProvider.js";
import { radius, spacing } from "../../../../core/design-system/index.js";
import { useChainsQuery } from "../../../../core/hooks/others/useChainQuery.js";
import { formatCurrencyAmount, formatTokenAmount, } from "../../ConnectWallet/screens/formatTokenBalance.js";
import { Container, ModalHeader } from "../../components/basic.js";
import { Button } from "../../components/buttons.js";
import { Spacer } from "../../components/Spacer.js";
import { Text } from "../../components/text.js";
import { PaymentOverview } from "./PaymentOverview.js";
export function PaymentDetails({ uiOptions, client, paymentMethod, preparedQuote, onConfirm, onBack, onError, }) {
    const theme = useCustomTheme();
    const handleConfirm = () => {
        try {
            onConfirm();
        }
        catch (error) {
            onError(error);
        }
    };
    useQuery({
        queryFn: () => {
            if (preparedQuote.type === "buy" ||
                preparedQuote.type === "sell" ||
                preparedQuote.type === "transfer") {
                trackPayEvent({
                    chainId: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.chainId
                        : preparedQuote.intent.originChainId,
                    client,
                    event: "payment_details",
                    fromToken: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.tokenAddress
                        : preparedQuote.intent.originTokenAddress,
                    toChainId: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.chainId
                        : preparedQuote.intent.destinationChainId,
                    toToken: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.tokenAddress
                        : preparedQuote.intent.destinationTokenAddress,
                });
            }
        },
        queryKey: ["payment_details", preparedQuote.type],
    });
    const chainsQuery = useChainsQuery(preparedQuote.steps.flatMap((s) => [
        defineChain(s.originToken.chainId),
        defineChain(s.destinationToken.chainId),
    ]), 10);
    const chainsMetadata = useMemo(() => chainsQuery.map((c) => c.data), [chainsQuery]).filter((c) => !!c);
    // Extract common data based on quote type
    const getDisplayData = () => {
        switch (preparedQuote.type) {
            case "transfer": {
                const token = paymentMethod.type === "wallet"
                    ? paymentMethod.originToken
                    : undefined;
                if (!token) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: formatTokenAmount(preparedQuote.destinationAmount, token.decimals),
                    destinationToken: token,
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                    originAmount: formatTokenAmount(preparedQuote.originAmount, token.decimals),
                    originToken: token,
                };
            }
            case "buy": {
                const method = paymentMethod.type === "wallet" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: formatTokenAmount(preparedQuote.destinationAmount, preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken?.decimals ?? 18),
                    destinationToken: preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken,
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                    originAmount: formatTokenAmount(preparedQuote.originAmount, method.originToken.decimals),
                    originToken: paymentMethod.type === "wallet"
                        ? paymentMethod.originToken
                        : undefined,
                };
            }
            case "onramp": {
                const method = paymentMethod.type === "fiat" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: formatTokenAmount(preparedQuote.destinationAmount, preparedQuote.destinationToken.decimals), // Onramp starts with fiat
                    destinationToken: preparedQuote.destinationToken,
                    estimatedTime: undefined,
                    originAmount: formatCurrencyAmount(method.currency, Number(preparedQuote.currencyAmount)),
                    originToken: undefined,
                };
            }
            default: {
                throw new Error(`Unsupported bridge prepare type: ${preparedQuote.type}`);
            }
        }
    };
    const displayData = getDisplayData();
    return (_jsxs(Container, { flex: "column", fullHeight: true, p: "lg", children: [_jsx(ModalHeader, { onBack: onBack, title: "Payment Details" }), _jsx(Spacer, { y: "xl" }), _jsxs(Container, { flex: "column", children: [_jsxs(Container, { flex: "column", children: [displayData.destinationToken && (_jsx(PaymentOverview, { client: client, fromAmount: displayData.originAmount, paymentMethod: paymentMethod, receiver: preparedQuote.intent.receiver, sender: preparedQuote.intent.sender ||
                                    paymentMethod.payerWallet.getAccount()?.address, toAmount: displayData.destinationAmount, toToken: displayData.destinationToken, uiOptions: uiOptions })), _jsx(Spacer, { y: "md" }), _jsxs(Container, { flex: "row", gap: "sm", children: [_jsxs(Container, { flex: "row", gap: "xs", style: { flex: 1, justifyContent: "center" }, children: [_jsx(Text, { color: "secondaryText", size: "sm", children: "Estimated Time" }), _jsx(Text, { color: "primaryText", size: "sm", children: displayData.estimatedTime
                                                    ? `~${Math.ceil(displayData.estimatedTime / 60000)} min`
                                                    : "~2 min" })] }), preparedQuote.steps.length > 1 ? (_jsxs(Container, { flex: "row", gap: "xs", style: { flex: 1, justifyContent: "center" }, children: [_jsx(Text, { color: "secondaryText", size: "sm", children: "Route Length" }), _jsxs(Text, { color: "primaryText", size: "sm", children: [preparedQuote.steps.length, " step", preparedQuote.steps.length !== 1 ? "s" : ""] })] })) : null] })] }), preparedQuote.steps.length > 1 && (_jsxs(Container, { flex: "column", children: [_jsx(Spacer, { y: "sm" }), _jsx(Container, { flex: "column", gap: "sm", style: {
                                    backgroundColor: theme.colors.tertiaryBg,
                                    border: `1px solid ${theme.colors.borderColor}`,
                                    borderRadius: radius.md,
                                    padding: `${spacing.sm} ${spacing.md}`,
                                }, children: preparedQuote.steps.map((step, stepIndex) => (_jsx(Container, { flex: "column", gap: "sm", children: _jsxs(Container, { flex: "row", gap: "md", style: { alignItems: "center" }, children: [_jsx(Container, { center: "both", flex: "row", style: {
                                                    backgroundColor: theme.colors.accentButtonBg,
                                                    borderRadius: "50%",
                                                    color: theme.colors.accentButtonText,
                                                    flexShrink: 0,
                                                    fontSize: "12px",
                                                    fontWeight: "bold",
                                                    height: "24px",
                                                    width: "24px",
                                                }, children: _jsx(Text, { color: "accentButtonText", size: "xs", children: stepIndex + 1 }) }), _jsx(Container, { center: "y", flex: "row", gap: "sm", style: { flex: 1 }, children: _jsxs(Container, { flex: "column", gap: "3xs", style: { flex: 1 }, children: [_jsx(Text, { color: "primaryText", size: "sm", children: step.destinationToken.chainId !==
                                                                step.originToken.chainId ? (_jsxs(_Fragment, { children: ["Bridge", " ", step.originToken.symbol ===
                                                                        step.destinationToken.symbol
                                                                        ? step.originToken.symbol
                                                                        : `${step.originToken.symbol} to ${step.destinationToken.symbol}`] })) : (_jsxs(_Fragment, { children: ["Swap ", step.originToken.symbol, " to", " ", step.destinationToken.symbol] })) }), _jsx(Text, { color: "secondaryText", size: "xs", children: step.originToken.chainId !==
                                                                step.destinationToken.chainId ? (_jsxs(_Fragment, { children: [chainsMetadata.find((c) => c.chainId === step.originToken.chainId)?.name, " ", "to", " ", chainsMetadata.find((c) => c.chainId === step.destinationToken.chainId)?.name] })) : (chainsMetadata.find((c) => c.chainId === step.originToken.chainId)?.name) })] }) })] }) }, `step-${stepIndex}-${step.originToken.address}-${step.destinationToken.address}`))) })] })), _jsx(Spacer, { y: "lg" }), _jsx(Container, { flex: "column", gap: "sm", children: _jsx(Button, { fullWidth: true, onClick: handleConfirm, variant: "accent", children: "Confirm Payment" }) })] })] }));
}
//# sourceMappingURL=PaymentDetails.js.map