"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { useEffect } from "react";
import { trackPayEvent } from "../../../../analytics/track/pay.js";
import { toUnits } from "../../../../utils/units.js";
import { useBridgePrepare, } from "../../../core/hooks/useBridgePrepare.js";
import { Container } from "../components/basic.js";
import { Spacer } from "../components/Spacer.js";
import { Spinner } from "../components/Spinner.js";
import { Text } from "../components/text.js";
export function QuoteLoader({ uiOptions, destinationToken, paymentMethod, amount, sender, receiver, client, onQuoteReceived, onError, purchaseData, paymentLinkId, }) {
    // For now, we'll use a simple buy operation
    // This will be expanded to handle different bridge types based on the payment method
    const feePayer = uiOptions.mode === "direct_payment"
        ? uiOptions.paymentInfo.feePayer
        : undefined;
    const mode = uiOptions.mode;
    const request = getBridgeParams({
        amount,
        client,
        destinationToken,
        feePayer,
        paymentLinkId,
        paymentMethod,
        purchaseData,
        receiver,
        sender,
    });
    const prepareQuery = useBridgePrepare(request);
    useQuery({
        queryFn: () => {
            trackPayEvent({
                chainId: paymentMethod.type === "wallet"
                    ? paymentMethod.originToken.chainId
                    : undefined,
                client,
                event: `ub:ui:loading_quote:${mode}`,
                fromToken: paymentMethod.type === "wallet"
                    ? paymentMethod.originToken.address
                    : undefined,
                toChainId: destinationToken.chainId,
                toToken: destinationToken.address,
            });
        },
        queryKey: ["loading_quote", paymentMethod.type],
    });
    // Handle successful quote
    useEffect(() => {
        if (prepareQuery.data) {
            onQuoteReceived(prepareQuery.data, request);
        }
    }, [prepareQuery.data, onQuoteReceived, request]);
    // Handle errors
    useEffect(() => {
        if (prepareQuery.error) {
            onError(prepareQuery.error);
        }
    }, [prepareQuery.error, onError]);
    return (_jsxs(Container, { center: "both", flex: "column", fullHeight: true, p: "lg", style: { minHeight: "350px" }, children: [_jsx(Spinner, { color: "secondaryText", size: "xl" }), _jsx(Spacer, { y: "md" }), _jsx(Text, { center: true, color: "primaryText", size: "lg", style: { fontWeight: 600 }, children: "Finding the best route..." }), _jsx(Spacer, { y: "sm" }), _jsx(Text, { center: true, color: "secondaryText", size: "sm", children: "We're searching for the most efficient path for this payment." })] }));
}
function getBridgeParams(args) {
    const { paymentMethod, amount, destinationToken, receiver, client, sender } = args;
    switch (paymentMethod.type) {
        case "fiat":
            return {
                amount: toUnits(amount, destinationToken.decimals),
                chainId: destinationToken.chainId,
                client,
                currency: paymentMethod.currency,
                enabled: !!(destinationToken && amount && client),
                onramp: paymentMethod.onramp || "coinbase",
                paymentLinkId: args.paymentLinkId,
                purchaseData: args.purchaseData,
                receiver,
                sender, // always onramp to native token
                tokenAddress: destinationToken.address,
                type: "onramp",
            };
        case "wallet":
            // if the origin token is the same as the destination token, use transfer type
            if (paymentMethod.originToken.chainId === destinationToken.chainId &&
                paymentMethod.originToken.address.toLowerCase() ===
                    destinationToken.address.toLowerCase()) {
                return {
                    amount: toUnits(amount, destinationToken.decimals),
                    chainId: destinationToken.chainId,
                    client,
                    enabled: !!(destinationToken && amount && client),
                    feePayer: args.feePayer || "sender",
                    paymentLinkId: args.paymentLinkId,
                    purchaseData: args.purchaseData,
                    receiver,
                    sender: sender ||
                        paymentMethod.payerWallet.getAccount()?.address ||
                        receiver,
                    tokenAddress: destinationToken.address,
                    type: "transfer",
                };
            }
            return {
                amount: toUnits(amount, destinationToken.decimals),
                client,
                destinationChainId: destinationToken.chainId,
                destinationTokenAddress: destinationToken.address,
                enabled: !!(destinationToken && amount && client),
                originChainId: paymentMethod.originToken.chainId,
                originTokenAddress: paymentMethod.originToken.address,
                paymentLinkId: args.paymentLinkId,
                purchaseData: args.purchaseData,
                receiver,
                sender: sender || paymentMethod.payerWallet.getAccount()?.address || receiver,
                type: "buy",
            };
    }
}
//# sourceMappingURL=QuoteLoader.js.map