"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentDetails = PaymentDetails;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const pay_js_1 = require("../../../../../analytics/track/pay.js");
const utils_js_1 = require("../../../../../chains/utils.js");
const CustomThemeProvider_js_1 = require("../../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../../core/hooks/others/useChainQuery.js");
const formatTokenBalance_js_1 = require("../../ConnectWallet/screens/formatTokenBalance.js");
const basic_js_1 = require("../../components/basic.js");
const buttons_js_1 = require("../../components/buttons.js");
const Spacer_js_1 = require("../../components/Spacer.js");
const text_js_1 = require("../../components/text.js");
const PaymentOverview_js_1 = require("./PaymentOverview.js");
function PaymentDetails({ uiOptions, client, paymentMethod, preparedQuote, onConfirm, onBack, onError, }) {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    const handleConfirm = () => {
        try {
            onConfirm();
        }
        catch (error) {
            onError(error);
        }
    };
    (0, react_query_1.useQuery)({
        queryFn: () => {
            if (preparedQuote.type === "buy" ||
                preparedQuote.type === "sell" ||
                preparedQuote.type === "transfer") {
                (0, pay_js_1.trackPayEvent)({
                    chainId: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.chainId
                        : preparedQuote.intent.originChainId,
                    client,
                    event: "payment_details",
                    fromToken: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.tokenAddress
                        : preparedQuote.intent.originTokenAddress,
                    toChainId: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.chainId
                        : preparedQuote.intent.destinationChainId,
                    toToken: preparedQuote.type === "transfer"
                        ? preparedQuote.intent.tokenAddress
                        : preparedQuote.intent.destinationTokenAddress,
                });
            }
        },
        queryKey: ["payment_details", preparedQuote.type],
    });
    const chainsQuery = (0, useChainQuery_js_1.useChainsQuery)(preparedQuote.steps.flatMap((s) => [
        (0, utils_js_1.defineChain)(s.originToken.chainId),
        (0, utils_js_1.defineChain)(s.destinationToken.chainId),
    ]), 10);
    const chainsMetadata = (0, react_1.useMemo)(() => chainsQuery.map((c) => c.data), [chainsQuery]).filter((c) => !!c);
    // Extract common data based on quote type
    const getDisplayData = () => {
        switch (preparedQuote.type) {
            case "transfer": {
                const token = paymentMethod.type === "wallet"
                    ? paymentMethod.originToken
                    : undefined;
                if (!token) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, token.decimals),
                    destinationToken: token,
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                    originAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.originAmount, token.decimals),
                    originToken: token,
                };
            }
            case "buy": {
                const method = paymentMethod.type === "wallet" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken?.decimals ?? 18),
                    destinationToken: preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken,
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                    originAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.originAmount, method.originToken.decimals),
                    originToken: paymentMethod.type === "wallet"
                        ? paymentMethod.originToken
                        : undefined,
                };
            }
            case "onramp": {
                const method = paymentMethod.type === "fiat" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        destinationAmount: "0",
                        destinationToken: undefined,
                        estimatedTime: 0,
                        originAmount: "0",
                        originToken: undefined,
                    };
                }
                return {
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, preparedQuote.destinationToken.decimals), // Onramp starts with fiat
                    destinationToken: preparedQuote.destinationToken,
                    estimatedTime: undefined,
                    originAmount: (0, formatTokenBalance_js_1.formatCurrencyAmount)(method.currency, Number(preparedQuote.currencyAmount)),
                    originToken: undefined,
                };
            }
            default: {
                throw new Error(`Unsupported bridge prepare type: ${preparedQuote.type}`);
            }
        }
    };
    const displayData = getDisplayData();
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", fullHeight: true, p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { onBack: onBack, title: "Payment Details" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [displayData.destinationToken && ((0, jsx_runtime_1.jsx)(PaymentOverview_js_1.PaymentOverview, { client: client, fromAmount: displayData.originAmount, paymentMethod: paymentMethod, receiver: preparedQuote.intent.receiver, sender: preparedQuote.intent.sender ||
                                    paymentMethod.payerWallet.getAccount()?.address, toAmount: displayData.destinationAmount, toToken: displayData.destinationToken, uiOptions: uiOptions })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", style: { flex: 1, justifyContent: "center" }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "secondaryText", size: "sm", children: "Estimated Time" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", size: "sm", children: displayData.estimatedTime
                                                    ? `~${Math.ceil(displayData.estimatedTime / 60000)} min`
                                                    : "~2 min" })] }), preparedQuote.steps.length > 1 ? ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", style: { flex: 1, justifyContent: "center" }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "secondaryText", size: "sm", children: "Route Length" }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [preparedQuote.steps.length, " step", preparedQuote.steps.length !== 1 ? "s" : ""] })] })) : null] })] }), preparedQuote.steps.length > 1 && ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", style: {
                                    backgroundColor: theme.colors.tertiaryBg,
                                    border: `1px solid ${theme.colors.borderColor}`,
                                    borderRadius: index_js_1.radius.md,
                                    padding: `${index_js_1.spacing.sm} ${index_js_1.spacing.md}`,
                                }, children: preparedQuote.steps.map((step, stepIndex) => ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "md", style: { alignItems: "center" }, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { center: "both", flex: "row", style: {
                                                    backgroundColor: theme.colors.accentButtonBg,
                                                    borderRadius: "50%",
                                                    color: theme.colors.accentButtonText,
                                                    flexShrink: 0,
                                                    fontSize: "12px",
                                                    fontWeight: "bold",
                                                    height: "24px",
                                                    width: "24px",
                                                }, children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "accentButtonText", size: "xs", children: stepIndex + 1 }) }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { center: "y", flex: "row", gap: "sm", style: { flex: 1 }, children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "3xs", style: { flex: 1 }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", size: "sm", children: step.destinationToken.chainId !==
                                                                step.originToken.chainId ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Bridge", " ", step.originToken.symbol ===
                                                                        step.destinationToken.symbol
                                                                        ? step.originToken.symbol
                                                                        : `${step.originToken.symbol} to ${step.destinationToken.symbol}`] })) : ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Swap ", step.originToken.symbol, " to", " ", step.destinationToken.symbol] })) }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "secondaryText", size: "xs", children: step.originToken.chainId !==
                                                                step.destinationToken.chainId ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [chainsMetadata.find((c) => c.chainId === step.originToken.chainId)?.name, " ", "to", " ", chainsMetadata.find((c) => c.chainId === step.destinationToken.chainId)?.name] })) : (chainsMetadata.find((c) => c.chainId === step.originToken.chainId)?.name) })] }) })] }) }, `step-${stepIndex}-${step.originToken.address}-${step.destinationToken.address}`))) })] })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", children: (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { fullWidth: true, onClick: handleConfirm, variant: "accent", children: "Confirm Payment" }) })] })] }));
}
//# sourceMappingURL=PaymentDetails.js.map