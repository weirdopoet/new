"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoteLoader = QuoteLoader;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const pay_js_1 = require("../../../../analytics/track/pay.js");
const units_js_1 = require("../../../../utils/units.js");
const useBridgePrepare_js_1 = require("../../../core/hooks/useBridgePrepare.js");
const basic_js_1 = require("../components/basic.js");
const Spacer_js_1 = require("../components/Spacer.js");
const Spinner_js_1 = require("../components/Spinner.js");
const text_js_1 = require("../components/text.js");
function QuoteLoader({ uiOptions, destinationToken, paymentMethod, amount, sender, receiver, client, onQuoteReceived, onError, purchaseData, paymentLinkId, }) {
    // For now, we'll use a simple buy operation
    // This will be expanded to handle different bridge types based on the payment method
    const feePayer = uiOptions.mode === "direct_payment"
        ? uiOptions.paymentInfo.feePayer
        : undefined;
    const mode = uiOptions.mode;
    const request = getBridgeParams({
        amount,
        client,
        destinationToken,
        feePayer,
        paymentLinkId,
        paymentMethod,
        purchaseData,
        receiver,
        sender,
    });
    const prepareQuery = (0, useBridgePrepare_js_1.useBridgePrepare)(request);
    (0, react_query_1.useQuery)({
        queryFn: () => {
            (0, pay_js_1.trackPayEvent)({
                chainId: paymentMethod.type === "wallet"
                    ? paymentMethod.originToken.chainId
                    : undefined,
                client,
                event: `ub:ui:loading_quote:${mode}`,
                fromToken: paymentMethod.type === "wallet"
                    ? paymentMethod.originToken.address
                    : undefined,
                toChainId: destinationToken.chainId,
                toToken: destinationToken.address,
            });
        },
        queryKey: ["loading_quote", paymentMethod.type],
    });
    // Handle successful quote
    (0, react_1.useEffect)(() => {
        if (prepareQuery.data) {
            onQuoteReceived(prepareQuery.data, request);
        }
    }, [prepareQuery.data, onQuoteReceived, request]);
    // Handle errors
    (0, react_1.useEffect)(() => {
        if (prepareQuery.error) {
            onError(prepareQuery.error);
        }
    }, [prepareQuery.error, onError]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { center: "both", flex: "column", fullHeight: true, p: "lg", style: { minHeight: "350px" }, children: [(0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "secondaryText", size: "xl" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { center: true, color: "primaryText", size: "lg", style: { fontWeight: 600 }, children: "Finding the best route..." }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { center: true, color: "secondaryText", size: "sm", children: "We're searching for the most efficient path for this payment." })] }));
}
function getBridgeParams(args) {
    const { paymentMethod, amount, destinationToken, receiver, client, sender } = args;
    switch (paymentMethod.type) {
        case "fiat":
            return {
                amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                chainId: destinationToken.chainId,
                client,
                currency: paymentMethod.currency,
                enabled: !!(destinationToken && amount && client),
                onramp: paymentMethod.onramp || "coinbase",
                paymentLinkId: args.paymentLinkId,
                purchaseData: args.purchaseData,
                receiver,
                sender, // always onramp to native token
                tokenAddress: destinationToken.address,
                type: "onramp",
            };
        case "wallet":
            // if the origin token is the same as the destination token, use transfer type
            if (paymentMethod.originToken.chainId === destinationToken.chainId &&
                paymentMethod.originToken.address.toLowerCase() ===
                    destinationToken.address.toLowerCase()) {
                return {
                    amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                    chainId: destinationToken.chainId,
                    client,
                    enabled: !!(destinationToken && amount && client),
                    feePayer: args.feePayer || "sender",
                    paymentLinkId: args.paymentLinkId,
                    purchaseData: args.purchaseData,
                    receiver,
                    sender: sender ||
                        paymentMethod.payerWallet.getAccount()?.address ||
                        receiver,
                    tokenAddress: destinationToken.address,
                    type: "transfer",
                };
            }
            return {
                amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                client,
                destinationChainId: destinationToken.chainId,
                destinationTokenAddress: destinationToken.address,
                enabled: !!(destinationToken && amount && client),
                originChainId: paymentMethod.originToken.chainId,
                originTokenAddress: paymentMethod.originToken.address,
                paymentLinkId: args.paymentLinkId,
                purchaseData: args.purchaseData,
                receiver,
                sender: sender || paymentMethod.payerWallet.getAccount()?.address || receiver,
                type: "buy",
            };
    }
}
//# sourceMappingURL=QuoteLoader.js.map