"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeOrchestrator = BridgeOrchestrator;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const webStorage_js_1 = require("../../../../utils/storage/webStorage.js");
const paymentMachine_js_1 = require("../../../core/machines/paymentMachine.js");
const WindowAdapter_js_1 = require("../../adapters/WindowAdapter.js");
const en_js_1 = require("../ConnectWallet/locale/en.js");
const basic_js_1 = require("../components/basic.js");
const ExecutingScreen_js_1 = require("../TransactionButton/ExecutingScreen.js");
const DirectPayment_js_1 = require("./DirectPayment.js");
const ErrorBanner_js_1 = require("./ErrorBanner.js");
const FundWallet_js_1 = require("./FundWallet.js");
const PaymentDetails_js_1 = require("./payment-details/PaymentDetails.js");
const PaymentSelection_js_1 = require("./payment-selection/PaymentSelection.js");
const SuccessScreen_js_1 = require("./payment-success/SuccessScreen.js");
const QuoteLoader_js_1 = require("./QuoteLoader.js");
const StepRunner_js_1 = require("./StepRunner.js");
const TransactionPayment_js_1 = require("./TransactionPayment.js");
function BridgeOrchestrator({ client, uiOptions, receiverAddress, onComplete, onError, onCancel, connectOptions, connectLocale, purchaseData, paymentLinkId, presetOptions, paymentMethods = ["crypto", "card"], showThirdwebBranding = true, supportedTokens, }) {
    // Initialize adapters
    const adapters = (0, react_1.useMemo)(() => ({
        storage: webStorage_js_1.webLocalStorage,
        window: WindowAdapter_js_1.webWindowAdapter,
    }), []);
    // Create modified connect options with branding setting
    const modifiedConnectOptions = (0, react_1.useMemo)(() => {
        if (!connectOptions)
            return undefined;
        return {
            ...connectOptions,
            connectModal: {
                ...connectOptions.connectModal,
                showThirdwebBranding,
            },
        };
    }, [connectOptions, showThirdwebBranding]);
    // Use the payment machine hook
    const [state, send] = (0, paymentMachine_js_1.usePaymentMachine)(adapters, uiOptions.mode);
    // Handle buy completion
    const handleBuyComplete = (0, react_1.useCallback)(() => {
        if (uiOptions.mode === "transaction") {
            send({ type: "CONTINUE_TO_TRANSACTION" });
        }
        else {
            onComplete?.();
            send({ type: "RESET" });
        }
    }, [onComplete, send, uiOptions.mode]);
    // Handle post-buy transaction completion
    const handlePostBuyTransactionComplete = (0, react_1.useCallback)(() => {
        onComplete?.();
        send({ type: "RESET" });
    }, [onComplete, send]);
    // Handle errors
    const handleError = (0, react_1.useCallback)((error) => {
        console.error(error);
        onError?.(error);
        send({ error, type: "ERROR_OCCURRED" });
    }, [onError, send]);
    // Handle payment method selection
    const handlePaymentMethodSelected = (0, react_1.useCallback)((paymentMethod) => {
        send({ paymentMethod, type: "PAYMENT_METHOD_SELECTED" });
    }, [send]);
    // Handle quote received
    const handleQuoteReceived = (0, react_1.useCallback)((quote, request) => {
        send({ quote, request, type: "QUOTE_RECEIVED" });
    }, [send]);
    // Handle route confirmation
    const handleRouteConfirmed = (0, react_1.useCallback)(() => {
        send({ type: "ROUTE_CONFIRMED" });
    }, [send]);
    // Handle execution complete
    const handleExecutionComplete = (0, react_1.useCallback)((completedStatuses) => {
        send({ completedStatuses, type: "EXECUTION_COMPLETE" });
    }, [send]);
    // Handle retry
    const handleRetry = (0, react_1.useCallback)(() => {
        send({ type: "RETRY" });
    }, [send]);
    // Handle requirements resolved from FundWallet and DirectPayment
    const handleRequirementsResolved = (0, react_1.useCallback)((amount, token, receiverAddress) => {
        send({
            destinationAmount: amount,
            destinationToken: token,
            receiverAddress,
            type: "DESTINATION_CONFIRMED",
        });
    }, [send]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", fullHeight: true, children: [state.value === "error" && state.context.currentError && ((0, jsx_runtime_1.jsx)(ErrorBanner_js_1.ErrorBanner, { client: client, error: state.context.currentError, onCancel: () => {
                    send({ type: "RESET" });
                    onCancel?.();
                }, onRetry: handleRetry })), state.value === "init" && uiOptions.mode === "fund_wallet" && ((0, jsx_runtime_1.jsx)(FundWallet_js_1.FundWallet, { client: client, connectOptions: modifiedConnectOptions, onContinue: handleRequirementsResolved, presetOptions: presetOptions, receiverAddress: receiverAddress, showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "init" && uiOptions.mode === "direct_payment" && ((0, jsx_runtime_1.jsx)(DirectPayment_js_1.DirectPayment, { client: client, onContinue: handleRequirementsResolved, showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "init" && uiOptions.mode === "transaction" && ((0, jsx_runtime_1.jsx)(TransactionPayment_js_1.TransactionPayment, { client: client, connectOptions: modifiedConnectOptions, onContinue: handleRequirementsResolved, onExecuteTransaction: () => send({ type: "CONTINUE_TO_TRANSACTION" }), showThirdwebBranding: showThirdwebBranding, uiOptions: uiOptions })), state.value === "methodSelection" &&
                state.context.destinationToken &&
                state.context.destinationAmount &&
                state.context.receiverAddress && ((0, jsx_runtime_1.jsx)(PaymentSelection_js_1.PaymentSelection, { client: client, connectLocale: connectLocale || en_js_1.default, connectOptions: modifiedConnectOptions, destinationAmount: state.context.destinationAmount, destinationToken: state.context.destinationToken, feePayer: uiOptions.mode === "direct_payment"
                    ? uiOptions.paymentInfo.feePayer
                    : undefined, includeDestinationToken: uiOptions.mode !== "fund_wallet", onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError, onPaymentMethodSelected: handlePaymentMethodSelected, paymentMethods: paymentMethods, receiverAddress: state.context.receiverAddress, currency: uiOptions.currency, supportedTokens: supportedTokens })), state.value === "quote" &&
                state.context.selectedPaymentMethod &&
                state.context.receiverAddress &&
                state.context.destinationToken &&
                state.context.destinationAmount && ((0, jsx_runtime_1.jsx)(QuoteLoader_js_1.QuoteLoader, { amount: state.context.destinationAmount, client: client, destinationToken: state.context.destinationToken, onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError, onQuoteReceived: handleQuoteReceived, paymentLinkId: paymentLinkId, paymentMethod: state.context.selectedPaymentMethod, purchaseData: purchaseData, receiver: state.context.receiverAddress, uiOptions: uiOptions })), state.value === "preview" &&
                state.context.selectedPaymentMethod &&
                state.context.quote && ((0, jsx_runtime_1.jsx)(PaymentDetails_js_1.PaymentDetails, { client: client, onBack: () => {
                    send({ type: "BACK" });
                }, onConfirm: handleRouteConfirmed, onError: handleError, paymentMethod: state.context.selectedPaymentMethod, preparedQuote: state.context.quote, uiOptions: uiOptions })), state.value === "execute" &&
                state.context.quote &&
                state.context.request &&
                state.context.selectedPaymentMethod?.payerWallet && ((0, jsx_runtime_1.jsx)(StepRunner_js_1.StepRunner, { autoStart: true, client: client, onBack: () => {
                    send({ type: "BACK" });
                }, onCancel: onCancel, onComplete: handleExecutionComplete, request: state.context.request, wallet: state.context.selectedPaymentMethod?.payerWallet, windowAdapter: WindowAdapter_js_1.webWindowAdapter })), state.value === "success" &&
                state.context.quote &&
                state.context.completedStatuses && ((0, jsx_runtime_1.jsx)(SuccessScreen_js_1.SuccessScreen, { client: client, completedStatuses: state.context.completedStatuses, onDone: handleBuyComplete, preparedQuote: state.context.quote, uiOptions: uiOptions, windowAdapter: WindowAdapter_js_1.webWindowAdapter, hasPaymentId: !!paymentLinkId })), state.value === "post-buy-transaction" &&
                uiOptions.mode === "transaction" &&
                uiOptions.transaction && ((0, jsx_runtime_1.jsx)(ExecutingScreen_js_1.ExecutingTxScreen, { closeModal: handlePostBuyTransactionComplete, onTxSent: () => {
                    // Do nothing
                }, tx: uiOptions.transaction, windowAdapter: WindowAdapter_js_1.webWindowAdapter }))] }));
}
//# sourceMappingURL=BridgeOrchestrator.js.map