import type { Quote } from "../../../bridge/index.js";
import type { TokenWithPrices } from "../../../bridge/types/Token.js";
import type { Address } from "../../../utils/address.js";
import type { AsyncStorage } from "../../../utils/storage/AsyncStorage.js";
import type { Wallet } from "../../../wallets/interfaces/wallet.js";
import type { WindowAdapter } from "../adapters/WindowAdapter.js";
import type { BridgePrepareRequest, BridgePrepareResult } from "../hooks/useBridgePrepare.js";
import type { CompletedStatusResult } from "../hooks/useStepExecutor.js";
/**
 * Payment modes supported by BridgeEmbed
 */
type PaymentMode = "fund_wallet" | "direct_payment" | "transaction";
/**
 * Payment method types with their required data
 */
export type PaymentMethod = {
    type: "wallet";
    payerWallet: Wallet;
    originToken: TokenWithPrices;
    balance: bigint;
    quote: Quote;
} | {
    type: "fiat";
    payerWallet: Wallet;
    currency: string;
    onramp: "stripe" | "coinbase" | "transak";
};
/**
 * Payment machine context - holds all flow state data
 */
export interface PaymentMachineContext {
    mode: PaymentMode;
    destinationAmount?: string;
    destinationToken?: TokenWithPrices;
    receiverAddress?: Address;
    selectedPaymentMethod?: PaymentMethod;
    quote?: BridgePrepareResult;
    request?: BridgePrepareRequest;
    completedStatuses?: CompletedStatusResult[];
    currentError?: Error;
    retryState?: PaymentMachineState;
    adapters: {
        window: WindowAdapter;
        storage: AsyncStorage;
    };
}
/**
 * Events that can be sent to the payment machine
 */
type PaymentMachineEvent = {
    type: "DESTINATION_CONFIRMED";
    destinationToken: TokenWithPrices;
    destinationAmount: string;
    receiverAddress: Address;
} | {
    type: "PAYMENT_METHOD_SELECTED";
    paymentMethod: PaymentMethod;
} | {
    type: "QUOTE_RECEIVED";
    quote: BridgePrepareResult;
    request: BridgePrepareRequest;
} | {
    type: "ROUTE_CONFIRMED";
} | {
    type: "EXECUTION_COMPLETE";
    completedStatuses: CompletedStatusResult[];
} | {
    type: "ERROR_OCCURRED";
    error: Error;
} | {
    type: "CONTINUE_TO_TRANSACTION";
} | {
    type: "RETRY";
} | {
    type: "RESET";
} | {
    type: "BACK";
};
type PaymentMachineState = "init" | "methodSelection" | "quote" | "preview" | "execute" | "success" | "post-buy-transaction" | "error";
/**
 * Hook to create and use the payment machine
 */
export declare function usePaymentMachine(adapters: PaymentMachineContext["adapters"], mode?: PaymentMode): readonly [{
    readonly context: PaymentMachineContext;
    readonly value: PaymentMachineState;
}, (event: PaymentMachineEvent) => void];
export {};
//# sourceMappingURL=paymentMachine.d.ts.map