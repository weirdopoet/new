"use strict";
var m9 = Object.create;
var Uo = Object.defineProperty;
var g9 = Object.getOwnPropertyDescriptor;
var y9 = Object.getOwnPropertyNames;
var D9 = Object.getPrototypeOf, x9 = Object.prototype.hasOwnProperty;
var s = (e, t) => Uo(e, "name", { value: t, configurable: !0 });
var wt = (e, t) => () => (e && (t = e(e = 0)), t);
var I = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Gn = (e, t) => {
  for (var r in t)
    Uo(e, r, { get: t[r], enumerable: !0 });
}, Cx = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of y9(t))
      !x9.call(e, i) && i !== r && Uo(e, i, { get: () => t[i], enumerable: !(n = g9(t, i)) || n.enumerable });
  return e;
};
var J = (e, t, r) => (r = e != null ? m9(D9(e)) : {}, Cx(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Uo(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), Fu = (e) => Cx(Uo({}, "__esModule", { value: !0 }), e);

// ../node_modules/picocolors/picocolors.js
var Tr = I((Zse, ph) => {
  var ku = process || {}, wx = ku.argv || [], _u = ku.env || {}, b9 = !(_u.NO_COLOR || wx.includes("--no-color")) && (!!_u.FORCE_COLOR || wx.
  includes("--color") || ku.platform === "win32" || (ku.stdout || {}).isTTY && _u.TERM !== "dumb" || !!_u.CI), v9 = /* @__PURE__ */ s((e, t, r = e) => (n) => {
    let i = "" + n, o = i.indexOf(t, e.length);
    return ~o ? e + E9(i, t, r, o) + t : e + i + t;
  }, "formatter"), E9 = /* @__PURE__ */ s((e, t, r, n) => {
    let i = "", o = 0;
    do
      i += e.substring(o, n) + r, o = n + t.length, n = e.indexOf(t, o);
    while (~n);
    return i + e.substring(o);
  }, "replaceClose"), Sx = /* @__PURE__ */ s((e = b9) => {
    let t = e ? v9 : () => String;
    return {
      isColorSupported: e,
      reset: t("\x1B[0m", "\x1B[0m"),
      bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: t("\x1B[3m", "\x1B[23m"),
      underline: t("\x1B[4m", "\x1B[24m"),
      inverse: t("\x1B[7m", "\x1B[27m"),
      hidden: t("\x1B[8m", "\x1B[28m"),
      strikethrough: t("\x1B[9m", "\x1B[29m"),
      black: t("\x1B[30m", "\x1B[39m"),
      red: t("\x1B[31m", "\x1B[39m"),
      green: t("\x1B[32m", "\x1B[39m"),
      yellow: t("\x1B[33m", "\x1B[39m"),
      blue: t("\x1B[34m", "\x1B[39m"),
      magenta: t("\x1B[35m", "\x1B[39m"),
      cyan: t("\x1B[36m", "\x1B[39m"),
      white: t("\x1B[37m", "\x1B[39m"),
      gray: t("\x1B[90m", "\x1B[39m"),
      bgBlack: t("\x1B[40m", "\x1B[49m"),
      bgRed: t("\x1B[41m", "\x1B[49m"),
      bgGreen: t("\x1B[42m", "\x1B[49m"),
      bgYellow: t("\x1B[43m", "\x1B[49m"),
      bgBlue: t("\x1B[44m", "\x1B[49m"),
      bgMagenta: t("\x1B[45m", "\x1B[49m"),
      bgCyan: t("\x1B[46m", "\x1B[49m"),
      bgWhite: t("\x1B[47m", "\x1B[49m"),
      blackBright: t("\x1B[90m", "\x1B[39m"),
      redBright: t("\x1B[91m", "\x1B[39m"),
      greenBright: t("\x1B[92m", "\x1B[39m"),
      yellowBright: t("\x1B[93m", "\x1B[39m"),
      blueBright: t("\x1B[94m", "\x1B[39m"),
      magentaBright: t("\x1B[95m", "\x1B[39m"),
      cyanBright: t("\x1B[96m", "\x1B[39m"),
      whiteBright: t("\x1B[97m", "\x1B[39m"),
      bgBlackBright: t("\x1B[100m", "\x1B[49m"),
      bgRedBright: t("\x1B[101m", "\x1B[49m"),
      bgGreenBright: t("\x1B[102m", "\x1B[49m"),
      bgYellowBright: t("\x1B[103m", "\x1B[49m"),
      bgBlueBright: t("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
      bgCyanBright: t("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: t("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  ph.exports = Sx();
  ph.exports.createColors = Sx;
});

// ../node_modules/yocto-queue/index.js
var hh, Wo, Ax = wt(() => {
  hh = class {
    static {
      s(this, "Node");
    }
    value;
    next;
    constructor(t) {
      this.value = t;
    }
  }, Wo = class {
    static {
      s(this, "Queue");
    }
    #t;
    #r;
    #e;
    constructor() {
      this.clear();
    }
    enqueue(t) {
      let r = new hh(t);
      this.#t ? (this.#r.next = r, this.#r = r) : (this.#t = r, this.#r = r), this.#e++;
    }
    dequeue() {
      let t = this.#t;
      if (t)
        return this.#t = this.#t.next, this.#e--, t.value;
    }
    peek() {
      if (this.#t)
        return this.#t.value;
    }
    clear() {
      this.#t = void 0, this.#r = void 0, this.#e = 0;
    }
    get size() {
      return this.#e;
    }
    *[Symbol.iterator]() {
      let t = this.#t;
      for (; t; )
        yield t.value, t = t.next;
    }
    *drain() {
      for (; this.#t; )
        yield this.dequeue();
    }
  };
});

// ../node_modules/slash/index.js
function it(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
var _i = wt(() => {
  s(it, "slash");
});

// ../node_modules/ts-dedent/dist/index.js
var Bt = I((Go) => {
  "use strict";
  Object.defineProperty(Go, "__esModule", { value: !0 });
  Go.dedent = void 0;
  function Rx(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var n = Array.from(typeof e == "string" ? [e] : e);
    n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var i = n.reduce(function(u, l) {
      var c = l.match(/\n([\t ]+|(?!\s).)/g);
      return c ? u.concat(c.map(function(p) {
        var h, f;
        return (f = (h = p.match(/[\t ]/g)) === null || h === void 0 ? void 0 : h.length) !== null && f !== void 0 ? f : 0;
      })) : u;
    }, []);
    if (i.length) {
      var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
      n = n.map(function(u) {
        return u.replace(o, `
`);
      });
    }
    n[0] = n[0].replace(/^\r?\n/, "");
    var a = n[0];
    return t.forEach(function(u, l) {
      var c = a.match(/(?:^|\n)( *)$/), p = c ? c[1] : "", h = u;
      typeof u == "string" && u.includes(`
`) && (h = String(u).split(`
`).map(function(f, d) {
        return d === 0 ? f : "" + p + f;
      }).join(`
`)), a += h + n[l + 1];
    }), a;
  }
  s(Rx, "dedent");
  Go.dedent = Rx;
  Go.default = Rx;
});

// ../node_modules/tsconfig-paths/lib/filesystem.js
var Ou = I((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", { value: !0 });
  ar.removeExtension = ar.fileExistsAsync = ar.readJsonFromDiskAsync = ar.readJsonFromDiskSync = ar.fileExistsSync = void 0;
  var Jo = require("fs");
  function _9(e) {
    if (!Jo.existsSync(e))
      return !1;
    try {
      var t = Jo.statSync(e);
      return t.isFile();
    } catch {
      return !1;
    }
  }
  s(_9, "fileExistsSync");
  ar.fileExistsSync = _9;
  function k9(e) {
    if (Jo.existsSync(e))
      return require(e);
  }
  s(k9, "readJsonFromDiskSync");
  ar.readJsonFromDiskSync = k9;
  function T9(e, t) {
    Jo.readFile(e, "utf8", function(r, n) {
      if (r || !n)
        return t();
      var i = JSON.parse(n);
      return t(void 0, i);
    });
  }
  s(T9, "readJsonFromDiskAsync");
  ar.readJsonFromDiskAsync = T9;
  function I9(e, t) {
    Jo.stat(e, function(r, n) {
      if (r)
        return t(void 0, !1);
      t(void 0, n ? n.isFile() : !1);
    });
  }
  s(I9, "fileExistsAsync");
  ar.fileExistsAsync = I9;
  function P9(e) {
    return e.substring(0, e.lastIndexOf(".")) || e;
  }
  s(P9, "removeExtension");
  ar.removeExtension = P9;
});

// ../node_modules/tsconfig-paths/lib/mapping-entry.js
var yh = I((Ru) => {
  "use strict";
  Object.defineProperty(Ru, "__esModule", { value: !0 });
  Ru.getAbsoluteMappingEntries = void 0;
  var B9 = require("path");
  function O9(e, t, r) {
    for (var n = R9(Object.keys(t)), i = [], o = 0, a = n; o < a.length; o++) {
      var u = a[o];
      i.push({
        pattern: u,
        paths: t[u].map(function(l) {
          return B9.resolve(e, l);
        })
      });
    }
    return !t["*"] && r && i.push({
      pattern: "*",
      paths: ["".concat(e.replace(/\/$/, ""), "/*")]
    }), i;
  }
  s(O9, "getAbsoluteMappingEntries");
  Ru.getAbsoluteMappingEntries = O9;
  function R9(e) {
    return e.concat().sort(function(t, r) {
      return Nx(r) - Nx(t);
    });
  }
  s(R9, "sortByLongestPrefix");
  function Nx(e) {
    var t = e.indexOf("*");
    return e.substr(0, t).length;
  }
  s(Nx, "getPrefixLength");
});

// ../node_modules/tsconfig-paths/lib/try-path.js
var Dh = I((Jn) => {
  "use strict";
  Object.defineProperty(Jn, "__esModule", { value: !0 });
  Jn.exhaustiveTypeException = Jn.getStrippedPath = Jn.getPathsToTry = void 0;
  var Lx = require("path"), N9 = require("path"), L9 = Ou();
  function j9(e, t, r) {
    if (!(!t || !r || r[0] === ".")) {
      for (var n = [], i = 0, o = t; i < o.length; i++) {
        var a = o[i], u = a.pattern === r ? "" : q9(a.pattern, r);
        if (u !== void 0)
          for (var l = /* @__PURE__ */ s(function(f) {
            var d = f.replace("*", u);
            n.push({ type: "file", path: d }), n.push.apply(n, e.map(function(g) {
              return { type: "extension", path: d + g };
            })), n.push({
              type: "package",
              path: Lx.join(d, "/package.json")
            });
            var m = Lx.join(d, "/index");
            n.push.apply(n, e.map(function(g) {
              return { type: "index", path: m + g };
            }));
          }, "_loop_1"), c = 0, p = a.paths; c < p.length; c++) {
            var h = p[c];
            l(h);
          }
      }
      return n.length === 0 ? void 0 : n;
    }
  }
  s(j9, "getPathsToTry");
  Jn.getPathsToTry = j9;
  function M9(e) {
    return e.type === "index" ? (0, N9.dirname)(e.path) : e.type === "file" ? e.path : e.type === "extension" ? (0, L9.removeExtension)(e.path) :
    e.type === "package" ? e.path : jx(e.type);
  }
  s(M9, "getStrippedPath");
  Jn.getStrippedPath = M9;
  function jx(e) {
    throw new Error("Unknown type ".concat(e));
  }
  s(jx, "exhaustiveTypeException");
  Jn.exhaustiveTypeException = jx;
  function q9(e, t) {
    if (!(t.length < e.length)) {
      if (e === "*")
        return t;
      var r = e.indexOf("*");
      if (r !== -1) {
        var n = e.substring(0, r), i = e.substring(r + 1);
        if (t.substr(0, r) === n && t.substr(t.length - i.length) === i)
          return t.substr(r, t.length - i.length);
      }
    }
  }
  s(q9, "matchStar");
});

// ../node_modules/tsconfig-paths/lib/match-path-sync.js
var vh = I((bs) => {
  "use strict";
  Object.defineProperty(bs, "__esModule", { value: !0 });
  bs.matchFromAbsolutePaths = bs.createMatchPath = void 0;
  var Mx = require("path"), xh = Ou(), $9 = yh(), bh = Dh();
  function V9(e, t, r, n) {
    r === void 0 && (r = ["main"]), n === void 0 && (n = !0);
    var i = $9.getAbsoluteMappingEntries(e, t, n);
    return function(o, a, u, l) {
      return qx(i, o, a, u, l, r);
    };
  }
  s(V9, "createMatchPath");
  bs.createMatchPath = V9;
  function qx(e, t, r, n, i, o) {
    r === void 0 && (r = xh.readJsonFromDiskSync), n === void 0 && (n = xh.fileExistsSync), i === void 0 && (i = Object.keys(require.extensions)),
    o === void 0 && (o = ["main"]);
    var a = bh.getPathsToTry(i, e, t);
    if (a)
      return W9(a, r, n, o);
  }
  s(qx, "matchFromAbsolutePaths");
  bs.matchFromAbsolutePaths = qx;
  function U9(e, t, r, n) {
    for (var i = 0; i < t.length; i++) {
      var o = t[i], a = typeof o == "string" ? e[o] : o.reduce(function(l, c) {
        return l[c];
      }, e);
      if (a && typeof a == "string") {
        var u = Mx.join(Mx.dirname(r), a);
        if (n(u))
          return u;
      }
    }
  }
  s(U9, "findFirstExistingMainFieldMappedFile");
  function W9(e, t, r, n) {
    t === void 0 && (t = xh.readJsonFromDiskSync), n === void 0 && (n = ["main"]);
    for (var i = 0, o = e; i < o.length; i++) {
      var a = o[i];
      if (a.type === "file" || a.type === "extension" || a.type === "index") {
        if (r(a.path))
          return bh.getStrippedPath(a);
      } else if (a.type === "package") {
        var u = t(a.path);
        if (u) {
          var l = U9(u, n, a.path, r);
          if (l)
            return l;
        }
      } else
        bh.exhaustiveTypeException(a.type);
    }
  }
  s(W9, "findFirstExistingPath");
});

// ../node_modules/tsconfig-paths/lib/match-path-async.js
var zx = I((vs) => {
  "use strict";
  Object.defineProperty(vs, "__esModule", { value: !0 });
  vs.matchFromAbsolutePathsAsync = vs.createMatchPathAsync = void 0;
  var $x = require("path"), Eh = Dh(), z9 = yh(), Vx = Ou();
  function H9(e, t, r, n) {
    r === void 0 && (r = ["main"]), n === void 0 && (n = !0);
    var i = z9.getAbsoluteMappingEntries(e, t, n);
    return function(o, a, u, l, c) {
      return Ux(i, o, a, u, l, c, r);
    };
  }
  s(H9, "createMatchPathAsync");
  vs.createMatchPathAsync = H9;
  function Ux(e, t, r, n, i, o, a) {
    r === void 0 && (r = Vx.readJsonFromDiskAsync), n === void 0 && (n = Vx.fileExistsAsync), i === void 0 && (i = Object.keys(require.extensions)),
    a === void 0 && (a = ["main"]);
    var u = Eh.getPathsToTry(i, e, t);
    if (!u)
      return o();
    Nu(u, r, n, o, 0, a);
  }
  s(Ux, "matchFromAbsolutePathsAsync");
  vs.matchFromAbsolutePathsAsync = Ux;
  function Wx(e, t, r, n, i, o) {
    if (o === void 0 && (o = 0), o >= t.length)
      return i(void 0, void 0);
    var a = /* @__PURE__ */ s(function() {
      return Wx(e, t, r, n, i, o + 1);
    }, "tryNext"), u = t[o], l = typeof u == "string" ? e[u] : u.reduce(function(p, h) {
      return p[h];
    }, e);
    if (typeof l != "string")
      return a();
    var c = $x.join($x.dirname(r), l);
    n(c, function(p, h) {
      return p ? i(p) : h ? i(void 0, c) : a();
    });
  }
  s(Wx, "findFirstExistingMainFieldMappedFile");
  function Nu(e, t, r, n, i, o) {
    i === void 0 && (i = 0), o === void 0 && (o = ["main"]);
    var a = e[i];
    a.type === "file" || a.type === "extension" || a.type === "index" ? r(a.path, function(u, l) {
      return u ? n(u) : l ? n(void 0, Eh.getStrippedPath(a)) : i === e.length - 1 ? n() : Nu(e, t, r, n, i + 1, o);
    }) : a.type === "package" ? t(a.path, function(u, l) {
      return u ? n(u) : l ? Wx(l, o, a.path, r, function(c, p) {
        return c ? n(c) : p ? n(void 0, p) : Nu(e, t, r, n, i + 1, o);
      }) : Nu(e, t, r, n, i + 1, o);
    }) : Eh.exhaustiveTypeException(a.type);
  }
  s(Nu, "findFirstExistingPath");
});

// ../node_modules/json5/lib/unicode.js
var Hx = I((Noe, Lu) => {
  Lu.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  Lu.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  Lu.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var wh = I((Loe, Gx) => {
  var Ch = Hx();
  Gx.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && Ch.Space_Separator.test(e);
    },
    isIdStartChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || Ch.ID_Start.test(e));
    },
    isIdContinueChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e ===
      "\u200C" || e === "\u200D" || Ch.ID_Continue.test(e));
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e);
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var Yx = I((joe, Kx) => {
  var xt = wh(), Ah, Ot, Cn, Mu, Zn, Pr, bt, kh, Xo;
  Kx.exports = /* @__PURE__ */ s(function(t, r) {
    Ah = String(t), Ot = "start", Cn = [], Mu = 0, Zn = 1, Pr = 0, bt = void 0, kh = void 0, Xo = void 0;
    do
      bt = G9(), X9[Ot]();
    while (bt.type !== "eof");
    return typeof r == "function" ? Fh({ "": Xo }, "", r) : Xo;
  }, "parse");
  function Fh(e, t, r) {
    let n = e[t];
    if (n != null && typeof n == "object")
      if (Array.isArray(n))
        for (let i = 0; i < n.length; i++) {
          let o = String(i), a = Fh(n, o, r);
          a === void 0 ? delete n[o] : Object.defineProperty(n, o, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let i in n) {
          let o = Fh(n, i, r);
          o === void 0 ? delete n[i] : Object.defineProperty(n, i, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return r.call(e, t, n);
  }
  s(Fh, "internalize");
  var Fe, ve, Zo, En, Ie;
  function G9() {
    for (Fe = "default", ve = "", Zo = !1, En = 1; ; ) {
      Ie = wn();
      let e = Zx[Fe]();
      if (e)
        return e;
    }
  }
  s(G9, "lex");
  function wn() {
    if (Ah[Mu])
      return String.fromCodePoint(Ah.codePointAt(Mu));
  }
  s(wn, "peek");
  function X() {
    let e = wn();
    return e === `
` ? (Zn++, Pr = 0) : e ? Pr += e.length : Pr++, e && (Mu += e.length), e;
  }
  s(X, "read");
  var Zx = {
    default() {
      switch (Ie) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          X();
          return;
        case "/":
          X(), Fe = "comment";
          return;
        case void 0:
          return X(), Ze("eof");
      }
      if (xt.isSpaceSeparator(Ie)) {
        X();
        return;
      }
      return Zx[Ot]();
    },
    comment() {
      switch (Ie) {
        case "*":
          X(), Fe = "multiLineComment";
          return;
        case "/":
          X(), Fe = "singleLineComment";
          return;
      }
      throw Xe(X());
    },
    multiLineComment() {
      switch (Ie) {
        case "*":
          X(), Fe = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw Xe(X());
      }
      X();
    },
    multiLineCommentAsterisk() {
      switch (Ie) {
        case "*":
          X();
          return;
        case "/":
          X(), Fe = "default";
          return;
        case void 0:
          throw Xe(X());
      }
      X(), Fe = "multiLineComment";
    },
    singleLineComment() {
      switch (Ie) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          X(), Fe = "default";
          return;
        case void 0:
          return X(), Ze("eof");
      }
      X();
    },
    value() {
      switch (Ie) {
        case "{":
        case "[":
          return Ze("punctuator", X());
        case "n":
          return X(), ki("ull"), Ze("null", null);
        case "t":
          return X(), ki("rue"), Ze("boolean", !0);
        case "f":
          return X(), ki("alse"), Ze("boolean", !1);
        case "-":
        case "+":
          X() === "-" && (En = -1), Fe = "sign";
          return;
        case ".":
          ve = X(), Fe = "decimalPointLeading";
          return;
        case "0":
          ve = X(), Fe = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          ve = X(), Fe = "decimalInteger";
          return;
        case "I":
          return X(), ki("nfinity"), Ze("numeric", 1 / 0);
        case "N":
          return X(), ki("aN"), Ze("numeric", NaN);
        case '"':
        case "'":
          Zo = X() === '"', ve = "", Fe = "string";
          return;
      }
      throw Xe(X());
    },
    identifierNameStartEscape() {
      if (Ie !== "u")
        throw Xe(X());
      X();
      let e = _h();
      switch (e) {
        case "$":
        case "_":
          break;
        default:
          if (!xt.isIdStartChar(e))
            throw Jx();
          break;
      }
      ve += e, Fe = "identifierName";
    },
    identifierName() {
      switch (Ie) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          ve += X();
          return;
        case "\\":
          X(), Fe = "identifierNameEscape";
          return;
      }
      if (xt.isIdContinueChar(Ie)) {
        ve += X();
        return;
      }
      return Ze("identifier", ve);
    },
    identifierNameEscape() {
      if (Ie !== "u")
        throw Xe(X());
      X();
      let e = _h();
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!xt.isIdContinueChar(e))
            throw Jx();
          break;
      }
      ve += e, Fe = "identifierName";
    },
    sign() {
      switch (Ie) {
        case ".":
          ve = X(), Fe = "decimalPointLeading";
          return;
        case "0":
          ve = X(), Fe = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          ve = X(), Fe = "decimalInteger";
          return;
        case "I":
          return X(), ki("nfinity"), Ze("numeric", En * (1 / 0));
        case "N":
          return X(), ki("aN"), Ze("numeric", NaN);
      }
      throw Xe(X());
    },
    zero() {
      switch (Ie) {
        case ".":
          ve += X(), Fe = "decimalPoint";
          return;
        case "e":
        case "E":
          ve += X(), Fe = "decimalExponent";
          return;
        case "x":
        case "X":
          ve += X(), Fe = "hexadecimal";
          return;
      }
      return Ze("numeric", En * 0);
    },
    decimalInteger() {
      switch (Ie) {
        case ".":
          ve += X(), Fe = "decimalPoint";
          return;
        case "e":
        case "E":
          ve += X(), Fe = "decimalExponent";
          return;
      }
      if (xt.isDigit(Ie)) {
        ve += X();
        return;
      }
      return Ze("numeric", En * Number(ve));
    },
    decimalPointLeading() {
      if (xt.isDigit(Ie)) {
        ve += X(), Fe = "decimalFraction";
        return;
      }
      throw Xe(X());
    },
    decimalPoint() {
      switch (Ie) {
        case "e":
        case "E":
          ve += X(), Fe = "decimalExponent";
          return;
      }
      if (xt.isDigit(Ie)) {
        ve += X(), Fe = "decimalFraction";
        return;
      }
      return Ze("numeric", En * Number(ve));
    },
    decimalFraction() {
      switch (Ie) {
        case "e":
        case "E":
          ve += X(), Fe = "decimalExponent";
          return;
      }
      if (xt.isDigit(Ie)) {
        ve += X();
        return;
      }
      return Ze("numeric", En * Number(ve));
    },
    decimalExponent() {
      switch (Ie) {
        case "+":
        case "-":
          ve += X(), Fe = "decimalExponentSign";
          return;
      }
      if (xt.isDigit(Ie)) {
        ve += X(), Fe = "decimalExponentInteger";
        return;
      }
      throw Xe(X());
    },
    decimalExponentSign() {
      if (xt.isDigit(Ie)) {
        ve += X(), Fe = "decimalExponentInteger";
        return;
      }
      throw Xe(X());
    },
    decimalExponentInteger() {
      if (xt.isDigit(Ie)) {
        ve += X();
        return;
      }
      return Ze("numeric", En * Number(ve));
    },
    hexadecimal() {
      if (xt.isHexDigit(Ie)) {
        ve += X(), Fe = "hexadecimalInteger";
        return;
      }
      throw Xe(X());
    },
    hexadecimalInteger() {
      if (xt.isHexDigit(Ie)) {
        ve += X();
        return;
      }
      return Ze("numeric", En * Number(ve));
    },
    string() {
      switch (Ie) {
        case "\\":
          X(), ve += J9();
          return;
        case '"':
          if (Zo)
            return X(), Ze("string", ve);
          ve += X();
          return;
        case "'":
          if (!Zo)
            return X(), Ze("string", ve);
          ve += X();
          return;
        case `
`:
        case "\r":
          throw Xe(X());
        case "\u2028":
        case "\u2029":
          K9(Ie);
          break;
        case void 0:
          throw Xe(X());
      }
      ve += X();
    },
    start() {
      switch (Ie) {
        case "{":
        case "[":
          return Ze("punctuator", X());
      }
      Fe = "value";
    },
    beforePropertyName() {
      switch (Ie) {
        case "$":
        case "_":
          ve = X(), Fe = "identifierName";
          return;
        case "\\":
          X(), Fe = "identifierNameStartEscape";
          return;
        case "}":
          return Ze("punctuator", X());
        case '"':
        case "'":
          Zo = X() === '"', Fe = "string";
          return;
      }
      if (xt.isIdStartChar(Ie)) {
        ve += X(), Fe = "identifierName";
        return;
      }
      throw Xe(X());
    },
    afterPropertyName() {
      if (Ie === ":")
        return Ze("punctuator", X());
      throw Xe(X());
    },
    beforePropertyValue() {
      Fe = "value";
    },
    afterPropertyValue() {
      switch (Ie) {
        case ",":
        case "}":
          return Ze("punctuator", X());
      }
      throw Xe(X());
    },
    beforeArrayValue() {
      if (Ie === "]")
        return Ze("punctuator", X());
      Fe = "value";
    },
    afterArrayValue() {
      switch (Ie) {
        case ",":
        case "]":
          return Ze("punctuator", X());
      }
      throw Xe(X());
    },
    end() {
      throw Xe(X());
    }
  };
  function Ze(e, t) {
    return {
      type: e,
      value: t,
      line: Zn,
      column: Pr
    };
  }
  s(Ze, "newToken");
  function ki(e) {
    for (let t of e) {
      if (wn() !== t)
        throw Xe(X());
      X();
    }
  }
  s(ki, "literal");
  function J9() {
    switch (wn()) {
      case "b":
        return X(), "\b";
      case "f":
        return X(), "\f";
      case "n":
        return X(), `
`;
      case "r":
        return X(), "\r";
      case "t":
        return X(), "	";
      case "v":
        return X(), "\v";
      case "0":
        if (X(), xt.isDigit(wn()))
          throw Xe(X());
        return "\0";
      case "x":
        return X(), Z9();
      case "u":
        return X(), _h();
      case `
`:
      case "\u2028":
      case "\u2029":
        return X(), "";
      case "\r":
        return X(), wn() === `
` && X(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw Xe(X());
      case void 0:
        throw Xe(X());
    }
    return X();
  }
  s(J9, "escape");
  function Z9() {
    let e = "", t = wn();
    if (!xt.isHexDigit(t) || (e += X(), t = wn(), !xt.isHexDigit(t)))
      throw Xe(X());
    return e += X(), String.fromCodePoint(parseInt(e, 16));
  }
  s(Z9, "hexEscape");
  function _h() {
    let e = "", t = 4;
    for (; t-- > 0; ) {
      let r = wn();
      if (!xt.isHexDigit(r))
        throw Xe(X());
      e += X();
    }
    return String.fromCodePoint(parseInt(e, 16));
  }
  s(_h, "unicodeEscape");
  var X9 = {
    start() {
      if (bt.type === "eof")
        throw Ti();
      Sh();
    },
    beforePropertyName() {
      switch (bt.type) {
        case "identifier":
        case "string":
          kh = bt.value, Ot = "afterPropertyName";
          return;
        case "punctuator":
          ju();
          return;
        case "eof":
          throw Ti();
      }
    },
    afterPropertyName() {
      if (bt.type === "eof")
        throw Ti();
      Ot = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (bt.type === "eof")
        throw Ti();
      Sh();
    },
    beforeArrayValue() {
      if (bt.type === "eof")
        throw Ti();
      if (bt.type === "punctuator" && bt.value === "]") {
        ju();
        return;
      }
      Sh();
    },
    afterPropertyValue() {
      if (bt.type === "eof")
        throw Ti();
      switch (bt.value) {
        case ",":
          Ot = "beforePropertyName";
          return;
        case "}":
          ju();
      }
    },
    afterArrayValue() {
      if (bt.type === "eof")
        throw Ti();
      switch (bt.value) {
        case ",":
          Ot = "beforeArrayValue";
          return;
        case "]":
          ju();
      }
    },
    end() {
    }
  };
  function Sh() {
    let e;
    switch (bt.type) {
      case "punctuator":
        switch (bt.value) {
          case "{":
            e = {};
            break;
          case "[":
            e = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = bt.value;
        break;
    }
    if (Xo === void 0)
      Xo = e;
    else {
      let t = Cn[Cn.length - 1];
      Array.isArray(t) ? t.push(e) : Object.defineProperty(t, kh, {
        value: e,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (e !== null && typeof e == "object")
      Cn.push(e), Array.isArray(e) ? Ot = "beforeArrayValue" : Ot = "beforePropertyName";
    else {
      let t = Cn[Cn.length - 1];
      t == null ? Ot = "end" : Array.isArray(t) ? Ot = "afterArrayValue" : Ot = "afterPropertyValue";
    }
  }
  s(Sh, "push");
  function ju() {
    Cn.pop();
    let e = Cn[Cn.length - 1];
    e == null ? Ot = "end" : Array.isArray(e) ? Ot = "afterArrayValue" : Ot = "afterPropertyValue";
  }
  s(ju, "pop");
  function Xe(e) {
    return qu(e === void 0 ? `JSON5: invalid end of input at ${Zn}:${Pr}` : `JSON5: invalid character '${Xx(e)}' at ${Zn}:${Pr}`);
  }
  s(Xe, "invalidChar");
  function Ti() {
    return qu(`JSON5: invalid end of input at ${Zn}:${Pr}`);
  }
  s(Ti, "invalidEOF");
  function Jx() {
    return Pr -= 5, qu(`JSON5: invalid identifier character at ${Zn}:${Pr}`);
  }
  s(Jx, "invalidIdentifier");
  function K9(e) {
    console.warn(`JSON5: '${Xx(e)}' in strings is not valid ECMAScript; consider escaping`);
  }
  s(K9, "separatorChar");
  function Xx(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (t[e])
      return t[e];
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16);
      return "\\x" + ("00" + r).substring(r.length);
    }
    return e;
  }
  s(Xx, "formatChar");
  function qu(e) {
    let t = new SyntaxError(e);
    return t.lineNumber = Zn, t.columnNumber = Pr, t;
  }
  s(qu, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var eb = I((qoe, Qx) => {
  var Th = wh();
  Qx.exports = /* @__PURE__ */ s(function(t, r, n) {
    let i = [], o = "", a, u, l = "", c;
    if (r != null && typeof r == "object" && !Array.isArray(r) && (n = r.space, c = r.quote, r = r.replacer), typeof r == "function")
      u = r;
    else if (Array.isArray(r)) {
      a = [];
      for (let g of r) {
        let b;
        typeof g == "string" ? b = g : (typeof g == "number" || g instanceof String || g instanceof Number) && (b = String(g)), b !== void 0 &&
        a.indexOf(b) < 0 && a.push(b);
      }
    }
    return n instanceof Number ? n = Number(n) : n instanceof String && (n = String(n)), typeof n == "number" ? n > 0 && (n = Math.min(10, Math.
    floor(n)), l = "          ".substr(0, n)) : typeof n == "string" && (l = n.substr(0, 10)), p("", { "": t });
    function p(g, b) {
      let y = b[g];
      switch (y != null && (typeof y.toJSON5 == "function" ? y = y.toJSON5(g) : typeof y.toJSON == "function" && (y = y.toJSON(g))), u && (y =
      u.call(b, g, y)), y instanceof Number ? y = Number(y) : y instanceof String ? y = String(y) : y instanceof Boolean && (y = y.valueOf()),
      y) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof y == "string")
        return h(y, !1);
      if (typeof y == "number")
        return String(y);
      if (typeof y == "object")
        return Array.isArray(y) ? m(y) : f(y);
    }
    s(p, "serializeProperty");
    function h(g) {
      let b = {
        "'": 0.1,
        '"': 0.2
      }, y = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, E = "";
      for (let k = 0; k < g.length; k++) {
        let O = g[k];
        switch (O) {
          case "'":
          case '"':
            b[O]++, E += O;
            continue;
          case "\0":
            if (Th.isDigit(g[k + 1])) {
              E += "\\x00";
              continue;
            }
        }
        if (y[O]) {
          E += y[O];
          continue;
        }
        if (O < " ") {
          let w = O.charCodeAt(0).toString(16);
          E += "\\x" + ("00" + w).substring(w.length);
          continue;
        }
        E += O;
      }
      let A = c || Object.keys(b).reduce((k, O) => b[k] < b[O] ? k : O);
      return E = E.replace(new RegExp(A, "g"), y[A]), A + E + A;
    }
    s(h, "quoteString");
    function f(g) {
      if (i.indexOf(g) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      i.push(g);
      let b = o;
      o = o + l;
      let y = a || Object.keys(g), E = [];
      for (let k of y) {
        let O = p(k, g);
        if (O !== void 0) {
          let w = d(k) + ":";
          l !== "" && (w += " "), w += O, E.push(w);
        }
      }
      let A;
      if (E.length === 0)
        A = "{}";
      else {
        let k;
        if (l === "")
          k = E.join(","), A = "{" + k + "}";
        else {
          let O = `,
` + o;
          k = E.join(O), A = `{
` + o + k + `,
` + b + "}";
        }
      }
      return i.pop(), o = b, A;
    }
    s(f, "serializeObject");
    function d(g) {
      if (g.length === 0)
        return h(g, !0);
      let b = String.fromCodePoint(g.codePointAt(0));
      if (!Th.isIdStartChar(b))
        return h(g, !0);
      for (let y = b.length; y < g.length; y++)
        if (!Th.isIdContinueChar(String.fromCodePoint(g.codePointAt(y))))
          return h(g, !0);
      return g;
    }
    s(d, "serializeKey");
    function m(g) {
      if (i.indexOf(g) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      i.push(g);
      let b = o;
      o = o + l;
      let y = [];
      for (let A = 0; A < g.length; A++) {
        let k = p(String(A), g);
        y.push(k !== void 0 ? k : "null");
      }
      let E;
      if (y.length === 0)
        E = "[]";
      else if (l === "")
        E = "[" + y.join(",") + "]";
      else {
        let A = `,
` + o, k = y.join(A);
        E = `[
` + o + k + `,
` + b + "]";
      }
      return i.pop(), o = b, E;
    }
    s(m, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var rb = I((Voe, tb) => {
  var Y9 = Yx(), Q9 = eb(), e4 = {
    parse: Y9,
    stringify: Q9
  };
  tb.exports = e4;
});

// ../node_modules/strip-bom/index.js
var ib = I((Uoe, nb) => {
  "use strict";
  nb.exports = (e) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string, got " + typeof e);
    return e.charCodeAt(0) === 65279 ? e.slice(1) : e;
  };
});

// ../node_modules/tsconfig-paths/lib/tsconfig-loader.js
var ab = I((Kr) => {
  "use strict";
  var Ii = Kr && Kr.__assign || function() {
    return Ii = Object.assign || function(e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) {
        t = arguments[r];
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      }
      return e;
    }, Ii.apply(this, arguments);
  };
  Object.defineProperty(Kr, "__esModule", { value: !0 });
  Kr.loadTsconfig = Kr.walkForTsConfig = Kr.tsConfigLoader = void 0;
  var Br = require("path"), Ko = require("fs"), t4 = rb(), r4 = ib();
  function n4(e) {
    var t = e.getEnv, r = e.cwd, n = e.loadSync, i = n === void 0 ? i4 : n, o = t("TS_NODE_PROJECT"), a = t("TS_NODE_BASEURL"), u = i(r, o, a);
    return u;
  }
  s(n4, "tsConfigLoader");
  Kr.tsConfigLoader = n4;
  function i4(e, t, r) {
    var n = s4(e, t);
    if (!n)
      return {
        tsConfigPath: void 0,
        baseUrl: void 0,
        paths: void 0
      };
    var i = Ph(n);
    return {
      tsConfigPath: n,
      baseUrl: r || i && i.compilerOptions && i.compilerOptions.baseUrl,
      paths: i && i.compilerOptions && i.compilerOptions.paths
    };
  }
  s(i4, "loadSyncDefault");
  function s4(e, t) {
    if (t) {
      var r = Ko.lstatSync(t).isDirectory() ? Br.resolve(t, "./tsconfig.json") : Br.resolve(e, t);
      return r;
    }
    if (Ko.statSync(e).isFile())
      return Br.resolve(e);
    var n = Ih(e);
    return n ? Br.resolve(n) : void 0;
  }
  s(s4, "resolveConfigPath");
  function Ih(e, t) {
    t === void 0 && (t = Ko.readdirSync);
    for (var r = t(e), n = ["tsconfig.json", "jsconfig.json"], i = 0, o = n; i < o.length; i++) {
      var a = o[i];
      if (r.indexOf(a) !== -1)
        return Br.join(e, a);
    }
    var u = Br.dirname(e);
    if (e !== u)
      return Ih(u, t);
  }
  s(Ih, "walkForTsConfig");
  Kr.walkForTsConfig = Ih;
  function Ph(e, t, r) {
    if (t === void 0 && (t = Ko.existsSync), r === void 0 && (r = /* @__PURE__ */ s(function(l) {
      return Ko.readFileSync(l, "utf8");
    }, "readFileSync")), !!t(e)) {
      var n = r(e), i = r4(n), o;
      try {
        o = t4.parse(i);
      } catch (l) {
        throw new Error("".concat(e, " is malformed ").concat(l.message));
      }
      var a = o.extends;
      if (a) {
        var u = void 0;
        return Array.isArray(a) ? u = a.reduce(function(l, c) {
          return ob(l, sb(e, c, t, r));
        }, {}) : u = sb(e, a, t, r), ob(u, o);
      }
      return o;
    }
  }
  s(Ph, "loadTsconfig");
  Kr.loadTsconfig = Ph;
  function sb(e, t, r, n) {
    var i;
    typeof t == "string" && t.indexOf(".json") === -1 && (t += ".json");
    var o = Br.dirname(e), a = Br.join(o, t);
    t.indexOf("/") !== -1 && t.indexOf(".") !== -1 && !r(a) && (a = Br.join(o, "node_modules", t));
    var u = Ph(a, r, n) || {};
    if (!((i = u.compilerOptions) === null || i === void 0) && i.baseUrl) {
      var l = Br.dirname(t);
      u.compilerOptions.baseUrl = Br.join(l, u.compilerOptions.baseUrl);
    }
    return u;
  }
  s(sb, "loadTsconfigFromExtends");
  function ob(e, t) {
    return e = e || {}, t = t || {}, Ii(Ii(Ii({}, e), t), { compilerOptions: Ii(Ii({}, e.compilerOptions), t.compilerOptions) });
  }
  s(ob, "mergeTsconfigs");
});

// ../node_modules/tsconfig-paths/lib/config-loader.js
var Bh = I((Es) => {
  "use strict";
  Object.defineProperty(Es, "__esModule", { value: !0 });
  Es.configLoader = Es.loadConfig = void 0;
  var o4 = ab(), $u = require("path");
  function a4(e) {
    return e === void 0 && (e = process.cwd()), ub({ cwd: e });
  }
  s(a4, "loadConfig");
  Es.loadConfig = a4;
  function ub(e) {
    var t = e.cwd, r = e.explicitParams, n = e.tsConfigLoader, i = n === void 0 ? o4.tsConfigLoader : n;
    if (r) {
      var o = $u.isAbsolute(r.baseUrl) ? r.baseUrl : $u.join(t, r.baseUrl);
      return {
        resultType: "success",
        configFileAbsolutePath: "",
        baseUrl: r.baseUrl,
        absoluteBaseUrl: o,
        paths: r.paths,
        mainFields: r.mainFields,
        addMatchAll: r.addMatchAll
      };
    }
    var a = i({
      cwd: t,
      getEnv: /* @__PURE__ */ s(function(u) {
        return process.env[u];
      }, "getEnv")
    });
    return a.tsConfigPath ? {
      resultType: "success",
      configFileAbsolutePath: a.tsConfigPath,
      baseUrl: a.baseUrl,
      absoluteBaseUrl: $u.resolve($u.dirname(a.tsConfigPath), a.baseUrl || ""),
      paths: a.paths || {},
      addMatchAll: a.baseUrl !== void 0
    } : {
      resultType: "failed",
      message: "Couldn't find tsconfig.json"
    };
  }
  s(ub, "configLoader");
  Es.configLoader = ub;
});

// ../node_modules/minimist/index.js
var hb = I((Joe, pb) => {
  "use strict";
  function u4(e, t) {
    var r = e;
    t.slice(0, -1).forEach(function(i) {
      r = r[i] || {};
    });
    var n = t[t.length - 1];
    return n in r;
  }
  s(u4, "hasKey");
  function lb(e) {
    return typeof e == "number" || /^0x[0-9a-f]+$/i.test(e) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e);
  }
  s(lb, "isNumber");
  function cb(e, t) {
    return t === "constructor" && typeof e[t] == "function" || t === "__proto__";
  }
  s(cb, "isConstructorOrProto");
  pb.exports = function(e, t) {
    t || (t = {});
    var r = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    typeof t.unknown == "function" && (r.unknownFn = t.unknown), typeof t.boolean == "boolean" && t.boolean ? r.allBools = !0 : [].concat(t.
    boolean).filter(Boolean).forEach(function(k) {
      r.bools[k] = !0;
    });
    var n = {};
    function i(k) {
      return n[k].some(function(O) {
        return r.bools[O];
      });
    }
    s(i, "aliasIsBoolean"), Object.keys(t.alias || {}).forEach(function(k) {
      n[k] = [].concat(t.alias[k]), n[k].forEach(function(O) {
        n[O] = [k].concat(n[k].filter(function(w) {
          return O !== w;
        }));
      });
    }), [].concat(t.string).filter(Boolean).forEach(function(k) {
      r.strings[k] = !0, n[k] && [].concat(n[k]).forEach(function(O) {
        r.strings[O] = !0;
      });
    });
    var o = t.default || {}, a = { _: [] };
    function u(k, O) {
      return r.allBools && /^--[^=]+$/.test(O) || r.strings[k] || r.bools[k] || n[k];
    }
    s(u, "argDefined");
    function l(k, O, w) {
      for (var C = k, T = 0; T < O.length - 1; T++) {
        var F = O[T];
        if (cb(C, F))
          return;
        C[F] === void 0 && (C[F] = {}), (C[F] === Object.prototype || C[F] === Number.prototype || C[F] === String.prototype) && (C[F] = {}),
        C[F] === Array.prototype && (C[F] = []), C = C[F];
      }
      var $ = O[O.length - 1];
      cb(C, $) || ((C === Object.prototype || C === Number.prototype || C === String.prototype) && (C = {}), C === Array.prototype && (C = []),
      C[$] === void 0 || r.bools[$] || typeof C[$] == "boolean" ? C[$] = w : Array.isArray(C[$]) ? C[$].push(w) : C[$] = [C[$], w]);
    }
    s(l, "setKey");
    function c(k, O, w) {
      if (!(w && r.unknownFn && !u(k, w) && r.unknownFn(w) === !1)) {
        var C = !r.strings[k] && lb(O) ? Number(O) : O;
        l(a, k.split("."), C), (n[k] || []).forEach(function(T) {
          l(a, T.split("."), C);
        });
      }
    }
    s(c, "setArg"), Object.keys(r.bools).forEach(function(k) {
      c(k, o[k] === void 0 ? !1 : o[k]);
    });
    var p = [];
    e.indexOf("--") !== -1 && (p = e.slice(e.indexOf("--") + 1), e = e.slice(0, e.indexOf("--")));
    for (var h = 0; h < e.length; h++) {
      var f = e[h], d, m;
      if (/^--.+=/.test(f)) {
        var g = f.match(/^--([^=]+)=([\s\S]*)$/);
        d = g[1];
        var b = g[2];
        r.bools[d] && (b = b !== "false"), c(d, b, f);
      } else if (/^--no-.+/.test(f))
        d = f.match(/^--no-(.+)/)[1], c(d, !1, f);
      else if (/^--.+/.test(f))
        d = f.match(/^--(.+)/)[1], m = e[h + 1], m !== void 0 && !/^(-|--)[^-]/.test(m) && !r.bools[d] && !r.allBools && (!n[d] || !i(d)) ? (c(
        d, m, f), h += 1) : /^(true|false)$/.test(m) ? (c(d, m === "true", f), h += 1) : c(d, r.strings[d] ? "" : !0, f);
      else if (/^-[^-]+/.test(f)) {
        for (var y = f.slice(1, -1).split(""), E = !1, A = 0; A < y.length; A++) {
          if (m = f.slice(A + 2), m === "-") {
            c(y[A], m, f);
            continue;
          }
          if (/[A-Za-z]/.test(y[A]) && m[0] === "=") {
            c(y[A], m.slice(1), f), E = !0;
            break;
          }
          if (/[A-Za-z]/.test(y[A]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(m)) {
            c(y[A], m, f), E = !0;
            break;
          }
          if (y[A + 1] && y[A + 1].match(/\W/)) {
            c(y[A], f.slice(A + 2), f), E = !0;
            break;
          } else
            c(y[A], r.strings[y[A]] ? "" : !0, f);
        }
        d = f.slice(-1)[0], !E && d !== "-" && (e[h + 1] && !/^(-|--)[^-]/.test(e[h + 1]) && !r.bools[d] && (!n[d] || !i(d)) ? (c(d, e[h + 1],
        f), h += 1) : e[h + 1] && /^(true|false)$/.test(e[h + 1]) ? (c(d, e[h + 1] === "true", f), h += 1) : c(d, r.strings[d] ? "" : !0, f));
      } else if ((!r.unknownFn || r.unknownFn(f) !== !1) && a._.push(r.strings._ || !lb(f) ? f : Number(f)), t.stopEarly) {
        a._.push.apply(a._, e.slice(h + 1));
        break;
      }
    }
    return Object.keys(o).forEach(function(k) {
      u4(a, k.split(".")) || (l(a, k.split("."), o[k]), (n[k] || []).forEach(function(O) {
        l(a, O.split("."), o[k]);
      }));
    }), t["--"] ? a["--"] = p.slice() : p.forEach(function(k) {
      a._.push(k);
    }), a;
  };
});

// ../node_modules/tsconfig-paths/lib/register.js
var fb = I((Cs) => {
  "use strict";
  var l4 = Cs && Cs.__spreadArray || function(e, t, r) {
    if (r || arguments.length === 2) for (var n = 0, i = t.length, o; n < i; n++)
      (o || !(n in t)) && (o || (o = Array.prototype.slice.call(t, 0, n)), o[n] = t[n]);
    return e.concat(o || Array.prototype.slice.call(t));
  };
  Object.defineProperty(Cs, "__esModule", { value: !0 });
  Cs.register = void 0;
  var c4 = vh(), p4 = Bh(), h4 = /* @__PURE__ */ s(function() {
  }, "noOp");
  function f4(e) {
    e = e || [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "crypto",
      "dgram",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "net",
      "os",
      "path",
      "punycode",
      "querystring",
      "readline",
      "stream",
      "string_decoder",
      "tls",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "zlib"
    ];
    for (var t = {}, r = 0, n = e; r < n.length; r++) {
      var i = n[r];
      t[i] = !0;
    }
    return t;
  }
  s(f4, "getCoreModules");
  function d4(e) {
    var t, r;
    if (e)
      t = e.cwd, (e.baseUrl || e.paths) && (r = e);
    else {
      var n = hb(), i = n(process.argv.slice(2), {
        // eslint-disable-next-line id-denylist
        string: ["project"],
        alias: {
          project: ["P"]
        }
      });
      t = i.project;
    }
    var o = (0, p4.configLoader)({
      cwd: t ?? process.cwd(),
      explicitParams: r
    });
    if (o.resultType === "failed")
      return console.warn("".concat(o.message, ". tsconfig-paths will be skipped")), h4;
    var a = (0, c4.createMatchPath)(o.absoluteBaseUrl, o.paths, o.mainFields, o.addMatchAll), u = require("module"), l = u._resolveFilename,
    c = f4(u.builtinModules);
    return u._resolveFilename = function(p, h) {
      var f = c.hasOwnProperty(p);
      if (!f) {
        var d = a(p);
        if (d) {
          var m = l4([d], [].slice.call(arguments, 1), !0);
          return l.apply(this, m);
        }
      }
      return l.apply(this, arguments);
    }, function() {
      u._resolveFilename = l;
    };
  }
  s(d4, "register");
  Cs.register = d4;
});

// ../node_modules/tsconfig-paths/lib/index.js
var gb = I(($t) => {
  "use strict";
  Object.defineProperty($t, "__esModule", { value: !0 });
  $t.loadConfig = $t.register = $t.matchFromAbsolutePathsAsync = $t.createMatchPathAsync = $t.matchFromAbsolutePaths = $t.createMatchPath = void 0;
  var db = vh();
  Object.defineProperty($t, "createMatchPath", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return db.createMatchPath;
  }, "get") });
  Object.defineProperty($t, "matchFromAbsolutePaths", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return db.matchFromAbsolutePaths;
  }, "get") });
  var mb = zx();
  Object.defineProperty($t, "createMatchPathAsync", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return mb.createMatchPathAsync;
  }, "get") });
  Object.defineProperty($t, "matchFromAbsolutePathsAsync", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return mb.matchFromAbsolutePathsAsync;
  }, "get") });
  var m4 = fb();
  Object.defineProperty($t, "register", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return m4.register;
  }, "get") });
  var g4 = Bh();
  Object.defineProperty($t, "loadConfig", { enumerable: !0, get: /* @__PURE__ */ s(function() {
    return g4.loadConfig;
  }, "get") });
});

// ../node_modules/globby/node_modules/@sindresorhus/merge-streams/index.js
function qh(e) {
  if (!Array.isArray(e))
    throw new TypeError(`Expected an array, got \`${typeof e}\`.`);
  for (let i of e)
    Lh(i);
  let t = e.some(({ readableObjectMode: i }) => i), r = x4(e, t), n = new Nh({
    objectMode: t,
    writableHighWaterMark: r,
    readableHighWaterMark: r
  });
  for (let i of e)
    n.add(i);
  return e.length === 0 && Ib(n), n;
}
var Uu, _b, Mh, x4, Nh, b4, v4, E4, Lh, C4, kb, w4, S4, A4, Tb, Ib, jh, Pb, F4, Vu, Ab, Fb, Bb = wt(() => {
  Uu = require("node:events"), _b = require("node:stream"), Mh = require("node:stream/promises");
  s(qh, "mergeStreams");
  x4 = /* @__PURE__ */ s((e, t) => {
    if (e.length === 0)
      return 16384;
    let r = e.filter(({ readableObjectMode: n }) => n === t).map(({ readableHighWaterMark: n }) => n);
    return Math.max(...r);
  }, "getHighWaterMark"), Nh = class extends _b.PassThrough {
    static {
      s(this, "MergedStream");
    }
    #t = /* @__PURE__ */ new Set([]);
    #r = /* @__PURE__ */ new Set([]);
    #e = /* @__PURE__ */ new Set([]);
    #n;
    add(t) {
      Lh(t), !this.#t.has(t) && (this.#t.add(t), this.#n ??= b4(this, this.#t), C4({
        passThroughStream: this,
        stream: t,
        streams: this.#t,
        ended: this.#r,
        aborted: this.#e,
        onFinished: this.#n
      }), t.pipe(this, { end: !1 }));
    }
    remove(t) {
      return Lh(t), this.#t.has(t) ? (t.unpipe(this), !0) : !1;
    }
  }, b4 = /* @__PURE__ */ s(async (e, t) => {
    Vu(e, Ab);
    let r = new AbortController();
    try {
      await Promise.race([
        v4(e, r),
        E4(e, t, r)
      ]);
    } finally {
      r.abort(), Vu(e, -Ab);
    }
  }, "onMergedStreamFinished"), v4 = /* @__PURE__ */ s(async (e, { signal: t }) => {
    await (0, Mh.finished)(e, { signal: t, cleanup: !0 });
  }, "onMergedStreamEnd"), E4 = /* @__PURE__ */ s(async (e, t, { signal: r }) => {
    for await (let [n] of (0, Uu.on)(e, "unpipe", { signal: r }))
      t.has(n) && n.emit(Tb);
  }, "onInputStreamsUnpipe"), Lh = /* @__PURE__ */ s((e) => {
    if (typeof e?.pipe != "function")
      throw new TypeError(`Expected a readable stream, got: \`${typeof e}\`.`);
  }, "validateStream"), C4 = /* @__PURE__ */ s(async ({ passThroughStream: e, stream: t, streams: r, ended: n, aborted: i, onFinished: o }) => {
    Vu(e, Fb);
    let a = new AbortController();
    try {
      await Promise.race([
        w4(o, t),
        S4({ passThroughStream: e, stream: t, streams: r, ended: n, aborted: i, controller: a }),
        A4({ stream: t, streams: r, ended: n, aborted: i, controller: a })
      ]);
    } finally {
      a.abort(), Vu(e, -Fb);
    }
    r.size === n.size + i.size && (n.size === 0 && i.size > 0 ? jh(e) : Ib(e));
  }, "endWhenStreamsDone"), kb = /* @__PURE__ */ s((e) => e?.code === "ERR_STREAM_PREMATURE_CLOSE", "isAbortError"), w4 = /* @__PURE__ */ s(
  async (e, t) => {
    try {
      await e, jh(t);
    } catch (r) {
      kb(r) ? jh(t) : Pb(t, r);
    }
  }, "afterMergedStreamFinished"), S4 = /* @__PURE__ */ s(async ({ passThroughStream: e, stream: t, streams: r, ended: n, aborted: i, controller: {
  signal: o } }) => {
    try {
      await (0, Mh.finished)(t, { signal: o, cleanup: !0, readable: !0, writable: !1 }), r.has(t) && n.add(t);
    } catch (a) {
      if (o.aborted || !r.has(t))
        return;
      kb(a) ? i.add(t) : Pb(e, a);
    }
  }, "onInputStreamEnd"), A4 = /* @__PURE__ */ s(async ({ stream: e, streams: t, ended: r, aborted: n, controller: { signal: i } }) => {
    await (0, Uu.once)(e, Tb, { signal: i }), t.delete(e), r.delete(e), n.delete(e);
  }, "onInputStreamUnpipe"), Tb = Symbol("unpipe"), Ib = /* @__PURE__ */ s((e) => {
    e.writable && e.end();
  }, "endStream"), jh = /* @__PURE__ */ s((e) => {
    (e.readable || e.writable) && e.destroy();
  }, "abortStream"), Pb = /* @__PURE__ */ s((e, t) => {
    e.destroyed || (e.once("error", F4), e.destroy(t));
  }, "errorStream"), F4 = /* @__PURE__ */ s(() => {
  }, "noop"), Vu = /* @__PURE__ */ s((e, t) => {
    let r = e.getMaxListeners();
    r !== 0 && r !== Number.POSITIVE_INFINITY && e.setMaxListeners(r + t);
  }, "updateMaxListeners"), Ab = 2, Fb = 1;
});

// ../node_modules/fast-glob/out/utils/array.js
var Ob = I((ws) => {
  "use strict";
  Object.defineProperty(ws, "__esModule", { value: !0 });
  ws.splitWhen = ws.flatten = void 0;
  function _4(e) {
    return e.reduce((t, r) => [].concat(t, r), []);
  }
  s(_4, "flatten");
  ws.flatten = _4;
  function k4(e, t) {
    let r = [[]], n = 0;
    for (let i of e)
      t(i) ? (n++, r[n] = []) : r[n].push(i);
    return r;
  }
  s(k4, "splitWhen");
  ws.splitWhen = k4;
});

// ../node_modules/fast-glob/out/utils/errno.js
var Rb = I((Wu) => {
  "use strict";
  Object.defineProperty(Wu, "__esModule", { value: !0 });
  Wu.isEnoentCodeError = void 0;
  function T4(e) {
    return e.code === "ENOENT";
  }
  s(T4, "isEnoentCodeError");
  Wu.isEnoentCodeError = T4;
});

// ../node_modules/fast-glob/out/utils/fs.js
var Nb = I((zu) => {
  "use strict";
  Object.defineProperty(zu, "__esModule", { value: !0 });
  zu.createDirentFromStats = void 0;
  var $h = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function I4(e, t) {
    return new $h(e, t);
  }
  s(I4, "createDirentFromStats");
  zu.createDirentFromStats = I4;
});

// ../node_modules/fast-glob/out/utils/path.js
var qb = I((dt) => {
  "use strict";
  Object.defineProperty(dt, "__esModule", { value: !0 });
  dt.convertPosixPathToPattern = dt.convertWindowsPathToPattern = dt.convertPathToPattern = dt.escapePosixPath = dt.escapeWindowsPath = dt.escape =
  dt.removeLeadingDotSegment = dt.makeAbsolute = dt.unixify = void 0;
  var P4 = require("os"), B4 = require("path"), Lb = P4.platform() === "win32", O4 = 2, R4 = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g,
  N4 = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, L4 = /^\\\\([.?])/, j4 = /\\(?![!()+@[\]{}])/g;
  function M4(e) {
    return e.replace(/\\/g, "/");
  }
  s(M4, "unixify");
  dt.unixify = M4;
  function q4(e, t) {
    return B4.resolve(e, t);
  }
  s(q4, "makeAbsolute");
  dt.makeAbsolute = q4;
  function $4(e) {
    if (e.charAt(0) === ".") {
      let t = e.charAt(1);
      if (t === "/" || t === "\\")
        return e.slice(O4);
    }
    return e;
  }
  s($4, "removeLeadingDotSegment");
  dt.removeLeadingDotSegment = $4;
  dt.escape = Lb ? Vh : Uh;
  function Vh(e) {
    return e.replace(N4, "\\$2");
  }
  s(Vh, "escapeWindowsPath");
  dt.escapeWindowsPath = Vh;
  function Uh(e) {
    return e.replace(R4, "\\$2");
  }
  s(Uh, "escapePosixPath");
  dt.escapePosixPath = Uh;
  dt.convertPathToPattern = Lb ? jb : Mb;
  function jb(e) {
    return Vh(e).replace(L4, "//$1").replace(j4, "/");
  }
  s(jb, "convertWindowsPathToPattern");
  dt.convertWindowsPathToPattern = jb;
  function Mb(e) {
    return Uh(e);
  }
  s(Mb, "convertPosixPathToPattern");
  dt.convertPosixPathToPattern = Mb;
});

// ../node_modules/is-extglob/index.js
var Vb = I((Sae, $b) => {
  $b.exports = /* @__PURE__ */ s(function(t) {
    if (typeof t != "string" || t === "")
      return !1;
    for (var r; r = /(\\).|([@?!+*]\(.*\))/g.exec(t); ) {
      if (r[2]) return !0;
      t = t.slice(r.index + r[0].length);
    }
    return !1;
  }, "isExtglob");
});

// ../node_modules/is-glob/index.js
var zb = I((Fae, Wb) => {
  var V4 = Vb(), Ub = { "{": "}", "(": ")", "[": "]" }, U4 = /* @__PURE__ */ s(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0, r = -2, n = -2, i = -2, o = -2, a = -2; t < e.length; ) {
      if (e[t] === "*" || e[t + 1] === "?" && /[\].+)]/.test(e[t]) || n !== -1 && e[t] === "[" && e[t + 1] !== "]" && (n < t && (n = e.indexOf(
      "]", t)), n > t && (a === -1 || a > n || (a = e.indexOf("\\", t), a === -1 || a > n))) || i !== -1 && e[t] === "{" && e[t + 1] !== "}" &&
      (i = e.indexOf("}", t), i > t && (a = e.indexOf("\\", t), a === -1 || a > i)) || o !== -1 && e[t] === "(" && e[t + 1] === "?" && /[:!=]/.
      test(e[t + 2]) && e[t + 3] !== ")" && (o = e.indexOf(")", t), o > t && (a = e.indexOf("\\", t), a === -1 || a > o)) || r !== -1 && e[t] ===
      "(" && e[t + 1] !== "|" && (r < t && (r = e.indexOf("|", t)), r !== -1 && e[r + 1] !== ")" && (o = e.indexOf(")", r), o > r && (a = e.
      indexOf("\\", r), a === -1 || a > o))))
        return !0;
      if (e[t] === "\\") {
        var u = e[t + 1];
        t += 2;
        var l = Ub[u];
        if (l) {
          var c = e.indexOf(l, t);
          c !== -1 && (t = c + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "strictCheck"), W4 = /* @__PURE__ */ s(function(e) {
    if (e[0] === "!")
      return !0;
    for (var t = 0; t < e.length; ) {
      if (/[*?{}()[\]]/.test(e[t]))
        return !0;
      if (e[t] === "\\") {
        var r = e[t + 1];
        t += 2;
        var n = Ub[r];
        if (n) {
          var i = e.indexOf(n, t);
          i !== -1 && (t = i + 1);
        }
        if (e[t] === "!")
          return !0;
      } else
        t++;
    }
    return !1;
  }, "relaxedCheck");
  Wb.exports = /* @__PURE__ */ s(function(t, r) {
    if (typeof t != "string" || t === "")
      return !1;
    if (V4(t))
      return !0;
    var n = U4;
    return r && r.strict === !1 && (n = W4), n(t);
  }, "isGlob");
});

// ../node_modules/fast-glob/node_modules/glob-parent/index.js
var Gb = I((kae, Hb) => {
  "use strict";
  var z4 = zb(), H4 = require("path").posix.dirname, G4 = require("os").platform() === "win32", Wh = "/", J4 = /\\/g, Z4 = /[\{\[].*[\}\]]$/,
  X4 = /(^|[^\\])([\{\[]|\([^\)]+$)/, K4 = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  Hb.exports = /* @__PURE__ */ s(function(t, r) {
    var n = Object.assign({ flipBackslashes: !0 }, r);
    n.flipBackslashes && G4 && t.indexOf(Wh) < 0 && (t = t.replace(J4, Wh)), Z4.test(t) && (t += Wh), t += "a";
    do
      t = H4(t);
    while (z4(t) || X4.test(t));
    return t.replace(K4, "$1");
  }, "globParent");
});

// ../node_modules/braces/lib/utils.js
var Hu = I((ur) => {
  "use strict";
  ur.isInteger = (e) => typeof e == "number" ? Number.isInteger(e) : typeof e == "string" && e.trim() !== "" ? Number.isInteger(Number(e)) :
  !1;
  ur.find = (e, t) => e.nodes.find((r) => r.type === t);
  ur.exceedsLimit = (e, t, r = 1, n) => n === !1 || !ur.isInteger(e) || !ur.isInteger(t) ? !1 : (Number(t) - Number(e)) / Number(r) >= n;
  ur.escapeNode = (e, t = 0, r) => {
    let n = e.nodes[t];
    n && (r && n.type === r || n.type === "open" || n.type === "close") && n.escaped !== !0 && (n.value = "\\" + n.value, n.escaped = !0);
  };
  ur.encloseBrace = (e) => e.type !== "brace" ? !1 : e.commas >> 0 + e.ranges >> 0 === 0 ? (e.invalid = !0, !0) : !1;
  ur.isInvalidBrace = (e) => e.type !== "brace" ? !1 : e.invalid === !0 || e.dollar ? !0 : e.commas >> 0 + e.ranges >> 0 === 0 || e.open !==
  !0 || e.close !== !0 ? (e.invalid = !0, !0) : !1;
  ur.isOpenOrClose = (e) => e.type === "open" || e.type === "close" ? !0 : e.open === !0 || e.close === !0;
  ur.reduce = (e) => e.reduce((t, r) => (r.type === "text" && t.push(r.value), r.type === "range" && (r.type = "text"), t), []);
  ur.flatten = (...e) => {
    let t = [], r = /* @__PURE__ */ s((n) => {
      for (let i = 0; i < n.length; i++) {
        let o = n[i];
        if (Array.isArray(o)) {
          r(o);
          continue;
        }
        o !== void 0 && t.push(o);
      }
      return t;
    }, "flat");
    return r(e), t;
  };
});

// ../node_modules/braces/lib/stringify.js
var Gu = I((Bae, Zb) => {
  "use strict";
  var Jb = Hu();
  Zb.exports = (e, t = {}) => {
    let r = /* @__PURE__ */ s((n, i = {}) => {
      let o = t.escapeInvalid && Jb.isInvalidBrace(i), a = n.invalid === !0 && t.escapeInvalid === !0, u = "";
      if (n.value)
        return (o || a) && Jb.isOpenOrClose(n) ? "\\" + n.value : n.value;
      if (n.value)
        return n.value;
      if (n.nodes)
        for (let l of n.nodes)
          u += r(l);
      return u;
    }, "stringify");
    return r(e);
  };
});

// ../node_modules/is-number/index.js
var Kb = I((Rae, Xb) => {
  "use strict";
  Xb.exports = function(e) {
    return typeof e == "number" ? e - e === 0 : typeof e == "string" && e.trim() !== "" ? Number.isFinite ? Number.isFinite(+e) : isFinite(+e) :
    !1;
  };
});

// ../node_modules/to-regex-range/index.js
var ov = I((Nae, sv) => {
  "use strict";
  var Yb = Kb(), Pi = /* @__PURE__ */ s((e, t, r) => {
    if (Yb(e) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (t === void 0 || e === t)
      return String(e);
    if (Yb(t) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let n = { relaxZeros: !0, ...r };
    typeof n.strictZeros == "boolean" && (n.relaxZeros = n.strictZeros === !1);
    let i = String(n.relaxZeros), o = String(n.shorthand), a = String(n.capture), u = String(n.wrap), l = e + ":" + t + "=" + i + o + a + u;
    if (Pi.cache.hasOwnProperty(l))
      return Pi.cache[l].result;
    let c = Math.min(e, t), p = Math.max(e, t);
    if (Math.abs(c - p) === 1) {
      let g = e + "|" + t;
      return n.capture ? `(${g})` : n.wrap === !1 ? g : `(?:${g})`;
    }
    let h = iv(e) || iv(t), f = { min: e, max: t, a: c, b: p }, d = [], m = [];
    if (h && (f.isPadded = h, f.maxLen = String(f.max).length), c < 0) {
      let g = p < 0 ? Math.abs(p) : 1;
      m = Qb(g, Math.abs(c), f, n), c = f.a = 0;
    }
    return p >= 0 && (d = Qb(c, p, f, n)), f.negatives = m, f.positives = d, f.result = Y4(m, d, n), n.capture === !0 ? f.result = `(${f.result}\
)` : n.wrap !== !1 && d.length + m.length > 1 && (f.result = `(?:${f.result})`), Pi.cache[l] = f, f.result;
  }, "toRegexRange");
  function Y4(e, t, r) {
    let n = zh(e, t, "-", !1, r) || [], i = zh(t, e, "", !1, r) || [], o = zh(e, t, "-?", !0, r) || [];
    return n.concat(o).concat(i).join("|");
  }
  s(Y4, "collatePatterns");
  function Q4(e, t) {
    let r = 1, n = 1, i = tv(e, r), o = /* @__PURE__ */ new Set([t]);
    for (; e <= i && i <= t; )
      o.add(i), r += 1, i = tv(e, r);
    for (i = rv(t + 1, n) - 1; e < i && i <= t; )
      o.add(i), n += 1, i = rv(t + 1, n) - 1;
    return o = [...o], o.sort(rN), o;
  }
  s(Q4, "splitToRanges");
  function eN(e, t, r) {
    if (e === t)
      return { pattern: e, count: [], digits: 0 };
    let n = tN(e, t), i = n.length, o = "", a = 0;
    for (let u = 0; u < i; u++) {
      let [l, c] = n[u];
      l === c ? o += l : l !== "0" || c !== "9" ? o += nN(l, c, r) : a++;
    }
    return a && (o += r.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: o, count: [a], digits: i };
  }
  s(eN, "rangeToPattern");
  function Qb(e, t, r, n) {
    let i = Q4(e, t), o = [], a = e, u;
    for (let l = 0; l < i.length; l++) {
      let c = i[l], p = eN(String(a), String(c), n), h = "";
      if (!r.isPadded && u && u.pattern === p.pattern) {
        u.count.length > 1 && u.count.pop(), u.count.push(p.count[0]), u.string = u.pattern + nv(u.count), a = c + 1;
        continue;
      }
      r.isPadded && (h = iN(c, r, n)), p.string = h + p.pattern + nv(p.count), o.push(p), a = c + 1, u = p;
    }
    return o;
  }
  s(Qb, "splitToPatterns");
  function zh(e, t, r, n, i) {
    let o = [];
    for (let a of e) {
      let { string: u } = a;
      !n && !ev(t, "string", u) && o.push(r + u), n && ev(t, "string", u) && o.push(r + u);
    }
    return o;
  }
  s(zh, "filterPatterns");
  function tN(e, t) {
    let r = [];
    for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);
    return r;
  }
  s(tN, "zip");
  function rN(e, t) {
    return e > t ? 1 : t > e ? -1 : 0;
  }
  s(rN, "compare");
  function ev(e, t, r) {
    return e.some((n) => n[t] === r);
  }
  s(ev, "contains");
  function tv(e, t) {
    return Number(String(e).slice(0, -t) + "9".repeat(t));
  }
  s(tv, "countNines");
  function rv(e, t) {
    return e - e % Math.pow(10, t);
  }
  s(rv, "countZeros");
  function nv(e) {
    let [t = 0, r = ""] = e;
    return r || t > 1 ? `{${t + (r ? "," + r : "")}}` : "";
  }
  s(nv, "toQuantifier");
  function nN(e, t, r) {
    return `[${e}${t - e === 1 ? "" : "-"}${t}]`;
  }
  s(nN, "toCharacterClass");
  function iv(e) {
    return /^-?(0+)\d/.test(e);
  }
  s(iv, "hasPadding");
  function iN(e, t, r) {
    if (!t.isPadded)
      return e;
    let n = Math.abs(t.maxLen - String(e).length), i = r.relaxZeros !== !1;
    switch (n) {
      case 0:
        return "";
      case 1:
        return i ? "0?" : "0";
      case 2:
        return i ? "0{0,2}" : "00";
      default:
        return i ? `0{0,${n}}` : `0{${n}}`;
    }
  }
  s(iN, "padZeros");
  Pi.cache = {};
  Pi.clearCache = () => Pi.cache = {};
  sv.exports = Pi;
});

// ../node_modules/fill-range/index.js
var Jh = I((jae, fv) => {
  "use strict";
  var sN = require("util"), uv = ov(), av = /* @__PURE__ */ s((e) => e !== null && typeof e == "object" && !Array.isArray(e), "isObject"), oN = /* @__PURE__ */ s(
  (e) => (t) => e === !0 ? Number(t) : String(t), "transform"), Hh = /* @__PURE__ */ s((e) => typeof e == "number" || typeof e == "string" &&
  e !== "", "isValidValue"), Qo = /* @__PURE__ */ s((e) => Number.isInteger(+e), "isNumber"), Gh = /* @__PURE__ */ s((e) => {
    let t = `${e}`, r = -1;
    if (t[0] === "-" && (t = t.slice(1)), t === "0") return !1;
    for (; t[++r] === "0"; ) ;
    return r > 0;
  }, "zeros"), aN = /* @__PURE__ */ s((e, t, r) => typeof e == "string" || typeof t == "string" ? !0 : r.stringify === !0, "stringify"), uN = /* @__PURE__ */ s(
  (e, t, r) => {
    if (t > 0) {
      let n = e[0] === "-" ? "-" : "";
      n && (e = e.slice(1)), e = n + e.padStart(n ? t - 1 : t, "0");
    }
    return r === !1 ? String(e) : e;
  }, "pad"), Zu = /* @__PURE__ */ s((e, t) => {
    let r = e[0] === "-" ? "-" : "";
    for (r && (e = e.slice(1), t--); e.length < t; ) e = "0" + e;
    return r ? "-" + e : e;
  }, "toMaxLen"), lN = /* @__PURE__ */ s((e, t, r) => {
    e.negatives.sort((u, l) => u < l ? -1 : u > l ? 1 : 0), e.positives.sort((u, l) => u < l ? -1 : u > l ? 1 : 0);
    let n = t.capture ? "" : "?:", i = "", o = "", a;
    return e.positives.length && (i = e.positives.map((u) => Zu(String(u), r)).join("|")), e.negatives.length && (o = `-(${n}${e.negatives.map(
    (u) => Zu(String(u), r)).join("|")})`), i && o ? a = `${i}|${o}` : a = i || o, t.wrap ? `(${n}${a})` : a;
  }, "toSequence"), lv = /* @__PURE__ */ s((e, t, r, n) => {
    if (r)
      return uv(e, t, { wrap: !1, ...n });
    let i = String.fromCharCode(e);
    if (e === t) return i;
    let o = String.fromCharCode(t);
    return `[${i}-${o}]`;
  }, "toRange"), cv = /* @__PURE__ */ s((e, t, r) => {
    if (Array.isArray(e)) {
      let n = r.wrap === !0, i = r.capture ? "" : "?:";
      return n ? `(${i}${e.join("|")})` : e.join("|");
    }
    return uv(e, t, r);
  }, "toRegex"), pv = /* @__PURE__ */ s((...e) => new RangeError("Invalid range arguments: " + sN.inspect(...e)), "rangeError"), hv = /* @__PURE__ */ s(
  (e, t, r) => {
    if (r.strictRanges === !0) throw pv([e, t]);
    return [];
  }, "invalidRange"), cN = /* @__PURE__ */ s((e, t) => {
    if (t.strictRanges === !0)
      throw new TypeError(`Expected step "${e}" to be a number`);
    return [];
  }, "invalidStep"), pN = /* @__PURE__ */ s((e, t, r = 1, n = {}) => {
    let i = Number(e), o = Number(t);
    if (!Number.isInteger(i) || !Number.isInteger(o)) {
      if (n.strictRanges === !0) throw pv([e, t]);
      return [];
    }
    i === 0 && (i = 0), o === 0 && (o = 0);
    let a = i > o, u = String(e), l = String(t), c = String(r);
    r = Math.max(Math.abs(r), 1);
    let p = Gh(u) || Gh(l) || Gh(c), h = p ? Math.max(u.length, l.length, c.length) : 0, f = p === !1 && aN(e, t, n) === !1, d = n.transform ||
    oN(f);
    if (n.toRegex && r === 1)
      return lv(Zu(e, h), Zu(t, h), !0, n);
    let m = { negatives: [], positives: [] }, g = /* @__PURE__ */ s((E) => m[E < 0 ? "negatives" : "positives"].push(Math.abs(E)), "push"), b = [],
    y = 0;
    for (; a ? i >= o : i <= o; )
      n.toRegex === !0 && r > 1 ? g(i) : b.push(uN(d(i, y), h, f)), i = a ? i - r : i + r, y++;
    return n.toRegex === !0 ? r > 1 ? lN(m, n, h) : cv(b, null, { wrap: !1, ...n }) : b;
  }, "fillNumbers"), hN = /* @__PURE__ */ s((e, t, r = 1, n = {}) => {
    if (!Qo(e) && e.length > 1 || !Qo(t) && t.length > 1)
      return hv(e, t, n);
    let i = n.transform || ((f) => String.fromCharCode(f)), o = `${e}`.charCodeAt(0), a = `${t}`.charCodeAt(0), u = o > a, l = Math.min(o, a),
    c = Math.max(o, a);
    if (n.toRegex && r === 1)
      return lv(l, c, !1, n);
    let p = [], h = 0;
    for (; u ? o >= a : o <= a; )
      p.push(i(o, h)), o = u ? o - r : o + r, h++;
    return n.toRegex === !0 ? cv(p, null, { wrap: !1, options: n }) : p;
  }, "fillLetters"), Ju = /* @__PURE__ */ s((e, t, r, n = {}) => {
    if (t == null && Hh(e))
      return [e];
    if (!Hh(e) || !Hh(t))
      return hv(e, t, n);
    if (typeof r == "function")
      return Ju(e, t, 1, { transform: r });
    if (av(r))
      return Ju(e, t, 0, r);
    let i = { ...n };
    return i.capture === !0 && (i.wrap = !0), r = r || i.step || 1, Qo(r) ? Qo(e) && Qo(t) ? pN(e, t, r, i) : hN(e, t, Math.max(Math.abs(r),
    1), i) : r != null && !av(r) ? cN(r, i) : Ju(e, t, 1, r);
  }, "fill");
  fv.exports = Ju;
});

// ../node_modules/braces/lib/compile.js
var gv = I((qae, mv) => {
  "use strict";
  var fN = Jh(), dv = Hu(), dN = /* @__PURE__ */ s((e, t = {}) => {
    let r = /* @__PURE__ */ s((n, i = {}) => {
      let o = dv.isInvalidBrace(i), a = n.invalid === !0 && t.escapeInvalid === !0, u = o === !0 || a === !0, l = t.escapeInvalid === !0 ? "\
\\" : "", c = "";
      if (n.isOpen === !0)
        return l + n.value;
      if (n.isClose === !0)
        return console.log("node.isClose", l, n.value), l + n.value;
      if (n.type === "open")
        return u ? l + n.value : "(";
      if (n.type === "close")
        return u ? l + n.value : ")";
      if (n.type === "comma")
        return n.prev.type === "comma" ? "" : u ? n.value : "|";
      if (n.value)
        return n.value;
      if (n.nodes && n.ranges > 0) {
        let p = dv.reduce(n.nodes), h = fN(...p, { ...t, wrap: !1, toRegex: !0, strictZeros: !0 });
        if (h.length !== 0)
          return p.length > 1 && h.length > 1 ? `(${h})` : h;
      }
      if (n.nodes)
        for (let p of n.nodes)
          c += r(p, n);
      return c;
    }, "walk");
    return r(e);
  }, "compile");
  mv.exports = dN;
});

// ../node_modules/braces/lib/expand.js
var xv = I((Vae, Dv) => {
  "use strict";
  var mN = Jh(), yv = Gu(), Ss = Hu(), Bi = /* @__PURE__ */ s((e = "", t = "", r = !1) => {
    let n = [];
    if (e = [].concat(e), t = [].concat(t), !t.length) return e;
    if (!e.length)
      return r ? Ss.flatten(t).map((i) => `{${i}}`) : t;
    for (let i of e)
      if (Array.isArray(i))
        for (let o of i)
          n.push(Bi(o, t, r));
      else
        for (let o of t)
          r === !0 && typeof o == "string" && (o = `{${o}}`), n.push(Array.isArray(o) ? Bi(i, o, r) : i + o);
    return Ss.flatten(n);
  }, "append"), gN = /* @__PURE__ */ s((e, t = {}) => {
    let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit, n = /* @__PURE__ */ s((i, o = {}) => {
      i.queue = [];
      let a = o, u = o.queue;
      for (; a.type !== "brace" && a.type !== "root" && a.parent; )
        a = a.parent, u = a.queue;
      if (i.invalid || i.dollar) {
        u.push(Bi(u.pop(), yv(i, t)));
        return;
      }
      if (i.type === "brace" && i.invalid !== !0 && i.nodes.length === 2) {
        u.push(Bi(u.pop(), ["{}"]));
        return;
      }
      if (i.nodes && i.ranges > 0) {
        let h = Ss.reduce(i.nodes);
        if (Ss.exceedsLimit(...h, t.step, r))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let f = mN(...h, t);
        f.length === 0 && (f = yv(i, t)), u.push(Bi(u.pop(), f)), i.nodes = [];
        return;
      }
      let l = Ss.encloseBrace(i), c = i.queue, p = i;
      for (; p.type !== "brace" && p.type !== "root" && p.parent; )
        p = p.parent, c = p.queue;
      for (let h = 0; h < i.nodes.length; h++) {
        let f = i.nodes[h];
        if (f.type === "comma" && i.type === "brace") {
          h === 1 && c.push(""), c.push("");
          continue;
        }
        if (f.type === "close") {
          u.push(Bi(u.pop(), c, l));
          continue;
        }
        if (f.value && f.type !== "open") {
          c.push(Bi(c.pop(), f.value));
          continue;
        }
        f.nodes && n(f, i);
      }
      return c;
    }, "walk");
    return Ss.flatten(n(e));
  }, "expand");
  Dv.exports = gN;
});

// ../node_modules/braces/lib/constants.js
var vv = I((Wae, bv) => {
  "use strict";
  bv.exports = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  };
});

// ../node_modules/braces/lib/parse.js
var Av = I((zae, Sv) => {
  "use strict";
  var yN = Gu(), {
    MAX_LENGTH: Ev,
    CHAR_BACKSLASH: Zh,
    /* \ */
    CHAR_BACKTICK: DN,
    /* ` */
    CHAR_COMMA: xN,
    /* , */
    CHAR_DOT: bN,
    /* . */
    CHAR_LEFT_PARENTHESES: vN,
    /* ( */
    CHAR_RIGHT_PARENTHESES: EN,
    /* ) */
    CHAR_LEFT_CURLY_BRACE: CN,
    /* { */
    CHAR_RIGHT_CURLY_BRACE: wN,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET: Cv,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET: wv,
    /* ] */
    CHAR_DOUBLE_QUOTE: SN,
    /* " */
    CHAR_SINGLE_QUOTE: AN,
    /* ' */
    CHAR_NO_BREAK_SPACE: FN,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: _N
  } = vv(), kN = /* @__PURE__ */ s((e, t = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    let r = t || {}, n = typeof r.maxLength == "number" ? Math.min(Ev, r.maxLength) : Ev;
    if (e.length > n)
      throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${n})`);
    let i = { type: "root", input: e, nodes: [] }, o = [i], a = i, u = i, l = 0, c = e.length, p = 0, h = 0, f, d = /* @__PURE__ */ s(() => e[p++],
    "advance"), m = /* @__PURE__ */ s((g) => {
      if (g.type === "text" && u.type === "dot" && (u.type = "text"), u && u.type === "text" && g.type === "text") {
        u.value += g.value;
        return;
      }
      return a.nodes.push(g), g.parent = a, g.prev = u, u = g, g;
    }, "push");
    for (m({ type: "bos" }); p < c; )
      if (a = o[o.length - 1], f = d(), !(f === _N || f === FN)) {
        if (f === Zh) {
          m({ type: "text", value: (t.keepEscaping ? f : "") + d() });
          continue;
        }
        if (f === wv) {
          m({ type: "text", value: "\\" + f });
          continue;
        }
        if (f === Cv) {
          l++;
          let g;
          for (; p < c && (g = d()); ) {
            if (f += g, g === Cv) {
              l++;
              continue;
            }
            if (g === Zh) {
              f += d();
              continue;
            }
            if (g === wv && (l--, l === 0))
              break;
          }
          m({ type: "text", value: f });
          continue;
        }
        if (f === vN) {
          a = m({ type: "paren", nodes: [] }), o.push(a), m({ type: "text", value: f });
          continue;
        }
        if (f === EN) {
          if (a.type !== "paren") {
            m({ type: "text", value: f });
            continue;
          }
          a = o.pop(), m({ type: "text", value: f }), a = o[o.length - 1];
          continue;
        }
        if (f === SN || f === AN || f === DN) {
          let g = f, b;
          for (t.keepQuotes !== !0 && (f = ""); p < c && (b = d()); ) {
            if (b === Zh) {
              f += b + d();
              continue;
            }
            if (b === g) {
              t.keepQuotes === !0 && (f += b);
              break;
            }
            f += b;
          }
          m({ type: "text", value: f });
          continue;
        }
        if (f === CN) {
          h++;
          let b = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: u.value && u.value.slice(-1) === "$" || a.dollar === !0,
            depth: h,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          a = m(b), o.push(a), m({ type: "open", value: f });
          continue;
        }
        if (f === wN) {
          if (a.type !== "brace") {
            m({ type: "text", value: f });
            continue;
          }
          let g = "close";
          a = o.pop(), a.close = !0, m({ type: g, value: f }), h--, a = o[o.length - 1];
          continue;
        }
        if (f === xN && h > 0) {
          if (a.ranges > 0) {
            a.ranges = 0;
            let g = a.nodes.shift();
            a.nodes = [g, { type: "text", value: yN(a) }];
          }
          m({ type: "comma", value: f }), a.commas++;
          continue;
        }
        if (f === bN && h > 0 && a.commas === 0) {
          let g = a.nodes;
          if (h === 0 || g.length === 0) {
            m({ type: "text", value: f });
            continue;
          }
          if (u.type === "dot") {
            if (a.range = [], u.value += f, u.type = "range", a.nodes.length !== 3 && a.nodes.length !== 5) {
              a.invalid = !0, a.ranges = 0, u.type = "text";
              continue;
            }
            a.ranges++, a.args = [];
            continue;
          }
          if (u.type === "range") {
            g.pop();
            let b = g[g.length - 1];
            b.value += u.value + f, u = b, a.ranges--;
            continue;
          }
          m({ type: "dot", value: f });
          continue;
        }
        m({ type: "text", value: f });
      }
    do
      if (a = o.pop(), a.type !== "root") {
        a.nodes.forEach((y) => {
          y.nodes || (y.type === "open" && (y.isOpen = !0), y.type === "close" && (y.isClose = !0), y.nodes || (y.type = "text"), y.invalid =
          !0);
        });
        let g = o[o.length - 1], b = g.nodes.indexOf(a);
        g.nodes.splice(b, 1, ...a.nodes);
      }
    while (o.length > 0);
    return m({ type: "eos" }), i;
  }, "parse");
  Sv.exports = kN;
});

// ../node_modules/braces/index.js
var kv = I((Gae, _v) => {
  "use strict";
  var Fv = Gu(), TN = gv(), IN = xv(), PN = Av(), Kt = /* @__PURE__ */ s((e, t = {}) => {
    let r = [];
    if (Array.isArray(e))
      for (let n of e) {
        let i = Kt.create(n, t);
        Array.isArray(i) ? r.push(...i) : r.push(i);
      }
    else
      r = [].concat(Kt.create(e, t));
    return t && t.expand === !0 && t.nodupes === !0 && (r = [...new Set(r)]), r;
  }, "braces");
  Kt.parse = (e, t = {}) => PN(e, t);
  Kt.stringify = (e, t = {}) => Fv(typeof e == "string" ? Kt.parse(e, t) : e, t);
  Kt.compile = (e, t = {}) => (typeof e == "string" && (e = Kt.parse(e, t)), TN(e, t));
  Kt.expand = (e, t = {}) => {
    typeof e == "string" && (e = Kt.parse(e, t));
    let r = IN(e, t);
    return t.noempty === !0 && (r = r.filter(Boolean)), t.nodupes === !0 && (r = [...new Set(r)]), r;
  };
  Kt.create = (e, t = {}) => e === "" || e.length < 3 ? [e] : t.expand !== !0 ? Kt.compile(e, t) : Kt.expand(e, t);
  _v.exports = Kt;
});

// ../node_modules/picomatch/lib/constants.js
var ea = I((Zae, Ov) => {
  "use strict";
  var BN = require("path"), Qr = "\\\\/", Tv = `[^${Qr}]`, Sn = "\\.", ON = "\\+", RN = "\\?", Xu = "\\/", NN = "(?=.)", Iv = "[^/]", Xh = `\
(?:${Xu}|$)`, Pv = `(?:^|${Xu})`, Kh = `${Sn}{1,2}${Xh}`, LN = `(?!${Sn})`, jN = `(?!${Pv}${Kh})`, MN = `(?!${Sn}{0,1}${Xh})`, qN = `(?!${Kh}\
)`, $N = `[^.${Xu}]`, VN = `${Iv}*?`, Bv = {
    DOT_LITERAL: Sn,
    PLUS_LITERAL: ON,
    QMARK_LITERAL: RN,
    SLASH_LITERAL: Xu,
    ONE_CHAR: NN,
    QMARK: Iv,
    END_ANCHOR: Xh,
    DOTS_SLASH: Kh,
    NO_DOT: LN,
    NO_DOTS: jN,
    NO_DOT_SLASH: MN,
    NO_DOTS_SLASH: qN,
    QMARK_NO_DOT: $N,
    STAR: VN,
    START_ANCHOR: Pv
  }, UN = {
    ...Bv,
    SLASH_LITERAL: `[${Qr}]`,
    QMARK: Tv,
    STAR: `${Tv}*?`,
    DOTS_SLASH: `${Sn}{1,2}(?:[${Qr}]|$)`,
    NO_DOT: `(?!${Sn})`,
    NO_DOTS: `(?!(?:^|[${Qr}])${Sn}{1,2}(?:[${Qr}]|$))`,
    NO_DOT_SLASH: `(?!${Sn}{0,1}(?:[${Qr}]|$))`,
    NO_DOTS_SLASH: `(?!${Sn}{1,2}(?:[${Qr}]|$))`,
    QMARK_NO_DOT: `[^.${Qr}]`,
    START_ANCHOR: `(?:^|[${Qr}])`,
    END_ANCHOR: `(?:[${Qr}]|$)`
  }, WN = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  Ov.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: WN,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: BN.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(e) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(e) {
      return e === !0 ? UN : Bv;
    }
  };
});

// ../node_modules/picomatch/lib/utils.js
var ta = I((Vt) => {
  "use strict";
  var zN = require("path"), HN = process.platform === "win32", {
    REGEX_BACKSLASH: GN,
    REGEX_REMOVE_BACKSLASH: JN,
    REGEX_SPECIAL_CHARS: ZN,
    REGEX_SPECIAL_CHARS_GLOBAL: XN
  } = ea();
  Vt.isObject = (e) => e !== null && typeof e == "object" && !Array.isArray(e);
  Vt.hasRegexChars = (e) => ZN.test(e);
  Vt.isRegexChar = (e) => e.length === 1 && Vt.hasRegexChars(e);
  Vt.escapeRegex = (e) => e.replace(XN, "\\$1");
  Vt.toPosixSlashes = (e) => e.replace(GN, "/");
  Vt.removeBackslashes = (e) => e.replace(JN, (t) => t === "\\" ? "" : t);
  Vt.supportsLookbehinds = () => {
    let e = process.version.slice(1).split(".").map(Number);
    return e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10;
  };
  Vt.isWindows = (e) => e && typeof e.windows == "boolean" ? e.windows : HN === !0 || zN.sep === "\\";
  Vt.escapeLast = (e, t, r) => {
    let n = e.lastIndexOf(t, r);
    return n === -1 ? e : e[n - 1] === "\\" ? Vt.escapeLast(e, t, n - 1) : `${e.slice(0, n)}\\${e.slice(n)}`;
  };
  Vt.removePrefix = (e, t = {}) => {
    let r = e;
    return r.startsWith("./") && (r = r.slice(2), t.prefix = "./"), r;
  };
  Vt.wrapOutput = (e, t = {}, r = {}) => {
    let n = r.contains ? "" : "^", i = r.contains ? "" : "$", o = `${n}(?:${e})${i}`;
    return t.negated === !0 && (o = `(?:^(?!${o}).*$)`), o;
  };
});

// ../node_modules/picomatch/lib/scan.js
var Vv = I((Kae, $v) => {
  "use strict";
  var Rv = ta(), {
    CHAR_ASTERISK: Yh,
    /* * */
    CHAR_AT: KN,
    /* @ */
    CHAR_BACKWARD_SLASH: ra,
    /* \ */
    CHAR_COMMA: YN,
    /* , */
    CHAR_DOT: Qh,
    /* . */
    CHAR_EXCLAMATION_MARK: ef,
    /* ! */
    CHAR_FORWARD_SLASH: qv,
    /* / */
    CHAR_LEFT_CURLY_BRACE: tf,
    /* { */
    CHAR_LEFT_PARENTHESES: rf,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: QN,
    /* [ */
    CHAR_PLUS: e5,
    /* + */
    CHAR_QUESTION_MARK: Nv,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: t5,
    /* } */
    CHAR_RIGHT_PARENTHESES: Lv,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: r5
    /* ] */
  } = ea(), jv = /* @__PURE__ */ s((e) => e === qv || e === ra, "isPathSeparator"), Mv = /* @__PURE__ */ s((e) => {
    e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1);
  }, "depth"), n5 = /* @__PURE__ */ s((e, t) => {
    let r = t || {}, n = e.length - 1, i = r.parts === !0 || r.scanToEnd === !0, o = [], a = [], u = [], l = e, c = -1, p = 0, h = 0, f = !1,
    d = !1, m = !1, g = !1, b = !1, y = !1, E = !1, A = !1, k = !1, O = !1, w = 0, C, T, F = { value: "", depth: 0, isGlob: !1 }, $ = /* @__PURE__ */ s(
    () => c >= n, "eos"), R = /* @__PURE__ */ s(() => l.charCodeAt(c + 1), "peek"), U = /* @__PURE__ */ s(() => (C = T, l.charCodeAt(++c)), "\
advance");
    for (; c < n; ) {
      T = U();
      let z;
      if (T === ra) {
        E = F.backslashes = !0, T = U(), T === tf && (y = !0);
        continue;
      }
      if (y === !0 || T === tf) {
        for (w++; $() !== !0 && (T = U()); ) {
          if (T === ra) {
            E = F.backslashes = !0, U();
            continue;
          }
          if (T === tf) {
            w++;
            continue;
          }
          if (y !== !0 && T === Qh && (T = U()) === Qh) {
            if (f = F.isBrace = !0, m = F.isGlob = !0, O = !0, i === !0)
              continue;
            break;
          }
          if (y !== !0 && T === YN) {
            if (f = F.isBrace = !0, m = F.isGlob = !0, O = !0, i === !0)
              continue;
            break;
          }
          if (T === t5 && (w--, w === 0)) {
            y = !1, f = F.isBrace = !0, O = !0;
            break;
          }
        }
        if (i === !0)
          continue;
        break;
      }
      if (T === qv) {
        if (o.push(c), a.push(F), F = { value: "", depth: 0, isGlob: !1 }, O === !0) continue;
        if (C === Qh && c === p + 1) {
          p += 2;
          continue;
        }
        h = c + 1;
        continue;
      }
      if (r.noext !== !0 && (T === e5 || T === KN || T === Yh || T === Nv || T === ef) === !0 && R() === rf) {
        if (m = F.isGlob = !0, g = F.isExtglob = !0, O = !0, T === ef && c === p && (k = !0), i === !0) {
          for (; $() !== !0 && (T = U()); ) {
            if (T === ra) {
              E = F.backslashes = !0, T = U();
              continue;
            }
            if (T === Lv) {
              m = F.isGlob = !0, O = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (T === Yh) {
        if (C === Yh && (b = F.isGlobstar = !0), m = F.isGlob = !0, O = !0, i === !0)
          continue;
        break;
      }
      if (T === Nv) {
        if (m = F.isGlob = !0, O = !0, i === !0)
          continue;
        break;
      }
      if (T === QN) {
        for (; $() !== !0 && (z = U()); ) {
          if (z === ra) {
            E = F.backslashes = !0, U();
            continue;
          }
          if (z === r5) {
            d = F.isBracket = !0, m = F.isGlob = !0, O = !0;
            break;
          }
        }
        if (i === !0)
          continue;
        break;
      }
      if (r.nonegate !== !0 && T === ef && c === p) {
        A = F.negated = !0, p++;
        continue;
      }
      if (r.noparen !== !0 && T === rf) {
        if (m = F.isGlob = !0, i === !0) {
          for (; $() !== !0 && (T = U()); ) {
            if (T === rf) {
              E = F.backslashes = !0, T = U();
              continue;
            }
            if (T === Lv) {
              O = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (m === !0) {
        if (O = !0, i === !0)
          continue;
        break;
      }
    }
    r.noext === !0 && (g = !1, m = !1);
    let W = l, Y = "", j = "";
    p > 0 && (Y = l.slice(0, p), l = l.slice(p), h -= p), W && m === !0 && h > 0 ? (W = l.slice(0, h), j = l.slice(h)) : m === !0 ? (W = "",
    j = l) : W = l, W && W !== "" && W !== "/" && W !== l && jv(W.charCodeAt(W.length - 1)) && (W = W.slice(0, -1)), r.unescape === !0 && (j &&
    (j = Rv.removeBackslashes(j)), W && E === !0 && (W = Rv.removeBackslashes(W)));
    let N = {
      prefix: Y,
      input: e,
      start: p,
      base: W,
      glob: j,
      isBrace: f,
      isBracket: d,
      isGlob: m,
      isExtglob: g,
      isGlobstar: b,
      negated: A,
      negatedExtglob: k
    };
    if (r.tokens === !0 && (N.maxDepth = 0, jv(T) || a.push(F), N.tokens = a), r.parts === !0 || r.tokens === !0) {
      let z;
      for (let Q = 0; Q < o.length; Q++) {
        let ie = z ? z + 1 : p, B = o[Q], ce = e.slice(ie, B);
        r.tokens && (Q === 0 && p !== 0 ? (a[Q].isPrefix = !0, a[Q].value = Y) : a[Q].value = ce, Mv(a[Q]), N.maxDepth += a[Q].depth), (Q !==
        0 || ce !== "") && u.push(ce), z = B;
      }
      if (z && z + 1 < e.length) {
        let Q = e.slice(z + 1);
        u.push(Q), r.tokens && (a[a.length - 1].value = Q, Mv(a[a.length - 1]), N.maxDepth += a[a.length - 1].depth);
      }
      N.slashes = o, N.parts = u;
    }
    return N;
  }, "scan");
  $v.exports = n5;
});

// ../node_modules/picomatch/lib/parse.js
var zv = I((Qae, Wv) => {
  "use strict";
  var Ku = ea(), Yt = ta(), {
    MAX_LENGTH: Yu,
    POSIX_REGEX_SOURCE: i5,
    REGEX_NON_SPECIAL_CHARS: s5,
    REGEX_SPECIAL_CHARS_BACKREF: o5,
    REPLACEMENTS: Uv
  } = Ku, a5 = /* @__PURE__ */ s((e, t) => {
    if (typeof t.expandRange == "function")
      return t.expandRange(...e, t);
    e.sort();
    let r = `[${e.join("-")}]`;
    try {
      new RegExp(r);
    } catch {
      return e.map((i) => Yt.escapeRegex(i)).join("..");
    }
    return r;
  }, "expandRange"), As = /* @__PURE__ */ s((e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`, "syntaxError"), nf = /* @__PURE__ */ s(
  (e, t) => {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    e = Uv[e] || e;
    let r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(Yu, r.maxLength) : Yu, i = e.length;
    if (i > n)
      throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
    let o = { type: "bos", value: "", output: r.prepend || "" }, a = [o], u = r.capture ? "" : "?:", l = Yt.isWindows(t), c = Ku.globChars(l),
    p = Ku.extglobChars(c), {
      DOT_LITERAL: h,
      PLUS_LITERAL: f,
      SLASH_LITERAL: d,
      ONE_CHAR: m,
      DOTS_SLASH: g,
      NO_DOT: b,
      NO_DOT_SLASH: y,
      NO_DOTS_SLASH: E,
      QMARK: A,
      QMARK_NO_DOT: k,
      STAR: O,
      START_ANCHOR: w
    } = c, C = /* @__PURE__ */ s((re) => `(${u}(?:(?!${w}${re.dot ? g : h}).)*?)`, "globstar"), T = r.dot ? "" : b, F = r.dot ? A : k, $ = r.
    bash === !0 ? C(r) : O;
    r.capture && ($ = `(${$})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
    let R = {
      input: e,
      index: -1,
      start: 0,
      dot: r.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: a
    };
    e = Yt.removePrefix(e, R), i = e.length;
    let U = [], W = [], Y = [], j = o, N, z = /* @__PURE__ */ s(() => R.index === i - 1, "eos"), Q = R.peek = (re = 1) => e[R.index + re], ie = R.
    advance = () => e[++R.index] || "", B = /* @__PURE__ */ s(() => e.slice(R.index + 1), "remaining"), ce = /* @__PURE__ */ s((re = "", xe = 0) => {
      R.consumed += re, R.index += xe;
    }, "consume"), Je = /* @__PURE__ */ s((re) => {
      R.output += re.output != null ? re.output : re.value, ce(re.value);
    }, "append"), L = /* @__PURE__ */ s(() => {
      let re = 1;
      for (; Q() === "!" && (Q(2) !== "(" || Q(3) === "?"); )
        ie(), R.start++, re++;
      return re % 2 === 0 ? !1 : (R.negated = !0, R.start++, !0);
    }, "negate"), Ue = /* @__PURE__ */ s((re) => {
      R[re]++, Y.push(re);
    }, "increment"), $e = /* @__PURE__ */ s((re) => {
      R[re]--, Y.pop();
    }, "decrement"), me = /* @__PURE__ */ s((re) => {
      if (j.type === "globstar") {
        let xe = R.braces > 0 && (re.type === "comma" || re.type === "brace"), K = re.extglob === !0 || U.length && (re.type === "pipe" || re.
        type === "paren");
        re.type !== "slash" && re.type !== "paren" && !xe && !K && (R.output = R.output.slice(0, -j.output.length), j.type = "star", j.value =
        "*", j.output = $, R.output += j.output);
      }
      if (U.length && re.type !== "paren" && (U[U.length - 1].inner += re.value), (re.value || re.output) && Je(re), j && j.type === "text" &&
      re.type === "text") {
        j.value += re.value, j.output = (j.output || "") + re.value;
        return;
      }
      re.prev = j, a.push(re), j = re;
    }, "push"), It = /* @__PURE__ */ s((re, xe) => {
      let K = { ...p[xe], conditions: 1, inner: "" };
      K.prev = j, K.parens = R.parens, K.output = R.output;
      let se = (r.capture ? "(" : "") + K.open;
      Ue("parens"), me({ type: re, value: xe, output: R.output ? "" : m }), me({ type: "paren", extglob: !0, value: ie(), output: se }), U.push(
      K);
    }, "extglobOpen"), Me = /* @__PURE__ */ s((re) => {
      let xe = re.close + (r.capture ? ")" : ""), K;
      if (re.type === "negate") {
        let se = $;
        if (re.inner && re.inner.length > 1 && re.inner.includes("/") && (se = C(r)), (se !== $ || z() || /^\)+$/.test(B())) && (xe = re.close =
        `)$))${se}`), re.inner.includes("*") && (K = B()) && /^\.[^\\/.]+$/.test(K)) {
          let ge = nf(K, { ...t, fastpaths: !1 }).output;
          xe = re.close = `)${ge})${se})`;
        }
        re.prev.type === "bos" && (R.negatedExtglob = !0);
      }
      me({ type: "paren", extglob: !0, value: N, output: xe }), $e("parens");
    }, "extglobClose");
    if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
      let re = !1, xe = e.replace(o5, (K, se, ge, be, Ee, rt) => be === "\\" ? (re = !0, K) : be === "?" ? se ? se + be + (Ee ? A.repeat(Ee.
      length) : "") : rt === 0 ? F + (Ee ? A.repeat(Ee.length) : "") : A.repeat(ge.length) : be === "." ? h.repeat(ge.length) : be === "*" ?
      se ? se + be + (Ee ? $ : "") : $ : se ? K : `\\${K}`);
      return re === !0 && (r.unescape === !0 ? xe = xe.replace(/\\/g, "") : xe = xe.replace(/\\+/g, (K) => K.length % 2 === 0 ? "\\\\" : K ?
      "\\" : "")), xe === e && r.contains === !0 ? (R.output = e, R) : (R.output = Yt.wrapOutput(xe, R, t), R);
    }
    for (; !z(); ) {
      if (N = ie(), N === "\0")
        continue;
      if (N === "\\") {
        let K = Q();
        if (K === "/" && r.bash !== !0 || K === "." || K === ";")
          continue;
        if (!K) {
          N += "\\", me({ type: "text", value: N });
          continue;
        }
        let se = /^\\+/.exec(B()), ge = 0;
        if (se && se[0].length > 2 && (ge = se[0].length, R.index += ge, ge % 2 !== 0 && (N += "\\")), r.unescape === !0 ? N = ie() : N += ie(),
        R.brackets === 0) {
          me({ type: "text", value: N });
          continue;
        }
      }
      if (R.brackets > 0 && (N !== "]" || j.value === "[" || j.value === "[^")) {
        if (r.posix !== !1 && N === ":") {
          let K = j.value.slice(1);
          if (K.includes("[") && (j.posix = !0, K.includes(":"))) {
            let se = j.value.lastIndexOf("["), ge = j.value.slice(0, se), be = j.value.slice(se + 2), Ee = i5[be];
            if (Ee) {
              j.value = ge + Ee, R.backtrack = !0, ie(), !o.output && a.indexOf(j) === 1 && (o.output = m);
              continue;
            }
          }
        }
        (N === "[" && Q() !== ":" || N === "-" && Q() === "]") && (N = `\\${N}`), N === "]" && (j.value === "[" || j.value === "[^") && (N =
        `\\${N}`), r.posix === !0 && N === "!" && j.value === "[" && (N = "^"), j.value += N, Je({ value: N });
        continue;
      }
      if (R.quotes === 1 && N !== '"') {
        N = Yt.escapeRegex(N), j.value += N, Je({ value: N });
        continue;
      }
      if (N === '"') {
        R.quotes = R.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && me({ type: "text", value: N });
        continue;
      }
      if (N === "(") {
        Ue("parens"), me({ type: "paren", value: N });
        continue;
      }
      if (N === ")") {
        if (R.parens === 0 && r.strictBrackets === !0)
          throw new SyntaxError(As("opening", "("));
        let K = U[U.length - 1];
        if (K && R.parens === K.parens + 1) {
          Me(U.pop());
          continue;
        }
        me({ type: "paren", value: N, output: R.parens ? ")" : "\\)" }), $e("parens");
        continue;
      }
      if (N === "[") {
        if (r.nobracket === !0 || !B().includes("]")) {
          if (r.nobracket !== !0 && r.strictBrackets === !0)
            throw new SyntaxError(As("closing", "]"));
          N = `\\${N}`;
        } else
          Ue("brackets");
        me({ type: "bracket", value: N });
        continue;
      }
      if (N === "]") {
        if (r.nobracket === !0 || j && j.type === "bracket" && j.value.length === 1) {
          me({ type: "text", value: N, output: `\\${N}` });
          continue;
        }
        if (R.brackets === 0) {
          if (r.strictBrackets === !0)
            throw new SyntaxError(As("opening", "["));
          me({ type: "text", value: N, output: `\\${N}` });
          continue;
        }
        $e("brackets");
        let K = j.value.slice(1);
        if (j.posix !== !0 && K[0] === "^" && !K.includes("/") && (N = `/${N}`), j.value += N, Je({ value: N }), r.literalBrackets === !1 ||
        Yt.hasRegexChars(K))
          continue;
        let se = Yt.escapeRegex(j.value);
        if (R.output = R.output.slice(0, -j.value.length), r.literalBrackets === !0) {
          R.output += se, j.value = se;
          continue;
        }
        j.value = `(${u}${se}|${j.value})`, R.output += j.value;
        continue;
      }
      if (N === "{" && r.nobrace !== !0) {
        Ue("braces");
        let K = {
          type: "brace",
          value: N,
          output: "(",
          outputIndex: R.output.length,
          tokensIndex: R.tokens.length
        };
        W.push(K), me(K);
        continue;
      }
      if (N === "}") {
        let K = W[W.length - 1];
        if (r.nobrace === !0 || !K) {
          me({ type: "text", value: N, output: N });
          continue;
        }
        let se = ")";
        if (K.dots === !0) {
          let ge = a.slice(), be = [];
          for (let Ee = ge.length - 1; Ee >= 0 && (a.pop(), ge[Ee].type !== "brace"); Ee--)
            ge[Ee].type !== "dots" && be.unshift(ge[Ee].value);
          se = a5(be, r), R.backtrack = !0;
        }
        if (K.comma !== !0 && K.dots !== !0) {
          let ge = R.output.slice(0, K.outputIndex), be = R.tokens.slice(K.tokensIndex);
          K.value = K.output = "\\{", N = se = "\\}", R.output = ge;
          for (let Ee of be)
            R.output += Ee.output || Ee.value;
        }
        me({ type: "brace", value: N, output: se }), $e("braces"), W.pop();
        continue;
      }
      if (N === "|") {
        U.length > 0 && U[U.length - 1].conditions++, me({ type: "text", value: N });
        continue;
      }
      if (N === ",") {
        let K = N, se = W[W.length - 1];
        se && Y[Y.length - 1] === "braces" && (se.comma = !0, K = "|"), me({ type: "comma", value: N, output: K });
        continue;
      }
      if (N === "/") {
        if (j.type === "dot" && R.index === R.start + 1) {
          R.start = R.index + 1, R.consumed = "", R.output = "", a.pop(), j = o;
          continue;
        }
        me({ type: "slash", value: N, output: d });
        continue;
      }
      if (N === ".") {
        if (R.braces > 0 && j.type === "dot") {
          j.value === "." && (j.output = h);
          let K = W[W.length - 1];
          j.type = "dots", j.output += N, j.value += N, K.dots = !0;
          continue;
        }
        if (R.braces + R.parens === 0 && j.type !== "bos" && j.type !== "slash") {
          me({ type: "text", value: N, output: h });
          continue;
        }
        me({ type: "dot", value: N, output: h });
        continue;
      }
      if (N === "?") {
        if (!(j && j.value === "(") && r.noextglob !== !0 && Q() === "(" && Q(2) !== "?") {
          It("qmark", N);
          continue;
        }
        if (j && j.type === "paren") {
          let se = Q(), ge = N;
          if (se === "<" && !Yt.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (j.value === "(" && !/[!=<:]/.test(se) || se === "<" && !/<([!=]|\w+>)/.test(B())) && (ge = `\\${N}`), me({ type: "text", value: N,
          output: ge });
          continue;
        }
        if (r.dot !== !0 && (j.type === "slash" || j.type === "bos")) {
          me({ type: "qmark", value: N, output: k });
          continue;
        }
        me({ type: "qmark", value: N, output: A });
        continue;
      }
      if (N === "!") {
        if (r.noextglob !== !0 && Q() === "(" && (Q(2) !== "?" || !/[!=<:]/.test(Q(3)))) {
          It("negate", N);
          continue;
        }
        if (r.nonegate !== !0 && R.index === 0) {
          L();
          continue;
        }
      }
      if (N === "+") {
        if (r.noextglob !== !0 && Q() === "(" && Q(2) !== "?") {
          It("plus", N);
          continue;
        }
        if (j && j.value === "(" || r.regex === !1) {
          me({ type: "plus", value: N, output: f });
          continue;
        }
        if (j && (j.type === "bracket" || j.type === "paren" || j.type === "brace") || R.parens > 0) {
          me({ type: "plus", value: N });
          continue;
        }
        me({ type: "plus", value: f });
        continue;
      }
      if (N === "@") {
        if (r.noextglob !== !0 && Q() === "(" && Q(2) !== "?") {
          me({ type: "at", extglob: !0, value: N, output: "" });
          continue;
        }
        me({ type: "text", value: N });
        continue;
      }
      if (N !== "*") {
        (N === "$" || N === "^") && (N = `\\${N}`);
        let K = s5.exec(B());
        K && (N += K[0], R.index += K[0].length), me({ type: "text", value: N });
        continue;
      }
      if (j && (j.type === "globstar" || j.star === !0)) {
        j.type = "star", j.star = !0, j.value += N, j.output = $, R.backtrack = !0, R.globstar = !0, ce(N);
        continue;
      }
      let re = B();
      if (r.noextglob !== !0 && /^\([^?]/.test(re)) {
        It("star", N);
        continue;
      }
      if (j.type === "star") {
        if (r.noglobstar === !0) {
          ce(N);
          continue;
        }
        let K = j.prev, se = K.prev, ge = K.type === "slash" || K.type === "bos", be = se && (se.type === "star" || se.type === "globstar");
        if (r.bash === !0 && (!ge || re[0] && re[0] !== "/")) {
          me({ type: "star", value: N, output: "" });
          continue;
        }
        let Ee = R.braces > 0 && (K.type === "comma" || K.type === "brace"), rt = U.length && (K.type === "pipe" || K.type === "paren");
        if (!ge && K.type !== "paren" && !Ee && !rt) {
          me({ type: "star", value: N, output: "" });
          continue;
        }
        for (; re.slice(0, 3) === "/**"; ) {
          let Ct = e[R.index + 4];
          if (Ct && Ct !== "/")
            break;
          re = re.slice(3), ce("/**", 3);
        }
        if (K.type === "bos" && z()) {
          j.type = "globstar", j.value += N, j.output = C(r), R.output = j.output, R.globstar = !0, ce(N);
          continue;
        }
        if (K.type === "slash" && K.prev.type !== "bos" && !be && z()) {
          R.output = R.output.slice(0, -(K.output + j.output).length), K.output = `(?:${K.output}`, j.type = "globstar", j.output = C(r) + (r.
          strictSlashes ? ")" : "|$)"), j.value += N, R.globstar = !0, R.output += K.output + j.output, ce(N);
          continue;
        }
        if (K.type === "slash" && K.prev.type !== "bos" && re[0] === "/") {
          let Ct = re[1] !== void 0 ? "|$" : "";
          R.output = R.output.slice(0, -(K.output + j.output).length), K.output = `(?:${K.output}`, j.type = "globstar", j.output = `${C(r)}${d}\
|${d}${Ct})`, j.value += N, R.output += K.output + j.output, R.globstar = !0, ce(N + ie()), me({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (K.type === "bos" && re[0] === "/") {
          j.type = "globstar", j.value += N, j.output = `(?:^|${d}|${C(r)}${d})`, R.output = j.output, R.globstar = !0, ce(N + ie()), me({ type: "\
slash", value: "/", output: "" });
          continue;
        }
        R.output = R.output.slice(0, -j.output.length), j.type = "globstar", j.output = C(r), j.value += N, R.output += j.output, R.globstar =
        !0, ce(N);
        continue;
      }
      let xe = { type: "star", value: N, output: $ };
      if (r.bash === !0) {
        xe.output = ".*?", (j.type === "bos" || j.type === "slash") && (xe.output = T + xe.output), me(xe);
        continue;
      }
      if (j && (j.type === "bracket" || j.type === "paren") && r.regex === !0) {
        xe.output = N, me(xe);
        continue;
      }
      (R.index === R.start || j.type === "slash" || j.type === "dot") && (j.type === "dot" ? (R.output += y, j.output += y) : r.dot === !0 ?
      (R.output += E, j.output += E) : (R.output += T, j.output += T), Q() !== "*" && (R.output += m, j.output += m)), me(xe);
    }
    for (; R.brackets > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(As("closing", "]"));
      R.output = Yt.escapeLast(R.output, "["), $e("brackets");
    }
    for (; R.parens > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(As("closing", ")"));
      R.output = Yt.escapeLast(R.output, "("), $e("parens");
    }
    for (; R.braces > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(As("closing", "}"));
      R.output = Yt.escapeLast(R.output, "{"), $e("braces");
    }
    if (r.strictSlashes !== !0 && (j.type === "star" || j.type === "bracket") && me({ type: "maybe_slash", value: "", output: `${d}?` }), R.
    backtrack === !0) {
      R.output = "";
      for (let re of R.tokens)
        R.output += re.output != null ? re.output : re.value, re.suffix && (R.output += re.suffix);
    }
    return R;
  }, "parse");
  nf.fastpaths = (e, t) => {
    let r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(Yu, r.maxLength) : Yu, i = e.length;
    if (i > n)
      throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
    e = Uv[e] || e;
    let o = Yt.isWindows(t), {
      DOT_LITERAL: a,
      SLASH_LITERAL: u,
      ONE_CHAR: l,
      DOTS_SLASH: c,
      NO_DOT: p,
      NO_DOTS: h,
      NO_DOTS_SLASH: f,
      STAR: d,
      START_ANCHOR: m
    } = Ku.globChars(o), g = r.dot ? h : p, b = r.dot ? f : p, y = r.capture ? "" : "?:", E = { negated: !1, prefix: "" }, A = r.bash === !0 ?
    ".*?" : d;
    r.capture && (A = `(${A})`);
    let k = /* @__PURE__ */ s((T) => T.noglobstar === !0 ? A : `(${y}(?:(?!${m}${T.dot ? c : a}).)*?)`, "globstar"), O = /* @__PURE__ */ s((T) => {
      switch (T) {
        case "*":
          return `${g}${l}${A}`;
        case ".*":
          return `${a}${l}${A}`;
        case "*.*":
          return `${g}${A}${a}${l}${A}`;
        case "*/*":
          return `${g}${A}${u}${l}${b}${A}`;
        case "**":
          return g + k(r);
        case "**/*":
          return `(?:${g}${k(r)}${u})?${b}${l}${A}`;
        case "**/*.*":
          return `(?:${g}${k(r)}${u})?${b}${A}${a}${l}${A}`;
        case "**/.*":
          return `(?:${g}${k(r)}${u})?${a}${l}${A}`;
        default: {
          let F = /^(.*?)\.(\w+)$/.exec(T);
          if (!F) return;
          let $ = O(F[1]);
          return $ ? $ + a + F[2] : void 0;
        }
      }
    }, "create"), w = Yt.removePrefix(e, E), C = O(w);
    return C && r.strictSlashes !== !0 && (C += `${u}?`), C;
  };
  Wv.exports = nf;
});

// ../node_modules/picomatch/lib/picomatch.js
var Gv = I((tue, Hv) => {
  "use strict";
  var u5 = require("path"), l5 = Vv(), sf = zv(), of = ta(), c5 = ea(), p5 = /* @__PURE__ */ s((e) => e && typeof e == "object" && !Array.isArray(
  e), "isObject"), pt = /* @__PURE__ */ s((e, t, r = !1) => {
    if (Array.isArray(e)) {
      let p = e.map((f) => pt(f, t, r));
      return /* @__PURE__ */ s((f) => {
        for (let d of p) {
          let m = d(f);
          if (m) return m;
        }
        return !1;
      }, "arrayMatcher");
    }
    let n = p5(e) && e.tokens && e.input;
    if (e === "" || typeof e != "string" && !n)
      throw new TypeError("Expected pattern to be a non-empty string");
    let i = t || {}, o = of.isWindows(t), a = n ? pt.compileRe(e, t) : pt.makeRe(e, t, !1, !0), u = a.state;
    delete a.state;
    let l = /* @__PURE__ */ s(() => !1, "isIgnored");
    if (i.ignore) {
      let p = { ...t, ignore: null, onMatch: null, onResult: null };
      l = pt(i.ignore, p, r);
    }
    let c = /* @__PURE__ */ s((p, h = !1) => {
      let { isMatch: f, match: d, output: m } = pt.test(p, a, t, { glob: e, posix: o }), g = { glob: e, state: u, regex: a, posix: o, input: p,
      output: m, match: d, isMatch: f };
      return typeof i.onResult == "function" && i.onResult(g), f === !1 ? (g.isMatch = !1, h ? g : !1) : l(p) ? (typeof i.onIgnore == "funct\
ion" && i.onIgnore(g), g.isMatch = !1, h ? g : !1) : (typeof i.onMatch == "function" && i.onMatch(g), h ? g : !0);
    }, "matcher");
    return r && (c.state = u), c;
  }, "picomatch");
  pt.test = (e, t, r, { glob: n, posix: i } = {}) => {
    if (typeof e != "string")
      throw new TypeError("Expected input to be a string");
    if (e === "")
      return { isMatch: !1, output: "" };
    let o = r || {}, a = o.format || (i ? of.toPosixSlashes : null), u = e === n, l = u && a ? a(e) : e;
    return u === !1 && (l = a ? a(e) : e, u = l === n), (u === !1 || o.capture === !0) && (o.matchBase === !0 || o.basename === !0 ? u = pt.
    matchBase(e, t, r, i) : u = t.exec(l)), { isMatch: !!u, match: u, output: l };
  };
  pt.matchBase = (e, t, r, n = of.isWindows(r)) => (t instanceof RegExp ? t : pt.makeRe(t, r)).test(u5.basename(e));
  pt.isMatch = (e, t, r) => pt(t, r)(e);
  pt.parse = (e, t) => Array.isArray(e) ? e.map((r) => pt.parse(r, t)) : sf(e, { ...t, fastpaths: !1 });
  pt.scan = (e, t) => l5(e, t);
  pt.compileRe = (e, t, r = !1, n = !1) => {
    if (r === !0)
      return e.output;
    let i = t || {}, o = i.contains ? "" : "^", a = i.contains ? "" : "$", u = `${o}(?:${e.output})${a}`;
    e && e.negated === !0 && (u = `^(?!${u}).*$`);
    let l = pt.toRegex(u, t);
    return n === !0 && (l.state = e), l;
  };
  pt.makeRe = (e, t = {}, r = !1, n = !1) => {
    if (!e || typeof e != "string")
      throw new TypeError("Expected a non-empty string");
    let i = { negated: !1, fastpaths: !0 };
    return t.fastpaths !== !1 && (e[0] === "." || e[0] === "*") && (i.output = sf.fastpaths(e, t)), i.output || (i = sf(e, t)), pt.compileRe(
    i, t, r, n);
  };
  pt.toRegex = (e, t) => {
    try {
      let r = t || {};
      return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
    } catch (r) {
      if (t && t.debug === !0) throw r;
      return /$^/;
    }
  };
  pt.constants = c5;
  Hv.exports = pt;
});

// ../node_modules/picomatch/index.js
var Zv = I((nue, Jv) => {
  "use strict";
  Jv.exports = Gv();
});

// ../node_modules/micromatch/index.js
var tE = I((iue, eE) => {
  "use strict";
  var Kv = require("util"), Yv = kv(), en = Zv(), af = ta(), Xv = /* @__PURE__ */ s((e) => e === "" || e === "./", "isEmptyString"), Qv = /* @__PURE__ */ s(
  (e) => {
    let t = e.indexOf("{");
    return t > -1 && e.indexOf("}", t) > -1;
  }, "hasBraces"), Ke = /* @__PURE__ */ s((e, t, r) => {
    t = [].concat(t), e = [].concat(e);
    let n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = 0, u = /* @__PURE__ */ s((p) => {
      o.add(p.output), r && r.onResult && r.onResult(p);
    }, "onResult");
    for (let p = 0; p < t.length; p++) {
      let h = en(String(t[p]), { ...r, onResult: u }, !0), f = h.state.negated || h.state.negatedExtglob;
      f && a++;
      for (let d of e) {
        let m = h(d, !0);
        (f ? !m.isMatch : m.isMatch) && (f ? n.add(m.output) : (n.delete(m.output), i.add(m.output)));
      }
    }
    let c = (a === t.length ? [...o] : [...i]).filter((p) => !n.has(p));
    if (r && c.length === 0) {
      if (r.failglob === !0)
        throw new Error(`No matches found for "${t.join(", ")}"`);
      if (r.nonull === !0 || r.nullglob === !0)
        return r.unescape ? t.map((p) => p.replace(/\\/g, "")) : t;
    }
    return c;
  }, "micromatch");
  Ke.match = Ke;
  Ke.matcher = (e, t) => en(e, t);
  Ke.isMatch = (e, t, r) => en(t, r)(e);
  Ke.any = Ke.isMatch;
  Ke.not = (e, t, r = {}) => {
    t = [].concat(t).map(String);
    let n = /* @__PURE__ */ new Set(), i = [], o = /* @__PURE__ */ s((u) => {
      r.onResult && r.onResult(u), i.push(u.output);
    }, "onResult"), a = new Set(Ke(e, t, { ...r, onResult: o }));
    for (let u of i)
      a.has(u) || n.add(u);
    return [...n];
  };
  Ke.contains = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${Kv.inspect(e)}"`);
    if (Array.isArray(t))
      return t.some((n) => Ke.contains(e, n, r));
    if (typeof t == "string") {
      if (Xv(e) || Xv(t))
        return !1;
      if (e.includes(t) || e.startsWith("./") && e.slice(2).includes(t))
        return !0;
    }
    return Ke.isMatch(e, t, { ...r, contains: !0 });
  };
  Ke.matchKeys = (e, t, r) => {
    if (!af.isObject(e))
      throw new TypeError("Expected the first argument to be an object");
    let n = Ke(Object.keys(e), t, r), i = {};
    for (let o of n) i[o] = e[o];
    return i;
  };
  Ke.some = (e, t, r) => {
    let n = [].concat(e);
    for (let i of [].concat(t)) {
      let o = en(String(i), r);
      if (n.some((a) => o(a)))
        return !0;
    }
    return !1;
  };
  Ke.every = (e, t, r) => {
    let n = [].concat(e);
    for (let i of [].concat(t)) {
      let o = en(String(i), r);
      if (!n.every((a) => o(a)))
        return !1;
    }
    return !0;
  };
  Ke.all = (e, t, r) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string: "${Kv.inspect(e)}"`);
    return [].concat(t).every((n) => en(n, r)(e));
  };
  Ke.capture = (e, t, r) => {
    let n = af.isWindows(r), o = en.makeRe(String(e), { ...r, capture: !0 }).exec(n ? af.toPosixSlashes(t) : t);
    if (o)
      return o.slice(1).map((a) => a === void 0 ? "" : a);
  };
  Ke.makeRe = (...e) => en.makeRe(...e);
  Ke.scan = (...e) => en.scan(...e);
  Ke.parse = (e, t) => {
    let r = [];
    for (let n of [].concat(e || []))
      for (let i of Yv(String(n), t))
        r.push(en.parse(i, t));
    return r;
  };
  Ke.braces = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return t && t.nobrace === !0 || !Qv(e) ? [e] : Yv(e, t);
  };
  Ke.braceExpand = (e, t) => {
    if (typeof e != "string") throw new TypeError("Expected a string");
    return Ke.braces(e, { ...t, expand: !0 });
  };
  Ke.hasBraces = Qv;
  eE.exports = Ke;
});

// ../node_modules/fast-glob/out/utils/pattern.js
var pE = I((de) => {
  "use strict";
  Object.defineProperty(de, "__esModule", { value: !0 });
  de.isAbsolute = de.partitionAbsoluteAndRelative = de.removeDuplicateSlashes = de.matchAny = de.convertPatternsToRe = de.makeRe = de.getPatternParts =
  de.expandBraceExpansion = de.expandPatternsWithBraceExpansion = de.isAffectDepthOfReadingPattern = de.endsWithSlashGlobStar = de.hasGlobStar =
  de.getBaseDirectory = de.isPatternRelatedToParentDirectory = de.getPatternsOutsideCurrentDirectory = de.getPatternsInsideCurrentDirectory =
  de.getPositivePatterns = de.getNegativePatterns = de.isPositivePattern = de.isNegativePattern = de.convertToNegativePattern = de.convertToPositivePattern =
  de.isDynamicPattern = de.isStaticPattern = void 0;
  var rE = require("path"), h5 = Gb(), uf = tE(), nE = "**", f5 = "\\", d5 = /[*?]|^!/, m5 = /\[[^[]*]/, g5 = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/,
  y5 = /[!*+?@]\([^(]*\)/, D5 = /,|\.\./, x5 = /(?!^)\/{2,}/g;
  function iE(e, t = {}) {
    return !sE(e, t);
  }
  s(iE, "isStaticPattern");
  de.isStaticPattern = iE;
  function sE(e, t = {}) {
    return e === "" ? !1 : !!(t.caseSensitiveMatch === !1 || e.includes(f5) || d5.test(e) || m5.test(e) || g5.test(e) || t.extglob !== !1 &&
    y5.test(e) || t.braceExpansion !== !1 && b5(e));
  }
  s(sE, "isDynamicPattern");
  de.isDynamicPattern = sE;
  function b5(e) {
    let t = e.indexOf("{");
    if (t === -1)
      return !1;
    let r = e.indexOf("}", t + 1);
    if (r === -1)
      return !1;
    let n = e.slice(t, r);
    return D5.test(n);
  }
  s(b5, "hasBraceExpansion");
  function v5(e) {
    return Qu(e) ? e.slice(1) : e;
  }
  s(v5, "convertToPositivePattern");
  de.convertToPositivePattern = v5;
  function E5(e) {
    return "!" + e;
  }
  s(E5, "convertToNegativePattern");
  de.convertToNegativePattern = E5;
  function Qu(e) {
    return e.startsWith("!") && e[1] !== "(";
  }
  s(Qu, "isNegativePattern");
  de.isNegativePattern = Qu;
  function oE(e) {
    return !Qu(e);
  }
  s(oE, "isPositivePattern");
  de.isPositivePattern = oE;
  function C5(e) {
    return e.filter(Qu);
  }
  s(C5, "getNegativePatterns");
  de.getNegativePatterns = C5;
  function w5(e) {
    return e.filter(oE);
  }
  s(w5, "getPositivePatterns");
  de.getPositivePatterns = w5;
  function S5(e) {
    return e.filter((t) => !lf(t));
  }
  s(S5, "getPatternsInsideCurrentDirectory");
  de.getPatternsInsideCurrentDirectory = S5;
  function A5(e) {
    return e.filter(lf);
  }
  s(A5, "getPatternsOutsideCurrentDirectory");
  de.getPatternsOutsideCurrentDirectory = A5;
  function lf(e) {
    return e.startsWith("..") || e.startsWith("./..");
  }
  s(lf, "isPatternRelatedToParentDirectory");
  de.isPatternRelatedToParentDirectory = lf;
  function F5(e) {
    return h5(e, { flipBackslashes: !1 });
  }
  s(F5, "getBaseDirectory");
  de.getBaseDirectory = F5;
  function _5(e) {
    return e.includes(nE);
  }
  s(_5, "hasGlobStar");
  de.hasGlobStar = _5;
  function aE(e) {
    return e.endsWith("/" + nE);
  }
  s(aE, "endsWithSlashGlobStar");
  de.endsWithSlashGlobStar = aE;
  function k5(e) {
    let t = rE.basename(e);
    return aE(e) || iE(t);
  }
  s(k5, "isAffectDepthOfReadingPattern");
  de.isAffectDepthOfReadingPattern = k5;
  function T5(e) {
    return e.reduce((t, r) => t.concat(uE(r)), []);
  }
  s(T5, "expandPatternsWithBraceExpansion");
  de.expandPatternsWithBraceExpansion = T5;
  function uE(e) {
    let t = uf.braces(e, { expand: !0, nodupes: !0, keepEscaping: !0 });
    return t.sort((r, n) => r.length - n.length), t.filter((r) => r !== "");
  }
  s(uE, "expandBraceExpansion");
  de.expandBraceExpansion = uE;
  function I5(e, t) {
    let { parts: r } = uf.scan(e, Object.assign(Object.assign({}, t), { parts: !0 }));
    return r.length === 0 && (r = [e]), r[0].startsWith("/") && (r[0] = r[0].slice(1), r.unshift("")), r;
  }
  s(I5, "getPatternParts");
  de.getPatternParts = I5;
  function lE(e, t) {
    return uf.makeRe(e, t);
  }
  s(lE, "makeRe");
  de.makeRe = lE;
  function P5(e, t) {
    return e.map((r) => lE(r, t));
  }
  s(P5, "convertPatternsToRe");
  de.convertPatternsToRe = P5;
  function B5(e, t) {
    return t.some((r) => r.test(e));
  }
  s(B5, "matchAny");
  de.matchAny = B5;
  function O5(e) {
    return e.replace(x5, "/");
  }
  s(O5, "removeDuplicateSlashes");
  de.removeDuplicateSlashes = O5;
  function R5(e) {
    let t = [], r = [];
    for (let n of e)
      cE(n) ? t.push(n) : r.push(n);
    return [t, r];
  }
  s(R5, "partitionAbsoluteAndRelative");
  de.partitionAbsoluteAndRelative = R5;
  function cE(e) {
    return rE.isAbsolute(e);
  }
  s(cE, "isAbsolute");
  de.isAbsolute = cE;
});

// ../node_modules/merge2/index.js
var mE = I((uue, dE) => {
  "use strict";
  var N5 = require("stream"), hE = N5.PassThrough, L5 = Array.prototype.slice;
  dE.exports = j5;
  function j5() {
    let e = [], t = L5.call(arguments), r = !1, n = t[t.length - 1];
    n && !Array.isArray(n) && n.pipe == null ? t.pop() : n = {};
    let i = n.end !== !1, o = n.pipeError === !0;
    n.objectMode == null && (n.objectMode = !0), n.highWaterMark == null && (n.highWaterMark = 64 * 1024);
    let a = hE(n);
    function u() {
      for (let p = 0, h = arguments.length; p < h; p++)
        e.push(fE(arguments[p], n));
      return l(), this;
    }
    s(u, "addStream");
    function l() {
      if (r)
        return;
      r = !0;
      let p = e.shift();
      if (!p) {
        process.nextTick(c);
        return;
      }
      Array.isArray(p) || (p = [p]);
      let h = p.length + 1;
      function f() {
        --h > 0 || (r = !1, l());
      }
      s(f, "next");
      function d(m) {
        function g() {
          m.removeListener("merge2UnpipeEnd", g), m.removeListener("end", g), o && m.removeListener("error", b), f();
        }
        s(g, "onend");
        function b(y) {
          a.emit("error", y);
        }
        if (s(b, "onerror"), m._readableState.endEmitted)
          return f();
        m.on("merge2UnpipeEnd", g), m.on("end", g), o && m.on("error", b), m.pipe(a, { end: !1 }), m.resume();
      }
      s(d, "pipe");
      for (let m = 0; m < p.length; m++)
        d(p[m]);
      f();
    }
    s(l, "mergeStream");
    function c() {
      r = !1, a.emit("queueDrain"), i && a.end();
    }
    return s(c, "endStream"), a.setMaxListeners(0), a.add = u, a.on("unpipe", function(p) {
      p.emit("merge2UnpipeEnd");
    }), t.length && u.apply(null, t), a;
  }
  s(j5, "merge2");
  function fE(e, t) {
    if (Array.isArray(e))
      for (let r = 0, n = e.length; r < n; r++)
        e[r] = fE(e[r], t);
    else {
      if (!e._readableState && e.pipe && (e = e.pipe(hE(t))), !e._readableState || !e.pause || !e.pipe)
        throw new Error("Only readable stream can be merged.");
      e.pause();
    }
    return e;
  }
  s(fE, "pauseStreams");
});

// ../node_modules/fast-glob/out/utils/stream.js
var yE = I((el) => {
  "use strict";
  Object.defineProperty(el, "__esModule", { value: !0 });
  el.merge = void 0;
  var M5 = mE();
  function q5(e) {
    let t = M5(e);
    return e.forEach((r) => {
      r.once("error", (n) => t.emit("error", n));
    }), t.once("close", () => gE(e)), t.once("end", () => gE(e)), t;
  }
  s(q5, "merge");
  el.merge = q5;
  function gE(e) {
    e.forEach((t) => t.emit("close"));
  }
  s(gE, "propagateCloseEventToSources");
});

// ../node_modules/fast-glob/out/utils/string.js
var DE = I((Fs) => {
  "use strict";
  Object.defineProperty(Fs, "__esModule", { value: !0 });
  Fs.isEmpty = Fs.isString = void 0;
  function $5(e) {
    return typeof e == "string";
  }
  s($5, "isString");
  Fs.isString = $5;
  function V5(e) {
    return e === "";
  }
  s(V5, "isEmpty");
  Fs.isEmpty = V5;
});

// ../node_modules/fast-glob/out/utils/index.js
var An = I((At) => {
  "use strict";
  Object.defineProperty(At, "__esModule", { value: !0 });
  At.string = At.stream = At.pattern = At.path = At.fs = At.errno = At.array = void 0;
  var U5 = Ob();
  At.array = U5;
  var W5 = Rb();
  At.errno = W5;
  var z5 = Nb();
  At.fs = z5;
  var H5 = qb();
  At.path = H5;
  var G5 = pE();
  At.pattern = G5;
  var J5 = yE();
  At.stream = J5;
  var Z5 = DE();
  At.string = Z5;
});

// ../node_modules/fast-glob/out/managers/tasks.js
var EE = I((Ft) => {
  "use strict";
  Object.defineProperty(Ft, "__esModule", { value: !0 });
  Ft.convertPatternGroupToTask = Ft.convertPatternGroupsToTasks = Ft.groupPatternsByBaseDirectory = Ft.getNegativePatternsAsPositive = Ft.getPositivePatterns =
  Ft.convertPatternsToTasks = Ft.generate = void 0;
  var Or = An();
  function X5(e, t) {
    let r = xE(e, t), n = xE(t.ignore, t), i = bE(r), o = vE(r, n), a = i.filter((p) => Or.pattern.isStaticPattern(p, t)), u = i.filter((p) => Or.
    pattern.isDynamicPattern(p, t)), l = cf(
      a,
      o,
      /* dynamic */
      !1
    ), c = cf(
      u,
      o,
      /* dynamic */
      !0
    );
    return l.concat(c);
  }
  s(X5, "generate");
  Ft.generate = X5;
  function xE(e, t) {
    let r = e;
    return t.braceExpansion && (r = Or.pattern.expandPatternsWithBraceExpansion(r)), t.baseNameMatch && (r = r.map((n) => n.includes("/") ? n :
    `**/${n}`)), r.map((n) => Or.pattern.removeDuplicateSlashes(n));
  }
  s(xE, "processPatterns");
  function cf(e, t, r) {
    let n = [], i = Or.pattern.getPatternsOutsideCurrentDirectory(e), o = Or.pattern.getPatternsInsideCurrentDirectory(e), a = pf(i), u = pf(
    o);
    return n.push(...hf(a, t, r)), "." in u ? n.push(ff(".", o, t, r)) : n.push(...hf(u, t, r)), n;
  }
  s(cf, "convertPatternsToTasks");
  Ft.convertPatternsToTasks = cf;
  function bE(e) {
    return Or.pattern.getPositivePatterns(e);
  }
  s(bE, "getPositivePatterns");
  Ft.getPositivePatterns = bE;
  function vE(e, t) {
    return Or.pattern.getNegativePatterns(e).concat(t).map(Or.pattern.convertToPositivePattern);
  }
  s(vE, "getNegativePatternsAsPositive");
  Ft.getNegativePatternsAsPositive = vE;
  function pf(e) {
    let t = {};
    return e.reduce((r, n) => {
      let i = Or.pattern.getBaseDirectory(n);
      return i in r ? r[i].push(n) : r[i] = [n], r;
    }, t);
  }
  s(pf, "groupPatternsByBaseDirectory");
  Ft.groupPatternsByBaseDirectory = pf;
  function hf(e, t, r) {
    return Object.keys(e).map((n) => ff(n, e[n], t, r));
  }
  s(hf, "convertPatternGroupsToTasks");
  Ft.convertPatternGroupsToTasks = hf;
  function ff(e, t, r, n) {
    return {
      dynamic: n,
      positive: t,
      negative: r,
      base: e,
      patterns: [].concat(t, r.map(Or.pattern.convertToNegativePattern))
    };
  }
  s(ff, "convertPatternGroupToTask");
  Ft.convertPatternGroupToTask = ff;
});

// ../node_modules/@nodelib/fs.stat/out/providers/async.js
var wE = I((tl) => {
  "use strict";
  Object.defineProperty(tl, "__esModule", { value: !0 });
  tl.read = void 0;
  function K5(e, t, r) {
    t.fs.lstat(e, (n, i) => {
      if (n !== null) {
        CE(r, n);
        return;
      }
      if (!i.isSymbolicLink() || !t.followSymbolicLink) {
        df(r, i);
        return;
      }
      t.fs.stat(e, (o, a) => {
        if (o !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            CE(r, o);
            return;
          }
          df(r, i);
          return;
        }
        t.markSymbolicLink && (a.isSymbolicLink = () => !0), df(r, a);
      });
    });
  }
  s(K5, "read");
  tl.read = K5;
  function CE(e, t) {
    e(t);
  }
  s(CE, "callFailureCallback");
  function df(e, t) {
    e(null, t);
  }
  s(df, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.stat/out/providers/sync.js
var SE = I((rl) => {
  "use strict";
  Object.defineProperty(rl, "__esModule", { value: !0 });
  rl.read = void 0;
  function Y5(e, t) {
    let r = t.fs.lstatSync(e);
    if (!r.isSymbolicLink() || !t.followSymbolicLink)
      return r;
    try {
      let n = t.fs.statSync(e);
      return t.markSymbolicLink && (n.isSymbolicLink = () => !0), n;
    } catch (n) {
      if (!t.throwErrorOnBrokenSymbolicLink)
        return r;
      throw n;
    }
  }
  s(Y5, "read");
  rl.read = Y5;
});

// ../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var AE = I((Xn) => {
  "use strict";
  Object.defineProperty(Xn, "__esModule", { value: !0 });
  Xn.createFileSystemAdapter = Xn.FILE_SYSTEM_ADAPTER = void 0;
  var nl = require("fs");
  Xn.FILE_SYSTEM_ADAPTER = {
    lstat: nl.lstat,
    stat: nl.stat,
    lstatSync: nl.lstatSync,
    statSync: nl.statSync
  };
  function Q5(e) {
    return e === void 0 ? Xn.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, Xn.FILE_SYSTEM_ADAPTER), e);
  }
  s(Q5, "createFileSystemAdapter");
  Xn.createFileSystemAdapter = Q5;
});

// ../node_modules/@nodelib/fs.stat/out/settings.js
var FE = I((gf) => {
  "use strict";
  Object.defineProperty(gf, "__esModule", { value: !0 });
  var e7 = AE(), mf = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = e7.createFileSystemAdapter(
      this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this.
      _getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  gf.default = mf;
});

// ../node_modules/@nodelib/fs.stat/out/index.js
var Oi = I((Kn) => {
  "use strict";
  Object.defineProperty(Kn, "__esModule", { value: !0 });
  Kn.statSync = Kn.stat = Kn.Settings = void 0;
  var _E = wE(), t7 = SE(), yf = FE();
  Kn.Settings = yf.default;
  function r7(e, t, r) {
    if (typeof t == "function") {
      _E.read(e, Df(), t);
      return;
    }
    _E.read(e, Df(t), r);
  }
  s(r7, "stat");
  Kn.stat = r7;
  function n7(e, t) {
    let r = Df(t);
    return t7.read(e, r);
  }
  s(n7, "statSync");
  Kn.statSync = n7;
  function Df(e = {}) {
    return e instanceof yf.default ? e : new yf.default(e);
  }
  s(Df, "getSettings");
});

// ../node_modules/queue-microtask/index.js
var IE = I((Fue, TE) => {
  var kE;
  TE.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (e) => (kE || (kE = Promise.
  resolve())).then(e).catch((t) => setTimeout(() => {
    throw t;
  }, 0));
});

// ../node_modules/run-parallel/index.js
var BE = I((_ue, PE) => {
  PE.exports = s7;
  var i7 = IE();
  function s7(e, t) {
    let r, n, i, o = !0;
    Array.isArray(e) ? (r = [], n = e.length) : (i = Object.keys(e), r = {}, n = i.length);
    function a(l) {
      function c() {
        t && t(l, r), t = null;
      }
      s(c, "end"), o ? i7(c) : c();
    }
    s(a, "done");
    function u(l, c, p) {
      r[l] = p, (--n === 0 || c) && a(c);
    }
    s(u, "each"), n ? i ? i.forEach(function(l) {
      e[l](function(c, p) {
        u(l, c, p);
      });
    }) : e.forEach(function(l, c) {
      l(function(p, h) {
        u(c, p, h);
      });
    }) : a(null), o = !1;
  }
  s(s7, "runParallel");
});

// ../node_modules/@nodelib/fs.scandir/out/constants.js
var xf = I((sl) => {
  "use strict";
  Object.defineProperty(sl, "__esModule", { value: !0 });
  sl.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var il = process.versions.node.split(".");
  if (il[0] === void 0 || il[1] === void 0)
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  var OE = Number.parseInt(il[0], 10), o7 = Number.parseInt(il[1], 10), RE = 10, a7 = 10, u7 = OE > RE, l7 = OE === RE && o7 >= a7;
  sl.IS_SUPPORT_READDIR_WITH_FILE_TYPES = u7 || l7;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var NE = I((ol) => {
  "use strict";
  Object.defineProperty(ol, "__esModule", { value: !0 });
  ol.createDirentFromStats = void 0;
  var bf = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(t, r) {
      this.name = t, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function c7(e, t) {
    return new bf(e, t);
  }
  s(c7, "createDirentFromStats");
  ol.createDirentFromStats = c7;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/index.js
var vf = I((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", { value: !0 });
  al.fs = void 0;
  var p7 = NE();
  al.fs = p7;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/common.js
var Ef = I((ul) => {
  "use strict";
  Object.defineProperty(ul, "__esModule", { value: !0 });
  ul.joinPathSegments = void 0;
  function h7(e, t, r) {
    return e.endsWith(r) ? e + t : e + r + t;
  }
  s(h7, "joinPathSegments");
  ul.joinPathSegments = h7;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/async.js
var VE = I((Yn) => {
  "use strict";
  Object.defineProperty(Yn, "__esModule", { value: !0 });
  Yn.readdir = Yn.readdirWithFileTypes = Yn.read = void 0;
  var f7 = Oi(), LE = BE(), d7 = xf(), jE = vf(), ME = Ef();
  function m7(e, t, r) {
    if (!t.stats && d7.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      qE(e, t, r);
      return;
    }
    $E(e, t, r);
  }
  s(m7, "read");
  Yn.read = m7;
  function qE(e, t, r) {
    t.fs.readdir(e, { withFileTypes: !0 }, (n, i) => {
      if (n !== null) {
        ll(r, n);
        return;
      }
      let o = i.map((u) => ({
        dirent: u,
        name: u.name,
        path: ME.joinPathSegments(e, u.name, t.pathSegmentSeparator)
      }));
      if (!t.followSymbolicLinks) {
        Cf(r, o);
        return;
      }
      let a = o.map((u) => g7(u, t));
      LE(a, (u, l) => {
        if (u !== null) {
          ll(r, u);
          return;
        }
        Cf(r, l);
      });
    });
  }
  s(qE, "readdirWithFileTypes");
  Yn.readdirWithFileTypes = qE;
  function g7(e, t) {
    return (r) => {
      if (!e.dirent.isSymbolicLink()) {
        r(null, e);
        return;
      }
      t.fs.stat(e.path, (n, i) => {
        if (n !== null) {
          if (t.throwErrorOnBrokenSymbolicLink) {
            r(n);
            return;
          }
          r(null, e);
          return;
        }
        e.dirent = jE.fs.createDirentFromStats(e.name, i), r(null, e);
      });
    };
  }
  s(g7, "makeRplTaskEntry");
  function $E(e, t, r) {
    t.fs.readdir(e, (n, i) => {
      if (n !== null) {
        ll(r, n);
        return;
      }
      let o = i.map((a) => {
        let u = ME.joinPathSegments(e, a, t.pathSegmentSeparator);
        return (l) => {
          f7.stat(u, t.fsStatSettings, (c, p) => {
            if (c !== null) {
              l(c);
              return;
            }
            let h = {
              name: a,
              path: u,
              dirent: jE.fs.createDirentFromStats(a, p)
            };
            t.stats && (h.stats = p), l(null, h);
          });
        };
      });
      LE(o, (a, u) => {
        if (a !== null) {
          ll(r, a);
          return;
        }
        Cf(r, u);
      });
    });
  }
  s($E, "readdir");
  Yn.readdir = $E;
  function ll(e, t) {
    e(t);
  }
  s(ll, "callFailureCallback");
  function Cf(e, t) {
    e(null, t);
  }
  s(Cf, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var GE = I((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", { value: !0 });
  Qn.readdir = Qn.readdirWithFileTypes = Qn.read = void 0;
  var y7 = Oi(), D7 = xf(), UE = vf(), WE = Ef();
  function x7(e, t) {
    return !t.stats && D7.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? zE(e, t) : HE(e, t);
  }
  s(x7, "read");
  Qn.read = x7;
  function zE(e, t) {
    return t.fs.readdirSync(e, { withFileTypes: !0 }).map((n) => {
      let i = {
        dirent: n,
        name: n.name,
        path: WE.joinPathSegments(e, n.name, t.pathSegmentSeparator)
      };
      if (i.dirent.isSymbolicLink() && t.followSymbolicLinks)
        try {
          let o = t.fs.statSync(i.path);
          i.dirent = UE.fs.createDirentFromStats(i.name, o);
        } catch (o) {
          if (t.throwErrorOnBrokenSymbolicLink)
            throw o;
        }
      return i;
    });
  }
  s(zE, "readdirWithFileTypes");
  Qn.readdirWithFileTypes = zE;
  function HE(e, t) {
    return t.fs.readdirSync(e).map((n) => {
      let i = WE.joinPathSegments(e, n, t.pathSegmentSeparator), o = y7.statSync(i, t.fsStatSettings), a = {
        name: n,
        path: i,
        dirent: UE.fs.createDirentFromStats(n, o)
      };
      return t.stats && (a.stats = o), a;
    });
  }
  s(HE, "readdir");
  Qn.readdir = HE;
});

// ../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var JE = I((ei) => {
  "use strict";
  Object.defineProperty(ei, "__esModule", { value: !0 });
  ei.createFileSystemAdapter = ei.FILE_SYSTEM_ADAPTER = void 0;
  var _s = require("fs");
  ei.FILE_SYSTEM_ADAPTER = {
    lstat: _s.lstat,
    stat: _s.stat,
    lstatSync: _s.lstatSync,
    statSync: _s.statSync,
    readdir: _s.readdir,
    readdirSync: _s.readdirSync
  };
  function b7(e) {
    return e === void 0 ? ei.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, ei.FILE_SYSTEM_ADAPTER), e);
  }
  s(b7, "createFileSystemAdapter");
  ei.createFileSystemAdapter = b7;
});

// ../node_modules/@nodelib/fs.scandir/out/settings.js
var ZE = I((Sf) => {
  "use strict";
  Object.defineProperty(Sf, "__esModule", { value: !0 });
  var v7 = require("path"), E7 = Oi(), C7 = JE(), wf = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = C7.createFileSystemAdapter(
      this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, v7.sep), this.stats = this._getValue(
      this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.
      fsStatSettings = new E7.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  Sf.default = wf;
});

// ../node_modules/@nodelib/fs.scandir/out/index.js
var cl = I((ti) => {
  "use strict";
  Object.defineProperty(ti, "__esModule", { value: !0 });
  ti.Settings = ti.scandirSync = ti.scandir = void 0;
  var XE = VE(), w7 = GE(), Af = ZE();
  ti.Settings = Af.default;
  function S7(e, t, r) {
    if (typeof t == "function") {
      XE.read(e, Ff(), t);
      return;
    }
    XE.read(e, Ff(t), r);
  }
  s(S7, "scandir");
  ti.scandir = S7;
  function A7(e, t) {
    let r = Ff(t);
    return w7.read(e, r);
  }
  s(A7, "scandirSync");
  ti.scandirSync = A7;
  function Ff(e = {}) {
    return e instanceof Af.default ? e : new Af.default(e);
  }
  s(Ff, "getSettings");
});

// ../node_modules/reusify/reusify.js
var YE = I((Hue, KE) => {
  "use strict";
  function F7(e) {
    var t = new e(), r = t;
    function n() {
      var o = t;
      return o.next ? t = o.next : (t = new e(), r = t), o.next = null, o;
    }
    s(n, "get");
    function i(o) {
      r.next = o, r = o;
    }
    return s(i, "release"), {
      get: n,
      release: i
    };
  }
  s(F7, "reusify");
  KE.exports = F7;
});

// ../node_modules/fastq/queue.js
var e1 = I((Jue, _f) => {
  "use strict";
  var _7 = YE();
  function QE(e, t, r) {
    if (typeof e == "function" && (r = t, t = e, e = null), !(r >= 1))
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    var n = _7(k7), i = null, o = null, a = 0, u = null, l = {
      push: g,
      drain: lr,
      saturated: lr,
      pause: p,
      paused: !1,
      get concurrency() {
        return r;
      },
      set concurrency(O) {
        if (!(O >= 1))
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        if (r = O, !l.paused)
          for (; i && a < r; )
            a++, y();
      },
      running: c,
      resume: d,
      idle: m,
      length: h,
      getQueue: f,
      unshift: b,
      empty: lr,
      kill: E,
      killAndDrain: A,
      error: k
    };
    return l;
    function c() {
      return a;
    }
    function p() {
      l.paused = !0;
    }
    function h() {
      for (var O = i, w = 0; O; )
        O = O.next, w++;
      return w;
    }
    function f() {
      for (var O = i, w = []; O; )
        w.push(O.value), O = O.next;
      return w;
    }
    function d() {
      if (l.paused) {
        if (l.paused = !1, i === null) {
          a++, y();
          return;
        }
        for (; i && a < r; )
          a++, y();
      }
    }
    function m() {
      return a === 0 && l.length() === 0;
    }
    function g(O, w) {
      var C = n.get();
      C.context = e, C.release = y, C.value = O, C.callback = w || lr, C.errorHandler = u, a >= r || l.paused ? o ? (o.next = C, o = C) : (i =
      C, o = C, l.saturated()) : (a++, t.call(e, C.value, C.worked));
    }
    function b(O, w) {
      var C = n.get();
      C.context = e, C.release = y, C.value = O, C.callback = w || lr, C.errorHandler = u, a >= r || l.paused ? i ? (C.next = i, i = C) : (i =
      C, o = C, l.saturated()) : (a++, t.call(e, C.value, C.worked));
    }
    function y(O) {
      O && n.release(O);
      var w = i;
      w && a <= r ? l.paused ? a-- : (o === i && (o = null), i = w.next, w.next = null, t.call(e, w.value, w.worked), o === null && l.empty()) :
      --a === 0 && l.drain();
    }
    function E() {
      i = null, o = null, l.drain = lr;
    }
    function A() {
      i = null, o = null, l.drain(), l.drain = lr;
    }
    function k(O) {
      u = O;
    }
  }
  s(QE, "fastqueue");
  function lr() {
  }
  s(lr, "noop");
  function k7() {
    this.value = null, this.callback = lr, this.next = null, this.release = lr, this.context = null, this.errorHandler = null;
    var e = this;
    this.worked = /* @__PURE__ */ s(function(r, n) {
      var i = e.callback, o = e.errorHandler, a = e.value;
      e.value = null, e.callback = lr, e.errorHandler && o(r, a), i.call(e.context, r, n), e.release(e);
    }, "worked");
  }
  s(k7, "Task");
  function T7(e, t, r) {
    typeof e == "function" && (r = t, t = e, e = null);
    function n(p, h) {
      t.call(this, p).then(function(f) {
        h(null, f);
      }, h);
    }
    s(n, "asyncWrapper");
    var i = QE(e, n, r), o = i.push, a = i.unshift;
    return i.push = u, i.unshift = l, i.drained = c, i;
    function u(p) {
      var h = new Promise(function(f, d) {
        o(p, function(m, g) {
          if (m) {
            d(m);
            return;
          }
          f(g);
        });
      });
      return h.catch(lr), h;
    }
    s(u, "push");
    function l(p) {
      var h = new Promise(function(f, d) {
        a(p, function(m, g) {
          if (m) {
            d(m);
            return;
          }
          f(g);
        });
      });
      return h.catch(lr), h;
    }
    s(l, "unshift");
    function c() {
      var p = new Promise(function(h) {
        process.nextTick(function() {
          if (i.idle())
            h();
          else {
            var f = i.drain;
            i.drain = function() {
              typeof f == "function" && f(), h(), i.drain = f;
            };
          }
        });
      });
      return p;
    }
    s(c, "drained");
  }
  s(T7, "queueAsPromised");
  _f.exports = QE;
  _f.exports.promise = T7;
});

// ../node_modules/@nodelib/fs.walk/out/readers/common.js
var pl = I((tn) => {
  "use strict";
  Object.defineProperty(tn, "__esModule", { value: !0 });
  tn.joinPathSegments = tn.replacePathSegmentSeparator = tn.isAppliedFilter = tn.isFatalError = void 0;
  function I7(e, t) {
    return e.errorFilter === null ? !0 : !e.errorFilter(t);
  }
  s(I7, "isFatalError");
  tn.isFatalError = I7;
  function P7(e, t) {
    return e === null || e(t);
  }
  s(P7, "isAppliedFilter");
  tn.isAppliedFilter = P7;
  function B7(e, t) {
    return e.split(/[/\\]/).join(t);
  }
  s(B7, "replacePathSegmentSeparator");
  tn.replacePathSegmentSeparator = B7;
  function O7(e, t, r) {
    return e === "" ? t : e.endsWith(r) ? e + t : e + r + t;
  }
  s(O7, "joinPathSegments");
  tn.joinPathSegments = O7;
});

// ../node_modules/@nodelib/fs.walk/out/readers/reader.js
var If = I((Tf) => {
  "use strict";
  Object.defineProperty(Tf, "__esModule", { value: !0 });
  var R7 = pl(), kf = class {
    static {
      s(this, "Reader");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._root = R7.replacePathSegmentSeparator(t, r.pathSegmentSeparator);
    }
  };
  Tf.default = kf;
});

// ../node_modules/@nodelib/fs.walk/out/readers/async.js
var Of = I((Bf) => {
  "use strict";
  Object.defineProperty(Bf, "__esModule", { value: !0 });
  var N7 = require("events"), L7 = cl(), j7 = e1(), hl = pl(), M7 = If(), Pf = class extends M7.default {
    static {
      s(this, "AsyncReader");
    }
    constructor(t, r) {
      super(t, r), this._settings = r, this._scandir = L7.scandir, this._emitter = new N7.EventEmitter(), this._queue = j7(this._worker.bind(
      this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
        this._isFatalError || this._emitter.emit("end");
      };
    }
    read() {
      return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      }), this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed)
        throw new Error("The reader is already destroyed");
      this._isDestroyed = !0, this._queue.killAndDrain();
    }
    onEntry(t) {
      this._emitter.on("entry", t);
    }
    onError(t) {
      this._emitter.once("error", t);
    }
    onEnd(t) {
      this._emitter.once("end", t);
    }
    _pushToQueue(t, r) {
      let n = { directory: t, base: r };
      this._queue.push(n, (i) => {
        i !== null && this._handleError(i);
      });
    }
    _worker(t, r) {
      this._scandir(t.directory, this._settings.fsScandirSettings, (n, i) => {
        if (n !== null) {
          r(n, void 0);
          return;
        }
        for (let o of i)
          this._handleEntry(o, t.base);
        r(null, void 0);
      });
    }
    _handleError(t) {
      this._isDestroyed || !hl.isFatalError(this._settings, t) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("erro\
r", t));
    }
    _handleEntry(t, r) {
      if (this._isDestroyed || this._isFatalError)
        return;
      let n = t.path;
      r !== void 0 && (t.path = hl.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), hl.isAppliedFilter(this._settings.entryFilter,
      t) && this._emitEntry(t), t.dirent.isDirectory() && hl.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(n, r === void 0 ?
      void 0 : t.path);
    }
    _emitEntry(t) {
      this._emitter.emit("entry", t);
    }
  };
  Bf.default = Pf;
});

// ../node_modules/@nodelib/fs.walk/out/providers/async.js
var t1 = I((Nf) => {
  "use strict";
  Object.defineProperty(Nf, "__esModule", { value: !0 });
  var q7 = Of(), Rf = class {
    static {
      s(this, "AsyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new q7.default(this._root, this._settings), this._storage = [];
    }
    read(t) {
      this._reader.onError((r) => {
        $7(t, r);
      }), this._reader.onEntry((r) => {
        this._storage.push(r);
      }), this._reader.onEnd(() => {
        V7(t, this._storage);
      }), this._reader.read();
    }
  };
  Nf.default = Rf;
  function $7(e, t) {
    e(t);
  }
  s($7, "callFailureCallback");
  function V7(e, t) {
    e(null, t);
  }
  s(V7, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.walk/out/providers/stream.js
var r1 = I((jf) => {
  "use strict";
  Object.defineProperty(jf, "__esModule", { value: !0 });
  var U7 = require("stream"), W7 = Of(), Lf = class {
    static {
      s(this, "StreamProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new W7.default(this._root, this._settings), this._stream = new U7.Readable({
        objectMode: !0,
        read: /* @__PURE__ */ s(() => {
        }, "read"),
        destroy: /* @__PURE__ */ s(() => {
          this._reader.isDestroyed || this._reader.destroy();
        }, "destroy")
      });
    }
    read() {
      return this._reader.onError((t) => {
        this._stream.emit("error", t);
      }), this._reader.onEntry((t) => {
        this._stream.push(t);
      }), this._reader.onEnd(() => {
        this._stream.push(null);
      }), this._reader.read(), this._stream;
    }
  };
  jf.default = Lf;
});

// ../node_modules/@nodelib/fs.walk/out/readers/sync.js
var n1 = I((qf) => {
  "use strict";
  Object.defineProperty(qf, "__esModule", { value: !0 });
  var z7 = cl(), fl = pl(), H7 = If(), Mf = class extends H7.default {
    static {
      s(this, "SyncReader");
    }
    constructor() {
      super(...arguments), this._scandir = z7.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
    }
    read() {
      return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
    }
    _pushToQueue(t, r) {
      this._queue.add({ directory: t, base: r });
    }
    _handleQueue() {
      for (let t of this._queue.values())
        this._handleDirectory(t.directory, t.base);
    }
    _handleDirectory(t, r) {
      try {
        let n = this._scandir(t, this._settings.fsScandirSettings);
        for (let i of n)
          this._handleEntry(i, r);
      } catch (n) {
        this._handleError(n);
      }
    }
    _handleError(t) {
      if (fl.isFatalError(this._settings, t))
        throw t;
    }
    _handleEntry(t, r) {
      let n = t.path;
      r !== void 0 && (t.path = fl.joinPathSegments(r, t.name, this._settings.pathSegmentSeparator)), fl.isAppliedFilter(this._settings.entryFilter,
      t) && this._pushToStorage(t), t.dirent.isDirectory() && fl.isAppliedFilter(this._settings.deepFilter, t) && this._pushToQueue(n, r ===
      void 0 ? void 0 : t.path);
    }
    _pushToStorage(t) {
      this._storage.push(t);
    }
  };
  qf.default = Mf;
});

// ../node_modules/@nodelib/fs.walk/out/providers/sync.js
var i1 = I((Vf) => {
  "use strict";
  Object.defineProperty(Vf, "__esModule", { value: !0 });
  var G7 = n1(), $f = class {
    static {
      s(this, "SyncProvider");
    }
    constructor(t, r) {
      this._root = t, this._settings = r, this._reader = new G7.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  Vf.default = $f;
});

// ../node_modules/@nodelib/fs.walk/out/settings.js
var s1 = I((Wf) => {
  "use strict";
  Object.defineProperty(Wf, "__esModule", { value: !0 });
  var J7 = require("path"), Z7 = cl(), Uf = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency,
      Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.
      entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this.
      _options.pathSegmentSeparator, J7.sep), this.fsScandirSettings = new Z7.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(t, r) {
      return t ?? r;
    }
  };
  Wf.default = Uf;
});

// ../node_modules/@nodelib/fs.walk/out/index.js
var ml = I((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", { value: !0 });
  rn.Settings = rn.walkStream = rn.walkSync = rn.walk = void 0;
  var o1 = t1(), X7 = r1(), K7 = i1(), zf = s1();
  rn.Settings = zf.default;
  function Y7(e, t, r) {
    if (typeof t == "function") {
      new o1.default(e, dl()).read(t);
      return;
    }
    new o1.default(e, dl(t)).read(r);
  }
  s(Y7, "walk");
  rn.walk = Y7;
  function Q7(e, t) {
    let r = dl(t);
    return new K7.default(e, r).read();
  }
  s(Q7, "walkSync");
  rn.walkSync = Q7;
  function eL(e, t) {
    let r = dl(t);
    return new X7.default(e, r).read();
  }
  s(eL, "walkStream");
  rn.walkStream = eL;
  function dl(e = {}) {
    return e instanceof zf.default ? e : new zf.default(e);
  }
  s(dl, "getSettings");
});

// ../node_modules/fast-glob/out/readers/reader.js
var gl = I((Gf) => {
  "use strict";
  Object.defineProperty(Gf, "__esModule", { value: !0 });
  var tL = require("path"), rL = Oi(), a1 = An(), Hf = class {
    static {
      s(this, "Reader");
    }
    constructor(t) {
      this._settings = t, this._fsStatSettings = new rL.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(t) {
      return tL.resolve(this._settings.cwd, t);
    }
    _makeEntry(t, r) {
      let n = {
        name: r,
        path: r,
        dirent: a1.fs.createDirentFromStats(r, t)
      };
      return this._settings.stats && (n.stats = t), n;
    }
    _isFatalError(t) {
      return !a1.errno.isEnoentCodeError(t) && !this._settings.suppressErrors;
    }
  };
  Gf.default = Hf;
});

// ../node_modules/fast-glob/out/readers/stream.js
var Xf = I((Zf) => {
  "use strict";
  Object.defineProperty(Zf, "__esModule", { value: !0 });
  var nL = require("stream"), iL = Oi(), sL = ml(), oL = gl(), Jf = class extends oL.default {
    static {
      s(this, "ReaderStream");
    }
    constructor() {
      super(...arguments), this._walkStream = sL.walkStream, this._stat = iL.stat;
    }
    dynamic(t, r) {
      return this._walkStream(t, r);
    }
    static(t, r) {
      let n = t.map(this._getFullEntryPath, this), i = new nL.PassThrough({ objectMode: !0 });
      i._write = (o, a, u) => this._getEntry(n[o], t[o], r).then((l) => {
        l !== null && r.entryFilter(l) && i.push(l), o === n.length - 1 && i.end(), u();
      }).catch(u);
      for (let o = 0; o < n.length; o++)
        i.write(o);
      return i;
    }
    _getEntry(t, r, n) {
      return this._getStat(t).then((i) => this._makeEntry(i, r)).catch((i) => {
        if (n.errorFilter(i))
          return null;
        throw i;
      });
    }
    _getStat(t) {
      return new Promise((r, n) => {
        this._stat(t, this._fsStatSettings, (i, o) => i === null ? r(o) : n(i));
      });
    }
  };
  Zf.default = Jf;
});

// ../node_modules/fast-glob/out/readers/async.js
var u1 = I((Yf) => {
  "use strict";
  Object.defineProperty(Yf, "__esModule", { value: !0 });
  var aL = ml(), uL = gl(), lL = Xf(), Kf = class extends uL.default {
    static {
      s(this, "ReaderAsync");
    }
    constructor() {
      super(...arguments), this._walkAsync = aL.walk, this._readerStream = new lL.default(this._settings);
    }
    dynamic(t, r) {
      return new Promise((n, i) => {
        this._walkAsync(t, r, (o, a) => {
          o === null ? n(a) : i(o);
        });
      });
    }
    async static(t, r) {
      let n = [], i = this._readerStream.static(t, r);
      return new Promise((o, a) => {
        i.once("error", a), i.on("data", (u) => n.push(u)), i.once("end", () => o(n));
      });
    }
  };
  Yf.default = Kf;
});

// ../node_modules/fast-glob/out/providers/matchers/matcher.js
var l1 = I((ed) => {
  "use strict";
  Object.defineProperty(ed, "__esModule", { value: !0 });
  var na = An(), Qf = class {
    static {
      s(this, "Matcher");
    }
    constructor(t, r, n) {
      this._patterns = t, this._settings = r, this._micromatchOptions = n, this._storage = [], this._fillStorage();
    }
    _fillStorage() {
      for (let t of this._patterns) {
        let r = this._getPatternSegments(t), n = this._splitSegmentsIntoSections(r);
        this._storage.push({
          complete: n.length <= 1,
          pattern: t,
          segments: r,
          sections: n
        });
      }
    }
    _getPatternSegments(t) {
      return na.pattern.getPatternParts(t, this._micromatchOptions).map((n) => na.pattern.isDynamicPattern(n, this._settings) ? {
        dynamic: !0,
        pattern: n,
        patternRe: na.pattern.makeRe(n, this._micromatchOptions)
      } : {
        dynamic: !1,
        pattern: n
      });
    }
    _splitSegmentsIntoSections(t) {
      return na.array.splitWhen(t, (r) => r.dynamic && na.pattern.hasGlobStar(r.pattern));
    }
  };
  ed.default = Qf;
});

// ../node_modules/fast-glob/out/providers/matchers/partial.js
var c1 = I((rd) => {
  "use strict";
  Object.defineProperty(rd, "__esModule", { value: !0 });
  var cL = l1(), td = class extends cL.default {
    static {
      s(this, "PartialMatcher");
    }
    match(t) {
      let r = t.split("/"), n = r.length, i = this._storage.filter((o) => !o.complete || o.segments.length > n);
      for (let o of i) {
        let a = o.sections[0];
        if (!o.complete && n > a.length || r.every((l, c) => {
          let p = o.segments[c];
          return !!(p.dynamic && p.patternRe.test(l) || !p.dynamic && p.pattern === l);
        }))
          return !0;
      }
      return !1;
    }
  };
  rd.default = td;
});

// ../node_modules/fast-glob/out/providers/filters/deep.js
var p1 = I((id) => {
  "use strict";
  Object.defineProperty(id, "__esModule", { value: !0 });
  var yl = An(), pL = c1(), nd = class {
    static {
      s(this, "DeepFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r;
    }
    getFilter(t, r, n) {
      let i = this._getMatcher(r), o = this._getNegativePatternsRe(n);
      return (a) => this._filter(t, a, i, o);
    }
    _getMatcher(t) {
      return new pL.default(t, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(t) {
      let r = t.filter(yl.pattern.isAffectDepthOfReadingPattern);
      return yl.pattern.convertPatternsToRe(r, this._micromatchOptions);
    }
    _filter(t, r, n, i) {
      if (this._isSkippedByDeep(t, r.path) || this._isSkippedSymbolicLink(r))
        return !1;
      let o = yl.path.removeLeadingDotSegment(r.path);
      return this._isSkippedByPositivePatterns(o, n) ? !1 : this._isSkippedByNegativePatterns(o, i);
    }
    _isSkippedByDeep(t, r) {
      return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(t, r) >= this._settings.deep;
    }
    _getEntryLevel(t, r) {
      let n = r.split("/").length;
      if (t === "")
        return n;
      let i = t.split("/").length;
      return n - i;
    }
    _isSkippedSymbolicLink(t) {
      return !this._settings.followSymbolicLinks && t.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(t, r) {
      return !this._settings.baseNameMatch && !r.match(t);
    }
    _isSkippedByNegativePatterns(t, r) {
      return !yl.pattern.matchAny(t, r);
    }
  };
  id.default = nd;
});

// ../node_modules/fast-glob/out/providers/filters/entry.js
var h1 = I((od) => {
  "use strict";
  Object.defineProperty(od, "__esModule", { value: !0 });
  var ri = An(), sd = class {
    static {
      s(this, "EntryFilter");
    }
    constructor(t, r) {
      this._settings = t, this._micromatchOptions = r, this.index = /* @__PURE__ */ new Map();
    }
    getFilter(t, r) {
      let [n, i] = ri.pattern.partitionAbsoluteAndRelative(r), o = {
        positive: {
          all: ri.pattern.convertPatternsToRe(t, this._micromatchOptions)
        },
        negative: {
          absolute: ri.pattern.convertPatternsToRe(n, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 })),
          relative: ri.pattern.convertPatternsToRe(i, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }))
        }
      };
      return (a) => this._filter(a, o);
    }
    _filter(t, r) {
      let n = ri.path.removeLeadingDotSegment(t.path);
      if (this._settings.unique && this._isDuplicateEntry(n) || this._onlyFileFilter(t) || this._onlyDirectoryFilter(t))
        return !1;
      let i = this._isMatchToPatternsSet(n, r, t.dirent.isDirectory());
      return this._settings.unique && i && this._createIndexRecord(n), i;
    }
    _isDuplicateEntry(t) {
      return this.index.has(t);
    }
    _createIndexRecord(t) {
      this.index.set(t, void 0);
    }
    _onlyFileFilter(t) {
      return this._settings.onlyFiles && !t.dirent.isFile();
    }
    _onlyDirectoryFilter(t) {
      return this._settings.onlyDirectories && !t.dirent.isDirectory();
    }
    _isMatchToPatternsSet(t, r, n) {
      return !(!this._isMatchToPatterns(t, r.positive.all, n) || this._isMatchToPatterns(t, r.negative.relative, n) || this._isMatchToAbsoluteNegative(
      t, r.negative.absolute, n));
    }
    _isMatchToAbsoluteNegative(t, r, n) {
      if (r.length === 0)
        return !1;
      let i = ri.path.makeAbsolute(this._settings.cwd, t);
      return this._isMatchToPatterns(i, r, n);
    }
    _isMatchToPatterns(t, r, n) {
      if (r.length === 0)
        return !1;
      let i = ri.pattern.matchAny(t, r);
      return !i && n ? ri.pattern.matchAny(t + "/", r) : i;
    }
  };
  od.default = sd;
});

// ../node_modules/fast-glob/out/providers/filters/error.js
var f1 = I((ud) => {
  "use strict";
  Object.defineProperty(ud, "__esModule", { value: !0 });
  var hL = An(), ad = class {
    static {
      s(this, "ErrorFilter");
    }
    constructor(t) {
      this._settings = t;
    }
    getFilter() {
      return (t) => this._isNonFatalError(t);
    }
    _isNonFatalError(t) {
      return hL.errno.isEnoentCodeError(t) || this._settings.suppressErrors;
    }
  };
  ud.default = ad;
});

// ../node_modules/fast-glob/out/providers/transformers/entry.js
var m1 = I((cd) => {
  "use strict";
  Object.defineProperty(cd, "__esModule", { value: !0 });
  var d1 = An(), ld = class {
    static {
      s(this, "EntryTransformer");
    }
    constructor(t) {
      this._settings = t;
    }
    getTransformer() {
      return (t) => this._transform(t);
    }
    _transform(t) {
      let r = t.path;
      return this._settings.absolute && (r = d1.path.makeAbsolute(this._settings.cwd, r), r = d1.path.unixify(r)), this._settings.markDirectories &&
      t.dirent.isDirectory() && (r += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, t), { path: r }) : r;
    }
  };
  cd.default = ld;
});

// ../node_modules/fast-glob/out/providers/provider.js
var Dl = I((hd) => {
  "use strict";
  Object.defineProperty(hd, "__esModule", { value: !0 });
  var fL = require("path"), dL = p1(), mL = h1(), gL = f1(), yL = m1(), pd = class {
    static {
      s(this, "Provider");
    }
    constructor(t) {
      this._settings = t, this.errorFilter = new gL.default(this._settings), this.entryFilter = new mL.default(this._settings, this._getMicromatchOptions()),
      this.deepFilter = new dL.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new yL.default(this._settings);
    }
    _getRootDirectory(t) {
      return fL.resolve(this._settings.cwd, t.base);
    }
    _getReaderOptions(t) {
      let r = t.base === "." ? "" : t.base;
      return {
        basePath: r,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(r, t.positive, t.negative),
        entryFilter: this.entryFilter.getFilter(t.positive, t.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: !0,
        strictSlashes: !1
      };
    }
  };
  hd.default = pd;
});

// ../node_modules/fast-glob/out/providers/async.js
var g1 = I((dd) => {
  "use strict";
  Object.defineProperty(dd, "__esModule", { value: !0 });
  var DL = u1(), xL = Dl(), fd = class extends xL.default {
    static {
      s(this, "ProviderAsync");
    }
    constructor() {
      super(...arguments), this._reader = new DL.default(this._settings);
    }
    async read(t) {
      let r = this._getRootDirectory(t), n = this._getReaderOptions(t);
      return (await this.api(r, t, n)).map((o) => n.transform(o));
    }
    api(t, r, n) {
      return r.dynamic ? this._reader.dynamic(t, n) : this._reader.static(r.patterns, n);
    }
  };
  dd.default = fd;
});

// ../node_modules/fast-glob/out/providers/stream.js
var y1 = I((gd) => {
  "use strict";
  Object.defineProperty(gd, "__esModule", { value: !0 });
  var bL = require("stream"), vL = Xf(), EL = Dl(), md = class extends EL.default {
    static {
      s(this, "ProviderStream");
    }
    constructor() {
      super(...arguments), this._reader = new vL.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), n = this._getReaderOptions(t), i = this.api(r, t, n), o = new bL.Readable({ objectMode: !0, read: /* @__PURE__ */ s(
      () => {
      }, "read") });
      return i.once("error", (a) => o.emit("error", a)).on("data", (a) => o.emit("data", n.transform(a))).once("end", () => o.emit("end")), o.
      once("close", () => i.destroy()), o;
    }
    api(t, r, n) {
      return r.dynamic ? this._reader.dynamic(t, n) : this._reader.static(r.patterns, n);
    }
  };
  gd.default = md;
});

// ../node_modules/fast-glob/out/readers/sync.js
var D1 = I((Dd) => {
  "use strict";
  Object.defineProperty(Dd, "__esModule", { value: !0 });
  var CL = Oi(), wL = ml(), SL = gl(), yd = class extends SL.default {
    static {
      s(this, "ReaderSync");
    }
    constructor() {
      super(...arguments), this._walkSync = wL.walkSync, this._statSync = CL.statSync;
    }
    dynamic(t, r) {
      return this._walkSync(t, r);
    }
    static(t, r) {
      let n = [];
      for (let i of t) {
        let o = this._getFullEntryPath(i), a = this._getEntry(o, i, r);
        a === null || !r.entryFilter(a) || n.push(a);
      }
      return n;
    }
    _getEntry(t, r, n) {
      try {
        let i = this._getStat(t);
        return this._makeEntry(i, r);
      } catch (i) {
        if (n.errorFilter(i))
          return null;
        throw i;
      }
    }
    _getStat(t) {
      return this._statSync(t, this._fsStatSettings);
    }
  };
  Dd.default = yd;
});

// ../node_modules/fast-glob/out/providers/sync.js
var x1 = I((bd) => {
  "use strict";
  Object.defineProperty(bd, "__esModule", { value: !0 });
  var AL = D1(), FL = Dl(), xd = class extends FL.default {
    static {
      s(this, "ProviderSync");
    }
    constructor() {
      super(...arguments), this._reader = new AL.default(this._settings);
    }
    read(t) {
      let r = this._getRootDirectory(t), n = this._getReaderOptions(t);
      return this.api(r, t, n).map(n.transform);
    }
    api(t, r, n) {
      return r.dynamic ? this._reader.dynamic(t, n) : this._reader.static(r.patterns, n);
    }
  };
  bd.default = xd;
});

// ../node_modules/fast-glob/out/settings.js
var b1 = I((Ts) => {
  "use strict";
  Object.defineProperty(Ts, "__esModule", { value: !0 });
  Ts.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var ks = require("fs"), _L = require("os"), kL = Math.max(_L.cpus().length, 1);
  Ts.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: ks.lstat,
    lstatSync: ks.lstatSync,
    stat: ks.stat,
    statSync: ks.statSync,
    readdir: ks.readdir,
    readdirSync: ks.readdirSync
  };
  var vd = class {
    static {
      s(this, "Settings");
    }
    constructor(t = {}) {
      this._options = t, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch,
      !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch,
      !0), this.concurrency = this._getValue(this._options.concurrency, kL), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.
      deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this.
      _options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(
      this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []),
      this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1),
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0),
      this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink =
      this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories &&
      (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(t, r) {
      return t === void 0 ? r : t;
    }
    _getFileSystemMethods(t = {}) {
      return Object.assign(Object.assign({}, Ts.DEFAULT_FILE_SYSTEM_ADAPTER), t);
    }
  };
  Ts.default = vd;
});

// ../node_modules/fast-glob/out/index.js
var Sd = I((Wle, E1) => {
  "use strict";
  var v1 = EE(), TL = g1(), IL = y1(), PL = x1(), Ed = b1(), cr = An();
  async function Cd(e, t) {
    Rr(e);
    let r = wd(e, TL.default, t), n = await Promise.all(r);
    return cr.array.flatten(n);
  }
  s(Cd, "FastGlob");
  (function(e) {
    e.glob = e, e.globSync = t, e.globStream = r, e.async = e;
    function t(c, p) {
      Rr(c);
      let h = wd(c, PL.default, p);
      return cr.array.flatten(h);
    }
    s(t, "sync"), e.sync = t;
    function r(c, p) {
      Rr(c);
      let h = wd(c, IL.default, p);
      return cr.stream.merge(h);
    }
    s(r, "stream"), e.stream = r;
    function n(c, p) {
      Rr(c);
      let h = [].concat(c), f = new Ed.default(p);
      return v1.generate(h, f);
    }
    s(n, "generateTasks"), e.generateTasks = n;
    function i(c, p) {
      Rr(c);
      let h = new Ed.default(p);
      return cr.pattern.isDynamicPattern(c, h);
    }
    s(i, "isDynamicPattern"), e.isDynamicPattern = i;
    function o(c) {
      return Rr(c), cr.path.escape(c);
    }
    s(o, "escapePath"), e.escapePath = o;
    function a(c) {
      return Rr(c), cr.path.convertPathToPattern(c);
    }
    s(a, "convertPathToPattern"), e.convertPathToPattern = a;
    let u;
    (function(c) {
      function p(f) {
        return Rr(f), cr.path.escapePosixPath(f);
      }
      s(p, "escapePath"), c.escapePath = p;
      function h(f) {
        return Rr(f), cr.path.convertPosixPathToPattern(f);
      }
      s(h, "convertPathToPattern"), c.convertPathToPattern = h;
    })(u = e.posix || (e.posix = {}));
    let l;
    (function(c) {
      function p(f) {
        return Rr(f), cr.path.escapeWindowsPath(f);
      }
      s(p, "escapePath"), c.escapePath = p;
      function h(f) {
        return Rr(f), cr.path.convertWindowsPathToPattern(f);
      }
      s(h, "convertPathToPattern"), c.convertPathToPattern = h;
    })(l = e.win32 || (e.win32 = {}));
  })(Cd || (Cd = {}));
  function wd(e, t, r) {
    let n = [].concat(e), i = new Ed.default(r), o = v1.generate(n, i), a = new t(i);
    return o.map(a.read, a);
  }
  s(wd, "getWorks");
  function Rr(e) {
    if (![].concat(e).every((n) => cr.string.isString(n) && !cr.string.isEmpty(n)))
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
  s(Rr, "assertPatternsInput");
  E1.exports = Cd;
});

// ../node_modules/globby/node_modules/path-type/index.js
async function Ad(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return (await w1.default[e](r))[t]();
  } catch (n) {
    if (n.code === "ENOENT")
      return !1;
    throw n;
  }
}
function Fd(e, t, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return C1.default[e](r)[t]();
  } catch (n) {
    if (n.code === "ENOENT")
      return !1;
    throw n;
  }
}
var C1, w1, Hle, S1, Gle, Jle, A1, Zle, F1 = wt(() => {
  C1 = J(require("node:fs"), 1), w1 = J(require("node:fs/promises"), 1);
  s(Ad, "isType");
  s(Fd, "isTypeSync");
  Hle = Ad.bind(void 0, "stat", "isFile"), S1 = Ad.bind(void 0, "stat", "isDirectory"), Gle = Ad.bind(void 0, "lstat", "isSymbolicLink"), Jle =
  Fd.bind(void 0, "statSync", "isFile"), A1 = Fd.bind(void 0, "statSync", "isDirectory"), Zle = Fd.bind(void 0, "lstatSync", "isSymbolicLink");
});

// ../node_modules/unicorn-magic/default.js
var _1 = wt(() => {
});

// ../node_modules/unicorn-magic/node.js
function ia(e) {
  return e instanceof URL ? (0, T1.fileURLToPath)(e) : e;
}
var k1, _d, BL, T1, ece, tce, kd = wt(() => {
  k1 = require("node:util"), _d = require("node:child_process"), BL = J(require("node:path"), 1), T1 = require("node:url");
  _1();
  ece = (0, k1.promisify)(_d.execFile);
  s(ia, "toPath");
  tce = 10 * 1024 * 1024;
});

// ../node_modules/globby/node_modules/ignore/index.js
var j1 = I((sce, Nd) => {
  function B1(e) {
    return Array.isArray(e) ? e : [e];
  }
  s(B1, "makeArray");
  var OL = void 0, Id = "", I1 = " ", Td = "\\", RL = /^\s+$/, NL = /(?:[^\\]|^)\\$/, LL = /^\\!/, jL = /^\\#/, ML = /\r?\n/g, qL = /^\.{0,2}\/|^\.{1,2}$/,
  $L = /\/$/, Is = "/", O1 = "node-ignore";
  typeof Symbol < "u" && (O1 = Symbol.for("node-ignore"));
  var R1 = O1, sa = /* @__PURE__ */ s((e, t, r) => (Object.defineProperty(e, t, { value: r }), r), "define"), VL = /([0-z])-([0-z])/g, N1 = /* @__PURE__ */ s(
  () => !1, "RETURN_FALSE"), UL = /* @__PURE__ */ s((e) => e.replace(
    VL,
    (t, r, n) => r.charCodeAt(0) <= n.charCodeAt(0) ? t : Id
  ), "sanitizeRange"), WL = /* @__PURE__ */ s((e) => {
    let { length: t } = e;
    return e.slice(0, t - t % 2);
  }, "cleanRangeBackSlash"), zL = [
    [
      // Remove BOM
      // TODO:
      // Other similar zero-width characters?
      /^\uFEFF/,
      () => Id
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a ) -> (a)
      // (a \ ) -> (a  )
      /((?:\\\\)*?)(\\?\s+)$/,
      (e, t, r) => t + (r.indexOf("\\") === 0 ? I1 : Id)
    ],
    // Replace (\ ) with ' '
    // (\ ) -> ' '
    // (\\ ) -> '\\ '
    // (\\\ ) -> '\\ '
    [
      /(\\+?)\s/g,
      (e, t) => {
        let { length: r } = t;
        return t.slice(0, r - r % 2) + I1;
      }
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (e) => `\\${e}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      /* @__PURE__ */ s(function() {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }, "startingReplacer")
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (e, t, r) => t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (e, t, r) => {
        let n = r.replace(/\\\*/g, "[^\\/]*");
        return t + n;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => Td
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => Td
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (e, t, r, n, i) => t === Td ? `\\[${r}${WL(n)}${i}` : i === "]" && n.length % 2 === 0 ? `[${UL(r)}${n}]` : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (e) => /\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`
    ]
  ], HL = /(^|\\\/)?\\\*$/, oa = "regex", xl = "checkRegex", P1 = "_", GL = {
    [oa](e, t) {
      return `${t ? `${t}[^/]+` : "[^/]*"}(?=$|\\/$)`;
    },
    [xl](e, t) {
      return `${t ? `${t}[^/]*` : "[^/]*"}(?=$|\\/$)`;
    }
  }, JL = /* @__PURE__ */ s((e) => zL.reduce(
    (t, [r, n]) => t.replace(r, n.bind(e)),
    e
  ), "makeRegexPrefix"), bl = /* @__PURE__ */ s((e) => typeof e == "string", "isString"), ZL = /* @__PURE__ */ s((e) => e && bl(e) && !RL.test(
  e) && !NL.test(e) && e.indexOf("#") !== 0, "checkPattern"), XL = /* @__PURE__ */ s((e) => e.split(ML).filter(Boolean), "splitPattern"), Pd = class {
    static {
      s(this, "IgnoreRule");
    }
    constructor(t, r, n, i, o, a) {
      this.pattern = t, this.mark = r, this.negative = o, sa(this, "body", n), sa(this, "ignoreCase", i), sa(this, "regexPrefix", a);
    }
    get regex() {
      let t = P1 + oa;
      return this[t] ? this[t] : this._make(oa, t);
    }
    get checkRegex() {
      let t = P1 + xl;
      return this[t] ? this[t] : this._make(xl, t);
    }
    _make(t, r) {
      let n = this.regexPrefix.replace(
        HL,
        // It does not need to bind pattern
        GL[t]
      ), i = this.ignoreCase ? new RegExp(n, "i") : new RegExp(n);
      return sa(this, r, i);
    }
  }, KL = /* @__PURE__ */ s(({
    pattern: e,
    mark: t
  }, r) => {
    let n = !1, i = e;
    i.indexOf("!") === 0 && (n = !0, i = i.substr(1)), i = i.replace(LL, "!").replace(jL, "#");
    let o = JL(i);
    return new Pd(
      e,
      t,
      i,
      r,
      n,
      o
    );
  }, "createRule"), Bd = class {
    static {
      s(this, "RuleManager");
    }
    constructor(t) {
      this._ignoreCase = t, this._rules = [];
    }
    _add(t) {
      if (t && t[R1]) {
        this._rules = this._rules.concat(t._rules._rules), this._added = !0;
        return;
      }
      if (bl(t) && (t = {
        pattern: t
      }), ZL(t.pattern)) {
        let r = KL(t, this._ignoreCase);
        this._added = !0, this._rules.push(r);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(t) {
      return this._added = !1, B1(
        bl(t) ? XL(t) : t
      ).forEach(this._add, this), this._added;
    }
    // Test one single path without recursively checking parent directories
    //
    // - checkUnignored `boolean` whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
    // @returns {TestResult} true if a file is ignored
    test(t, r, n) {
      let i = !1, o = !1, a;
      this._rules.forEach((l) => {
        let { negative: c } = l;
        o === c && i !== o || c && !i && !o && !r || !l[n].test(t) || (i = !c, o = c, a = c ? OL : l);
      });
      let u = {
        ignored: i,
        unignored: o
      };
      return a && (u.rule = a), u;
    }
  }, YL = /* @__PURE__ */ s((e, t) => {
    throw new t(e);
  }, "throwError"), Fn = /* @__PURE__ */ s((e, t, r) => bl(e) ? e ? Fn.isNotRelative(e) ? r(
    `path should be a \`path.relative()\`d string, but got "${t}"`,
    RangeError
  ) : !0 : r("path must not be empty", TypeError) : r(
    `path must be a string, but got \`${t}\``,
    TypeError
  ), "checkPath"), L1 = /* @__PURE__ */ s((e) => qL.test(e), "isNotRelative");
  Fn.isNotRelative = L1;
  Fn.convert = (e) => e;
  var Od = class {
    static {
      s(this, "Ignore");
    }
    constructor({
      ignorecase: t = !0,
      ignoreCase: r = t,
      allowRelativePaths: n = !1
    } = {}) {
      sa(this, R1, !0), this._rules = new Bd(r), this._strictPathCheck = !n, this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
    }
    add(t) {
      return this._rules.add(t) && this._initCache(), this;
    }
    // legacy
    addPattern(t) {
      return this.add(t);
    }
    // @returns {TestResult}
    _test(t, r, n, i) {
      let o = t && Fn.convert(t);
      return Fn(
        o,
        t,
        this._strictPathCheck ? YL : N1
      ), this._t(o, r, n, i);
    }
    checkIgnore(t) {
      if (!$L.test(t))
        return this.test(t);
      let r = t.split(Is).filter(Boolean);
      if (r.pop(), r.length) {
        let n = this._t(
          r.join(Is) + Is,
          this._testCache,
          !0,
          r
        );
        if (n.ignored)
          return n;
      }
      return this._rules.test(t, !1, xl);
    }
    _t(t, r, n, i) {
      if (t in r)
        return r[t];
      if (i || (i = t.split(Is).filter(Boolean)), i.pop(), !i.length)
        return r[t] = this._rules.test(t, n, oa);
      let o = this._t(
        i.join(Is) + Is,
        r,
        n,
        i
      );
      return r[t] = o.ignored ? o : this._rules.test(t, n, oa);
    }
    ignores(t) {
      return this._test(t, this._ignoreCache, !1).ignored;
    }
    createFilter() {
      return (t) => !this.ignores(t);
    }
    filter(t) {
      return B1(t).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(t) {
      return this._test(t, this._testCache, !0);
    }
  }, Rd = /* @__PURE__ */ s((e) => new Od(e), "factory"), QL = /* @__PURE__ */ s((e) => Fn(e && Fn.convert(e), e, N1), "isPathValid");
  if (
    // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
  ) {
    let e = /* @__PURE__ */ s((r) => /^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
    Fn.convert = e;
    let t = /^[a-z]:\//i;
    Fn.isNotRelative = (r) => t.test(r) || L1(r);
  }
  Nd.exports = Rd;
  Rd.default = Rd;
  Nd.exports.isPathValid = QL;
});

// ../node_modules/globby/utilities.js
var aa, Ld = wt(() => {
  aa = /* @__PURE__ */ s((e) => e[0] === "!", "isNegativePattern");
});

// ../node_modules/globby/ignore.js
var M1, q1, $1, Ri, jd, V1, ej, U1, vl, tj, rj, nj, W1, z1, ua, la, H1, G1, Md = wt(() => {
  M1 = J(require("node:process"), 1), q1 = J(require("node:fs"), 1), $1 = J(require("node:fs/promises"), 1), Ri = J(require("node:path"), 1),
  jd = J(Sd(), 1), V1 = J(j1(), 1);
  _i();
  kd();
  Ld();
  ej = [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ], U1 = {
    absolute: !0,
    dot: !0
  }, vl = "**/.gitignore", tj = /* @__PURE__ */ s((e, t) => aa(e) ? "!" + Ri.default.posix.join(t, e.slice(1)) : Ri.default.posix.join(t, e),
  "applyBaseToPattern"), rj = /* @__PURE__ */ s((e, t) => {
    let r = it(Ri.default.relative(t, Ri.default.dirname(e.filePath)));
    return e.content.split(/\r?\n/).filter((n) => n && !n.startsWith("#")).map((n) => tj(n, r));
  }, "parseIgnoreFile"), nj = /* @__PURE__ */ s((e, t) => {
    if (t = it(t), Ri.default.isAbsolute(e)) {
      if (it(e).startsWith(t))
        return Ri.default.relative(t, e);
      throw new Error(`Path ${e} is not in cwd ${t}`);
    }
    return e;
  }, "toRelativePath"), W1 = /* @__PURE__ */ s((e, t) => {
    let r = e.flatMap((i) => rj(i, t)), n = (0, V1.default)().add(r);
    return (i) => (i = ia(i), i = nj(i, t), i ? n.ignores(it(i)) : !1);
  }, "getIsIgnoredPredicate"), z1 = /* @__PURE__ */ s((e = {}) => ({
    cwd: ia(e.cwd) ?? M1.default.cwd(),
    suppressErrors: !!e.suppressErrors,
    deep: typeof e.deep == "number" ? e.deep : Number.POSITIVE_INFINITY,
    ignore: [...e.ignore ?? [], ...ej]
  }), "normalizeOptions"), ua = /* @__PURE__ */ s(async (e, t) => {
    let { cwd: r, suppressErrors: n, deep: i, ignore: o } = z1(t), a = await (0, jd.default)(e, {
      cwd: r,
      suppressErrors: n,
      deep: i,
      ignore: o,
      ...U1
    }), u = await Promise.all(
      a.map(async (l) => ({
        filePath: l,
        content: await $1.default.readFile(l, "utf8")
      }))
    );
    return W1(u, r);
  }, "isIgnoredByIgnoreFiles"), la = /* @__PURE__ */ s((e, t) => {
    let { cwd: r, suppressErrors: n, deep: i, ignore: o } = z1(t), u = jd.default.sync(e, {
      cwd: r,
      suppressErrors: n,
      deep: i,
      ignore: o,
      ...U1
    }).map((l) => ({
      filePath: l,
      content: q1.default.readFileSync(l, "utf8")
    }));
    return W1(u, r);
  }, "isIgnoredByIgnoreFilesSync"), H1 = /* @__PURE__ */ s((e) => ua(vl, e), "isGitIgnored"), G1 = /* @__PURE__ */ s((e) => la(vl, e), "isGi\
tIgnoredSync");
});

// ../node_modules/globby/index.js
var Ud = {};
Gn(Ud, {
  convertPathToPattern: () => fj,
  generateGlobTasks: () => pj,
  generateGlobTasksSync: () => hj,
  globby: () => aj,
  globbyStream: () => lj,
  globbySync: () => uj,
  isDynamicPattern: () => cj,
  isGitIgnored: () => H1,
  isGitIgnoredSync: () => G1,
  isIgnoredByIgnoreFiles: () => ua,
  isIgnoredByIgnoreFilesSync: () => la
});
var qd, X1, Ni, Ps, ij, K1, Y1, J1, Z1, $d, sj, Q1, eC, El, tC, oj, rC, nC, iC, sC, oC, aC, Vd, aj, uj, lj, cj, pj, hj, fj, Wd = wt(() => {
  qd = J(require("node:process"), 1), X1 = J(require("node:fs"), 1), Ni = J(require("node:path"), 1);
  Bb();
  Ps = J(Sd(), 1);
  F1();
  kd();
  Md();
  Ld();
  Md();
  ij = /* @__PURE__ */ s((e) => {
    if (e.some((t) => typeof t != "string"))
      throw new TypeError("Patterns must be a string or an array of strings");
  }, "assertPatternsInput"), K1 = /* @__PURE__ */ s((e, t) => {
    let r = aa(e) ? e.slice(1) : e;
    return Ni.default.isAbsolute(r) ? r : Ni.default.join(t, r);
  }, "normalizePathForDirectoryGlob"), Y1 = /* @__PURE__ */ s(({ directoryPath: e, files: t, extensions: r }) => {
    let n = r?.length > 0 ? `.${r.length > 1 ? `{${r.join(",")}}` : r[0]}` : "";
    return t ? t.map((i) => Ni.default.posix.join(e, `**/${Ni.default.extname(i) ? i : `${i}${n}`}`)) : [Ni.default.posix.join(e, `**${n ? `\
/*${n}` : ""}`)];
  }, "getDirectoryGlob"), J1 = /* @__PURE__ */ s(async (e, {
    cwd: t = qd.default.cwd(),
    files: r,
    extensions: n
  } = {}) => (await Promise.all(
    e.map(async (o) => await S1(K1(o, t)) ? Y1({ directoryPath: o, files: r, extensions: n }) : o)
  )).flat(), "directoryToGlob"), Z1 = /* @__PURE__ */ s((e, {
    cwd: t = qd.default.cwd(),
    files: r,
    extensions: n
  } = {}) => e.flatMap((i) => A1(K1(i, t)) ? Y1({ directoryPath: i, files: r, extensions: n }) : i), "directoryToGlobSync"), $d = /* @__PURE__ */ s(
  (e) => (e = [...new Set([e].flat())], ij(e), e), "toPatternsArray"), sj = /* @__PURE__ */ s((e) => {
    if (!e)
      return;
    let t;
    try {
      t = X1.default.statSync(e);
    } catch {
      return;
    }
    if (!t.isDirectory())
      throw new Error("The `cwd` option must be a path to a directory");
  }, "checkCwdOption"), Q1 = /* @__PURE__ */ s((e = {}) => (e = {
    ...e,
    ignore: e.ignore ?? [],
    expandDirectories: e.expandDirectories ?? !0,
    cwd: ia(e.cwd)
  }, sj(e.cwd), e), "normalizeOptions"), eC = /* @__PURE__ */ s((e) => async (t, r) => e($d(t), Q1(r)), "normalizeArguments"), El = /* @__PURE__ */ s(
  (e) => (t, r) => e($d(t), Q1(r)), "normalizeArgumentsSync"), tC = /* @__PURE__ */ s((e) => {
    let { ignoreFiles: t, gitignore: r } = e, n = t ? $d(t) : [];
    return r && n.push(vl), n;
  }, "getIgnoreFilesPatterns"), oj = /* @__PURE__ */ s(async (e) => {
    let t = tC(e);
    return nC(
      t.length > 0 && await ua(t, e)
    );
  }, "getFilter"), rC = /* @__PURE__ */ s((e) => {
    let t = tC(e);
    return nC(
      t.length > 0 && la(t, e)
    );
  }, "getFilterSync"), nC = /* @__PURE__ */ s((e) => {
    let t = /* @__PURE__ */ new Set();
    return (r) => {
      let n = Ni.default.normalize(r.path ?? r);
      return t.has(n) || e && e(n) ? !1 : (t.add(n), !0);
    };
  }, "createFilterFunction"), iC = /* @__PURE__ */ s((e, t) => e.flat().filter((r) => t(r)), "unionFastGlobResults"), sC = /* @__PURE__ */ s(
  (e, t) => {
    let r = [];
    for (; e.length > 0; ) {
      let n = e.findIndex((o) => aa(o));
      if (n === -1) {
        r.push({ patterns: e, options: t });
        break;
      }
      let i = e[n].slice(1);
      for (let o of r)
        o.options.ignore.push(i);
      n !== 0 && r.push({
        patterns: e.slice(0, n),
        options: {
          ...t,
          ignore: [
            ...t.ignore,
            i
          ]
        }
      }), e = e.slice(n + 1);
    }
    return r;
  }, "convertNegativePatterns"), oC = /* @__PURE__ */ s((e, t) => ({
    ...t ? { cwd: t } : {},
    ...Array.isArray(e) ? { files: e } : e
  }), "normalizeExpandDirectoriesOption"), aC = /* @__PURE__ */ s(async (e, t) => {
    let r = sC(e, t), { cwd: n, expandDirectories: i } = t;
    if (!i)
      return r;
    let o = oC(i, n);
    return Promise.all(
      r.map(async (a) => {
        let { patterns: u, options: l } = a;
        return [
          u,
          l.ignore
        ] = await Promise.all([
          J1(u, o),
          J1(l.ignore, { cwd: n })
        ]), { patterns: u, options: l };
      })
    );
  }, "generateTasks"), Vd = /* @__PURE__ */ s((e, t) => {
    let r = sC(e, t), { cwd: n, expandDirectories: i } = t;
    if (!i)
      return r;
    let o = oC(i, n);
    return r.map((a) => {
      let { patterns: u, options: l } = a;
      return u = Z1(u, o), l.ignore = Z1(l.ignore, { cwd: n }), { patterns: u, options: l };
    });
  }, "generateTasksSync"), aj = eC(async (e, t) => {
    let [
      r,
      n
    ] = await Promise.all([
      aC(e, t),
      oj(t)
    ]), i = await Promise.all(r.map((o) => (0, Ps.default)(o.patterns, o.options)));
    return iC(i, n);
  }), uj = El((e, t) => {
    let r = Vd(e, t), n = rC(t), i = r.map((o) => Ps.default.sync(o.patterns, o.options));
    return iC(i, n);
  }), lj = El((e, t) => {
    let r = Vd(e, t), n = rC(t), i = r.map((a) => Ps.default.stream(a.patterns, a.options));
    return qh(i).filter((a) => n(a));
  }), cj = El(
    (e, t) => e.some((r) => Ps.default.isDynamicPattern(r, t))
  ), pj = eC(aC), hj = El(Vd), { convertPathToPattern: fj } = Ps.default;
});

// ../node_modules/@storybook/docs-mdx/dist/chunk-H6DQNFQR.js
function gC(e, t) {
  let r = {}, n = {}, i = -1;
  for (; ++i < e.length; )
    Object.assign(r, e[i].property), Object.assign(n, e[i].normal);
  return new ca(r, n, t);
}
function Hd(e) {
  return e.toLowerCase();
}
function Li() {
  return 2 ** ++vj;
}
function uC(e, t, r) {
  r && (e[t] = r);
}
function Rs(e) {
  let t = {}, r = {}, n;
  for (n in e.properties)
    if (Ej.call(e.properties, n)) {
      let i = e.properties[n], o = new Kd(
        n,
        e.transform(e.attributes || {}, n),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(n) && (o.mustUseProperty = !0), t[n] = o, r[Hd(n)] = n, r[Hd(o.attribute)] = n;
    }
  return new ca(t, r, e.space);
}
function bC(e, t) {
  return t in e ? e[t] : t;
}
function vC(e, t) {
  return bC(e, t.toLowerCase());
}
function Fj(e, t) {
  let r = Hd(t), n = t, i = pr;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && Sj.test(t)) {
    if (t.charAt(4) === "-") {
      let o = t.slice(5).replace(lC, kj);
      n = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      let o = t.slice(4);
      if (!lC.test(o)) {
        let a = o.replace(Aj, _j);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = Kd;
  }
  return new i(n, t);
}
function _j(e) {
  return "-" + e.toLowerCase();
}
function kj(e) {
  return e.charAt(1).toUpperCase();
}
function wC(e) {
  return t;
  function t(r) {
    let n = r && r.position && r.position[e] || {};
    if (typeof n.line == "number" && n.line > 0 && typeof n.column == "number" && n.column > 0)
      return {
        line: n.line,
        column: n.column,
        offset: typeof n.offset == "number" && n.offset > -1 ? n.offset : void 0
      };
  }
}
function tm(e) {
  let t = em(e), r = Qd(e);
  if (t && r)
    return { start: t, end: r };
}
function Pj(e, t) {
  let r = t || {};
  function n(i, ...o) {
    let a = n.invalid, u = n.handlers;
    if (i && cC.call(i, e)) {
      let l = String(i[e]);
      a = cC.call(u, l) ? u[l] : n.unknown;
    }
    if (a)
      return a.call(this, i, ...o);
  }
  return s(n, "one"), n.handlers = r.handlers || {}, n.invalid = r.invalid, n.unknown = r.unknown, n;
}
function Bj(e, t) {
  let r = { type: "Block", value: e.value };
  t.inherit(e, r), t.comments.push(r);
  let n = {
    type: "JSXEmptyExpression",
    // @ts-expect-error: `comments` is custom.
    comments: [Object.assign({}, r, { leading: !1, trailing: !0 })]
  };
  t.patch(e, n);
  let i = { type: "JSXExpressionContainer", expression: n };
  return t.patch(e, i), i;
}
function Oj(e, t) {
  let r = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
function hr(e) {
  return e ? Rj.test(String.fromCodePoint(e)) : !1;
}
function Ns(e, t) {
  let n = (t || SC).jsx ? Lj : Nj;
  return e ? n.test(String.fromCodePoint(e)) : !1;
}
function Nr(e, t) {
  return ((t || SC).jsx ? Mj : jj).test(e);
}
function qj(e) {
  return e.join(" ").trim();
}
function Hj(e, t) {
  let r = t.schema, n = r, i = e.properties || {};
  r.space === "html" && e.tagName.toLowerCase() === "svg" && (n = Yd, t.schema = n);
  let o = t.all(e), a = [], u, l, c;
  for (u in i)
    if (Gd.call(i, u)) {
      let h = i[u], f = Fj(n, u), d;
      if (h == null || h === !1 || typeof h == "number" && Number.isNaN(h) || !h && f.boolean)
        continue;
      if (u = t.elementAttributeNameCase === "react" && f.space ? Tj[f.property] || f.property : f.attribute, Array.isArray(h) && (h = f.commaSeparated ?
      Oj(h) : qj(h)), u === "style") {
        let m = typeof h == "object" ? h : Gj(String(h), e.tagName);
        t.stylePropertyNameCase === "css" && (m = Jj(m));
        let g = [], b;
        for (b in m)
          Gd.call(m, b) && g.push({
            type: "Property",
            method: !1,
            shorthand: !1,
            computed: !1,
            key: Nr(b) ? { type: "Identifier", name: b } : { type: "Literal", value: b },
            value: { type: "Literal", value: String(m[b]) },
            kind: "init"
          });
        c = g, d = {
          type: "JSXExpressionContainer",
          expression: { type: "ObjectExpression", properties: g }
        };
      } else if (h === !0)
        d = null;
      else if (t.tableCellAlignToStyle && zj.has(e.tagName) && u === "align") {
        l = String(h);
        continue;
      } else
        d = { type: "Literal", value: String(h) };
      Nr(u, { jsx: !0 }) ? a.push({
        type: "JSXAttribute",
        name: { type: "JSXIdentifier", name: u },
        value: d
      }) : a.push({
        type: "JSXSpreadAttribute",
        argument: {
          type: "ObjectExpression",
          properties: [
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              key: { type: "Literal", value: String(u) },
              // @ts-expect-error No need to worry about `style` (which has a
              // `JSXExpressionContainer` value) because thats a valid identifier.
              value: d || { type: "Literal", value: !0 },
              kind: "init"
            }
          ]
        }
      });
    }
  if (l !== void 0) {
    c || (c = [], a.push({
      type: "JSXAttribute",
      name: { type: "JSXIdentifier", name: "style" },
      value: {
        type: "JSXExpressionContainer",
        expression: { type: "ObjectExpression", properties: c }
      }
    }));
    let h = t.stylePropertyNameCase === "css" ? AC("textAlign") : "textAlign";
    c.push({
      type: "Property",
      method: !1,
      shorthand: !1,
      computed: !1,
      key: Nr(h) ? { type: "Identifier", name: h } : { type: "Literal", value: h },
      value: { type: "Literal", value: l },
      kind: "init"
    });
  }
  t.schema = r;
  let p = {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: a,
      name: t.createJsxElementName(e.tagName),
      selfClosing: o.length === 0
    },
    closingElement: o.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.tagName)
    } : null,
    children: o
  };
  return t.inherit(e, p), p;
}
function Gj(e, t) {
  let r = {};
  try {
    Vj(e, n);
  } catch (i) {
    let o = (
      /** @type {Error} */
      i
    );
    throw new Error(
      "Could not parse `style` attribute on `" + t + "`",
      { cause: o }
    );
  }
  return r;
  function n(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(Wj, Zj)), r[a] = o;
  }
}
function Jj(e) {
  let t = {}, r;
  for (r in e)
    Gd.call(e, r) && (t[AC(r)] = e[r]);
  return t;
}
function AC(e) {
  let t = e.replace(Uj, Xj);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Zj(e, t) {
  return t.toUpperCase();
}
function Xj(e) {
  return "-" + e.toLowerCase();
}
function wl(e, t) {
  let r = t ? [...t].sort(rm) : Yj;
  r.length > 0 && FC(e, { comments: r, index: 0 });
}
function FC(e, t) {
  if (t.index === t.comments.length)
    return;
  let r = [], n = [], i;
  for (i in e)
    if (Kj.call(e, i)) {
      let a = e[i];
      if (a && typeof a == "object" && i !== "comments")
        if (Array.isArray(a)) {
          let u = -1;
          for (; ++u < a.length; )
            a[u] && typeof a[u].type == "string" && r.push(a[u]);
        } else typeof a.type == "string" && r.push(a);
    }
  r.sort(rm), n.push(...pC(t, e, !1, { leading: !0, trailing: !1 }));
  let o = -1;
  for (; ++o < r.length; )
    FC(r[o], t);
  n.push(
    ...pC(t, e, !0, {
      leading: !1,
      trailing: r.length > 0
    })
  ), n.length > 0 && (e.comments = n);
}
function pC(e, t, r, n) {
  let i = [];
  for (; e.comments[e.index] && rm(e.comments[e.index], t, r) < 1; )
    i.push(Object.assign({}, e.comments[e.index++], n));
  return i;
}
function rm(e, t, r) {
  let n = r ? "end" : "start";
  return e.range && t.range ? e.range[0] - t.range[r ? 1 : 0] : e.loc && e.loc.start && t.loc && t.loc[n] ? e.loc.start.line - t.loc[n].line ||
  e.loc.start.column - t.loc[n].column : "start" in e && n in t ? e.start - t[n] : Number.NaN;
}
function hC(e, t) {
  let r = e.data && e.data.estree, n = r && r.comments || [], i;
  r && (t.comments.push(...n), wl(r, r.comments), i = r.body[0] && r.body[0].type === "ExpressionStatement" && r.body[0].expression || void 0),
  i || (i = { type: "JSXEmptyExpression" }, t.patch(e, i));
  let o = { type: "JSXExpressionContainer", expression: i };
  return t.inherit(e, o), o;
}
function fC(e, t) {
  let r = t.schema, n = r, i = e.attributes || [], o = -1;
  e.name && r.space === "html" && e.name.toLowerCase() === "svg" && (n = Yd, t.schema = n);
  let a = t.all(e), u = [];
  for (; ++o < i.length; ) {
    let c = i[o], p = c.value, h;
    if (c.type === "mdxJsxAttribute") {
      if (p == null)
        h = null;
      else if (typeof p == "object") {
        let d = p.data && p.data.estree, m = d && d.comments || [], g;
        d && (t.comments.push(...m), wl(d, d.comments), g = d.body[0] && d.body[0].type === "ExpressionStatement" && d.body[0].expression ||
        void 0), h = {
          type: "JSXExpressionContainer",
          expression: g || { type: "JSXEmptyExpression" }
        }, t.inherit(p, h);
      } else
        h = { type: "Literal", value: String(p) };
      let f = {
        type: "JSXAttribute",
        name: t.createJsxAttributeName(c.name),
        value: h
      };
      t.inherit(c, f), u.push(f);
    } else {
      let f = c.data && c.data.estree, d = f && f.comments || [], m;
      f && (t.comments.push(...d), wl(f, f.comments), m = f.body[0] && f.body[0].type === "ExpressionStatement" && f.body[0].expression && f.
      body[0].expression.type === "ObjectExpression" && f.body[0].expression.properties && f.body[0].expression.properties[0] && f.body[0].expression.
      properties[0].type === "SpreadElement" && f.body[0].expression.properties[0].argument || void 0);
      let g = {
        type: "JSXSpreadAttribute",
        argument: m || { type: "ObjectExpression", properties: [] }
      };
      t.inherit(c, g), u.push(g);
    }
  }
  t.schema = r;
  let l = e.name ? {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: u,
      name: t.createJsxElementName(e.name),
      selfClosing: a.length === 0
    },
    closingElement: a.length > 0 ? {
      type: "JSXClosingElement",
      name: t.createJsxElementName(e.name)
    } : null,
    children: a
  } : {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: a
  };
  return t.inherit(e, l), l;
}
function Qj(e, t) {
  let r = e.data && e.data.estree, n = r && r.comments || [];
  r && (t.comments.push(...n), wl(r, n), t.esm.push(...r.body));
}
function tM(e) {
  return typeof e == "object" ? e.type === "text" ? dC(e.value) : !1 : dC(e);
}
function dC(e) {
  return e.replace(eM, "") === "";
}
function rM(e, t) {
  let r = t.all(e), n = [], i = -1, o;
  for (; ++i < r.length; ) {
    let u = r[i];
    u.type === "JSXExpressionContainer" && u.expression.type === "Literal" && tM(String(u.expression.value)) ? o && o.push(u) : (o && n.push(
    ...o), n.push(u), o = []);
  }
  let a = {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: n
  };
  return t.inherit(e, a), a;
}
function nM(e, t) {
  let r = String(e.value || "");
  if (r) {
    let n = { type: "Literal", value: r };
    t.inherit(e, n);
    let i = { type: "JSXExpressionContainer", expression: n };
    return t.patch(e, i), i;
  }
}
function sM() {
}
function uM(e) {
  let t = Pj("type", {
    invalid: lM,
    unknown: cM,
    handlers: { ...iM, ...e.handlers }
  });
  return {
    // Current space.
    elementAttributeNameCase: e.elementAttributeNameCase || "react",
    schema: e.space === "svg" ? Yd : Ij,
    stylePropertyNameCase: e.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: e.tableCellAlignToStyle !== !1,
    // Results.
    comments: [],
    esm: [],
    // Useful functions.
    all: pM,
    createJsxAttributeName: fM,
    createJsxElementName: dM,
    handle: r,
    inherit: hM,
    patch: _C
  };
  function r(n) {
    return t(n, this);
  }
}
function lM(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function cM(e) {
  throw "type" in e, new Error("Cannot handle unknown node `" + e.type + "`");
}
function pM(e) {
  let t = e.children || [], r = -1, n = [], i = this.schema.space === "html" && e.type === "element" && aM.has(e.tagName.toLowerCase());
  for (; ++r < t.length; ) {
    let o = t[r];
    if (i && o.type === "text" && o.value === `
`)
      continue;
    let a = this.handle(o);
    Array.isArray(a) ? n.push(...a) : a && n.push(a);
  }
  return n;
}
function hM(e, t) {
  let r = (
    /** @type {Record<string, unknown> | undefined} */
    e.data
  ), n, i;
  if (_C(e, t), r) {
    for (i in r)
      oM.call(r, i) && i !== "estree" && (n || (n = {}), n[i] = r[i]);
    n && (t.data = n);
  }
}
function _C(e, t) {
  let r = tm(e);
  r && r.start.offset !== void 0 && r.end.offset !== void 0 && (t.start = r.start.offset, t.end = r.end.offset, t.loc = {
    start: { line: r.start.line, column: r.start.column - 1 },
    end: { line: r.end.line, column: r.end.column - 1 }
  }, t.range = [r.start.offset, r.end.offset]);
}
function fM(e) {
  let t = kC(e);
  if (t.type === "JSXMemberExpression")
    throw new Error("Member expressions in attribute names are not supported");
  return t;
}
function dM(e) {
  return kC(e);
}
function kC(e) {
  if (e.includes(".")) {
    let t = e.split("."), r = t.shift();
    let n = { type: "JSXIdentifier", name: r };
    for (; r = t.shift(); )
      n = {
        type: "JSXMemberExpression",
        object: n,
        property: { type: "JSXIdentifier", name: r }
      };
    return n;
  }
  if (e.includes(":")) {
    let t = e.split(":");
    return {
      type: "JSXNamespacedName",
      namespace: { type: "JSXIdentifier", name: t[0] },
      name: { type: "JSXIdentifier", name: t[1] }
    };
  }
  return { type: "JSXIdentifier", name: e };
}
function Al(e, t) {
  let r = uM(t || {}), n = r.handle(e), i = r.esm;
  if (n) {
    n.type !== "JSXFragment" && n.type !== "JSXElement" && (n = {
      type: "JSXFragment",
      openingFragment: { type: "JSXOpeningFragment" },
      closingFragment: { type: "JSXClosingFragment" },
      children: [n]
    }, r.patch(e, n));
    let a = { type: "ExpressionStatement", expression: n };
    r.patch(e, a), i.push(a);
  }
  let o = {
    type: "Program",
    body: i,
    sourceType: "module",
    comments: r.comments
  };
  return r.patch(e, o), o;
}
var dj, Jd, mj, mC, gj, yj, Zd, Os, Xd, Dj, Sl, xj, bj, ca, pr, Cl, vj, Ce, mt, yC, ee, ze, Bs, Qt, zd, Kd, Ej, DC, xC, EC, CC, Cj, wj, Sj, lC,
Aj, Tj, Ij, Yd, Qd, em, cC, Rj, Nj, Lj, jj, Mj, SC, $j, Vj, Gd, Uj, Wj, zj, Kj, Yj, eM, iM, oM, aM, nm = wt(() => {
  dj = Object.create, Jd = Object.defineProperty, mj = Object.getOwnPropertyDescriptor, mC = Object.getOwnPropertyNames, gj = Object.getPrototypeOf,
  yj = Object.prototype.hasOwnProperty, Zd = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
    get: /* @__PURE__ */ s((t, r) => (typeof require < "u" ? require : t)[r], "get")
  }) : e)(function(e) {
    if (typeof require < "u")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
  }), Os = /* @__PURE__ */ s((e, t) => /* @__PURE__ */ s(function() {
    return t || (0, e[mC(e)[0]])((t = { exports: {} }).exports, t), t.exports;
  }, "__require2"), "__commonJS"), Xd = /* @__PURE__ */ s((e, t) => {
    for (var r in t)
      Jd(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), Dj = /* @__PURE__ */ s((e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of mC(t))
        !yj.call(e, i) && i !== r && Jd(e, i, { get: /* @__PURE__ */ s(() => t[i], "get"), enumerable: !(n = mj(t, i)) || n.enumerable });
    return e;
  }, "__copyProps"), Sl = /* @__PURE__ */ s((e, t, r) => (r = e != null ? dj(gj(e)) : {}, Dj(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    t || !e || !e.__esModule ? Jd(r, "default", { value: e, enumerable: !0 }) : r,
    e
  )), "__toESM"), xj = Os({
    "node_modules/inline-style-parser/index.js"(e, t) {
      var r = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, n = /\n/g, i = /^\s*/, o = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a = /^:\s*/, u = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
      l = /^[;\s]*/, c = /^\s+|\s+$/g, p = `
`, h = "/", f = "*", d = "", m = "comment", g = "declaration";
      t.exports = function(y, E) {
        if (typeof y != "string")
          throw new TypeError("First argument must be a string");
        if (!y)
          return [];
        E = E || {};
        var A = 1, k = 1;
        function O(N) {
          var z = N.match(n);
          z && (A += z.length);
          var Q = N.lastIndexOf(p);
          k = ~Q ? N.length - Q : k + N.length;
        }
        s(O, "updatePosition");
        function w() {
          var N = { line: A, column: k };
          return function(z) {
            return z.position = new C(N), R(), z;
          };
        }
        s(w, "position2");
        function C(N) {
          this.start = N, this.end = { line: A, column: k }, this.source = E.source;
        }
        s(C, "Position"), C.prototype.content = y;
        var T = [];
        function F(N) {
          var z = new Error(
            E.source + ":" + A + ":" + k + ": " + N
          );
          if (z.reason = N, z.filename = E.source, z.line = A, z.column = k, z.source = y, E.silent)
            T.push(z);
          else
            throw z;
        }
        s(F, "error");
        function $(N) {
          var z = N.exec(y);
          if (z) {
            var Q = z[0];
            return O(Q), y = y.slice(Q.length), z;
          }
        }
        s($, "match");
        function R() {
          $(i);
        }
        s(R, "whitespace2");
        function U(N) {
          var z;
          for (N = N || []; z = W(); )
            z !== !1 && N.push(z);
          return N;
        }
        s(U, "comments");
        function W() {
          var N = w();
          if (!(h != y.charAt(0) || f != y.charAt(1))) {
            for (var z = 2; d != y.charAt(z) && (f != y.charAt(z) || h != y.charAt(z + 1)); )
              ++z;
            if (z += 2, d === y.charAt(z - 1))
              return F("End of comment missing");
            var Q = y.slice(2, z - 2);
            return k += 2, O(Q), y = y.slice(z), k += 2, N({
              type: m,
              comment: Q
            });
          }
        }
        s(W, "comment2");
        function Y() {
          var N = w(), z = $(o);
          if (z) {
            if (W(), !$(a))
              return F("property missing ':'");
            var Q = $(u), ie = N({
              type: g,
              property: b(z[0].replace(r, d)),
              value: Q ? b(Q[0].replace(r, d)) : d
            });
            return $(l), ie;
          }
        }
        s(Y, "declaration");
        function j() {
          var N = [];
          U(N);
          for (var z; z = Y(); )
            z !== !1 && (N.push(z), U(N));
          return N;
        }
        return s(j, "declarations"), R(), j();
      };
      function b(y) {
        return y ? y.replace(c, d) : d;
      }
      s(b, "trim");
    }
  }), bj = Os({
    "node_modules/style-to-object/index.js"(e, t) {
      var r = xj();
      function n(i, o) {
        var a = null;
        if (!i || typeof i != "string")
          return a;
        for (var u, l = r(i), c = typeof o == "function", p, h, f = 0, d = l.length; f < d; f++)
          u = l[f], p = u.property, h = u.value, c ? o(p, h, u) : h && (a || (a = {}), a[p] = h);
        return a;
      }
      s(n, "StyleToObject2"), t.exports = n, t.exports.default = n;
    }
  }), ca = class {
    static {
      s(this, "Schema");
    }
    /**
     * @constructor
     * @param {Properties} property
     * @param {Normal} normal
     * @param {string} [space]
     */
    constructor(e, t, r) {
      this.property = e, this.normal = t, r && (this.space = r);
    }
  };
  ca.prototype.property = {};
  ca.prototype.normal = {};
  ca.prototype.space = null;
  s(gC, "merge");
  s(Hd, "normalize");
  pr = class {
    static {
      s(this, "Info");
    }
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     */
    constructor(e, t) {
      this.property = e, this.attribute = t;
    }
  };
  pr.prototype.space = null;
  pr.prototype.boolean = !1;
  pr.prototype.booleanish = !1;
  pr.prototype.overloadedBoolean = !1;
  pr.prototype.number = !1;
  pr.prototype.commaSeparated = !1;
  pr.prototype.spaceSeparated = !1;
  pr.prototype.commaOrSpaceSeparated = !1;
  pr.prototype.mustUseProperty = !1;
  pr.prototype.defined = !1;
  Cl = {};
  Xd(Cl, {
    boolean: /* @__PURE__ */ s(() => Ce, "boolean"),
    booleanish: /* @__PURE__ */ s(() => mt, "booleanish"),
    commaOrSpaceSeparated: /* @__PURE__ */ s(() => Qt, "commaOrSpaceSeparated"),
    commaSeparated: /* @__PURE__ */ s(() => Bs, "commaSeparated"),
    number: /* @__PURE__ */ s(() => ee, "number"),
    overloadedBoolean: /* @__PURE__ */ s(() => yC, "overloadedBoolean"),
    spaceSeparated: /* @__PURE__ */ s(() => ze, "spaceSeparated")
  });
  vj = 0, Ce = Li(), mt = Li(), yC = Li(), ee = Li(), ze = Li(), Bs = Li(), Qt = Li();
  s(Li, "increment");
  zd = Object.keys(Cl), Kd = class extends pr {
    static {
      s(this, "DefinedInfo");
    }
    /**
     * @constructor
     * @param {string} property
     * @param {string} attribute
     * @param {number|null} [mask]
     * @param {string} [space]
     */
    constructor(e, t, r, n) {
      let i = -1;
      if (super(e, t), uC(this, "space", n), typeof r == "number")
        for (; ++i < zd.length; ) {
          let o = zd[i];
          uC(this, zd[i], (r & Cl[o]) === Cl[o]);
        }
    }
  };
  Kd.prototype.defined = !0;
  s(uC, "mark");
  Ej = {}.hasOwnProperty;
  s(Rs, "create");
  DC = Rs({
    space: "xlink",
    transform(e, t) {
      return "xlink:" + t.slice(5).toLowerCase();
    },
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  }), xC = Rs({
    space: "xml",
    transform(e, t) {
      return "xml:" + t.slice(3).toLowerCase();
    },
    properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
  });
  s(bC, "caseSensitiveTransform");
  s(vC, "caseInsensitiveTransform");
  EC = Rs({
    space: "xmlns",
    attributes: { xmlnsxlink: "xmlns:xlink" },
    transform: vC,
    properties: { xmlns: null, xmlnsXLink: null }
  }), CC = Rs({
    transform(e, t) {
      return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
    },
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: mt,
      ariaAutoComplete: null,
      ariaBusy: mt,
      ariaChecked: mt,
      ariaColCount: ee,
      ariaColIndex: ee,
      ariaColSpan: ee,
      ariaControls: ze,
      ariaCurrent: null,
      ariaDescribedBy: ze,
      ariaDetails: null,
      ariaDisabled: mt,
      ariaDropEffect: ze,
      ariaErrorMessage: null,
      ariaExpanded: mt,
      ariaFlowTo: ze,
      ariaGrabbed: mt,
      ariaHasPopup: null,
      ariaHidden: mt,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: ze,
      ariaLevel: ee,
      ariaLive: null,
      ariaModal: mt,
      ariaMultiLine: mt,
      ariaMultiSelectable: mt,
      ariaOrientation: null,
      ariaOwns: ze,
      ariaPlaceholder: null,
      ariaPosInSet: ee,
      ariaPressed: mt,
      ariaReadOnly: mt,
      ariaRelevant: null,
      ariaRequired: mt,
      ariaRoleDescription: ze,
      ariaRowCount: ee,
      ariaRowIndex: ee,
      ariaRowSpan: ee,
      ariaSelected: mt,
      ariaSetSize: ee,
      ariaSort: null,
      ariaValueMax: ee,
      ariaValueMin: ee,
      ariaValueNow: ee,
      ariaValueText: null,
      role: null
    }
  }), Cj = Rs({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: vC,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: Bs,
      acceptCharset: ze,
      accessKey: ze,
      action: null,
      allow: null,
      allowFullScreen: Ce,
      allowPaymentRequest: Ce,
      allowUserMedia: Ce,
      alt: null,
      as: null,
      async: Ce,
      autoCapitalize: null,
      autoComplete: ze,
      autoFocus: Ce,
      autoPlay: Ce,
      blocking: ze,
      capture: Ce,
      charSet: null,
      checked: Ce,
      cite: null,
      className: ze,
      cols: ee,
      colSpan: null,
      content: null,
      contentEditable: mt,
      controls: Ce,
      controlsList: ze,
      coords: ee | Bs,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: Ce,
      defer: Ce,
      dir: null,
      dirName: null,
      disabled: Ce,
      download: yC,
      draggable: mt,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: Ce,
      formTarget: null,
      headers: ze,
      height: ee,
      hidden: Ce,
      high: ee,
      href: null,
      hrefLang: null,
      htmlFor: ze,
      httpEquiv: ze,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: Ce,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: Ce,
      itemId: null,
      itemProp: ze,
      itemRef: ze,
      itemScope: Ce,
      itemType: ze,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: Ce,
      low: ee,
      manifest: null,
      max: null,
      maxLength: ee,
      media: null,
      method: null,
      min: null,
      minLength: ee,
      multiple: Ce,
      muted: Ce,
      name: null,
      nonce: null,
      noModule: Ce,
      noValidate: Ce,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: Ce,
      optimum: ee,
      pattern: null,
      ping: ze,
      placeholder: null,
      playsInline: Ce,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: Ce,
      referrerPolicy: null,
      rel: ze,
      required: Ce,
      reversed: Ce,
      rows: ee,
      rowSpan: ee,
      sandbox: ze,
      scope: null,
      scoped: Ce,
      seamless: Ce,
      selected: Ce,
      shadowRootDelegatesFocus: Ce,
      shadowRootMode: null,
      shape: null,
      size: ee,
      sizes: null,
      slot: null,
      span: ee,
      spellCheck: mt,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: ee,
      step: null,
      style: null,
      tabIndex: ee,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: Ce,
      useMap: null,
      value: mt,
      width: ee,
      wrap: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: ze,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: ee,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: ee,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: Ce,
      // Lists. Use CSS to reduce space between items instead
      declare: Ce,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: ee,
      // `<img>` and `<object>`
      leftMargin: ee,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: ee,
      // `<body>`
      marginWidth: ee,
      // `<body>`
      noResize: Ce,
      // `<frame>`
      noHref: Ce,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: Ce,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: Ce,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: ee,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: mt,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: ee,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: ee,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: Ce,
      disableRemotePlayback: Ce,
      prefix: null,
      property: null,
      results: ee,
      security: null,
      unselectable: null
    }
  }), wj = Rs({
    space: "svg",
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    transform: bC,
    properties: {
      about: Qt,
      accentHeight: ee,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: ee,
      amplitude: ee,
      arabicForm: null,
      ascent: ee,
      attributeName: null,
      attributeType: null,
      azimuth: ee,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: ee,
      by: null,
      calcMode: null,
      capHeight: ee,
      className: ze,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: ee,
      diffuseConstant: ee,
      direction: null,
      display: null,
      dur: null,
      divisor: ee,
      dominantBaseline: null,
      download: Ce,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: ee,
      enableBackground: null,
      end: null,
      event: null,
      exponent: ee,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: ee,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: Bs,
      g2: Bs,
      glyphName: Bs,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: ee,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: ee,
      horizOriginX: ee,
      horizOriginY: ee,
      id: null,
      ideographic: ee,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: ee,
      k: ee,
      k1: ee,
      k2: ee,
      k3: ee,
      k4: ee,
      kernelMatrix: Qt,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: ee,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: ee,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: ee,
      overlineThickness: ee,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: ee,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: ze,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: ee,
      pointsAtY: ee,
      pointsAtZ: ee,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: Qt,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: Qt,
      rev: Qt,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: Qt,
      requiredFeatures: Qt,
      requiredFonts: Qt,
      requiredFormats: Qt,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: ee,
      specularExponent: ee,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: ee,
      strikethroughThickness: ee,
      string: null,
      stroke: null,
      strokeDashArray: Qt,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: ee,
      strokeOpacity: ee,
      strokeWidth: null,
      style: null,
      surfaceScale: ee,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: Qt,
      tabIndex: ee,
      tableValues: null,
      target: null,
      targetX: ee,
      targetY: ee,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: Qt,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: ee,
      underlineThickness: ee,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: ee,
      values: null,
      vAlphabetic: ee,
      vMathematical: ee,
      vectorEffect: null,
      vHanging: ee,
      vIdeographic: ee,
      version: null,
      vertAdvY: ee,
      vertOriginX: ee,
      vertOriginY: ee,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: ee,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    }
  }), Sj = /^data[-\w.:]+$/i, lC = /-[a-z]/g, Aj = /[A-Z]/g;
  s(Fj, "find");
  s(_j, "kebab");
  s(kj, "camelcase");
  Tj = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  }, Ij = gC([xC, DC, EC, CC, Cj], "html"), Yd = gC([xC, DC, EC, CC, wj], "svg"), Qd = wC("end"), em = wC("start");
  s(wC, "point");
  s(tm, "position");
  cC = {}.hasOwnProperty;
  s(Pj, "zwitch");
  s(Bj, "comment");
  s(Oj, "stringify");
  Rj = /[$_\p{ID_Start}]/u, Nj = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, Lj = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, jj = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
  Mj = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, SC = {};
  s(hr, "start");
  s(Ns, "cont");
  s(Nr, "name");
  s(qj, "stringify2");
  $j = Sl(bj(), 1), Vj = $j.default, Gd = {}.hasOwnProperty, Uj = /[A-Z]/g, Wj = /-([a-z])/g, zj = /* @__PURE__ */ new Set(["td", "th"]);
  s(Hj, "element");
  s(Gj, "parseStyle");
  s(Jj, "transformStylesToCssCasing");
  s(AC, "transformStyleToCssCasing");
  s(Zj, "toCamel");
  s(Xj, "toDash");
  Kj = {}.hasOwnProperty, Yj = [];
  s(wl, "attachComments");
  s(FC, "walk");
  s(pC, "slice");
  s(rm, "compare");
  s(hC, "mdxExpression");
  s(fC, "mdxJsxElement");
  s(Qj, "mdxjsEsm");
  eM = /[ \t\n\f\r]/g;
  s(tM, "whitespace");
  s(dC, "empty");
  s(rM, "root");
  s(nM, "text");
  iM = {
    comment: Bj,
    doctype: sM,
    element: Hj,
    mdxFlowExpression: hC,
    mdxJsxFlowElement: fC,
    mdxJsxTextElement: fC,
    mdxTextExpression: hC,
    mdxjsEsm: Qj,
    root: rM,
    text: nM
  };
  s(sM, "ignore");
  oM = {}.hasOwnProperty, aM = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
  s(uM, "createState");
  s(lM, "invalid");
  s(cM, "unknown");
  s(pM, "all");
  s(hM, "inherit");
  s(_C, "patch");
  s(fM, "createJsxAttributeName");
  s(dM, "createJsxElementName");
  s(kC, "createJsxNameFromString");
  s(Al, "toEstree");
});

// ../node_modules/@storybook/docs-mdx/node_modules/acorn/dist/acorn.mjs
function am(e, t) {
  for (var r = 65536, n = 0; n < t.length; n += 2) {
    if (r += t[n], r > e)
      return !1;
    if (r += t[n + 1], r >= e)
      return !0;
  }
  return !1;
}
function _n(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && xM.test(String.fromCharCode(e)) : t ===
  !1 ? !1 : am(e, RC);
}
function Ls(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && bM.test(String.
  fromCharCode(e)) : t === !1 ? !1 : am(e, RC) || am(e, mM);
}
function fr(e, t) {
  return new Re(e, { beforeExpr: !0, binop: t });
}
function Be(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, pm[e] = new Re(e, t);
}
function js(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function LC(e, t, r) {
  r === void 0 && (r = e.length);
  for (var n = t; n < r; n++) {
    var i = e.charCodeAt(n);
    if (js(i))
      return n < r - 1 && i === 13 && e.charCodeAt(n + 1) === 10 ? n + 2 : n + 1;
  }
  return -1;
}
function ni(e) {
  return IC[e] || (IC[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function kn(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function qC(e, t) {
  for (var r = 1, n = 0; ; ) {
    var i = LC(e, n, t);
    if (i < 0)
      return new ha(r, t - n);
    ++r, n = i;
  }
}
function SM(e) {
  var t = {};
  for (var r in um)
    t[r] = e && Ms(e, r) ? e[r] : um[r];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!PC && typeof console == "object" && console.warn && (PC =
  !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.
  allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14),
  TC(t.onToken)) {
    var n = t.onToken;
    t.onToken = function(i) {
      return n.push(i);
    };
  }
  return TC(t.onComment) && (t.onComment = AM(t, t.onComment)), t;
}
function AM(e, t) {
  return function(r, n, i, o, a, u) {
    var l = {
      type: r ? "Block" : "Line",
      value: n,
      start: i,
      end: o
    };
    e.locations && (l.loc = new Pl(this, a, u)), e.ranges && (l.range = [i, o]), t.push(l);
  };
}
function dm(e, t) {
  return qs | (e ? hm : 0) | (t ? $C : 0);
}
function TM(e, t) {
  var r = t.key.name, n = e[r], i = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (i = (t.static ? "s" : "i") + t.kind), n === "iget" && i ===
  "iset" || n === "iset" && i === "iget" || n === "sget" && i === "sset" || n === "sset" && i === "sget" ? (e[r] = "true", !1) : n ? !0 : (e[r] =
  i, !1);
}
function kl(e, t) {
  var r = e.computed, n = e.key;
  return !r && (n.type === "Identifier" && n.name === t || n.type === "Literal" && n.value === t);
}
function JC(e) {
  return e.type === "Identifier" || e.type === "ParenthesizedExpression" && JC(e.expression);
}
function cm(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && cm(e.expression) || e.type ===
  "ParenthesizedExpression" && cm(e.expression);
}
function ZC(e, t, r, n) {
  return e.type = t, e.end = r, this.options.locations && (e.loc.end = n), this.options.ranges && (e.range[1] = r), e;
}
function qM(e) {
  var t = ow[e] = {
    binary: ni(RM[e] + " " + BC),
    binaryOfStrings: ni(LM[e]),
    nonBinary: {
      General_Category: ni(BC),
      Script: ni(MM[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.
  nonBinary.scx = t.nonBinary.Script_Extensions;
}
function $M(e) {
  for (var t in e)
    return !0;
  return !1;
}
function VM(e) {
  return e === 105 || e === 109 || e === 115;
}
function aw(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
function UM(e) {
  return _n(e, !0) || e === 36 || e === 95;
}
function WM(e) {
  return Ls(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
function uw(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
function zM(e) {
  return e >= 0 && e <= 1114111;
}
function HM(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
function cw(e) {
  return uw(e) || e === 95;
}
function GM(e) {
  return cw(e) || Ll(e);
}
function JM(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function ZM(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
function XM(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
function Ll(e) {
  return e >= 48 && e <= 57;
}
function pw(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function hw(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
function fw(e) {
  return e >= 48 && e <= 55;
}
function KM(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function dw(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
var mM, RC, gM, NC, im, sm, yM, DM, xM, bM, Re, dr, Ut, pm, S, yr, vM, jC, mr, MC, EM, CM, Ms, TC, IC, wM, ha, Pl, um, PC, fa, qs, hm, $C, fm,
VC, Bl, UC, ji, da, Ol, _l, mm, In, WC, zC, HC, gt, nn, Rt, FM, Rl, ae, gm, _M, kM, pa, lm, GC, Dr, Lr, Qe, $s, De, IM, Tl, ii, PM, Nl, ma, BM,
XC, KC, YC, QC, ew, OM, RM, NM, LM, BC, tw, rw, nw, iw, sw, jM, MM, ow, OC, Fl, om, oe, Il, sn, lw, Tn, gr, ym, Pe, mw, YM, gw = wt(() => {
  mM = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123,
  2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158,
  11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19,
  13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6,
  3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49,
  4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759,
  9, 787719, 239], RC = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7,
  2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41,
  2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28,
  4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0,
  9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2,
  24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0,
  26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32,
  7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36,
  18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74,
  6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8,
  8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2,
  24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27,
  229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0,
  2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719,
  33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], gM = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\
\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\
\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369\
-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\
\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65",
  NC = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\
\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\
\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\
\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18\
-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\
\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\
\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  im = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package pri\
vate protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  }, sm = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false\
 instanceof typeof void delete new in this", yM = {
    5: sm,
    "5module": sm + " export import",
    6: sm + " const class extends export import super"
  }, DM = /^in(stanceof)?$/, xM = new RegExp("[" + NC + "]"), bM = new RegExp("[" + NC + gM + "]");
  s(am, "isInAstralSet");
  s(_n, "isIdentifierStart");
  s(Ls, "isIdentifierChar");
  Re = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.
    isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.
    updateContext = null;
  }, "TokenType");
  s(fr, "binop");
  dr = { beforeExpr: !0 }, Ut = { startsExpr: !0 }, pm = {};
  s(Be, "kw");
  S = {
    num: new Re("num", Ut),
    regexp: new Re("regexp", Ut),
    string: new Re("string", Ut),
    name: new Re("name", Ut),
    privateId: new Re("privateId", Ut),
    eof: new Re("eof"),
    // Punctuation token types.
    bracketL: new Re("[", { beforeExpr: !0, startsExpr: !0 }),
    bracketR: new Re("]"),
    braceL: new Re("{", { beforeExpr: !0, startsExpr: !0 }),
    braceR: new Re("}"),
    parenL: new Re("(", { beforeExpr: !0, startsExpr: !0 }),
    parenR: new Re(")"),
    comma: new Re(",", dr),
    semi: new Re(";", dr),
    colon: new Re(":", dr),
    dot: new Re("."),
    question: new Re("?", dr),
    questionDot: new Re("?."),
    arrow: new Re("=>", dr),
    template: new Re("template"),
    invalidTemplate: new Re("invalidTemplate"),
    ellipsis: new Re("...", dr),
    backQuote: new Re("`", Ut),
    dollarBraceL: new Re("${", { beforeExpr: !0, startsExpr: !0 }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new Re("=", { beforeExpr: !0, isAssign: !0 }),
    assign: new Re("_=", { beforeExpr: !0, isAssign: !0 }),
    incDec: new Re("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
    prefix: new Re("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    logicalOR: fr("||", 1),
    logicalAND: fr("&&", 2),
    bitwiseOR: fr("|", 3),
    bitwiseXOR: fr("^", 4),
    bitwiseAND: fr("&", 5),
    equality: fr("==/!=/===/!==", 6),
    relational: fr("</>/<=/>=", 7),
    bitShift: fr("<</>>/>>>", 8),
    plusMin: new Re("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
    modulo: fr("%", 10),
    star: fr("*", 10),
    slash: fr("/", 10),
    starstar: new Re("**", { beforeExpr: !0 }),
    coalesce: fr("??", 1),
    // Keyword token types.
    _break: Be("break"),
    _case: Be("case", dr),
    _catch: Be("catch"),
    _continue: Be("continue"),
    _debugger: Be("debugger"),
    _default: Be("default", dr),
    _do: Be("do", { isLoop: !0, beforeExpr: !0 }),
    _else: Be("else", dr),
    _finally: Be("finally"),
    _for: Be("for", { isLoop: !0 }),
    _function: Be("function", Ut),
    _if: Be("if"),
    _return: Be("return", dr),
    _switch: Be("switch"),
    _throw: Be("throw", dr),
    _try: Be("try"),
    _var: Be("var"),
    _const: Be("const"),
    _while: Be("while", { isLoop: !0 }),
    _with: Be("with"),
    _new: Be("new", { beforeExpr: !0, startsExpr: !0 }),
    _this: Be("this", Ut),
    _super: Be("super", Ut),
    _class: Be("class", Ut),
    _extends: Be("extends", dr),
    _export: Be("export"),
    _import: Be("import", Ut),
    _null: Be("null", Ut),
    _true: Be("true", Ut),
    _false: Be("false", Ut),
    _in: Be("in", { beforeExpr: !0, binop: 7 }),
    _instanceof: Be("instanceof", { beforeExpr: !0, binop: 7 }),
    _typeof: Be("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _void: Be("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
    _delete: Be("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
  }, yr = /\r\n?|\n|\u2028|\u2029/, vM = new RegExp(yr.source, "g");
  s(js, "isNewLine");
  s(LC, "nextLineBreak");
  jC = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, mr = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, MC = Object.prototype, EM = MC.hasOwnProperty,
  CM = MC.toString, Ms = Object.hasOwn || function(e, t) {
    return EM.call(e, t);
  }, TC = Array.isArray || function(e) {
    return CM.call(e) === "[object Array]";
  }, IC = /* @__PURE__ */ Object.create(null);
  s(ni, "wordsRegexp");
  s(kn, "codePointToString");
  wM = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, ha = /* @__PURE__ */ s(function(t, r) {
    this.line = t, this.column = r;
  }, "Position");
  ha.prototype.offset = /* @__PURE__ */ s(function(t) {
    return new ha(this.line, this.column + t);
  }, "offset");
  Pl = /* @__PURE__ */ s(function(t, r, n) {
    this.start = r, this.end = n, t.sourceFile !== null && (this.source = t.sourceFile);
  }, "SourceLocation");
  s(qC, "getLineInfo");
  um = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
    // (the latest version the library supports). This influences
    // support for strict mode, the set of reserved words, and support
    // for new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called when
    // a semicolon is automatically inserted. It will be passed the
    // position of the inserted semicolon as an offset, and if
    // `locations` is enabled, it is given the location as a `{line,
    // column}` object as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: !1,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: !1,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file is
    // allowed and treated as a line comment. Enabled by default when
    // `ecmaVersion` >= 2023.
    allowHashBang: !1,
    // By default, the parser will verify that private properties are
    // only used in places where they are valid and have been declared.
    // Set this to false to turn such checks off.
    checkPrivateFields: !0,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: !1,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callbackthat will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callbackthat will corrupt its internal state.
    // When this option has an array as value, objects representing the
    // comments are pushed to it.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: !1,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: !1
  }, PC = !1;
  s(SM, "getOptions");
  s(AM, "pushComment");
  fa = 1, qs = 2, hm = 4, $C = 8, fm = 16, VC = 32, Bl = 64, UC = 128, ji = 256, da = 512, Ol = fa | qs | ji;
  s(dm, "functionFlags");
  _l = 0, mm = 1, In = 2, WC = 3, zC = 4, HC = 5, gt = /* @__PURE__ */ s(function(t, r, n) {
    this.options = t = SM(t), this.sourceFile = t.sourceFile, this.keywords = ni(yM[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5m\
odule" : 5]);
    var i = "";
    t.allowReserved !== !0 && (i = im[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (i += " await")), this.
    reservedWords = ni(i);
    var o = (i ? i + " " : "") + im.strict;
    this.reservedWordsStrict = ni(o), this.reservedWordsStrictBind = ni(o + " " + im.strictBind), this.input = String(r), this.containsEsc =
    !1, n ? (this.pos = n, this.lineStart = this.input.lastIndexOf(`
`, n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(yr).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.
    type = S.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc =
    this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0,
    this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.
    potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.
    create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.
    enterScope(fa), this.regexpState = null, this.privateNameStack = [];
  }, "Parser"), nn = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 },
  allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 },
  inClassStaticBlock: { configurable: !0 } };
  gt.prototype.parse = /* @__PURE__ */ s(function() {
    var t = this.options.program || this.startNode();
    return this.nextToken(), this.parseTopLevel(t);
  }, "parse");
  nn.inFunction.get = function() {
    return (this.currentVarScope().flags & qs) > 0;
  };
  nn.inGenerator.get = function() {
    return (this.currentVarScope().flags & $C) > 0;
  };
  nn.inAsync.get = function() {
    return (this.currentVarScope().flags & hm) > 0;
  };
  nn.canAwait.get = function() {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var t = this.scopeStack[e], r = t.flags;
      if (r & (ji | da))
        return !1;
      if (r & qs)
        return (r & hm) > 0;
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  nn.allowSuper.get = function() {
    var e = this.currentThisScope(), t = e.flags;
    return (t & Bl) > 0 || this.options.allowSuperOutsideMethod;
  };
  nn.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & UC) > 0;
  };
  nn.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  nn.allowNewDotTarget.get = function() {
    for (var e = this.scopeStack.length - 1; e >= 0; e--) {
      var t = this.scopeStack[e], r = t.flags;
      if (r & (ji | da) || r & qs && !(r & fm))
        return !0;
    }
    return !1;
  };
  nn.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & ji) > 0;
  };
  gt.extend = /* @__PURE__ */ s(function() {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    for (var n = this, i = 0; i < t.length; i++)
      n = t[i](n);
    return n;
  }, "extend");
  gt.parse = /* @__PURE__ */ s(function(t, r) {
    return new this(r, t).parse();
  }, "parse");
  gt.parseExpressionAt = /* @__PURE__ */ s(function(t, r, n) {
    var i = new this(n, t, r);
    return i.nextToken(), i.parseExpression();
  }, "parseExpressionAt");
  gt.tokenizer = /* @__PURE__ */ s(function(t, r) {
    return new this(r, t);
  }, "tokenizer");
  Object.defineProperties(gt.prototype, nn);
  Rt = gt.prototype, FM = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  Rt.strictDirective = function(e) {
    if (this.options.ecmaVersion < 5)
      return !1;
    for (; ; ) {
      mr.lastIndex = e, e += mr.exec(this.input)[0].length;
      var t = FM.exec(this.input.slice(e));
      if (!t)
        return !1;
      if ((t[1] || t[2]) === "use strict") {
        mr.lastIndex = e + t[0].length;
        var r = mr.exec(this.input), n = r.index + r[0].length, i = this.input.charAt(n);
        return i === ";" || i === "}" || yr.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(i) || i === "!" && this.input.charAt(n + 1) === "=");
      }
      e += t[0].length, mr.lastIndex = e, e += mr.exec(this.input)[0].length, this.input[e] === ";" && e++;
    }
  };
  Rt.eat = function(e) {
    return this.type === e ? (this.next(), !0) : !1;
  };
  Rt.isContextual = function(e) {
    return this.type === S.name && this.value === e && !this.containsEsc;
  };
  Rt.eatContextual = function(e) {
    return this.isContextual(e) ? (this.next(), !0) : !1;
  };
  Rt.expectContextual = function(e) {
    this.eatContextual(e) || this.unexpected();
  };
  Rt.canInsertSemicolon = function() {
    return this.type === S.eof || this.type === S.braceR || yr.test(this.input.slice(this.lastTokEnd, this.start));
  };
  Rt.insertSemicolon = function() {
    if (this.canInsertSemicolon())
      return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
  };
  Rt.semicolon = function() {
    !this.eat(S.semi) && !this.insertSemicolon() && this.unexpected();
  };
  Rt.afterTrailingComma = function(e, t) {
    if (this.type === e)
      return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
  };
  Rt.expect = function(e) {
    this.eat(e) || this.unexpected();
  };
  Rt.unexpected = function(e) {
    this.raise(e ?? this.start, "Unexpected token");
  };
  Rl = /* @__PURE__ */ s(function() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }, "DestructuringErrors");
  Rt.checkPatternErrors = function(e, t) {
    if (e) {
      e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
      var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
      r > -1 && this.raiseRecoverable(r, t ? "Assigning to rvalue" : "Parenthesized pattern");
    }
  };
  Rt.checkExpressionErrors = function(e, t) {
    if (!e)
      return !1;
    var r = e.shorthandAssign, n = e.doubleProto;
    if (!t)
      return r >= 0 || n >= 0;
    r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), n >= 0 && this.raiseRecoverable(n, "\
Redefinition of __proto__ property");
  };
  Rt.checkYieldAwaitInDefaultParams = function() {
    this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default va\
lue"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
  };
  Rt.isSimpleAssignTarget = function(e) {
    return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExp\
ression";
  };
  ae = gt.prototype;
  ae.parseTopLevel = function(e) {
    var t = /* @__PURE__ */ Object.create(null);
    for (e.body || (e.body = []); this.type !== S.eof; ) {
      var r = this.parseStatement(null, !0, t);
      e.body.push(r);
    }
    if (this.inModule)
      for (var n = 0, i = Object.keys(this.undefinedExports); n < i.length; n += 1) {
        var o = i[n];
        this.raiseRecoverable(this.undefinedExports[o].start, "Export '" + o + "' is not defined");
      }
    return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
  };
  gm = { kind: "loop" }, _M = { kind: "switch" };
  ae.isLet = function(e) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
      return !1;
    mr.lastIndex = this.pos;
    var t = mr.exec(this.input), r = this.pos + t[0].length, n = this.input.charCodeAt(r);
    if (n === 91 || n === 92)
      return !0;
    if (e)
      return !1;
    if (n === 123 || n > 55295 && n < 56320)
      return !0;
    if (_n(n, !0)) {
      for (var i = r + 1; Ls(n = this.input.charCodeAt(i), !0); )
        ++i;
      if (n === 92 || n > 55295 && n < 56320)
        return !0;
      var o = this.input.slice(r, i);
      if (!DM.test(o))
        return !0;
    }
    return !1;
  };
  ae.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      return !1;
    mr.lastIndex = this.pos;
    var e = mr.exec(this.input), t = this.pos + e[0].length, r;
    return !yr.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(Ls(r = this.
    input.charCodeAt(t + 8)) || r > 55295 && r < 56320));
  };
  ae.parseStatement = function(e, t, r) {
    var n = this.type, i = this.startNode(), o;
    switch (this.isLet(e) && (n = S._var, o = "let"), n) {
      case S._break:
      case S._continue:
        return this.parseBreakContinueStatement(i, n.keyword);
      case S._debugger:
        return this.parseDebuggerStatement(i);
      case S._do:
        return this.parseDoStatement(i);
      case S._for:
        return this.parseForStatement(i);
      case S._function:
        return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(
        i, !1, !e);
      case S._class:
        return e && this.unexpected(), this.parseClass(i, !0);
      case S._if:
        return this.parseIfStatement(i);
      case S._return:
        return this.parseReturnStatement(i);
      case S._switch:
        return this.parseSwitchStatement(i);
      case S._throw:
        return this.parseThrowStatement(i);
      case S._try:
        return this.parseTryStatement(i);
      case S._const:
      case S._var:
        return o = o || this.value, e && o !== "var" && this.unexpected(), this.parseVarStatement(i, o);
      case S._while:
        return this.parseWhileStatement(i);
      case S._with:
        return this.parseWithStatement(i);
      case S.braceL:
        return this.parseBlock(!0, i);
      case S.semi:
        return this.parseEmptyStatement(i);
      case S._export:
      case S._import:
        if (this.options.ecmaVersion > 10 && n === S._import) {
          mr.lastIndex = this.pos;
          var a = mr.exec(this.input), u = this.pos + a[0].length, l = this.input.charCodeAt(u);
          if (l === 40 || l === 46)
            return this.parseExpressionStatement(i, this.parseExpression());
        }
        return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top le\
vel"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), n === S._import ? this.parseImport(
        i) : this.parseExport(i, r);
      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction())
          return e && this.unexpected(), this.next(), this.parseFunctionStatement(i, !0, !e);
        var c = this.value, p = this.parseExpression();
        return n === S.name && p.type === "Identifier" && this.eat(S.colon) ? this.parseLabeledStatement(i, c, p, e) : this.parseExpressionStatement(
        i, p);
    }
  };
  ae.parseBreakContinueStatement = function(e, t) {
    var r = t === "break";
    this.next(), this.eat(S.semi) || this.insertSemicolon() ? e.label = null : this.type !== S.name ? this.unexpected() : (e.label = this.parseIdent(),
    this.semicolon());
    for (var n = 0; n < this.labels.length; ++n) {
      var i = this.labels[n];
      if ((e.label == null || i.name === e.label.name) && (i.kind != null && (r || i.kind === "loop") || e.label && r))
        break;
    }
    return n === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
  };
  ae.parseDebuggerStatement = function(e) {
    return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
  };
  ae.parseDoStatement = function(e) {
    return this.next(), this.labels.push(gm), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(S._while), e.test = this.parseParenExpression(),
    this.options.ecmaVersion >= 6 ? this.eat(S.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
  };
  ae.parseForStatement = function(e) {
    this.next();
    var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    if (this.labels.push(gm), this.enterScope(0), this.expect(S.parenL), this.type === S.semi)
      return t > -1 && this.unexpected(t), this.parseFor(e, null);
    var r = this.isLet();
    if (this.type === S._var || this.type === S._const || r) {
      var n = this.startNode(), i = r ? "let" : this.value;
      return this.next(), this.parseVar(n, !0, i), this.finishNode(n, "VariableDeclaration"), (this.type === S._in || this.options.ecmaVersion >=
      6 && this.isContextual("of")) && n.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === S._in ? t > -1 && this.
      unexpected(t) : e.await = t > -1), this.parseForIn(e, n)) : (t > -1 && this.unexpected(t), this.parseFor(e, n));
    }
    var o = this.isContextual("let"), a = !1, u = this.containsEsc, l = new Rl(), c = this.start, p = t > -1 ? this.parseExprSubscripts(l, "\
await") : this.parseExpression(!0, l);
    return this.type === S._in || (a = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === S._in && this.unexpected(
    t), e.await = !0) : a && this.options.ecmaVersion >= 8 && (p.start === c && !u && p.type === "Identifier" && p.name === "async" ? this.unexpected() :
    this.options.ecmaVersion >= 9 && (e.await = !1)), o && a && this.raise(p.start, "The left-hand side of a for-of loop may not start with \
'let'."), this.toAssignable(p, !1, l), this.checkLValPattern(p), this.parseForIn(e, p)) : (this.checkExpressionErrors(l, !0), t > -1 && this.
    unexpected(t), this.parseFor(e, p));
  };
  ae.parseFunctionStatement = function(e, t, r) {
    return this.next(), this.parseFunction(e, pa | (r ? 0 : lm), !1, t);
  };
  ae.parseIfStatement = function(e) {
    return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(S._else) ? this.
    parseStatement("if") : null, this.finishNode(e, "IfStatement");
  };
  ae.parseReturnStatement = function(e) {
    return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(),
    this.eat(S.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(
    e, "ReturnStatement");
  };
  ae.parseSwitchStatement = function(e) {
    this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(S.braceL), this.labels.push(_M), this.enterScope(0);
    for (var t, r = !1; this.type !== S.braceR; )
      if (this.type === S._case || this.type === S._default) {
        var n = this.type === S._case;
        t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), n ? t.test = this.parseExpression() :
        (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, t.test = null), this.expect(S.colon);
      } else
        t || this.unexpected(), t.consequent.push(this.parseStatement(null));
    return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
  };
  ae.parseThrowStatement = function(e) {
    return this.next(), yr.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"),
    e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
  };
  kM = [];
  ae.parseCatchClauseParam = function() {
    var e = this.parseBindingAtom(), t = e.type === "Identifier";
    return this.enterScope(t ? VC : 0), this.checkLValPattern(e, t ? zC : In), this.expect(S.parenR), e;
  };
  ae.parseTryStatement = function(e) {
    if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === S._catch) {
      var t = this.startNode();
      this.next(), this.eat(S.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param =
      null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
    }
    return e.finalizer = this.eat(S._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch o\
r finally clause"), this.finishNode(e, "TryStatement");
  };
  ae.parseVarStatement = function(e, t, r) {
    return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, "VariableDeclaration");
  };
  ae.parseWhileStatement = function(e) {
    return this.next(), e.test = this.parseParenExpression(), this.labels.push(gm), e.body = this.parseStatement("while"), this.labels.pop(),
    this.finishNode(e, "WhileStatement");
  };
  ae.parseWithStatement = function(e) {
    return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.
    parseStatement("with"), this.finishNode(e, "WithStatement");
  };
  ae.parseEmptyStatement = function(e) {
    return this.next(), this.finishNode(e, "EmptyStatement");
  };
  ae.parseLabeledStatement = function(e, t, r, n) {
    for (var i = 0, o = this.labels; i < o.length; i += 1) {
      var a = o[i];
      a.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
    }
    for (var u = this.type.isLoop ? "loop" : this.type === S._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
      var c = this.labels[l];
      if (c.statementStart === e.start)
        c.statementStart = this.start, c.kind = u;
      else
        break;
    }
    return this.labels.push({ name: t, kind: u, statementStart: this.start }), e.body = this.parseStatement(n ? n.indexOf("label") === -1 ? n +
    "label" : n : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
  };
  ae.parseExpressionStatement = function(e, t) {
    return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
  };
  ae.parseBlock = function(e, t, r) {
    for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(S.braceL), e && this.enterScope(0); this.
    type !== S.braceR; ) {
      var n = this.parseStatement(null);
      t.body.push(n);
    }
    return r && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
  };
  ae.parseFor = function(e, t) {
    return e.init = t, this.expect(S.semi), e.test = this.type === S.semi ? null : this.parseExpression(), this.expect(S.semi), e.update = this.
    type === S.parenR ? null : this.parseExpression(), this.expect(S.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.
    pop(), this.finishNode(e, "ForStatement");
  };
  ae.parseForIn = function(e, t) {
    var r = this.type === S._in;
    return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict ||
    t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
      t.start,
      (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    ), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(S.parenR), e.body = this.parseStatement("for"),
    this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
  };
  ae.parseVar = function(e, t, r, n) {
    for (e.declarations = [], e.kind = r; ; ) {
      var i = this.startNode();
      if (this.parseVarId(i, r), this.eat(S.eq) ? i.init = this.parseMaybeAssign(t) : !n && r === "const" && !(this.type === S._in || this.options.
      ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !n && i.id.type !== "Identifier" && !(t && (this.type === S._in || this.
      isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.
      push(this.finishNode(i, "VariableDeclarator")), !this.eat(S.comma))
        break;
    }
    return e;
  };
  ae.parseVarId = function(e, t) {
    e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? mm : In, !1);
  };
  pa = 1, lm = 2, GC = 4;
  ae.parseFunction = function(e, t, r, n, i) {
    this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !n) && (this.type === S.star && t & lm && this.
    unexpected(), e.generator = this.eat(S.star)), this.options.ecmaVersion >= 8 && (e.async = !!n), t & pa && (e.id = t & GC && this.type !==
    S.name ? null : this.parseIdent(), e.id && !(t & lm) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ?
    mm : In : WC));
    var o = this.yieldPos, a = this.awaitPos, u = this.awaitIdentPos;
    return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(dm(e.async, e.generator)), t & pa || (e.id = this.type ===
    S.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, !1, i), this.yieldPos = o, this.awaitPos =
    a, this.awaitIdentPos = u, this.finishNode(e, t & pa ? "FunctionDeclaration" : "FunctionExpression");
  };
  ae.parseFunctionParams = function(e) {
    this.expect(S.parenL), e.params = this.parseBindingList(S.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
  };
  ae.parseClass = function(e, t) {
    this.next();
    var r = this.strict;
    this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
    var n = this.enterClassBody(), i = this.startNode(), o = !1;
    for (i.body = [], this.expect(S.braceL); this.type !== S.braceR; ) {
      var a = this.parseClassElement(e.superClass !== null);
      a && (i.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" ? (o && this.raiseRecoverable(a.start, "Duplicate cons\
tructor in the same class"), o = !0) : a.key && a.key.type === "PrivateIdentifier" && TM(n, a) && this.raiseRecoverable(a.key.start, "Identi\
fier '#" + a.key.name + "' has already been declared"));
    }
    return this.strict = r, this.next(), e.body = this.finishNode(i, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclar\
ation" : "ClassExpression");
  };
  ae.parseClassElement = function(e) {
    if (this.eat(S.semi))
      return null;
    var t = this.options.ecmaVersion, r = this.startNode(), n = "", i = !1, o = !1, a = "method", u = !1;
    if (this.eatContextual("static")) {
      if (t >= 13 && this.eat(S.braceL))
        return this.parseClassStaticBlock(r), r;
      this.isClassElementNameStart() || this.type === S.star ? u = !0 : n = "static";
    }
    if (r.static = u, !n && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === S.star) && !this.canInsertSemicolon() ?
    o = !0 : n = "async"), !n && (t >= 9 || !o) && this.eat(S.star) && (i = !0), !n && !o && !i) {
      var l = this.value;
      (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a = l : n = l);
    }
    if (n ? (r.computed = !1, r.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r.key.name = n, this.finishNode(r.key, "Ide\
ntifier")) : this.parseClassElementName(r), t < 13 || this.type === S.parenL || a !== "method" || i || o) {
      var c = !r.static && kl(r, "constructor"), p = c && e;
      c && a !== "method" && this.raise(r.key.start, "Constructor can't have get/set modifier"), r.kind = c ? "constructor" : a, this.parseClassMethod(
      r, i, o, p);
    } else
      this.parseClassField(r);
    return r;
  };
  ae.isClassElementNameStart = function() {
    return this.type === S.name || this.type === S.privateId || this.type === S.num || this.type === S.string || this.type === S.bracketL ||
    this.type.keyword;
  };
  ae.parseClassElementName = function(e) {
    this.type === S.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"),
    e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
  };
  ae.parseClassMethod = function(e, t, r, n) {
    var i = e.key;
    e.kind === "constructor" ? (t && this.raise(i.start, "Constructor can't be a generator"), r && this.raise(i.start, "Constructor can't be\
 an async method")) : e.static && kl(e, "prototype") && this.raise(i.start, "Classes may not have a static property named prototype");
    var o = e.value = this.parseMethod(t, r, n);
    return e.kind === "get" && o.params.length !== 0 && this.raiseRecoverable(o.start, "getter should have no params"), e.kind === "set" && o.
    params.length !== 1 && this.raiseRecoverable(o.start, "setter should have exactly one param"), e.kind === "set" && o.params[0].type === "\
RestElement" && this.raiseRecoverable(o.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
  };
  ae.parseClassField = function(e) {
    return kl(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && kl(e, "prototype") &&
    this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(S.eq) ? (this.enterScope(da | Bl), e.value = this.
    parseMaybeAssign(), this.exitScope()) : e.value = null, this.semicolon(), this.finishNode(e, "PropertyDefinition");
  };
  ae.parseClassStaticBlock = function(e) {
    e.body = [];
    var t = this.labels;
    for (this.labels = [], this.enterScope(ji | Bl); this.type !== S.braceR; ) {
      var r = this.parseStatement(null);
      e.body.push(r);
    }
    return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
  };
  ae.parseClassId = function(e, t) {
    this.type === S.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, In, !1)) : (t === !0 && this.unexpected(), e.id = null);
  };
  ae.parseClassSuper = function(e) {
    e.superClass = this.eat(S._extends) ? this.parseExprSubscripts(null, !1) : null;
  };
  ae.enterClassBody = function() {
    var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
    return this.privateNameStack.push(e), e.declared;
  };
  ae.exitClassBody = function() {
    var e = this.privateNameStack.pop(), t = e.declared, r = e.used;
    if (this.options.checkPrivateFields)
      for (var n = this.privateNameStack.length, i = n === 0 ? null : this.privateNameStack[n - 1], o = 0; o < r.length; ++o) {
        var a = r[o];
        Ms(t, a.name) || (i ? i.used.push(a) : this.raiseRecoverable(a.start, "Private field '#" + a.name + "' must be declared in an enclos\
ing class"));
      }
  };
  s(TM, "isPrivateNameConflicted");
  s(kl, "checkKeyName");
  ae.parseExportAllDeclaration = function(e, t) {
    return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported,
    this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== S.string && this.unexpected(), e.source = this.parseExprAtom(),
    this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
  };
  ae.parseExport = function(e, t) {
    if (this.next(), this.eat(S.star))
      return this.parseExportAllDeclaration(e, t);
    if (this.eat(S._default))
      return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "Ex\
portDefaultDeclaration");
    if (this.shouldParseExportStatement())
      e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.
      declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null, this.options.ecmaVersion >=
      16 && (e.attributes = []);
    else {
      if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
        this.type !== S.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.
        parseWithClause());
      else {
        for (var r = 0, n = e.specifiers; r < n.length; r += 1) {
          var i = n[r];
          this.checkUnreserved(i.local), this.checkLocalExport(i.local), i.local.type === "Literal" && this.raise(i.local.start, "A string l\
iteral cannot be used as an exported binding without `from`.");
        }
        e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
      }
      this.semicolon();
    }
    return this.finishNode(e, "ExportNamedDeclaration");
  };
  ae.parseExportDeclaration = function(e) {
    return this.parseStatement(null);
  };
  ae.parseExportDefaultDeclaration = function() {
    var e;
    if (this.type === S._function || (e = this.isAsyncFunction())) {
      var t = this.startNode();
      return this.next(), e && this.next(), this.parseFunction(t, pa | GC, !1, e);
    } else if (this.type === S._class) {
      var r = this.startNode();
      return this.parseClass(r, "nullableID");
    } else {
      var n = this.parseMaybeAssign();
      return this.semicolon(), n;
    }
  };
  ae.checkExport = function(e, t, r) {
    e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Ms(e, t) && this.raiseRecoverable(r, "Duplicate export '" +
    t + "'"), e[t] = !0);
  };
  ae.checkPatternExport = function(e, t) {
    var r = t.type;
    if (r === "Identifier")
      this.checkExport(e, t, t.start);
    else if (r === "ObjectPattern")
      for (var n = 0, i = t.properties; n < i.length; n += 1) {
        var o = i[n];
        this.checkPatternExport(e, o);
      }
    else if (r === "ArrayPattern")
      for (var a = 0, u = t.elements; a < u.length; a += 1) {
        var l = u[a];
        l && this.checkPatternExport(e, l);
      }
    else r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "Re\
stElement" && this.checkPatternExport(e, t.argument);
  };
  ae.checkVariableExport = function(e, t) {
    if (e)
      for (var r = 0, n = t; r < n.length; r += 1) {
        var i = n[r];
        this.checkPatternExport(e, i.id);
      }
  };
  ae.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" ||
    this.isLet() || this.isAsyncFunction();
  };
  ae.parseExportSpecifier = function(e) {
    var t = this.startNode();
    return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
      e,
      t.exported,
      t.exported.start
    ), this.finishNode(t, "ExportSpecifier");
  };
  ae.parseExportSpecifiers = function(e) {
    var t = [], r = !0;
    for (this.expect(S.braceL); !this.eat(S.braceR); ) {
      if (r)
        r = !1;
      else if (this.expect(S.comma), this.afterTrailingComma(S.braceR))
        break;
      t.push(this.parseExportSpecifier(e));
    }
    return t;
  };
  ae.parseImport = function(e) {
    return this.next(), this.type === S.string ? (e.specifiers = kM, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(),
    this.expectContextual("from"), e.source = this.type === S.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >=
    16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
  };
  ae.parseImportSpecifier = function() {
    var e = this.startNode();
    return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported),
    e.local = e.imported), this.checkLValSimple(e.local, In), this.finishNode(e, "ImportSpecifier");
  };
  ae.parseImportDefaultSpecifier = function() {
    var e = this.startNode();
    return e.local = this.parseIdent(), this.checkLValSimple(e.local, In), this.finishNode(e, "ImportDefaultSpecifier");
  };
  ae.parseImportNamespaceSpecifier = function() {
    var e = this.startNode();
    return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, In), this.finishNode(e, "Imp\
ortNamespaceSpecifier");
  };
  ae.parseImportSpecifiers = function() {
    var e = [], t = !0;
    if (this.type === S.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(S.comma)))
      return e;
    if (this.type === S.star)
      return e.push(this.parseImportNamespaceSpecifier()), e;
    for (this.expect(S.braceL); !this.eat(S.braceR); ) {
      if (t)
        t = !1;
      else if (this.expect(S.comma), this.afterTrailingComma(S.braceR))
        break;
      e.push(this.parseImportSpecifier());
    }
    return e;
  };
  ae.parseWithClause = function() {
    var e = [];
    if (!this.eat(S._with))
      return e;
    this.expect(S.braceL);
    for (var t = {}, r = !0; !this.eat(S.braceR); ) {
      if (r)
        r = !1;
      else if (this.expect(S.comma), this.afterTrailingComma(S.braceR))
        break;
      var n = this.parseImportAttribute(), i = n.key.type === "Identifier" ? n.key.name : n.key.value;
      Ms(t, i) && this.raiseRecoverable(n.key.start, "Duplicate attribute key '" + i + "'"), t[i] = !0, e.push(n);
    }
    return e;
  };
  ae.parseImportAttribute = function() {
    var e = this.startNode();
    return e.key = this.type === S.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(S.colon),
    this.type !== S.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
  };
  ae.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === S.string) {
      var e = this.parseLiteral(this.value);
      return wM.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
    }
    return this.parseIdent(!0);
  };
  ae.adaptDirectivePrologue = function(e) {
    for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
      e[t].directive = e[t].expression.raw.slice(1, -1);
  };
  ae.isDirectiveCandidate = function(e) {
    return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value ==
    "string" && // Reject parenthesized strings.
    (this.input[e.start] === '"' || this.input[e.start] === "'");
  };
  Dr = gt.prototype;
  Dr.toAssignable = function(e, t, r) {
    if (this.options.ecmaVersion >= 6 && e)
      switch (e.type) {
        case "Identifier":
          this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
          for (var n = 0, i = e.properties; n < i.length; n += 1) {
            var o = i[n];
            this.toAssignable(o, t), o.type === "RestElement" && (o.argument.type === "ArrayPattern" || o.argument.type === "ObjectPattern") &&
            this.raise(o.argument.start, "Unexpected token");
          }
          break;
        case "Property":
          e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
          break;
        case "ArrayExpression":
          e.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(e.elements, t);
          break;
        case "SpreadElement":
          e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "\
Rest elements cannot have a default value");
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentP\
attern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t, r);
          break;
        case "ChainExpression":
          this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!t)
            break;
        default:
          this.raise(e.start, "Assigning to rvalue");
      }
    else r && this.checkPatternErrors(r, !0);
    return e;
  };
  Dr.toAssignableList = function(e, t) {
    for (var r = e.length, n = 0; n < r; n++) {
      var i = e[n];
      i && this.toAssignable(i, t);
    }
    if (r) {
      var o = e[r - 1];
      this.options.ecmaVersion === 6 && t && o && o.type === "RestElement" && o.argument.type !== "Identifier" && this.unexpected(o.argument.
      start);
    }
    return e;
  };
  Dr.parseSpread = function(e) {
    var t = this.startNode();
    return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
  };
  Dr.parseRestBinding = function() {
    var e = this.startNode();
    return this.next(), this.options.ecmaVersion === 6 && this.type !== S.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.
    finishNode(e, "RestElement");
  };
  Dr.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6)
      switch (this.type) {
        case S.bracketL:
          var e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(S.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
        case S.braceL:
          return this.parseObj(!0);
      }
    return this.parseIdent();
  };
  Dr.parseBindingList = function(e, t, r, n) {
    for (var i = [], o = !0; !this.eat(e); )
      if (o ? o = !1 : this.expect(S.comma), t && this.type === S.comma)
        i.push(null);
      else {
        if (r && this.afterTrailingComma(e))
          break;
        if (this.type === S.ellipsis) {
          var a = this.parseRestBinding();
          this.parseBindingListItem(a), i.push(a), this.type === S.comma && this.raiseRecoverable(this.start, "Comma is not permitted after \
the rest element"), this.expect(e);
          break;
        } else
          i.push(this.parseAssignableListItem(n));
      }
    return i;
  };
  Dr.parseAssignableListItem = function(e) {
    var t = this.parseMaybeDefault(this.start, this.startLoc);
    return this.parseBindingListItem(t), t;
  };
  Dr.parseBindingListItem = function(e) {
    return e;
  };
  Dr.parseMaybeDefault = function(e, t, r) {
    if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(S.eq))
      return r;
    var n = this.startNodeAt(e, t);
    return n.left = r, n.right = this.parseMaybeAssign(), this.finishNode(n, "AssignmentPattern");
  };
  Dr.checkLValSimple = function(e, t, r) {
    t === void 0 && (t = _l);
    var n = t !== _l;
    switch (e.type) {
      case "Identifier":
        this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (n ? "Binding " : "Assigning to ") + e.name +
        " in strict mode"), n && (t === In && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound nam\
e"), r && (Ms(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = !0), t !== HC && this.declareName(e.name, t, e.
        start));
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        n && this.raiseRecoverable(e.start, "Binding member expression");
        break;
      case "ParenthesizedExpression":
        return n && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, r);
      default:
        this.raise(e.start, (n ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  Dr.checkLValPattern = function(e, t, r) {
    switch (t === void 0 && (t = _l), e.type) {
      case "ObjectPattern":
        for (var n = 0, i = e.properties; n < i.length; n += 1) {
          var o = i[n];
          this.checkLValInnerPattern(o, t, r);
        }
        break;
      case "ArrayPattern":
        for (var a = 0, u = e.elements; a < u.length; a += 1) {
          var l = u[a];
          l && this.checkLValInnerPattern(l, t, r);
        }
        break;
      default:
        this.checkLValSimple(e, t, r);
    }
  };
  Dr.checkLValInnerPattern = function(e, t, r) {
    switch (t === void 0 && (t = _l), e.type) {
      case "Property":
        this.checkLValInnerPattern(e.value, t, r);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(e.left, t, r);
        break;
      case "RestElement":
        this.checkLValPattern(e.argument, t, r);
        break;
      default:
        this.checkLValPattern(e, t, r);
    }
  };
  Lr = /* @__PURE__ */ s(function(t, r, n, i, o) {
    this.token = t, this.isExpr = !!r, this.preserveSpace = !!n, this.override = i, this.generator = !!o;
  }, "TokContext"), Qe = {
    b_stat: new Lr("{", !1),
    b_expr: new Lr("{", !0),
    b_tmpl: new Lr("${", !1),
    p_stat: new Lr("(", !1),
    p_expr: new Lr("(", !0),
    q_tmpl: new Lr("`", !0, !0, function(e) {
      return e.tryReadTemplateToken();
    }),
    f_stat: new Lr("function", !1),
    f_expr: new Lr("function", !0),
    f_expr_gen: new Lr("function", !0, !1, null, !0),
    f_gen: new Lr("function", !1, !1, null, !0)
  }, $s = gt.prototype;
  $s.initialContext = function() {
    return [Qe.b_stat];
  };
  $s.curContext = function() {
    return this.context[this.context.length - 1];
  };
  $s.braceIsBlock = function(e) {
    var t = this.curContext();
    return t === Qe.f_expr || t === Qe.f_stat ? !0 : e === S.colon && (t === Qe.b_stat || t === Qe.b_expr) ? !t.isExpr : e === S._return || e ===
    S.name && this.exprAllowed ? yr.test(this.input.slice(this.lastTokEnd, this.start)) : e === S._else || e === S.semi || e === S.eof || e ===
    S.parenR || e === S.arrow ? !0 : e === S.braceL ? t === Qe.b_stat : e === S._var || e === S._const || e === S.name ? !1 : !this.exprAllowed;
  };
  $s.inGeneratorContext = function() {
    for (var e = this.context.length - 1; e >= 1; e--) {
      var t = this.context[e];
      if (t.token === "function")
        return t.generator;
    }
    return !1;
  };
  $s.updateContext = function(e) {
    var t, r = this.type;
    r.keyword && e === S.dot ? this.exprAllowed = !1 : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
  };
  $s.overrideContext = function(e) {
    this.curContext() !== e && (this.context[this.context.length - 1] = e);
  };
  S.parenR.updateContext = S.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = !0;
      return;
    }
    var e = this.context.pop();
    e === Qe.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
  };
  S.braceL.updateContext = function(e) {
    this.context.push(this.braceIsBlock(e) ? Qe.b_stat : Qe.b_expr), this.exprAllowed = !0;
  };
  S.dollarBraceL.updateContext = function() {
    this.context.push(Qe.b_tmpl), this.exprAllowed = !0;
  };
  S.parenL.updateContext = function(e) {
    var t = e === S._if || e === S._for || e === S._with || e === S._while;
    this.context.push(t ? Qe.p_stat : Qe.p_expr), this.exprAllowed = !0;
  };
  S.incDec.updateContext = function() {
  };
  S._function.updateContext = S._class.updateContext = function(e) {
    e.beforeExpr && e !== S._else && !(e === S.semi && this.curContext() !== Qe.p_stat) && !(e === S._return && yr.test(this.input.slice(this.
    lastTokEnd, this.start))) && !((e === S.colon || e === S.braceL) && this.curContext() === Qe.b_stat) ? this.context.push(Qe.f_expr) : this.
    context.push(Qe.f_stat), this.exprAllowed = !1;
  };
  S.colon.updateContext = function() {
    this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
  };
  S.backQuote.updateContext = function() {
    this.curContext() === Qe.q_tmpl ? this.context.pop() : this.context.push(Qe.q_tmpl), this.exprAllowed = !1;
  };
  S.star.updateContext = function(e) {
    if (e === S._function) {
      var t = this.context.length - 1;
      this.context[t] === Qe.f_expr ? this.context[t] = Qe.f_expr_gen : this.context[t] = Qe.f_gen;
    }
    this.exprAllowed = !0;
  };
  S.name.updateContext = function(e) {
    var t = !1;
    this.options.ecmaVersion >= 6 && e !== S.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) &&
    (t = !0), this.exprAllowed = t;
  };
  De = gt.prototype;
  De.checkPropClash = function(e, t, r) {
    if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
      var n = e.key, i;
      switch (n.type) {
        case "Identifier":
          i = n.name;
          break;
        case "Literal":
          i = String(n.value);
          break;
        default:
          return;
      }
      var o = e.kind;
      if (this.options.ecmaVersion >= 6) {
        i === "__proto__" && o === "init" && (t.proto && (r ? r.doubleProto < 0 && (r.doubleProto = n.start) : this.raiseRecoverable(n.start,
        "Redefinition of __proto__ property")), t.proto = !0);
        return;
      }
      i = "$" + i;
      var a = t[i];
      if (a) {
        var u;
        o === "init" ? u = this.strict && a.init || a.get || a.set : u = a.init || a[o], u && this.raiseRecoverable(n.start, "Redefinition o\
f property");
      } else
        a = t[i] = {
          init: !1,
          get: !1,
          set: !1
        };
      a[o] = !0;
    }
  };
  De.parseExpression = function(e, t) {
    var r = this.start, n = this.startLoc, i = this.parseMaybeAssign(e, t);
    if (this.type === S.comma) {
      var o = this.startNodeAt(r, n);
      for (o.expressions = [i]; this.eat(S.comma); )
        o.expressions.push(this.parseMaybeAssign(e, t));
      return this.finishNode(o, "SequenceExpression");
    }
    return i;
  };
  De.parseMaybeAssign = function(e, t, r) {
    if (this.isContextual("yield")) {
      if (this.inGenerator)
        return this.parseYield(e);
      this.exprAllowed = !1;
    }
    var n = !1, i = -1, o = -1, a = -1;
    t ? (i = t.parenthesizedAssign, o = t.trailingComma, a = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Rl(), n =
    !0);
    var u = this.start, l = this.startLoc;
    (this.type === S.parenL || this.type === S.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
    var c = this.parseMaybeConditional(e, t);
    if (r && (c = r.call(this, c, u, l)), this.type.isAssign) {
      var p = this.startNodeAt(u, l);
      return p.operator = this.value, this.type === S.eq && (c = this.toAssignable(c, !1, t)), n || (t.parenthesizedAssign = t.trailingComma =
      t.doubleProto = -1), t.shorthandAssign >= c.start && (t.shorthandAssign = -1), this.type === S.eq ? this.checkLValPattern(c) : this.checkLValSimple(
      c), p.left = c, this.next(), p.right = this.parseMaybeAssign(e), a > -1 && (t.doubleProto = a), this.finishNode(p, "AssignmentExpressi\
on");
    } else
      n && this.checkExpressionErrors(t, !0);
    return i > -1 && (t.parenthesizedAssign = i), o > -1 && (t.trailingComma = o), c;
  };
  De.parseMaybeConditional = function(e, t) {
    var r = this.start, n = this.startLoc, i = this.parseExprOps(e, t);
    if (this.checkExpressionErrors(t))
      return i;
    if (this.eat(S.question)) {
      var o = this.startNodeAt(r, n);
      return o.test = i, o.consequent = this.parseMaybeAssign(), this.expect(S.colon), o.alternate = this.parseMaybeAssign(e), this.finishNode(
      o, "ConditionalExpression");
    }
    return i;
  };
  De.parseExprOps = function(e, t) {
    var r = this.start, n = this.startLoc, i = this.parseMaybeUnary(t, !1, !1, e);
    return this.checkExpressionErrors(t) || i.start === r && i.type === "ArrowFunctionExpression" ? i : this.parseExprOp(i, r, n, -1, e);
  };
  De.parseExprOp = function(e, t, r, n, i) {
    var o = this.type.binop;
    if (o != null && (!i || this.type !== S._in) && o > n) {
      var a = this.type === S.logicalOR || this.type === S.logicalAND, u = this.type === S.coalesce;
      u && (o = S.logicalAND.binop);
      var l = this.value;
      this.next();
      var c = this.start, p = this.startLoc, h = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, i), c, p, o, i), f = this.buildBinary(t,
      r, e, h, l, a || u);
      return (a && this.type === S.coalesce || u && (this.type === S.logicalOR || this.type === S.logicalAND)) && this.raiseRecoverable(this.
      start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(f, t, r, n, i);
    }
    return e;
  };
  De.buildBinary = function(e, t, r, n, i, o) {
    n.type === "PrivateIdentifier" && this.raise(n.start, "Private identifier can only be left side of binary expression");
    var a = this.startNodeAt(e, t);
    return a.left = r, a.operator = i, a.right = n, this.finishNode(a, o ? "LogicalExpression" : "BinaryExpression");
  };
  De.parseMaybeUnary = function(e, t, r, n) {
    var i = this.start, o = this.startLoc, a;
    if (this.isContextual("await") && this.canAwait)
      a = this.parseAwait(n), t = !0;
    else if (this.type.prefix) {
      var u = this.startNode(), l = this.type === S.incDec;
      u.operator = this.value, u.prefix = !0, this.next(), u.argument = this.parseMaybeUnary(null, !0, l, n), this.checkExpressionErrors(e, !0),
      l ? this.checkLValSimple(u.argument) : this.strict && u.operator === "delete" && JC(u.argument) ? this.raiseRecoverable(u.start, "Dele\
ting local variable in strict mode") : u.operator === "delete" && cm(u.argument) ? this.raiseRecoverable(u.start, "Private fields can not be\
 deleted") : t = !0, a = this.finishNode(u, l ? "UpdateExpression" : "UnaryExpression");
    } else if (!t && this.type === S.privateId)
      (n || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), a = this.parsePrivateIdent(), this.
      type !== S._in && this.unexpected();
    else {
      if (a = this.parseExprSubscripts(e, n), this.checkExpressionErrors(e))
        return a;
      for (; this.type.postfix && !this.canInsertSemicolon(); ) {
        var c = this.startNodeAt(i, o);
        c.operator = this.value, c.prefix = !1, c.argument = a, this.checkLValSimple(a), this.next(), a = this.finishNode(c, "UpdateExpressi\
on");
      }
    }
    if (!r && this.eat(S.starstar))
      if (t)
        this.unexpected(this.lastTokStart);
      else
        return this.buildBinary(i, o, a, this.parseMaybeUnary(null, !1, !1, n), "**", !1);
    else
      return a;
  };
  s(JC, "isLocalVariableAccess");
  s(cm, "isPrivateFieldAccess");
  De.parseExprSubscripts = function(e, t) {
    var r = this.start, n = this.startLoc, i = this.parseExprAtom(e, t);
    if (i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      return i;
    var o = this.parseSubscripts(i, r, n, !1, t);
    return e && o.type === "MemberExpression" && (e.parenthesizedAssign >= o.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= o.
    start && (e.parenthesizedBind = -1), e.trailingComma >= o.start && (e.trailingComma = -1)), o;
  };
  De.parseSubscripts = function(e, t, r, n, i) {
    for (var o = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() &&
    e.end - e.start === 5 && this.potentialArrowAt === e.start, a = !1; ; ) {
      var u = this.parseSubscript(e, t, r, n, o, a, i);
      if (u.optional && (a = !0), u === e || u.type === "ArrowFunctionExpression") {
        if (a) {
          var l = this.startNodeAt(t, r);
          l.expression = u, u = this.finishNode(l, "ChainExpression");
        }
        return u;
      }
      e = u;
    }
  };
  De.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(S.arrow);
  };
  De.parseSubscriptAsyncArrow = function(e, t, r, n) {
    return this.parseArrowExpression(this.startNodeAt(e, t), r, !0, n);
  };
  De.parseSubscript = function(e, t, r, n, i, o, a) {
    var u = this.options.ecmaVersion >= 11, l = u && this.eat(S.questionDot);
    n && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var c = this.eat(S.bracketL);
    if (c || l && this.type !== S.parenL && this.type !== S.backQuote || this.eat(S.dot)) {
      var p = this.startNodeAt(t, r);
      p.object = e, c ? (p.property = this.parseExpression(), this.expect(S.bracketR)) : this.type === S.privateId && e.type !== "Super" ? p.
      property = this.parsePrivateIdent() : p.property = this.parseIdent(this.options.allowReserved !== "never"), p.computed = !!c, u && (p.
      optional = l), e = this.finishNode(p, "MemberExpression");
    } else if (!n && this.eat(S.parenL)) {
      var h = new Rl(), f = this.yieldPos, d = this.awaitPos, m = this.awaitIdentPos;
      this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
      var g = this.parseExprList(S.parenR, this.options.ecmaVersion >= 8, !1, h);
      if (i && !l && this.shouldParseAsyncArrow())
        return this.checkPatternErrors(h, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos,
        "Cannot use 'await' as identifier inside an async function"), this.yieldPos = f, this.awaitPos = d, this.awaitIdentPos = m, this.parseSubscriptAsyncArrow(
        t, r, g, a);
      this.checkExpressionErrors(h, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = d || this.awaitPos, this.awaitIdentPos = m || this.
      awaitIdentPos;
      var b = this.startNodeAt(t, r);
      b.callee = e, b.arguments = g, u && (b.optional = l), e = this.finishNode(b, "CallExpression");
    } else if (this.type === S.backQuote) {
      (l || o) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      var y = this.startNodeAt(t, r);
      y.tag = e, y.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(y, "TaggedTemplateExpression");
    }
    return e;
  };
  De.parseExprAtom = function(e, t, r) {
    this.type === S.slash && this.readRegexp();
    var n, i = this.potentialArrowAt === this.start;
    switch (this.type) {
      case S._super:
        return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), n = this.startNode(), this.next(), this.type ===
        S.parenL && !this.allowDirectSuper && this.raise(n.start, "super() call outside constructor of a subclass"), this.type !== S.dot && this.
        type !== S.bracketL && this.type !== S.parenL && this.unexpected(), this.finishNode(n, "Super");
      case S._this:
        return n = this.startNode(), this.next(), this.finishNode(n, "ThisExpression");
      case S.name:
        var o = this.start, a = this.startLoc, u = this.containsEsc, l = this.parseIdent(!1);
        if (this.options.ecmaVersion >= 8 && !u && l.name === "async" && !this.canInsertSemicolon() && this.eat(S._function))
          return this.overrideContext(Qe.f_expr), this.parseFunction(this.startNodeAt(o, a), 0, !1, !0, t);
        if (i && !this.canInsertSemicolon()) {
          if (this.eat(S.arrow))
            return this.parseArrowExpression(this.startNodeAt(o, a), [l], !1, t);
          if (this.options.ecmaVersion >= 8 && l.name === "async" && this.type === S.name && !u && (!this.potentialArrowInForAwait || this.value !==
          "of" || this.containsEsc))
            return l = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(S.arrow)) && this.unexpected(), this.parseArrowExpression(
            this.startNodeAt(o, a), [l], !0, t);
        }
        return l;
      case S.regexp:
        var c = this.value;
        return n = this.parseLiteral(c.value), n.regex = { pattern: c.pattern, flags: c.flags }, n;
      case S.num:
      case S.string:
        return this.parseLiteral(this.value);
      case S._null:
      case S._true:
      case S._false:
        return n = this.startNode(), n.value = this.type === S._null ? null : this.type === S._true, n.raw = this.type.keyword, this.next(),
        this.finishNode(n, "Literal");
      case S.parenL:
        var p = this.start, h = this.parseParenAndDistinguishExpression(i, t);
        return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (e.parenthesizedAssign = p), e.parenthesizedBind < 0 && (e.
        parenthesizedBind = p)), h;
      case S.bracketL:
        return n = this.startNode(), this.next(), n.elements = this.parseExprList(S.bracketR, !0, !0, e), this.finishNode(n, "ArrayExpressio\
n");
      case S.braceL:
        return this.overrideContext(Qe.b_expr), this.parseObj(!1, e);
      case S._function:
        return n = this.startNode(), this.next(), this.parseFunction(n, 0);
      case S._class:
        return this.parseClass(this.startNode(), !1);
      case S._new:
        return this.parseNew();
      case S.backQuote:
        return this.parseTemplate();
      case S._import:
        return this.options.ecmaVersion >= 11 ? this.parseExprImport(r) : this.unexpected();
      default:
        return this.parseExprAtomDefault();
    }
  };
  De.parseExprAtomDefault = function() {
    this.unexpected();
  };
  De.parseExprImport = function(e) {
    var t = this.startNode();
    if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === S.parenL && !e)
      return this.parseDynamicImport(t);
    if (this.type === S.dot) {
      var r = this.startNodeAt(t.start, t.loc && t.loc.start);
      return r.name = "import", t.meta = this.finishNode(r, "Identifier"), this.parseImportMeta(t);
    } else
      this.unexpected();
  };
  De.parseDynamicImport = function(e) {
    if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
      this.eat(S.parenR) ? e.options = null : (this.expect(S.comma), this.afterTrailingComma(S.parenR) ? e.options = null : (e.options = this.
      parseMaybeAssign(), this.eat(S.parenR) || (this.expect(S.comma), this.afterTrailingComma(S.parenR) || this.unexpected())));
    else if (!this.eat(S.parenR)) {
      var t = this.start;
      this.eat(S.comma) && this.eat(S.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
    }
    return this.finishNode(e, "ImportExpression");
  };
  De.parseImportMeta = function(e) {
    this.next();
    var t = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta prop\
erty for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !==
    "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.
    finishNode(e, "MetaProperty");
  };
  De.parseLiteral = function(e) {
    var t = this.startNode();
    return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(
    0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
  };
  De.parseParenExpression = function() {
    this.expect(S.parenL);
    var e = this.parseExpression();
    return this.expect(S.parenR), e;
  };
  De.shouldParseArrow = function(e) {
    return !this.canInsertSemicolon();
  };
  De.parseParenAndDistinguishExpression = function(e, t) {
    var r = this.start, n = this.startLoc, i, o = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var a = this.start, u = this.startLoc, l = [], c = !0, p = !1, h = new Rl(), f = this.yieldPos, d = this.awaitPos, m;
      for (this.yieldPos = 0, this.awaitPos = 0; this.type !== S.parenR; )
        if (c ? c = !1 : this.expect(S.comma), o && this.afterTrailingComma(S.parenR, !0)) {
          p = !0;
          break;
        } else if (this.type === S.ellipsis) {
          m = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === S.comma && this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
          break;
        } else
          l.push(this.parseMaybeAssign(!1, h, this.parseParenItem));
      var g = this.lastTokEnd, b = this.lastTokEndLoc;
      if (this.expect(S.parenR), e && this.shouldParseArrow(l) && this.eat(S.arrow))
        return this.checkPatternErrors(h, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = d, this.parseParenArrowList(
        r, n, l, t);
      (!l.length || p) && this.unexpected(this.lastTokStart), m && this.unexpected(m), this.checkExpressionErrors(h, !0), this.yieldPos = f ||
      this.yieldPos, this.awaitPos = d || this.awaitPos, l.length > 1 ? (i = this.startNodeAt(a, u), i.expressions = l, this.finishNodeAt(i,
      "SequenceExpression", g, b)) : i = l[0];
    } else
      i = this.parseParenExpression();
    if (this.options.preserveParens) {
      var y = this.startNodeAt(r, n);
      return y.expression = i, this.finishNode(y, "ParenthesizedExpression");
    } else
      return i;
  };
  De.parseParenItem = function(e) {
    return e;
  };
  De.parseParenArrowList = function(e, t, r, n) {
    return this.parseArrowExpression(this.startNodeAt(e, t), r, !1, n);
  };
  IM = [];
  De.parseNew = function() {
    this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var e = this.startNode();
    if (this.next(), this.options.ecmaVersion >= 6 && this.type === S.dot) {
      var t = this.startNodeAt(e.start, e.loc && e.loc.start);
      t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
      var r = this.containsEsc;
      return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta \
property for new is 'new.target'"), r && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget ||
      this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
    }
    var n = this.start, i = this.startLoc;
    return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), n, i, !0, !1), this.eat(S.parenL) ? e.arguments = this.parseExprList(
    S.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = IM, this.finishNode(e, "NewExpression");
  };
  De.parseTemplateElement = function(e) {
    var t = e.isTagged, r = this.startNode();
    return this.type === S.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.
    value = {
      raw: this.value.replace(/\r\n?/g, `
`),
      cooked: null
    }) : r.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
      cooked: this.value
    }, this.next(), r.tail = this.type === S.backQuote, this.finishNode(r, "TemplateElement");
  };
  De.parseTemplate = function(e) {
    e === void 0 && (e = {});
    var t = e.isTagged;
    t === void 0 && (t = !1);
    var r = this.startNode();
    this.next(), r.expressions = [];
    var n = this.parseTemplateElement({ isTagged: t });
    for (r.quasis = [n]; !n.tail; )
      this.type === S.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(S.dollarBraceL), r.expressions.push(this.parseExpression()),
      this.expect(S.braceR), r.quasis.push(n = this.parseTemplateElement({ isTagged: t }));
    return this.next(), this.finishNode(r, "TemplateLiteral");
  };
  De.isAsyncProp = function(e) {
    return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === S.name || this.type === S.num || this.type ===
    S.string || this.type === S.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === S.star) && !yr.test(this.input.
    slice(this.lastTokEnd, this.start));
  };
  De.parseObj = function(e, t) {
    var r = this.startNode(), n = !0, i = {};
    for (r.properties = [], this.next(); !this.eat(S.braceR); ) {
      if (n)
        n = !1;
      else if (this.expect(S.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(S.braceR))
        break;
      var o = this.parseProperty(e, t);
      e || this.checkPropClash(o, i, t), r.properties.push(o);
    }
    return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
  };
  De.parseProperty = function(e, t) {
    var r = this.startNode(), n, i, o, a;
    if (this.options.ecmaVersion >= 9 && this.eat(S.ellipsis))
      return e ? (r.argument = this.parseIdent(!1), this.type === S.comma && this.raiseRecoverable(this.start, "Comma is not permitted after\
 the rest element"), this.finishNode(r, "RestElement")) : (r.argument = this.parseMaybeAssign(!1, t), this.type === S.comma && t && t.trailingComma <
      0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
    this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (e || t) && (o = this.start, a = this.startLoc), e || (n = this.eat(S.
    star)));
    var u = this.containsEsc;
    return this.parsePropertyName(r), !e && !u && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(r) ? (i = !0, n = this.options.ecmaVersion >=
    9 && this.eat(S.star), this.parsePropertyName(r)) : i = !1, this.parsePropertyValue(r, e, n, i, o, a, t, u), this.finishNode(r, "Propert\
y");
  };
  De.parseGetterSetter = function(e) {
    var t = e.key.name;
    this.parsePropertyName(e), e.value = this.parseMethod(!1), e.kind = t;
    var r = e.kind === "get" ? 0 : 1;
    if (e.value.params.length !== r) {
      var n = e.value.start;
      e.kind === "get" ? this.raiseRecoverable(n, "getter should have no params") : this.raiseRecoverable(n, "setter should have exactly one\
 param");
    } else
      e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest\
 params");
  };
  De.parsePropertyValue = function(e, t, r, n, i, o, a, u) {
    (r || n) && this.type === S.colon && this.unexpected(), this.eat(S.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) :
    this.parseMaybeAssign(!1, a), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === S.parenL ? (t && this.unexpected(), e.method =
    !0, e.value = this.parseMethod(r, n), e.kind = "init") : !t && !u && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Ide\
ntifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== S.comma && this.type !== S.braceR && this.type !== S.eq ? ((r ||
    n) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r ||
    n) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = i), t ? e.value =
    this.parseMaybeDefault(i, o, this.copyNode(e.key)) : this.type === S.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start),
    e.value = this.parseMaybeDefault(i, o, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.kind = "init", e.shorthand = !0) : this.
    unexpected();
  };
  De.parsePropertyName = function(e) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(S.bracketL))
        return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(S.bracketR), e.key;
      e.computed = !1;
    }
    return e.key = this.type === S.num || this.type === S.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "ne\
ver");
  };
  De.initFunction = function(e) {
    e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
  };
  De.parseMethod = function(e, t, r) {
    var n = this.startNode(), i = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos;
    return this.initFunction(n), this.options.ecmaVersion >= 6 && (n.generator = e), this.options.ecmaVersion >= 8 && (n.async = !!t), this.
    yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(dm(t, n.generator) | Bl | (r ? UC : 0)), this.expect(S.parenL),
    n.params = this.parseBindingList(S.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(
    n, !1, !0, !1), this.yieldPos = i, this.awaitPos = o, this.awaitIdentPos = a, this.finishNode(n, "FunctionExpression");
  };
  De.parseArrowExpression = function(e, t, r, n) {
    var i = this.yieldPos, o = this.awaitPos, a = this.awaitIdentPos;
    return this.enterScope(dm(r, !1) | fm), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.
    awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, n), this.yieldPos = i, this.
    awaitPos = o, this.awaitIdentPos = a, this.finishNode(e, "ArrowFunctionExpression");
  };
  De.parseFunctionBody = function(e, t, r, n) {
    var i = t && this.type !== S.braceL, o = this.strict, a = !1;
    if (i)
      e.body = this.parseMaybeAssign(n), e.expression = !0, this.checkParams(e, !1);
    else {
      var u = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
      (!o || u) && (a = this.strictDirective(this.end), a && u && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function\
 with non-simple parameter list"));
      var l = this.labels;
      this.labels = [], a && (this.strict = !0), this.checkParams(e, !o && !a && !t && !r && this.isSimpleParamList(e.params)), this.strict &&
      e.id && this.checkLValSimple(e.id, HC), e.body = this.parseBlock(!1, void 0, a && !o), e.expression = !1, this.adaptDirectivePrologue(
      e.body.body), this.labels = l;
    }
    this.exitScope();
  };
  De.isSimpleParamList = function(e) {
    for (var t = 0, r = e; t < r.length; t += 1) {
      var n = r[t];
      if (n.type !== "Identifier")
        return !1;
    }
    return !0;
  };
  De.checkParams = function(e, t) {
    for (var r = /* @__PURE__ */ Object.create(null), n = 0, i = e.params; n < i.length; n += 1) {
      var o = i[n];
      this.checkLValInnerPattern(o, mm, t ? null : r);
    }
  };
  De.parseExprList = function(e, t, r, n) {
    for (var i = [], o = !0; !this.eat(e); ) {
      if (o)
        o = !1;
      else if (this.expect(S.comma), t && this.afterTrailingComma(e))
        break;
      var a = void 0;
      r && this.type === S.comma ? a = null : this.type === S.ellipsis ? (a = this.parseSpread(n), n && this.type === S.comma && n.trailingComma <
      0 && (n.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, n), i.push(a);
    }
    return i;
  };
  De.checkUnreserved = function(e) {
    var t = e.start, r = e.end, n = e.name;
    if (this.inGenerator && n === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync &&
    n === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), !(this.currentThisScope().flags &
    Ol) && n === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (n ===
    "arguments" || n === "await") && this.raise(t, "Cannot use " + n + " in class static initialization block"), this.keywords.test(n) && this.
    raise(t, "Unexpected keyword '" + n + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
      var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
      i.test(n) && (!this.inAsync && n === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.
      raiseRecoverable(t, "The keyword '" + n + "' is reserved"));
    }
  };
  De.parseIdent = function(e) {
    var t = this.parseIdentNode();
    return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.
    awaitIdentPos = t.start)), t;
  };
  De.parseIdentNode = function() {
    var e = this.startNode();
    return this.type === S.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "\
function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type =
    S.name) : this.unexpected(), e;
  };
  De.parsePrivateIdent = function() {
    var e = this.startNode();
    return this.type === S.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.
    checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an \
enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
  };
  De.parseYield = function(e) {
    this.yieldPos || (this.yieldPos = this.start);
    var t = this.startNode();
    return this.next(), this.type === S.semi || this.canInsertSemicolon() || this.type !== S.star && !this.type.startsExpr ? (t.delegate = !1,
    t.argument = null) : (t.delegate = this.eat(S.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
  };
  De.parseAwait = function(e) {
    this.awaitPos || (this.awaitPos = this.start);
    var t = this.startNode();
    return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
  };
  Tl = gt.prototype;
  Tl.raise = function(e, t) {
    var r = qC(this.input, e);
    t += " (" + r.line + ":" + r.column + ")", this.sourceFile && (t += " in " + this.sourceFile);
    var n = new SyntaxError(t);
    throw n.pos = e, n.loc = r, n.raisedAt = this.pos, n;
  };
  Tl.raiseRecoverable = Tl.raise;
  Tl.curPosition = function() {
    if (this.options.locations)
      return new ha(this.curLine, this.pos - this.lineStart);
  };
  ii = gt.prototype, PM = /* @__PURE__ */ s(function(t) {
    this.flags = t, this.var = [], this.lexical = [], this.functions = [];
  }, "Scope");
  ii.enterScope = function(e) {
    this.scopeStack.push(new PM(e));
  };
  ii.exitScope = function() {
    this.scopeStack.pop();
  };
  ii.treatFunctionsAsVarInScope = function(e) {
    return e.flags & qs || !this.inModule && e.flags & fa;
  };
  ii.declareName = function(e, t, r) {
    var n = !1;
    if (t === In) {
      var i = this.currentScope();
      n = i.lexical.indexOf(e) > -1 || i.functions.indexOf(e) > -1 || i.var.indexOf(e) > -1, i.lexical.push(e), this.inModule && i.flags & fa &&
      delete this.undefinedExports[e];
    } else if (t === zC) {
      var o = this.currentScope();
      o.lexical.push(e);
    } else if (t === WC) {
      var a = this.currentScope();
      this.treatFunctionsAsVar ? n = a.lexical.indexOf(e) > -1 : n = a.lexical.indexOf(e) > -1 || a.var.indexOf(e) > -1, a.functions.push(e);
    } else
      for (var u = this.scopeStack.length - 1; u >= 0; --u) {
        var l = this.scopeStack[u];
        if (l.lexical.indexOf(e) > -1 && !(l.flags & VC && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(
        e) > -1) {
          n = !0;
          break;
        }
        if (l.var.push(e), this.inModule && l.flags & fa && delete this.undefinedExports[e], l.flags & Ol)
          break;
      }
    n && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
  };
  ii.checkLocalExport = function(e) {
    this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
  };
  ii.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  ii.currentVarScope = function() {
    for (var e = this.scopeStack.length - 1; ; e--) {
      var t = this.scopeStack[e];
      if (t.flags & (Ol | da | ji))
        return t;
    }
  };
  ii.currentThisScope = function() {
    for (var e = this.scopeStack.length - 1; ; e--) {
      var t = this.scopeStack[e];
      if (t.flags & (Ol | da | ji) && !(t.flags & fm))
        return t;
    }
  };
  Nl = /* @__PURE__ */ s(function(t, r, n) {
    this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new Pl(t, n)), t.options.directSourceFile && (this.sourceFile =
    t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
  }, "Node"), ma = gt.prototype;
  ma.startNode = function() {
    return new Nl(this, this.start, this.startLoc);
  };
  ma.startNodeAt = function(e, t) {
    return new Nl(this, e, t);
  };
  s(ZC, "finishNodeAt");
  ma.finishNode = function(e, t) {
    return ZC.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
  };
  ma.finishNodeAt = function(e, t, r, n) {
    return ZC.call(this, e, t, r, n);
  };
  ma.copyNode = function(e) {
    var t = new Nl(this, e.start, this.startLoc);
    for (var r in e)
      t[r] = e[r];
    return t;
  };
  BM = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tu\
lu_Tigalari Tutg Unknown Zzzz", XC = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case\
_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF\
 Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Compo\
nent Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binar\
y_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowe\
rcase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indic\
ator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White\
_Space space XID_Continue XIDC XID_Start XIDS", KC = XC + " Extended_Pictographic", YC = KC, QC = YC + " EBase EComp EMod EPres ExtPict", ew =
  QC, OM = ew, RM = {
    9: XC,
    10: KC,
    11: YC,
    12: QC,
    13: ew,
    14: OM
  }, NM = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequen\
ce RGI_Emoji", LM = {
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: NM
  }, BC = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Num\
ber Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_L\
etter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C \
Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z S\
pace_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", tw = "Adlam Adlm Ahom Anatol\
ian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks B\
opomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham\
 Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egypti\
an_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru\
 Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phl\
i Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khud\
awadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam \
Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hierog\
lyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Og\
ham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old\
_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahl\
avi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Som\
peng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri\
 Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wa\
ra Yi Yiii Zanabazar_Square Zanb", rw = tw + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian \
Sogo Sogdian Sogd", nw = rw + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", iw = nw + " Chorasmian Chrs Diak Div\
es_Akuru Khitan_Small_Script Kits Yezi Yezidi", sw = iw + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", jM = sw + " " +
  BM, MM = {
    9: tw,
    10: rw,
    11: nw,
    12: iw,
    13: sw,
    14: jM
  }, ow = {};
  s(qM, "buildUnicodeData");
  for (Fl = 0, om = [9, 10, 11, 12, 13, 14]; Fl < om.length; Fl += 1)
    OC = om[Fl], qM(OC);
  oe = gt.prototype, Il = /* @__PURE__ */ s(function(t, r) {
    this.parent = t, this.base = r || this;
  }, "BranchID");
  Il.prototype.separatedFrom = /* @__PURE__ */ s(function(t) {
    for (var r = this; r; r = r.parent)
      for (var n = t; n; n = n.parent)
        if (r.base === n.base && r !== n)
          return !0;
    return !1;
  }, "separatedFrom");
  Il.prototype.sibling = /* @__PURE__ */ s(function() {
    return new Il(this.parent, this.base);
  }, "sibling");
  sn = /* @__PURE__ */ s(function(t) {
    this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.
    ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = ow[t.options.ecmaVersion >= 14 ? 14 :
    t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.
    pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference =
    0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
  }, "RegExpValidationState");
  sn.prototype.reset = /* @__PURE__ */ s(function(t, r, n) {
    var i = n.indexOf("v") !== -1, o = n.indexOf("u") !== -1;
    this.start = t | 0, this.source = r + "", this.flags = n, i && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV =
    !0, this.switchN = !0) : (this.switchU = o && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = o && this.parser.options.
    ecmaVersion >= 9);
  }, "reset");
  sn.prototype.raise = /* @__PURE__ */ s(function(t) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
  }, "raise");
  sn.prototype.at = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    var n = this.source, i = n.length;
    if (t >= i)
      return -1;
    var o = n.charCodeAt(t);
    if (!(r || this.switchU) || o <= 55295 || o >= 57344 || t + 1 >= i)
      return o;
    var a = n.charCodeAt(t + 1);
    return a >= 56320 && a <= 57343 ? (o << 10) + a - 56613888 : o;
  }, "at");
  sn.prototype.nextIndex = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    var n = this.source, i = n.length;
    if (t >= i)
      return i;
    var o = n.charCodeAt(t), a;
    return !(r || this.switchU) || o <= 55295 || o >= 57344 || t + 1 >= i || (a = n.charCodeAt(t + 1)) < 56320 || a > 57343 ? t + 1 : t + 2;
  }, "nextIndex");
  sn.prototype.current = /* @__PURE__ */ s(function(t) {
    return t === void 0 && (t = !1), this.at(this.pos, t);
  }, "current");
  sn.prototype.lookahead = /* @__PURE__ */ s(function(t) {
    return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
  }, "lookahead");
  sn.prototype.advance = /* @__PURE__ */ s(function(t) {
    t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
  }, "advance");
  sn.prototype.eat = /* @__PURE__ */ s(function(t, r) {
    return r === void 0 && (r = !1), this.current(r) === t ? (this.advance(r), !0) : !1;
  }, "eat");
  sn.prototype.eatChars = /* @__PURE__ */ s(function(t, r) {
    r === void 0 && (r = !1);
    for (var n = this.pos, i = 0, o = t; i < o.length; i += 1) {
      var a = o[i], u = this.at(n, r);
      if (u === -1 || u !== a)
        return !1;
      n = this.nextIndex(n, r);
    }
    return this.pos = n, !0;
  }, "eatChars");
  oe.validateRegExpFlags = function(e) {
    for (var t = e.validFlags, r = e.flags, n = !1, i = !1, o = 0; o < r.length; o++) {
      var a = r.charAt(o);
      t.indexOf(a) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(a, o + 1) > -1 && this.raise(e.start, "Duplic\
ate regular expression flag"), a === "u" && (n = !0), a === "v" && (i = !0);
    }
    this.options.ecmaVersion >= 15 && n && i && this.raise(e.start, "Invalid regular expression flag");
  };
  s($M, "hasProp");
  oe.validateRegExpPattern = function(e) {
    this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && $M(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
  };
  oe.regexp_pattern = function(e) {
    e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference =
    0, e.groupNames = /* @__PURE__ */ Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.
    pos !== e.source.length && (e.eat(
      41
      /* ) */
    ) && e.raise("Unmatched ')'"), (e.eat(
      93
      /* ] */
    ) || e.eat(
      125
      /* } */
    )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
    for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
      var n = r[t];
      e.groupNames[n] || e.raise("Invalid named capture referenced");
    }
  };
  oe.regexp_disjunction = function(e) {
    var t = this.options.ecmaVersion >= 16;
    for (t && (e.branchID = new Il(e.branchID, null)), this.regexp_alternative(e); e.eat(
      124
      /* | */
    ); )
      t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
    t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
      123
      /* { */
    ) && e.raise("Lone quantifier brackets");
  };
  oe.regexp_alternative = function(e) {
    for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
      ;
  };
  oe.regexp_eatTerm = function(e) {
    return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid qua\
ntifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
  };
  oe.regexp_eatAssertion = function(e) {
    var t = e.pos;
    if (e.lastAssertionIsQuantifiable = !1, e.eat(
      94
      /* ^ */
    ) || e.eat(
      36
      /* $ */
    ))
      return !0;
    if (e.eat(
      92
      /* \ */
    )) {
      if (e.eat(
        66
        /* B */
      ) || e.eat(
        98
        /* b */
      ))
        return !0;
      e.pos = t;
    }
    if (e.eat(
      40
      /* ( */
    ) && e.eat(
      63
      /* ? */
    )) {
      var r = !1;
      if (this.options.ecmaVersion >= 9 && (r = e.eat(
        60
        /* < */
      )), e.eat(
        61
        /* = */
      ) || e.eat(
        33
        /* ! */
      ))
        return this.regexp_disjunction(e), e.eat(
          41
          /* ) */
        ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, !0;
    }
    return e.pos = t, !1;
  };
  oe.regexp_eatQuantifier = function(e, t) {
    return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
      63
      /* ? */
    ), !0) : !1;
  };
  oe.regexp_eatQuantifierPrefix = function(e, t) {
    return e.eat(
      42
      /* * */
    ) || e.eat(
      43
      /* + */
    ) || e.eat(
      63
      /* ? */
    ) || this.regexp_eatBracedQuantifier(e, t);
  };
  oe.regexp_eatBracedQuantifier = function(e, t) {
    var r = e.pos;
    if (e.eat(
      123
      /* { */
    )) {
      var n = 0, i = -1;
      if (this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue, e.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue), e.eat(
        125
        /* } */
      )))
        return i !== -1 && i < n && !t && e.raise("numbers out of order in {} quantifier"), !0;
      e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
    }
    return !1;
  };
  oe.regexp_eatAtom = function(e) {
    return this.regexp_eatPatternCharacters(e) || e.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(
    e);
  };
  oe.regexp_eatReverseSolidusAtomEscape = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatAtomEscape(e))
        return !0;
      e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatUncapturingGroup = function(e) {
    var t = e.pos;
    if (e.eat(
      40
      /* ( */
    )) {
      if (e.eat(
        63
        /* ? */
      )) {
        if (this.options.ecmaVersion >= 16) {
          var r = this.regexp_eatModifiers(e), n = e.eat(
            45
            /* - */
          );
          if (r || n) {
            for (var i = 0; i < r.length; i++) {
              var o = r.charAt(i);
              r.indexOf(o, i + 1) > -1 && e.raise("Duplicate regular expression modifiers");
            }
            if (n) {
              var a = this.regexp_eatModifiers(e);
              !r && !a && e.current() === 58 && e.raise("Invalid regular expression modifiers");
              for (var u = 0; u < a.length; u++) {
                var l = a.charAt(u);
                (a.indexOf(l, u + 1) > -1 || r.indexOf(l) > -1) && e.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
        if (e.eat(
          58
          /* : */
        )) {
          if (this.regexp_disjunction(e), e.eat(
            41
            /* ) */
          ))
            return !0;
          e.raise("Unterminated group");
        }
      }
      e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatCapturingGroup = function(e) {
    if (e.eat(
      40
      /* ( */
    )) {
      if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(
      e), e.eat(
        41
        /* ) */
      ))
        return e.numCapturingParens += 1, !0;
      e.raise("Unterminated group");
    }
    return !1;
  };
  oe.regexp_eatModifiers = function(e) {
    for (var t = "", r = 0; (r = e.current()) !== -1 && VM(r); )
      t += kn(r), e.advance();
    return t;
  };
  s(VM, "isRegularExpressionModifier");
  oe.regexp_eatExtendedAtom = function(e) {
    return e.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(
    e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
  };
  oe.regexp_eatInvalidBracedQuantifier = function(e) {
    return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
  };
  oe.regexp_eatSyntaxCharacter = function(e) {
    var t = e.current();
    return aw(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  s(aw, "isSyntaxCharacter");
  oe.regexp_eatPatternCharacters = function(e) {
    for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !aw(r); )
      e.advance();
    return e.pos !== t;
  };
  oe.regexp_eatExtendedPatternCharacter = function(e) {
    var t = e.current();
    return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
  };
  oe.regexp_groupSpecifier = function(e) {
    if (e.eat(
      63
      /* ? */
    )) {
      this.regexp_eatGroupName(e) || e.raise("Invalid group");
      var t = this.options.ecmaVersion >= 16, r = e.groupNames[e.lastStringValue];
      if (r)
        if (t)
          for (var n = 0, i = r; n < i.length; n += 1) {
            var o = i[n];
            o.separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
          }
        else
          e.raise("Duplicate capture group name");
      t ? (r || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
    }
  };
  oe.regexp_eatGroupName = function(e) {
    if (e.lastStringValue = "", e.eat(
      60
      /* < */
    )) {
      if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
        62
        /* > */
      ))
        return !0;
      e.raise("Invalid capture group name");
    }
    return !1;
  };
  oe.regexp_eatRegExpIdentifierName = function(e) {
    if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
      for (e.lastStringValue += kn(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
        e.lastStringValue += kn(e.lastIntValue);
      return !0;
    }
    return !1;
  };
  oe.regexp_eatRegExpIdentifierStart = function(e) {
    var t = e.pos, r = this.options.ecmaVersion >= 11, n = e.current(r);
    return e.advance(r), n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (n = e.lastIntValue), UM(n) ? (e.lastIntValue = n, !0) :
    (e.pos = t, !1);
  };
  s(UM, "isRegExpIdentifierStart");
  oe.regexp_eatRegExpIdentifierPart = function(e) {
    var t = e.pos, r = this.options.ecmaVersion >= 11, n = e.current(r);
    return e.advance(r), n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (n = e.lastIntValue), WM(n) ? (e.lastIntValue = n, !0) :
    (e.pos = t, !1);
  };
  s(WM, "isRegExpIdentifierPart");
  oe.regexp_eatAtomEscape = function(e) {
    return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.
    regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
  };
  oe.regexp_eatBackReference = function(e) {
    var t = e.pos;
    if (this.regexp_eatDecimalEscape(e)) {
      var r = e.lastIntValue;
      if (e.switchU)
        return r > e.maxBackReference && (e.maxBackReference = r), !0;
      if (r <= e.numCapturingParens)
        return !0;
      e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatKGroupName = function(e) {
    if (e.eat(
      107
      /* k */
    )) {
      if (this.regexp_eatGroupName(e))
        return e.backReferenceNames.push(e.lastStringValue), !0;
      e.raise("Invalid named reference");
    }
    return !1;
  };
  oe.regexp_eatCharacterEscape = function(e) {
    return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(
    e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(
    e);
  };
  oe.regexp_eatCControlLetter = function(e) {
    var t = e.pos;
    if (e.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatControlLetter(e))
        return !0;
      e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatZero = function(e) {
    return e.current() === 48 && !Ll(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
  };
  oe.regexp_eatControlEscape = function(e) {
    var t = e.current();
    return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue =
    11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
  };
  oe.regexp_eatControlLetter = function(e) {
    var t = e.current();
    return uw(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
  };
  s(uw, "isControlLetter");
  oe.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
    t === void 0 && (t = !1);
    var r = e.pos, n = t || e.switchU;
    if (e.eat(
      117
      /* u */
    )) {
      if (this.regexp_eatFixedHexDigits(e, 4)) {
        var i = e.lastIntValue;
        if (n && i >= 55296 && i <= 56319) {
          var o = e.pos;
          if (e.eat(
            92
            /* \ */
          ) && e.eat(
            117
            /* u */
          ) && this.regexp_eatFixedHexDigits(e, 4)) {
            var a = e.lastIntValue;
            if (a >= 56320 && a <= 57343)
              return e.lastIntValue = (i - 55296) * 1024 + (a - 56320) + 65536, !0;
          }
          e.pos = o, e.lastIntValue = i;
        }
        return !0;
      }
      if (n && e.eat(
        123
        /* { */
      ) && this.regexp_eatHexDigits(e) && e.eat(
        125
        /* } */
      ) && zM(e.lastIntValue))
        return !0;
      n && e.raise("Invalid unicode escape"), e.pos = r;
    }
    return !1;
  };
  s(zM, "isValidUnicode");
  oe.regexp_eatIdentityEscape = function(e) {
    if (e.switchU)
      return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
        47
        /* / */
      ) ? (e.lastIntValue = 47, !0) : !1;
    var t = e.current();
    return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  oe.regexp_eatDecimalEscape = function(e) {
    e.lastIntValue = 0;
    var t = e.current();
    if (t >= 49 && t <= 57) {
      do
        e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
      while ((t = e.current()) >= 48 && t <= 57);
      return !0;
    }
    return !1;
  };
  lw = 0, Tn = 1, gr = 2;
  oe.regexp_eatCharacterClassEscape = function(e) {
    var t = e.current();
    if (HM(t))
      return e.lastIntValue = -1, e.advance(), Tn;
    var r = !1;
    if (e.switchU && this.options.ecmaVersion >= 9 && ((r = t === 80) || t === 112)) {
      e.lastIntValue = -1, e.advance();
      var n;
      if (e.eat(
        123
        /* { */
      ) && (n = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
        125
        /* } */
      ))
        return r && n === gr && e.raise("Invalid property name"), n;
      e.raise("Invalid property name");
    }
    return lw;
  };
  s(HM, "isCharacterClassEscape");
  oe.regexp_eatUnicodePropertyValueExpression = function(e) {
    var t = e.pos;
    if (this.regexp_eatUnicodePropertyName(e) && e.eat(
      61
      /* = */
    )) {
      var r = e.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(e)) {
        var n = e.lastStringValue;
        return this.regexp_validateUnicodePropertyNameAndValue(e, r, n), Tn;
      }
    }
    if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
      var i = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(e, i);
    }
    return lw;
  };
  oe.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
    Ms(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid p\
roperty value");
  };
  oe.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
    if (e.unicodeProperties.binary.test(t))
      return Tn;
    if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
      return gr;
    e.raise("Invalid property name");
  };
  oe.regexp_eatUnicodePropertyName = function(e) {
    var t = 0;
    for (e.lastStringValue = ""; cw(t = e.current()); )
      e.lastStringValue += kn(t), e.advance();
    return e.lastStringValue !== "";
  };
  s(cw, "isUnicodePropertyNameCharacter");
  oe.regexp_eatUnicodePropertyValue = function(e) {
    var t = 0;
    for (e.lastStringValue = ""; GM(t = e.current()); )
      e.lastStringValue += kn(t), e.advance();
    return e.lastStringValue !== "";
  };
  s(GM, "isUnicodePropertyValueCharacter");
  oe.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
    return this.regexp_eatUnicodePropertyValue(e);
  };
  oe.regexp_eatCharacterClass = function(e) {
    if (e.eat(
      91
      /* [ */
    )) {
      var t = e.eat(
        94
        /* ^ */
      ), r = this.regexp_classContents(e);
      return e.eat(
        93
        /* ] */
      ) || e.raise("Unterminated character class"), t && r === gr && e.raise("Negated character class may contain strings"), !0;
    }
    return !1;
  };
  oe.regexp_classContents = function(e) {
    return e.current() === 93 ? Tn : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Tn);
  };
  oe.regexp_nonEmptyClassRanges = function(e) {
    for (; this.regexp_eatClassAtom(e); ) {
      var t = e.lastIntValue;
      if (e.eat(
        45
        /* - */
      ) && this.regexp_eatClassAtom(e)) {
        var r = e.lastIntValue;
        e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of or\
der in character class");
      }
    }
  };
  oe.regexp_eatClassAtom = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatClassEscape(e))
        return !0;
      if (e.switchU) {
        var r = e.current();
        (r === 99 || fw(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
      }
      e.pos = t;
    }
    var n = e.current();
    return n !== 93 ? (e.lastIntValue = n, e.advance(), !0) : !1;
  };
  oe.regexp_eatClassEscape = function(e) {
    var t = e.pos;
    if (e.eat(
      98
      /* b */
    ))
      return e.lastIntValue = 8, !0;
    if (e.switchU && e.eat(
      45
      /* - */
    ))
      return e.lastIntValue = 45, !0;
    if (!e.switchU && e.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatClassControlLetter(e))
        return !0;
      e.pos = t;
    }
    return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
  };
  oe.regexp_classSetExpression = function(e) {
    var t = Tn, r;
    if (!this.regexp_eatClassSetRange(e)) if (r = this.regexp_eatClassSetOperand(e)) {
      r === gr && (t = gr);
      for (var n = e.pos; e.eatChars(
        [38, 38]
        /* && */
      ); ) {
        if (e.current() !== 38 && (r = this.regexp_eatClassSetOperand(e))) {
          r !== gr && (t = Tn);
          continue;
        }
        e.raise("Invalid character in character class");
      }
      if (n !== e.pos)
        return t;
      for (; e.eatChars(
        [45, 45]
        /* -- */
      ); )
        this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
      if (n !== e.pos)
        return t;
    } else
      e.raise("Invalid character in character class");
    for (; ; )
      if (!this.regexp_eatClassSetRange(e)) {
        if (r = this.regexp_eatClassSetOperand(e), !r)
          return t;
        r === gr && (t = gr);
      }
  };
  oe.regexp_eatClassSetRange = function(e) {
    var t = e.pos;
    if (this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      if (e.eat(
        45
        /* - */
      ) && this.regexp_eatClassSetCharacter(e)) {
        var n = e.lastIntValue;
        return r !== -1 && n !== -1 && r > n && e.raise("Range out of order in character class"), !0;
      }
      e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatClassSetOperand = function(e) {
    return this.regexp_eatClassSetCharacter(e) ? Tn : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
  };
  oe.regexp_eatNestedClass = function(e) {
    var t = e.pos;
    if (e.eat(
      91
      /* [ */
    )) {
      var r = e.eat(
        94
        /* ^ */
      ), n = this.regexp_classContents(e);
      if (e.eat(
        93
        /* ] */
      ))
        return r && n === gr && e.raise("Negated character class may contain strings"), n;
      e.pos = t;
    }
    if (e.eat(
      92
      /* \ */
    )) {
      var i = this.regexp_eatCharacterClassEscape(e);
      if (i)
        return i;
      e.pos = t;
    }
    return null;
  };
  oe.regexp_eatClassStringDisjunction = function(e) {
    var t = e.pos;
    if (e.eatChars(
      [92, 113]
      /* \q */
    )) {
      if (e.eat(
        123
        /* { */
      )) {
        var r = this.regexp_classStringDisjunctionContents(e);
        if (e.eat(
          125
          /* } */
        ))
          return r;
      } else
        e.raise("Invalid escape");
      e.pos = t;
    }
    return null;
  };
  oe.regexp_classStringDisjunctionContents = function(e) {
    for (var t = this.regexp_classString(e); e.eat(
      124
      /* | */
    ); )
      this.regexp_classString(e) === gr && (t = gr);
    return t;
  };
  oe.regexp_classString = function(e) {
    for (var t = 0; this.regexp_eatClassSetCharacter(e); )
      t++;
    return t === 1 ? Tn : gr;
  };
  oe.regexp_eatClassSetCharacter = function(e) {
    var t = e.pos;
    if (e.eat(
      92
      /* \ */
    ))
      return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
        98
        /* b */
      ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
    var r = e.current();
    return r < 0 || r === e.lookahead() && JM(r) || ZM(r) ? !1 : (e.advance(), e.lastIntValue = r, !0);
  };
  s(JM, "isClassSetReservedDoublePunctuatorCharacter");
  s(ZM, "isClassSetSyntaxCharacter");
  oe.regexp_eatClassSetReservedPunctuator = function(e) {
    var t = e.current();
    return XM(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
  };
  s(XM, "isClassSetReservedPunctuator");
  oe.regexp_eatClassControlLetter = function(e) {
    var t = e.current();
    return Ll(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
  };
  oe.regexp_eatHexEscapeSequence = function(e) {
    var t = e.pos;
    if (e.eat(
      120
      /* x */
    )) {
      if (this.regexp_eatFixedHexDigits(e, 2))
        return !0;
      e.switchU && e.raise("Invalid escape"), e.pos = t;
    }
    return !1;
  };
  oe.regexp_eatDecimalDigits = function(e) {
    var t = e.pos, r = 0;
    for (e.lastIntValue = 0; Ll(r = e.current()); )
      e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
    return e.pos !== t;
  };
  s(Ll, "isDecimalDigit");
  oe.regexp_eatHexDigits = function(e) {
    var t = e.pos, r = 0;
    for (e.lastIntValue = 0; pw(r = e.current()); )
      e.lastIntValue = 16 * e.lastIntValue + hw(r), e.advance();
    return e.pos !== t;
  };
  s(pw, "isHexDigit");
  s(hw, "hexToInt");
  oe.regexp_eatLegacyOctalEscapeSequence = function(e) {
    if (this.regexp_eatOctalDigit(e)) {
      var t = e.lastIntValue;
      if (this.regexp_eatOctalDigit(e)) {
        var r = e.lastIntValue;
        t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
      } else
        e.lastIntValue = t;
      return !0;
    }
    return !1;
  };
  oe.regexp_eatOctalDigit = function(e) {
    var t = e.current();
    return fw(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
  };
  s(fw, "isOctalDigit");
  oe.regexp_eatFixedHexDigits = function(e, t) {
    var r = e.pos;
    e.lastIntValue = 0;
    for (var n = 0; n < t; ++n) {
      var i = e.current();
      if (!pw(i))
        return e.pos = r, !1;
      e.lastIntValue = 16 * e.lastIntValue + hw(i), e.advance();
    }
    return !0;
  };
  ym = /* @__PURE__ */ s(function(t) {
    this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new Pl(t, t.startLoc,
    t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
  }, "Token"), Pe = gt.prototype;
  Pe.next = function(e) {
    !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.
    options.onToken && this.options.onToken(new ym(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.
    endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
  };
  Pe.getToken = function() {
    return this.next(), new ym(this);
  };
  typeof Symbol < "u" && (Pe[Symbol.iterator] = function() {
    var e = this;
    return {
      next: /* @__PURE__ */ s(function() {
        var t = e.getToken();
        return {
          done: t.type === S.eof,
          value: t
        };
      }, "next")
    };
  });
  Pe.nextToken = function() {
    var e = this.curContext();
    if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()),
    this.pos >= this.input.length)
      return this.finishToken(S.eof);
    if (e.override)
      return e.override(this);
    this.readToken(this.fullCharCodeAtPos());
  };
  Pe.readToken = function(e) {
    return _n(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
  };
  Pe.fullCharCodeAtPos = function() {
    var e = this.input.charCodeAt(this.pos);
    if (e <= 55295 || e >= 56320)
      return e;
    var t = this.input.charCodeAt(this.pos + 1);
    return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
  };
  Pe.skipBlockComment = function() {
    var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
    if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations)
      for (var n = void 0, i = t; (n = LC(this.input, i, this.pos)) > -1; )
        ++this.curLine, i = this.lineStart = n;
    this.options.onComment && this.options.onComment(
      !0,
      this.input.slice(t + 2, r),
      t,
      this.pos,
      e,
      this.curPosition()
    );
  };
  Pe.skipLineComment = function(e) {
    for (var t = this.pos, r = this.options.onComment && this.curPosition(), n = this.input.charCodeAt(this.pos += e); this.pos < this.input.
    length && !js(n); )
      n = this.input.charCodeAt(++this.pos);
    this.options.onComment && this.options.onComment(
      !1,
      this.input.slice(t + e, this.pos),
      t,
      this.pos,
      r,
      this.curPosition()
    );
  };
  Pe.skipSpace = function() {
    e: for (; this.pos < this.input.length; ) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && jC.test(String.fromCharCode(e)))
            ++this.pos;
          else
            break e;
      }
    }
  };
  Pe.finishToken = function(e, t) {
    this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
    var r = this.type;
    this.type = e, this.value = t, this.updateContext(r);
  };
  Pe.readToken_dot = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e >= 48 && e <= 57)
      return this.readNumber(!0);
    var t = this.input.charCodeAt(this.pos + 2);
    return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(S.ellipsis)) : (++this.pos, this.finishToken(
    S.dot));
  };
  Pe.readToken_slash = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(S.assign, 2) : this.finishOp(S.slash, 1);
  };
  Pe.readToken_mult_modulo_exp = function(e) {
    var t = this.input.charCodeAt(this.pos + 1), r = 1, n = e === 42 ? S.star : S.modulo;
    return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, n = S.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ?
    this.finishOp(S.assign, r + 1) : this.finishOp(n, r);
  };
  Pe.readToken_pipe_amp = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === e) {
      if (this.options.ecmaVersion >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(S.assign, 3);
      }
      return this.finishOp(e === 124 ? S.logicalOR : S.logicalAND, 2);
    }
    return t === 61 ? this.finishOp(S.assign, 2) : this.finishOp(e === 124 ? S.bitwiseOR : S.bitwiseAND, 1);
  };
  Pe.readToken_caret = function() {
    var e = this.input.charCodeAt(this.pos + 1);
    return e === 61 ? this.finishOp(S.assign, 2) : this.finishOp(S.bitwiseXOR, 1);
  };
  Pe.readToken_plus_min = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || yr.test(this.input.
    slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(S.incDec, 2) : t === 61 ?
    this.finishOp(S.assign, 2) : this.finishOp(S.plusMin, 1);
  };
  Pe.readToken_lt_gt = function(e) {
    var t = this.input.charCodeAt(this.pos + 1), r = 1;
    return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.
    finishOp(S.assign, r + 1) : this.finishOp(S.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) ===
    45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2),
    this.finishOp(S.relational, r));
  };
  Pe.readToken_eq_excl = function(e) {
    var t = this.input.charCodeAt(this.pos + 1);
    return t === 61 ? this.finishOp(S.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >=
    6 ? (this.pos += 2, this.finishToken(S.arrow)) : this.finishOp(e === 61 ? S.eq : S.prefix, 1);
  };
  Pe.readToken_question = function() {
    var e = this.options.ecmaVersion;
    if (e >= 11) {
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 46) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r < 48 || r > 57)
          return this.finishOp(S.questionDot, 2);
      }
      if (t === 63) {
        if (e >= 12) {
          var n = this.input.charCodeAt(this.pos + 2);
          if (n === 61)
            return this.finishOp(S.assign, 3);
        }
        return this.finishOp(S.coalesce, 2);
      }
    }
    return this.finishOp(S.question, 1);
  };
  Pe.readToken_numberSign = function() {
    var e = this.options.ecmaVersion, t = 35;
    if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), _n(t, !0) || t === 92))
      return this.finishToken(S.privateId, this.readWord1());
    this.raise(this.pos, "Unexpected character '" + kn(t) + "'");
  };
  Pe.getTokenFromCode = function(e) {
    switch (e) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        return this.readToken_dot();
      // Punctuation tokens.
      case 40:
        return ++this.pos, this.finishToken(S.parenL);
      case 41:
        return ++this.pos, this.finishToken(S.parenR);
      case 59:
        return ++this.pos, this.finishToken(S.semi);
      case 44:
        return ++this.pos, this.finishToken(S.comma);
      case 91:
        return ++this.pos, this.finishToken(S.bracketL);
      case 93:
        return ++this.pos, this.finishToken(S.bracketR);
      case 123:
        return ++this.pos, this.finishToken(S.braceL);
      case 125:
        return ++this.pos, this.finishToken(S.braceR);
      case 58:
        return ++this.pos, this.finishToken(S.colon);
      case 96:
        if (this.options.ecmaVersion < 6)
          break;
        return ++this.pos, this.finishToken(S.backQuote);
      case 48:
        var t = this.input.charCodeAt(this.pos + 1);
        if (t === 120 || t === 88)
          return this.readRadixNumber(16);
        if (this.options.ecmaVersion >= 6) {
          if (t === 111 || t === 79)
            return this.readRadixNumber(8);
          if (t === 98 || t === 66)
            return this.readRadixNumber(2);
        }
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(!1);
      // Quotes produce strings.
      case 34:
      case 39:
        return this.readString(e);
      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(e);
      case 124:
      case 38:
        return this.readToken_pipe_amp(e);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(e);
      case 60:
      case 62:
        return this.readToken_lt_gt(e);
      case 61:
      case 33:
        return this.readToken_eq_excl(e);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(S.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + kn(e) + "'");
  };
  Pe.finishOp = function(e, t) {
    var r = this.input.slice(this.pos, this.pos + t);
    return this.pos += t, this.finishToken(e, r);
  };
  Pe.readRegexp = function() {
    for (var e, t, r = this.pos; ; ) {
      this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
      var n = this.input.charAt(this.pos);
      if (yr.test(n) && this.raise(r, "Unterminated regular expression"), e)
        e = !1;
      else {
        if (n === "[")
          t = !0;
        else if (n === "]" && t)
          t = !1;
        else if (n === "/" && !t)
          break;
        e = n === "\\";
      }
      ++this.pos;
    }
    var i = this.input.slice(r, this.pos);
    ++this.pos;
    var o = this.pos, a = this.readWord1();
    this.containsEsc && this.unexpected(o);
    var u = this.regexpState || (this.regexpState = new sn(this));
    u.reset(r, i, a), this.validateRegExpFlags(u), this.validateRegExpPattern(u);
    var l = null;
    try {
      l = new RegExp(i, a);
    } catch {
    }
    return this.finishToken(S.regexp, { pattern: i, flags: a, value: l });
  };
  Pe.readInt = function(e, t, r) {
    for (var n = this.options.ecmaVersion >= 12 && t === void 0, i = r && this.input.charCodeAt(this.pos) === 48, o = this.pos, a = 0, u = 0,
    l = 0, c = t ?? 1 / 0; l < c; ++l, ++this.pos) {
      var p = this.input.charCodeAt(this.pos), h = void 0;
      if (n && p === 95) {
        i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), u === 95 && this.raiseRecoverable(
        this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not \
allowed at the first of digits"), u = p;
        continue;
      }
      if (p >= 97 ? h = p - 97 + 10 : p >= 65 ? h = p - 65 + 10 : p >= 48 && p <= 57 ? h = p - 48 : h = 1 / 0, h >= e)
        break;
      u = p, a = a * e + h;
    }
    return n && u === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === o ||
    t != null && this.pos - o !== t ? null : a;
  };
  s(KM, "stringToNumber");
  s(dw, "stringToBigInt");
  Pe.readRadixNumber = function(e) {
    var t = this.pos;
    this.pos += 2;
    var r = this.readInt(e);
    return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(
    this.pos) === 110 ? (r = dw(this.input.slice(t, this.pos)), ++this.pos) : _n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifi\
er directly after number"), this.finishToken(S.num, r);
  };
  Pe.readNumber = function(e) {
    var t = this.pos;
    !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
    var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
    r && this.strict && this.raise(t, "Invalid number");
    var n = this.input.charCodeAt(this.pos);
    if (!r && !e && this.options.ecmaVersion >= 11 && n === 110) {
      var i = dw(this.input.slice(t, this.pos));
      return ++this.pos, _n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(S.num, i);
    }
    r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1), n === 46 && !r && (++this.pos, this.readInt(10), n = this.input.charCodeAt(
    this.pos)), (n === 69 || n === 101) && !r && (n = this.input.charCodeAt(++this.pos), (n === 43 || n === 45) && ++this.pos, this.readInt(
    10) === null && this.raise(t, "Invalid number")), _n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    var o = KM(this.input.slice(t, this.pos), r);
    return this.finishToken(S.num, o);
  };
  Pe.readCodePoint = function() {
    var e = this.input.charCodeAt(this.pos), t;
    if (e === 123) {
      this.options.ecmaVersion < 6 && this.unexpected();
      var r = ++this.pos;
      t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point \
out of bounds");
    } else
      t = this.readHexChar(4);
    return t;
  };
  Pe.readString = function(e) {
    for (var t = "", r = ++this.pos; ; ) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
      var n = this.input.charCodeAt(this.pos);
      if (n === e)
        break;
      n === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(!1), r = this.pos) : n === 8232 || n === 8233 ? (this.options.
      ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.
      lineStart = this.pos)) : (js(n) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
    }
    return t += this.input.slice(r, this.pos++), this.finishToken(S.string, t);
  };
  mw = {};
  Pe.tryReadTemplateToken = function() {
    this.inTemplateElement = !0;
    try {
      this.readTmplToken();
    } catch (e) {
      if (e === mw)
        this.readInvalidTemplateToken();
      else
        throw e;
    }
    this.inTemplateElement = !1;
  };
  Pe.invalidStringToken = function(e, t) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9)
      throw mw;
    this.raise(e, t);
  };
  Pe.readTmplToken = function() {
    for (var e = "", t = this.pos; ; ) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
      var r = this.input.charCodeAt(this.pos);
      if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
        return this.pos === this.start && (this.type === S.template || this.type === S.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(
        S.dollarBraceL)) : (++this.pos, this.finishToken(S.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(S.template, e));
      if (r === 92)
        e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
      else if (js(r)) {
        switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          case 10:
            e += `
`;
            break;
          default:
            e += String.fromCharCode(r);
            break;
        }
        this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
      } else
        ++this.pos;
    }
  };
  Pe.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++)
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{")
            break;
        // fall through
        case "`":
          return this.finishToken(S.invalidTemplate, this.input.slice(this.start, this.pos));
        case "\r":
          this.input[this.pos + 1] === `
` && ++this.pos;
        // fall through
        case `
`:
        case "\u2028":
        case "\u2029":
          ++this.curLine, this.lineStart = this.pos + 1;
          break;
      }
    this.raise(this.start, "Unterminated template");
  };
  Pe.readEscapedChar = function(e) {
    var t = this.input.charCodeAt(++this.pos);
    switch (++this.pos, t) {
      case 110:
        return `
`;
      // 'n' -> '\n'
      case 114:
        return "\r";
      // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      // 'x'
      case 117:
        return kn(this.readCodePoint());
      // 'u'
      case 116:
        return "	";
      // 't' -> '\t'
      case 98:
        return "\b";
      // 'b' -> '\b'
      case 118:
        return "\v";
      // 'v' -> '\u000b'
      case 102:
        return "\f";
      // 'f' -> '\f'
      case 13:
        this.input.charCodeAt(this.pos) === 10 && ++this.pos;
      // '\r\n'
      case 10:
        return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
      case 56:
      case 57:
        if (this.strict && this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        ), e) {
          var r = this.pos - 1;
          this.invalidStringToken(
            r,
            "Invalid escape sequence in template string"
          );
        }
      default:
        if (t >= 48 && t <= 55) {
          var n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(n, 8);
          return i > 255 && (n = n.slice(0, -1), i = parseInt(n, 8)), this.pos += n.length - 1, t = this.input.charCodeAt(this.pos), (n !== "\
0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
            this.pos - 1 - n.length,
            e ? "Octal literal in template string" : "Octal literal in strict mode"
          ), String.fromCharCode(i);
        }
        return js(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
    }
  };
  Pe.readHexChar = function(e) {
    var t = this.pos, r = this.readInt(16, e);
    return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
  };
  Pe.readWord1 = function() {
    this.containsEsc = !1;
    for (var e = "", t = !0, r = this.pos, n = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
      var i = this.fullCharCodeAtPos();
      if (Ls(i, n))
        this.pos += i <= 65535 ? 1 : 2;
      else if (i === 92) {
        this.containsEsc = !0, e += this.input.slice(r, this.pos);
        var o = this.pos;
        this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.
        pos;
        var a = this.readCodePoint();
        (t ? _n : Ls)(a, n) || this.invalidStringToken(o, "Invalid Unicode escape"), e += kn(a), r = this.pos;
      } else
        break;
      t = !1;
    }
    return e + this.input.slice(r, this.pos);
  };
  Pe.readWord = function() {
    var e = this.readWord1(), t = S.name;
    return this.keywords.test(e) && (t = pm[e]), this.finishToken(t, e);
  };
  YM = "8.14.1";
  gt.acorn = {
    Parser: gt,
    version: YM,
    defaultOptions: um,
    Position: ha,
    SourceLocation: Pl,
    getLineInfo: qC,
    Node: Nl,
    TokenType: Re,
    tokTypes: S,
    keywordTypes: pm,
    TokContext: Lr,
    tokContexts: Qe,
    isIdentifierChar: Ls,
    isIdentifierStart: _n,
    Token: ym,
    isNewLine: js,
    lineBreak: yr,
    lineBreakG: vM,
    nonASCIIwhitespace: jC
  };
});

// ../node_modules/@storybook/docs-mdx/dist/mdx-N42X6CFJ.js
var uS = {};
Gn(uS, {
  compile: () => iS,
  compileSync: () => sS,
  createProcessor: () => Jm,
  evaluate: () => oz,
  evaluateSync: () => az,
  nodeTypes: () => nS,
  run: () => Zm,
  runSync: () => aS
});
function br(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? yw(e.position) : "start" in e || "end" in e ? yw(e) : "line" in e ||
  "column" in e ? Bm(e) : "";
}
function Bm(e) {
  return Dw(e && e.line) + ":" + Dw(e && e.column);
}
function yw(e) {
  return Bm(e && e.start) + "-" + Bm(e && e.end);
}
function Dw(e) {
  return e && typeof e == "number" ? e : 1;
}
function xw(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function xm(e, t) {
  if (e && e.includes(jr.default.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + jr.default.sep + "`"
    );
}
function bm(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function bw(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function rq(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
function b2(e, t) {
  let r = oq(e) ? e : new x2(e), { format: n, ...i } = t || {};
  return {
    file: r,
    options: {
      format: n === "md" || n === "mdx" ? n : r.extname && (i.mdExtensions || sq).includes(r.extname) ? "md" : "mdx",
      ...i
    }
  };
}
function oq(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function aq() {
  return {
    enter: {
      mdxFlowExpression: lq,
      mdxTextExpression: cq
    },
    exit: {
      mdxFlowExpression: vw,
      mdxFlowExpressionChunk: Ew,
      mdxTextExpression: vw,
      mdxTextExpressionChunk: Ew
    }
  };
}
function uq() {
  return {
    handlers: {
      mdxFlowExpression: Cw,
      mdxTextExpression: Cw
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" }
    ]
  };
}
function lq(e) {
  this.enter({ type: "mdxFlowExpression", value: "" }, e), this.buffer();
}
function cq(e) {
  this.enter({ type: "mdxTextExpression", value: "" }, e), this.buffer();
}
function vw(e) {
  let t = this.resume(), r = e.estree, n = this.stack[this.stack.length - 1];
  n.type === "mdxFlowExpression" || n.type, this.exit(e), n.value = t, r && (n.data = { estree: r });
}
function Ew(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function Cw(e) {
  return "{" + (e.value || "") + "}";
}
function ww(e, t) {
  let r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let n = 0, i = r.indexOf(t);
  for (; i !== -1; )
    n++, i = r.indexOf(t, i + t.length);
  return n;
}
function v2(e) {
  let t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function hq(e) {
  let t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
function fq(e) {
  let t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function Aw(e) {
  return fq(e) || v2(e);
}
function xa(e) {
  return dq.call(Fw, e) ? Fw[e] : !1;
}
function gq(e, t = {}) {
  let r = typeof t.additional == "string" ? t.additional.charCodeAt(0) : t.additional, n = [], i = 0, o = -1, a = "", u, l;
  t.position && ("start" in t.position || "indent" in t.position ? (l = t.position.indent, u = t.position.start) : u = t.position);
  let c = (u ? u.line : 0) || 1, p = (u ? u.column : 0) || 1, h = d(), f;
  for (i--; ++i <= e.length; )
    if (f === 10 && (p = (l ? l[o] : 0) || 1), f = e.charCodeAt(i), f === 38) {
      let b = e.charCodeAt(i + 1);
      if (b === 9 || b === 10 || b === 12 || b === 32 || b === 38 || b === 60 || Number.isNaN(b) || r && b === r) {
        a += Vs(f), p++;
        continue;
      }
      let y = i + 1, E = y, A = y, k;
      if (b === 35) {
        A = ++E;
        let U = e.charCodeAt(A);
        U === 88 || U === 120 ? (k = "hexadecimal", A = ++E) : k = "decimal";
      } else
        k = "named";
      let O = "", w = "", C = "", T = k === "named" ? Aw : k === "decimal" ? v2 : hq;
      for (A--; ++A <= e.length; ) {
        let U = e.charCodeAt(A);
        if (!T(U))
          break;
        C += Vs(U), k === "named" && pq.includes(C) && (O = C, w = xa(C));
      }
      let F = e.charCodeAt(A) === 59;
      if (F) {
        A++;
        let U = k === "named" ? xa(C) : !1;
        U && (O = C, w = U);
      }
      let $ = 1 + A - y, R = "";
      if (!(!F && t.nonTerminated === !1))
        if (!C)
          k !== "named" && m(4, $);
        else if (k === "named") {
          if (F && !w)
            m(5, 1);
          else if (O !== C && (A = E + O.length, $ = 1 + A - E, F = !1), !F) {
            let U = O ? 1 : 3;
            if (t.attribute) {
              let W = e.charCodeAt(A);
              W === 61 ? (m(U, $), w = "") : Aw(W) ? w = "" : m(U, $);
            } else
              m(U, $);
          }
          R = w;
        } else {
          F || m(2, $);
          let U = Number.parseInt(
            C,
            k === "hexadecimal" ? 16 : 10
          );
          if (yq(U))
            m(7, $), R = Vs(
              65533
              /* `` */
            );
          else if (U in Sw)
            m(6, $), R = Sw[U];
          else {
            let W = "";
            Dq(U) && m(6, $), U > 65535 && (U -= 65536, W += Vs(U >>> 10 | 55296), U = 56320 | U & 1023), R = W + Vs(U);
          }
        }
      if (R) {
        g(), h = d(), i = A - 1, p += A - y + 1, n.push(R);
        let U = d();
        U.offset++, t.reference && t.reference.call(
          t.referenceContext,
          R,
          { start: h, end: U },
          e.slice(y - 1, A)
        ), h = U;
      } else
        C = e.slice(y - 1, A), a += C, p += C.length, i = A - 1;
    } else
      f === 10 && (c++, o++, p = 0), Number.isNaN(f) ? g() : (a += Vs(f), p++);
  return n.join("");
  function d() {
    return {
      line: c,
      column: p,
      offset: i + ((u ? u.offset : 0) || 0)
    };
  }
  function m(b, y) {
    let E;
    t.warning && (E = d(), E.column += y, E.offset += y, t.warning.call(
      t.warningContext,
      mq[b],
      E,
      b
    ));
  }
  function g() {
    a && (n.push(a), t.text && t.text.call(t.textContext, a, {
      start: h,
      end: d()
    }), a = "");
  }
}
function yq(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function Dq(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e &
  65535) === 65534;
}
function xq(e, t) {
  if (e = e.replace(
    t.subset ? bq(t.subset) : /["&'<>`]/g,
    n
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, r).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    n
  );
  function r(i, o, a) {
    return t.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(o + 2),
      t
    );
  }
  function n(i, o, a) {
    return t.format(
      i.charCodeAt(0),
      a.charCodeAt(o + 1),
      t
    );
  }
}
function bq(e) {
  let t = [], r = -1;
  for (; ++r < e.length; )
    t.push(e[r].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
function vq(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Eq(e, t) {
  return xq(e, Object.assign({ format: vq }, t));
}
function Cq() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: r,
      mdxJsxFlowTagClosingMarker: n,
      mdxJsxFlowTagAttribute: p,
      mdxJsxFlowTagExpressionAttribute: h,
      mdxJsxFlowTagAttributeValueLiteral: e,
      mdxJsxFlowTagAttributeValueExpression: e,
      mdxJsxFlowTagSelfClosingMarker: o,
      mdxJsxTextTag: r,
      mdxJsxTextTagClosingMarker: n,
      mdxJsxTextTagAttribute: p,
      mdxJsxTextTagExpressionAttribute: h,
      mdxJsxTextTagAttributeValueLiteral: e,
      mdxJsxTextTagAttributeValueExpression: e,
      mdxJsxTextTagSelfClosingMarker: o
    },
    exit: {
      mdxJsxFlowTagClosingMarker: a,
      mdxJsxFlowTagNamePrimary: u,
      mdxJsxFlowTagNameMember: l,
      mdxJsxFlowTagNameLocal: c,
      mdxJsxFlowTagExpressionAttribute: f,
      mdxJsxFlowTagExpressionAttributeValue: t,
      mdxJsxFlowTagAttributeNamePrimary: d,
      mdxJsxFlowTagAttributeNameLocal: m,
      mdxJsxFlowTagAttributeValueLiteral: g,
      mdxJsxFlowTagAttributeValueLiteralValue: t,
      mdxJsxFlowTagAttributeValueExpression: b,
      mdxJsxFlowTagAttributeValueExpressionValue: t,
      mdxJsxFlowTagSelfClosingMarker: y,
      mdxJsxFlowTag: E,
      mdxJsxTextTagClosingMarker: a,
      mdxJsxTextTagNamePrimary: u,
      mdxJsxTextTagNameMember: l,
      mdxJsxTextTagNameLocal: c,
      mdxJsxTextTagExpressionAttribute: f,
      mdxJsxTextTagExpressionAttributeValue: t,
      mdxJsxTextTagAttributeNamePrimary: d,
      mdxJsxTextTagAttributeNameLocal: m,
      mdxJsxTextTagAttributeValueLiteral: g,
      mdxJsxTextTagAttributeValueLiteralValue: t,
      mdxJsxTextTagAttributeValueExpression: b,
      mdxJsxTextTagAttributeValueExpressionValue: t,
      mdxJsxTextTagSelfClosingMarker: y,
      mdxJsxTextTag: E
    }
  };
  function e() {
    this.buffer();
  }
  function t(w) {
    this.config.enter.data.call(this, w), this.config.exit.data.call(this, w);
  }
  function r(w) {
    let C = {
      name: void 0,
      attributes: [],
      close: !1,
      selfClosing: !1,
      start: w.start,
      end: w.end
    };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = C, this.buffer();
  }
  function n(w) {
    let C = this.data.mdxJsxTagStack;
    if (C.length === 0)
      throw new Ne(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: w.start, end: w.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function i(w) {
    let C = this.data.mdxJsxTag;
    if (C.close)
      throw new Ne(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: w.start, end: w.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function o(w) {
    let C = this.data.mdxJsxTag;
    if (C.close)
      throw new Ne(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: w.start, end: w.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function a() {
    let w = this.data.mdxJsxTag;
    w.close = !0;
  }
  function u(w) {
    let C = this.data.mdxJsxTag;
    C.name = this.sliceSerialize(w);
  }
  function l(w) {
    let C = this.data.mdxJsxTag;
    C.name += "." + this.sliceSerialize(w);
  }
  function c(w) {
    let C = this.data.mdxJsxTag;
    C.name += ":" + this.sliceSerialize(w);
  }
  function p(w) {
    let C = this.data.mdxJsxTag;
    i.call(this, w), C.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
  }
  function h(w) {
    let C = this.data.mdxJsxTag;
    i.call(this, w), C.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }), this.buffer();
  }
  function f(w) {
    let C = this.data.mdxJsxTag;
    let T = C.attributes[C.attributes.length - 1];
    T.type;
    let F = w.estree;
    T.value = this.resume(), F && (T.data = { estree: F });
  }
  function d(w) {
    let C = this.data.mdxJsxTag;
    let T = C.attributes[C.attributes.length - 1];
    T.type, T.name = this.sliceSerialize(w);
  }
  function m(w) {
    let C = this.data.mdxJsxTag;
    let T = C.attributes[C.attributes.length - 1];
    T.type, T.name += ":" + this.sliceSerialize(w);
  }
  function g() {
    let w = this.data.mdxJsxTag;
    w.attributes[w.attributes.length - 1].value = gq(
      this.resume(),
      { nonTerminated: !1 }
    );
  }
  function b(w) {
    let C = this.data.mdxJsxTag;
    let T = C.attributes[C.attributes.length - 1];
    T.type;
    let F = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, $ = w.estree;
    $ && (F.data = { estree: $ }), T.value = F;
  }
  function y() {
    let w = this.data.mdxJsxTag;
    w.selfClosing = !0;
  }
  function E(w) {
    let C = this.data.mdxJsxTag;
    let T = this.data.mdxJsxTagStack;
    let F = T[T.length - 1];
    if (C.close && F.name !== C.name)
      throw new Ne(
        "Unexpected closing tag `" + O(C) + "`, expected corresponding closing tag for `" + O(F) + "` (" + br(F) + ")",
        { start: w.start, end: w.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(), C.close ? T.pop() : this.enter(
      {
        type: w.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
        name: C.name || null,
        attributes: C.attributes,
        children: []
      },
      w,
      A
    ), C.selfClosing || C.close ? this.exit(w, k) : T.push(C);
  }
  function A(w, C) {
    let T = this.data.mdxJsxTag;
    let F = w ? " before the end of `" + w.type + "`" : "", $ = w ? { start: w.start, end: w.end } : void 0;
    throw new Ne(
      "Expected a closing tag for `" + O(T) + "` (" + br({ start: C.start, end: C.end }) + ")" + F,
      $,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function k(w, C) {
    let T = this.data.mdxJsxTag;
    throw new Ne(
      "Expected the closing tag `" + O(T) + "` either after the end of `" + C.type + "` (" + br(C.end) + ") or another opening tag after the\
 start of `" + C.type + "` (" + br(C.start) + ")",
      { start: w.start, end: w.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function O(w) {
    return "<" + (w.close ? "/" : "") + (w.name || "") + ">";
  }
}
function wq(e) {
  let t = e || {}, r = t.quote || '"', n = t.quoteSmart || !1, i = t.tightSelfClosing || !1, o = t.printWidth || Number.POSITIVE_INFINITY, a = r ===
  '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error(
      "Cannot serialize attribute values with `" + r + "` for `options.quote`, expected `\"`, or `'`"
    );
  return u.peek = Aq, {
    handlers: {
      mdxJsxFlowElement: u,
      mdxJsxTextElement: u
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: !0,
    // Always generate links with resources (never autolinks).
    resourceLink: !0
  };
  function u(l, c, p, h) {
    let f = l.type === "mdxJsxFlowElement", d = l.name ? !l.children || l.children.length === 0 : !1, m = C2(p), g = w2(m), b = p.createTracker(
    h), y = p.createTracker(h), E = [], A = (f ? g : "") + "<" + (l.name || ""), k = p.enter(l.type);
    if (b.move(A), y.move(A), l.attributes && l.attributes.length > 0) {
      if (!l.name)
        throw new Error("Cannot serialize fragment w/ attributes");
      let F = -1;
      for (; ++F < l.attributes.length; ) {
        let $ = l.attributes[F], R;
        if ($.type === "mdxJsxExpressionAttribute")
          R = "{" + ($.value || "") + "}";
        else {
          if (!$.name)
            throw new Error("Cannot serialize attribute w/o name");
          let U = $.value, W = $.name, Y = "";
          if (U != null)
            if (typeof U == "object")
              Y = "{" + (U.value || "") + "}";
            else {
              let j = n && ww(U, r) > ww(U, a) ? a : r;
              Y = j + Eq(U, { subset: [j] }) + j;
            }
          R = W + (Y ? "=" : "") + Y;
        }
        E.push(R);
      }
    }
    let O = !1, w = E.join(" ");
    // Block:
    f && // Including a line ending (expressions).
    (/\r?\n|\r/.test(w) || // Current position (including `<tag`).
    b.current().now.column + // -1 because columns, +1 for ` ` before attributes.
    // Attributes joined by spaces.
    w.length + // ` />`.
    (d ? i ? 2 : 3 : 1) > o) && (O = !0);
    let C = b, T = A;
    if (O) {
      C = y;
      let F = -1;
      for (; ++F < E.length; )
        E[F] = g + E2 + E[F];
      T += C.move(
        `
` + E.join(`
`) + `
` + g
      );
    } else w && (T += C.move(" " + w));
    return d && (T += C.move(
      (i || O ? "" : " ") + "/"
    )), T += C.move(">"), l.children && l.children.length > 0 && (l.type === "mdxJsxTextElement" ? T += C.move(
      // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
      // generates *hardcoded* types, which means that our dynamically added
      // directives are not present.
      // At some point, TS should fix that, and `from-markdown` should be fine.
      p.containerPhrasing(l, {
        ...C.current(),
        before: ">",
        after: "<"
      })
    ) : (C.shift(2), T += C.move(`
`), T += C.move(Sq(l, p, C.current())), T += C.move(`
`))), d || (T += C.move(
      (f ? g : "") + "</" + (l.name || "") + ">"
    )), k(), T;
  }
  s(u, "mdxElement");
}
function Sq(e, t, r) {
  let n = t.indexStack, i = e.children, o = t.createTracker(r), a = w2(C2(t)), u = [], l = -1;
  for (n.push(-1); ++l < i.length; ) {
    let c = i[l];
    n[n.length - 1] = l;
    let p = { before: `
`, after: `
`, ...o.current() }, h = t.handle(c, e, t, p), f = c.type === "mdxJsxFlowElement" ? h : t.indentLines(h, function(d, m, g) {
      return (g ? "" : a) + d;
    });
    u.push(o.move(f)), c.type !== "list" && (t.bulletLastUsed = void 0), l < i.length - 1 && u.push(o.move(`

`));
  }
  return n.pop(), u.join("");
}
function C2(e) {
  let t = 0;
  for (let r of e.stack)
    r === "mdxJsxFlowElement" && t++;
  return t;
}
function w2(e) {
  return E2.repeat(e);
}
function Aq() {
  return "<";
}
function Fq() {
  return {
    enter: { mdxjsEsm: kq },
    exit: { mdxjsEsm: Tq, mdxjsEsmData: Iq }
  };
}
function _q() {
  return { handlers: { mdxjsEsm: Pq } };
}
function kq(e) {
  this.enter({ type: "mdxjsEsm", value: "" }, e), this.buffer();
}
function Tq(e) {
  let t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, this.exit(e);
  let n = e.estree;
  r.value = t, n && (r.data = { estree: n });
}
function Iq(e) {
  this.config.enter.data.call(this, e), this.config.exit.data.call(this, e);
}
function Pq(e) {
  return e.value || "";
}
function Bq() {
  return [
    aq(),
    Cq(),
    Fq()
  ];
}
function Oq(e) {
  return {
    extensions: [
      uq(),
      wq(e),
      _q()
    ]
  };
}
function Om(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function le(e) {
  return e !== null && e < -2;
}
function ht(e) {
  return e !== null && (e < 0 || e === 32);
}
function Oe(e) {
  return e === -2 || e === -1 || e === 32;
}
function Mq(e) {
  return S2(e) || Nq(e);
}
function ui(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function qq(e) {
  return "\x1B[33m" + e + "\x1B[39m";
}
function Wq(e, t) {
  let r, n;
  typeof t == "function" ? r = t : t && typeof t == "object" && (t.enter && (r = t.enter), t.leave && (n = t.leave)), i(e, void 0, void 0, [])();
  function i(o, a, u, l) {
    return Em(o) && (c.displayName = "node (" + qq(o.type) + ")"), c;
    function c() {
      let p = r ? _w(r(o, a, u, l)) : [];
      if (p[0] === vm)
        return p;
      if (p[0] !== Uq) {
        let h;
        for (h in o)
          if ($q.call(o, h) && o[h] && typeof o[h] == "object" && // @ts-expect-error: custom esast extension.
          h !== "data" && // @ts-expect-error: custom esast extension.
          h !== "position") {
            let f = l.concat(o), d = o[h];
            if (Array.isArray(d)) {
              let m = (
                /** @type {Array<unknown>} */
                d
              ), g = 0;
              for (; g > -1 && g < m.length; ) {
                let b = m[g];
                if (Em(b)) {
                  let y = i(
                    b,
                    h,
                    g,
                    f
                  )();
                  if (y[0] === vm)
                    return y;
                  g = typeof y[1] == "number" ? y[1] : g + 1;
                } else
                  g++;
              }
            } else if (Em(d)) {
              let m = i(d, h, void 0, f)();
              if (m[0] === vm)
                return m;
            }
          }
      }
      return n ? _w(n(o, a, u, l)) : p;
    }
    s(c, "visit3");
  }
  s(i, "build");
}
function _w(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Vq, e] : [e];
}
function Em(e) {
  return !!(e && typeof e == "object" && "type" in e && typeof e.type == "string" && e.type.length > 0);
}
function A2(e, t) {
  let r = t.prefix || "", n = t.suffix || "", i = Object.assign({}, t.acornOptions), o = [], a = [], u = i.onComment, l = i.onToken, c = !1,
  p, h, f = Object.assign({}, i, {
    onComment: o,
    preserveParens: !0
  });
  l && (f.onToken = a);
  let d = zq(e, t.tokenTypes), m = d.value, g = r + m + n, b = t.expression && kw(m);
  if (b && !t.allowEmpty)
    throw new Ne("Unexpected empty expression", {
      place: E(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  try {
    p = t.expression && !b ? t.acorn.parseExpressionAt(g, 0, f) : t.acorn.parse(g, f);
  } catch (A) {
    let k = (
      /** @type {AcornError} */
      A
    ), O = E(k.pos);
    k.message = String(k.message).replace(/ \(\d+:\d+\)$/, ""), k.pos = O.offset, k.loc = {
      line: O.line,
      column: O.column - 1
    }, h = k, c = k.raisedAt >= r.length + m.length || // Broken comments are raised at their start, not their end.
    k.message === "Unterminated comment";
  }
  if (p && t.expression && !b)
    if (kw(g.slice(p.end, g.length - n.length)))
      p = {
        type: "Program",
        start: 0,
        end: r.length + m.length,
        // @ts-expect-error: Its good.
        body: [{
          type: "ExpressionStatement",
          expression: p,
          start: 0,
          end: r.length + m.length
        }],
        sourceType: "module",
        comments: []
      };
    else {
      let A = E(p.end), k = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      k.pos = A.offset, k.loc = {
        line: A.line,
        column: A.column - 1
      }, h = k, p = void 0;
    }
  if (p) {
    if (p.comments = o, Wq(p, function(A, k, O, w) {
      let C = (
        /** @type {AcornNode | Array<AcornNode>} */
        w[w.length - 1]
      ), T = k;
      A.type === "ParenthesizedExpression" && C && T && (typeof O == "number" && (C = C[T], T = O), C[T] = A.expression), y(A);
    }), Array.isArray(u))
      u.push(...o);
    else if (typeof u == "function")
      for (let A of o)
        u(A.type === "Block", A.value, A.start, A.end, A.loc.start, A.loc.end);
    for (let A of a)
      A.end <= r.length || A.start - r.length >= m.length || (y(A), Array.isArray(l) ? l.push(A) : l(A));
  }
  return {
    estree: p,
    error: h,
    swallow: c
  };
  function y(A) {
    let k = E(A.start), O = E(A.end);
    A.start = k.offset, A.end = O.offset, A.loc = {
      start: {
        line: k.line,
        column: k.column - 1,
        offset: k.offset
      },
      end: {
        line: O.line,
        column: O.column - 1,
        offset: O.offset
      }
    }, A.range = [A.start, A.end];
  }
  function E(A) {
    let k = A - r.length;
    k < 0 ? k = 0 : k > m.length && (k = m.length);
    let O = Hq(d.stops, k);
    return O || (O = {
      line: t.start.line,
      column: t.start.column,
      offset: t.start.offset
    }), O;
  }
}
function kw(e) {
  return /^\s*$/.test(e.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function zq(e, t) {
  let r = {
    value: "",
    stops: []
  }, n = -1;
  for (; ++n < e.length; ) {
    let i = e[n];
    if (i[0] === "enter") {
      let o = i[1].type;
      if (o === "lineEnding" || t.includes(o)) {
        let a = i[2].sliceStream(i[1]);
        for (; a.length > 0 && a[0] === -1; )
          a.shift();
        let u = Gq(a);
        r.stops.push([r.value.length, i[1].start]), r.value += u, r.stops.push([r.value.length, i[1].end]);
      }
    }
  }
  return r;
}
function Hq(e, t) {
  let r = 0;
  for (; r < e.length && e[r][0] <= t; )
    r += 1;
  if (r === 0)
    return;
  let [n, i] = e[r - 1], o = t - n;
  return {
    line: i.line,
    column: i.column + o,
    offset: i.offset + o
  };
}
function Gq(e) {
  let t = -1, r = [], n;
  for (; ++t < e.length; ) {
    let i = e[t], o;
    if (typeof i == "string")
      o = i;
    else
      switch (i) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = "	";
          break;
        }
        case -1: {
          if (n)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(i);
      }
    n = i === -2, r.push(o);
  }
  return r.join("");
}
function Bn(e) {
  let t = e || {}, r = t.loc || {}, n = t.range || [void 0, void 0], i = Tw(r.start, n[0] || t.start), o = Tw(r.end, n[1] || t.end);
  if (i && o)
    return { start: i, end: o };
}
function Tw(e, t) {
  if (e && typeof e == "object") {
    let r = "line" in e ? Cm(e.line) : void 0, n = "column" in e ? Cm(e.column) : void 0;
    if (r && n !== void 0)
      return {
        line: r,
        column: n + 1,
        offset: Cm(t)
      };
  }
}
function Cm(e) {
  return typeof e == "number" && e > -1 ? e : void 0;
}
function Wl(e, t, r, n, i, o, a, u, l, c, p) {
  let h = this, f = this.events.length + 3, d = 0, m, g;
  return b;
  function b(k) {
    return e.enter(r), e.enter(n), e.consume(k), e.exit(n), m = h.now(), y;
  }
  function y(k) {
    if (k === null) {
      if (g)
        throw g;
      let O = new Ne(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        {
          place: h.now(),
          ruleId: "unexpected-eof",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw O.url = Js + Jq, O;
    }
    if (le(k))
      return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), A;
    if (k === 125 && d === 0) {
      let O = o ? Yq.call(
        h,
        o,
        a,
        i,
        f,
        m,
        c || !1,
        l || !1
      ) : {
        type: "ok",
        estree: void 0
      };
      if (O.type === "ok") {
        e.enter(n), e.consume(k), e.exit(n);
        let w = e.exit(r);
        return u && O.estree && Object.assign(w, {
          estree: O.estree
        }), t;
      }
      return g = O.message, e.enter(i), e.consume(k), E;
    }
    return e.enter(i), E(k);
  }
  function E(k) {
    return k === 125 && d === 0 || k === null || le(k) ? (e.exit(i), y(k)) : (k === 123 && !o ? d += 1 : k === 125 && (d -= 1), e.consume(k),
    E);
  }
  function A(k) {
    let O = h.now();
    if (O.line !== m.line && !p && h.parser.lazy[O.line]) {
      let w = new Ne(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a \
list, etc",
        {
          place: h.now(),
          ruleId: "unexpected-lazy",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw w.url = Js + Zq, w;
    }
    return y(k);
  }
}
function Yq(e, t, r, n, i, o, a) {
  let u = A2(this.events.slice(n), {
    acorn: e,
    tokenTypes: [r],
    acornOptions: t,
    start: i,
    expression: !0,
    allowEmpty: o,
    prefix: a ? "({" : "",
    suffix: a ? "})" : ""
  }), l = u.estree;
  if (a && l) {
    let c = l.body[0];
    if (c.type !== "ExpressionStatement" || c.expression.type !== "ObjectExpression") {
      let p = Bn(c), h = new Ne(
        "Unexpected `" + c.type + "` in code: expected an object spread (`{...spread}`)",
        {
          place: p.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw h.url = Js + Iw, h;
    }
    if (c.expression.properties[1]) {
      let p = Bn(c.expression.properties[1]), h = new Ne(
        "Unexpected extra content in spread: only a single spread is supported",
        {
          place: p.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw h.url = Js + Xq, h;
    }
    if (c.expression.properties[0] && c.expression.properties[0].type !== "SpreadElement") {
      let p = Bn(c.expression.properties[0]), h = new Ne(
        "Unexpected `" + c.expression.properties[0].type + "` in code: only spread elements are supported",
        {
          place: p.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw h.url = Js + Iw, h;
    }
  }
  if (u.error) {
    let c = new Ne("Could not parse expression with acorn", {
      cause: u.error,
      place: {
        line: u.error.loc.line,
        column: u.error.loc.column + 1,
        offset: u.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    return c.url = Js + Kq, {
      type: "nok",
      message: c
    };
  }
  return {
    type: "ok",
    estree: l
  };
}
function qe(e, t, r, n) {
  let i = n ? n - 1 : Number.POSITIVE_INFINITY, o = 0;
  return a;
  function a(l) {
    return Oe(l) ? (e.enter(r), u(l)) : t(l);
  }
  function u(l) {
    return Oe(l) && o++ < i ? (e.consume(l), u) : (e.exit(r), t(l));
  }
}
function Qq(e) {
  let t = e || {}, r = t.addResult, n = t.acorn, i = t.spread, o = t.allowEmpty, a;
  if (o == null && (o = !0), n) {
    if (!n.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    a = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions);
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      123: {
        name: "mdxFlowExpression",
        tokenize: u,
        concrete: !0
      }
    },
    text: {
      123: {
        name: "mdxTextExpression",
        tokenize: l
      }
    }
  };
  function u(c, p, h) {
    let f = this;
    return d;
    function d(y) {
      return m(y);
    }
    function m(y) {
      return Wl.call(f, c, g, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", n, a, r, i, o)(y);
    }
    function g(y) {
      return Oe(y) ? qe(c, b, "whitespace")(y) : b(y);
    }
    function b(y) {
      let E = f.parser.constructs.flow[60], k = (Array.isArray(E) ? E : (
        /* c8 ignore next 3 -- always a list when normalized. */
        E ? [E] : []
      )).find(function(O) {
        return O.name === "mdxJsxFlowTag";
      });
      return y === 60 && k ? c.attempt(k, b, h)(y) : y === null || le(y) ? p(y) : h(y);
    }
  }
  function l(c, p) {
    let h = this;
    return f;
    function f(d) {
      return Wl.call(h, c, p, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", n, a, r, i, o, !0)(d);
    }
  }
}
function F2(e, t, r, n, i, o, a, u, l, c, p, h, f, d, m, g, b, y, E, A, k, O, w, C, T, F, $, R, U, W, Y, j) {
  let N = this, z, Q;
  return ie;
  function ie(v) {
    return e.enter(u), e.enter(l), e.consume(v), e.exit(l), B;
  }
  function B(v) {
    return ht(v) ? r(v) : (z = ce, x(v));
  }
  function ce(v) {
    if (v === 47)
      return e.enter(c), e.consume(v), e.exit(c), z = Je, x;
    if (v === 62)
      return Ye(v);
    if (v !== null && v >= 0 && hr(v))
      return e.enter(h), e.enter(f), e.consume(v), L;
    P(v, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (v === 33 ? " (note: to create a comment in MDX\
, use `{/* text */}`)" : ""));
  }
  function Je(v) {
    if (v === 62)
      return Ye(v);
    if (v !== null && v >= 0 && hr(v))
      return e.enter(h), e.enter(f), e.consume(v), L;
    P(v, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (v === 42 || v === 47 ? " (note: JS comments in\
 JSX tags are not supported in MDX)" : ""));
  }
  function L(v) {
    if (v !== null && v >= 0 && Ns(v, {
      jsx: !0
    }))
      return e.consume(v), L;
    if (v === 46 || v === 47 || v === 58 || v === 62 || v === 123 || ht(v) || Pn(v))
      return e.exit(f), z = Ue, x(v);
    P(v, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (v === 64 ?
    " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function Ue(v) {
    if (v === 46)
      return e.enter(d), e.consume(v), e.exit(d), z = $e, x;
    if (v === 58)
      return e.enter(g), e.consume(v), e.exit(g), z = Me, x;
    if (v === 47 || v === 62 || v === 123 || v !== null && v >= 0 && hr(v))
      return e.exit(h), K(v);
    P(v, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the en\
d of the tag");
  }
  function $e(v) {
    if (v !== null && v >= 0 && hr(v))
      return e.enter(m), e.consume(v), me;
    P(v, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; o\
r the end of the tag");
  }
  function me(v) {
    if (v !== null && v >= 0 && Ns(v, {
      jsx: !0
    }))
      return e.consume(v), me;
    if (v === 46 || v === 47 || v === 62 || v === 123 || ht(v) || Pn(v))
      return e.exit(m), z = It, x(v);
    P(v, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (v ===
    64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function It(v) {
    if (v === 46)
      return e.enter(d), e.consume(v), e.exit(d), z = $e, x;
    if (v === 47 || v === 62 || v === 123 || v !== null && v >= 0 && hr(v))
      return e.exit(h), K(v);
    P(v, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or\
 the end of the tag");
  }
  function Me(v) {
    if (v !== null && v >= 0 && hr(v))
      return e.enter(b), e.consume(v), re;
    P(v, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (v === 43 || v !== null && v > 46 && v < 58 ?
    " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function re(v) {
    if (v !== null && v >= 0 && Ns(v, {
      jsx: !0
    }))
      return e.consume(v), re;
    if (v === 47 || v === 62 || v === 123 || ht(v) || Pn(v))
      return e.exit(b), z = xe, x(v);
    P(v, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function xe(v) {
    if (v === 47 || v === 62 || v === 123 || v !== null && v >= 0 && hr(v))
      return e.exit(h), K(v);
    P(v, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or \
the end of the tag");
  }
  function K(v) {
    if (v === 47)
      return e.enter(p), e.consume(v), e.exit(p), z = pe, x;
    if (v === 62)
      return Ye(v);
    if (v === 123)
      return Wl.call(N, e, se, y, E, A, n, i, o, !0, !1, a)(v);
    if (v !== null && v >= 0 && hr(v))
      return e.enter(k), e.enter(O), e.enter(w), e.consume(v), ge;
    P(v, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes\
; or the end of the tag");
  }
  function se(v) {
    return z = K, x(v);
  }
  function ge(v) {
    if (v !== null && v >= 0 && Ns(v, {
      jsx: !0
    }))
      return e.consume(v), ge;
    if (v === 47 || v === 58 || v === 61 || v === 62 || v === 123 || ht(v) || Pn(v))
      return e.exit(w), z = be, x(v);
    P(v, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace befor\
e attributes; or the end of the tag");
  }
  function be(v) {
    if (v === 58)
      return e.enter(C), e.consume(v), e.exit(C), z = Ee, x;
    if (v === 61)
      return e.exit(O), e.enter(F), e.consume(v), e.exit(F), z = We, x;
    if (v === 47 || v === 62 || v === 123 || ht(v) || Pn(v) || v !== null && v >= 0 && hr(v))
      return e.exit(O), e.exit(k), z = K, x(v);
    P(v, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or\
 the end of the tag");
  }
  function Ee(v) {
    if (v !== null && v >= 0 && hr(v))
      return e.enter(T), e.consume(v), rt;
    P(v, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a va\
lue; or the end of the tag");
  }
  function rt(v) {
    if (v !== null && v >= 0 && Ns(v, {
      jsx: !0
    }))
      return e.consume(v), rt;
    if (v === 47 || v === 61 || v === 62 || v === 123 || ht(v) || Pn(v))
      return e.exit(T), e.exit(O), z = Ct, x(v);
    P(v, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace\
 before attributes; or the end of the tag");
  }
  function Ct(v) {
    if (v === 61)
      return e.enter(F), e.consume(v), e.exit(F), z = We, x;
    if (v === 47 || v === 62 || v === 123 || v !== null && v >= 0 && hr(v))
      return e.exit(k), K(v);
    P(v, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a val\
ue; or the end of the tag");
  }
  function We(v) {
    if (v === 34 || v === 39)
      return e.enter($), e.enter(R), e.consume(v), e.exit(R), Q = v, or;
    if (v === 123)
      return Wl.call(N, e, sr, W, Y, j, n, i, o, !1, !1, a)(v);
    P(v, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (v === 60 ? " (note: to use \
an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
  }
  function sr(v) {
    return e.exit(k), z = K, x(v);
  }
  function or(v) {
    return v === null && P(v, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(Q) + "`"), v === Q ? (e.enter(R),
    e.consume(v), e.exit(R), e.exit($), e.exit(k), Q = void 0, z = K, x) : le(v) ? (z = or, x(v)) : (e.enter(U), kr(v));
  }
  function kr(v) {
    return v === null || v === Q || le(v) ? (e.exit(U), or(v)) : (e.consume(v), kr);
  }
  function pe(v) {
    if (v === 62)
      return Ye(v);
    P(v, "after self-closing slash", "`>` to end the tag" + (v === 42 || v === 47 ? " (note: JS comments in JSX tags are not supported in MD\
X)" : ""));
  }
  function Ye(v) {
    return e.enter(l), e.consume(v), e.exit(l), e.exit(u), t;
  }
  function x(v) {
    return le(v) ? (e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), _) : Oe(v) || Pn(v) ? (e.enter("esWhitespace"), D(v)) : z(v);
  }
  function D(v) {
    return le(v) ? (e.exit("esWhitespace"), x(v)) : Oe(v) || Pn(v) ? (e.consume(v), D) : (e.exit("esWhitespace"), z(v));
  }
  function _(v) {
    if (!a && N.parser.lazy[N.now().line]) {
      let M = new Ne("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a l\
ist, etc", N.now(), "micromark-extension-mdx-jsx:unexpected-lazy");
      throw M.url = Pw + "#unexpected-lazy-line-in-container-expected-line-to-be", M;
    }
    return x(v);
  }
  function P(v, M, H) {
    let G = new Ne("Unexpected " + (v === null ? "end of file" : "character `" + (v === 96 ? "` ` `" : String.fromCodePoint(v)) + "` (" + e$(
    v) + ")") + " " + M + ", expected " + H, N.now(), "micromark-extension-mdx-jsx:unexpected-" + (v === null ? "eof" : "character"));
    throw G.url = Pw + (v === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), G;
  }
}
function e$(e) {
  return "U+" + e.toString(16).toUpperCase().padStart(4, "0");
}
function t$(e, t) {
  return {
    name: "mdxJsxTextTag",
    tokenize: r
  };
  function r(n, i, o) {
    return F2.call(this, n, i, o, e, t.acornOptions, t.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "\
mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember",
    "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker",
    "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "m\
dxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttribut\
eValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpressio\
n", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
  }
}
function r$(e, t) {
  return {
    name: "mdxJsxFlowTag",
    tokenize: r,
    concrete: !0
  };
  function r(n, i, o) {
    let a = this;
    return u;
    function u(h) {
      return l(h);
    }
    function l(h) {
      return F2.call(a, n, c, o, e, t.acornOptions, t.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "\
mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember",
      "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker",
      "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "\
mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttribu\
teValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpressi\
on", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(h);
    }
    function c(h) {
      return Oe(h) ? qe(n, p, "whitespace")(h) : p(h);
    }
    function p(h) {
      let f = a.parser.constructs.flow[123], m = (Array.isArray(f) ? f : f ? [f] : []).find((g) => g.name === "mdxFlowExpression");
      return h === 60 ? (
        // We cant just say: fine. Lines of blocks have to be parsed until an eol/eof.
        u(h)
      ) : h === 123 && m ? n.attempt(m, p, o)(h) : h === null || le(h) ? i(h) : o(h);
    }
  }
}
function n$(e) {
  let t = e || {}, r = t.acorn, n;
  if (r) {
    if (!r.parse || !r.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    n = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, t.acornOptions, {
      locations: !0
    });
  } else if (t.acornOptions || t.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      60: r$(r || void 0, {
        acornOptions: n,
        addResult: t.addResult || void 0
      })
    },
    text: {
      60: t$(r || void 0, {
        acornOptions: n,
        addResult: t.addResult || void 0
      })
    }
  };
}
function i$() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}
function on(e, t, r, n) {
  let i = e.length, o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, n.length < 1e4)
    a = Array.from(n), a.unshift(t, r), e.splice(...a);
  else
    for (r && e.splice(t, r); o < n.length; )
      a = n.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function xr(e, t) {
  return e.length > 0 ? (on(e, e.length, 0, t), e) : t;
}
function Bw(e) {
  if (e === null || ht(e) || Pn(e))
    return 1;
  if (Mq(e))
    return 2;
}
function qm(e, t, r) {
  let n = [], i = -1;
  for (; ++i < e.length; ) {
    let o = e[i].resolveAll;
    o && !n.includes(o) && (t = o(t, r), n.push(o));
  }
  return t;
}
function s$(e, t) {
  let r = -1, n, i, o, a, u, l, c, p;
  for (; ++r < e.length; )
    if (e[r][0] === "enter" && e[r][1].type === "attentionSequence" && e[r][1]._close) {
      for (n = r; n--; )
        if (e[n][0] === "exit" && e[n][1].type === "attentionSequence" && e[n][1]._open && // If the markers are the same:
        t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)) {
          if ((e[n][1]._close || e[r][1]._open) && (e[r][1].end.offset - e[r][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.
          offset + e[r][1].end.offset - e[r][1].start.offset) % 3))
            continue;
          l = e[n][1].end.offset - e[n][1].start.offset > 1 && e[r][1].end.offset - e[r][1].start.offset > 1 ? 2 : 1;
          let h = Object.assign({}, e[n][1].end), f = Object.assign({}, e[r][1].start);
          Ow(h, -l), Ow(f, l), a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: Object.assign({}, e[n][1].end)
          }, u = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[r][1].start),
            end: f
          }, o = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[n][1].end),
            end: Object.assign({}, e[r][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, u.end)
          }, e[n][1].end = Object.assign({}, a.start), e[r][1].start = Object.assign({}, u.end), c = [], e[n][1].end.offset - e[n][1].start.
          offset && (c = xr(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])), c = xr(c, [
            ["enter", i, t],
            ["enter", a, t],
            ["exit", a, t],
            ["enter", o, t]
          ]), c = xr(
            c,
            qm(
              t.parser.constructs.insideSpan.null,
              e.slice(n + 1, r),
              t
            )
          ), c = xr(c, [
            ["exit", o, t],
            ["enter", u, t],
            ["exit", u, t],
            ["exit", i, t]
          ]), e[r][1].end.offset - e[r][1].start.offset ? (p = 2, c = xr(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])) : p = 0, on(e, n - 1, r - n + 3, c), r = n + c.length - p - 2;
          break;
        }
    }
  for (r = -1; ++r < e.length; )
    e[r][1].type === "attentionSequence" && (e[r][1].type = "data");
  return e;
}
function o$(e, t) {
  let r = this.parser.constructs.attentionMarkers.null, n = this.previous, i = Bw(n), o;
  return a;
  function a(l) {
    return o = l, e.enter("attentionSequence"), u(l);
  }
  function u(l) {
    if (l === o)
      return e.consume(l), u;
    let c = e.exit("attentionSequence"), p = Bw(l), h = !p || p === 2 && i || r.includes(l), f = !i || i === 2 && p || r.includes(n);
    return c._open = !!(o === 42 ? h : h && (i || !f)), c._close = !!(o === 42 ? f : f && (p || !h)), t(l);
  }
}
function Ow(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
function u$(e, t, r) {
  let n = 0;
  return i;
  function i(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(d) {
    return qr(d) ? (e.consume(d), a) : c(d);
  }
  function a(d) {
    return d === 43 || d === 45 || d === 46 || er(d) ? (n = 1, u(d)) : c(d);
  }
  function u(d) {
    return d === 58 ? (e.consume(d), n = 0, l) : (d === 43 || d === 45 || d === 46 || er(d)) && n++ < 32 ? (e.consume(d), u) : (n = 0, c(d));
  }
  function l(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) :
    d === null || d === 32 || d === 60 || Om(d) ? r(d) : (e.consume(d), l);
  }
  function c(d) {
    return d === 64 ? (e.consume(d), p) : Lq(d) ? (e.consume(d), c) : r(d);
  }
  function p(d) {
    return er(d) ? h(d) : r(d);
  }
  function h(d) {
    return d === 46 ? (e.consume(d), n = 0, p) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.
    consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : f(d);
  }
  function f(d) {
    if ((d === 45 || er(d)) && n++ < 63) {
      let m = d === 45 ? f : h;
      return e.consume(d), m;
    }
    return r(d);
  }
}
function l$(e, t, r) {
  return n;
  function n(o) {
    return Oe(o) ? qe(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || le(o) ? t(o) : r(o);
  }
}
function c$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    if (a === 62) {
      let u = n.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return r(a);
  }
  function o(a) {
    return Oe(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) :
    (e.exit("blockQuotePrefix"), t(a));
  }
}
function p$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return Oe(a) ? qe(
      e,
      o,
      "linePrefix",
      n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a) : o(a);
  }
  function o(a) {
    return e.attempt(_2, t, r)(a);
  }
}
function h$(e) {
  e.exit("blockQuote");
}
function f$(e, t, r) {
  return n;
  function n(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return S2(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : r(o);
  }
}
function d$(e, t, r) {
  let n = this, i = 0, o, a;
  return u;
  function u(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), l;
  }
  function l(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("c\
haracterReferenceValue"), o = 31, a = er, p(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecima\
l"), e.enter("characterReferenceValue"), o = 6, a = jq, p) : (e.enter("characterReferenceValue"), o = 7, a = Rm, p(h));
  }
  function p(h) {
    if (h === 59 && i) {
      let f = e.exit("characterReferenceValue");
      return a === er && !xa(n.sliceSerialize(f)) ? r(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMar\
ker"), e.exit("characterReference"), t);
    }
    return a(h) && i++ < o ? (e.consume(h), p) : r(h);
  }
}
function m$(e, t, r) {
  let n = this, i = {
    tokenize: O,
    partial: !0
  }, o = 0, a = 0, u;
  return l;
  function l(w) {
    return c(w);
  }
  function c(w) {
    let C = n.events[n.events.length - 1];
    return o = C && C[1].type === "linePrefix" ? C[2].sliceSerialize(C[1], !0).length : 0, u = w, e.enter("codeFenced"), e.enter("codeFenced\
Fence"), e.enter("codeFencedFenceSequence"), p(w);
  }
  function p(w) {
    return w === u ? (a++, e.consume(w), p) : a < 3 ? r(w) : (e.exit("codeFencedFenceSequence"), Oe(w) ? qe(e, h, "whitespace")(w) : h(w));
  }
  function h(w) {
    return w === null || le(w) ? (e.exit("codeFencedFence"), n.interrupt ? t(w) : e.check(Rw, g, k)(w)) : (e.enter("codeFencedFenceInfo"), e.
    enter("chunkString", {
      contentType: "string"
    }), f(w));
  }
  function f(w) {
    return w === null || le(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(w)) : Oe(w) ? (e.exit("chunkString"), e.exit("code\
FencedFenceInfo"), qe(e, d, "whitespace")(w)) : w === 96 && w === u ? r(w) : (e.consume(w), f);
  }
  function d(w) {
    return w === null || le(w) ? h(w) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), m(w));
  }
  function m(w) {
    return w === null || le(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(w)) : w === 96 && w === u ? r(w) : (e.consume(w), m);
  }
  function g(w) {
    return e.attempt(i, k, b)(w);
  }
  function b(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), y;
  }
  function y(w) {
    return o > 0 && Oe(w) ? qe(
      e,
      E,
      "linePrefix",
      o + 1
    )(w) : E(w);
  }
  function E(w) {
    return w === null || le(w) ? e.check(Rw, g, k)(w) : (e.enter("codeFlowValue"), A(w));
  }
  function A(w) {
    return w === null || le(w) ? (e.exit("codeFlowValue"), E(w)) : (e.consume(w), A);
  }
  function k(w) {
    return e.exit("codeFenced"), t(w);
  }
  function O(w, C, T) {
    let F = 0;
    return $;
    function $(j) {
      return w.enter("lineEnding"), w.consume(j), w.exit("lineEnding"), R;
    }
    function R(j) {
      return w.enter("codeFencedFence"), Oe(j) ? qe(
        w,
        U,
        "linePrefix",
        n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(j) : U(j);
    }
    function U(j) {
      return j === u ? (w.enter("codeFencedFenceSequence"), W(j)) : T(j);
    }
    function W(j) {
      return j === u ? (F++, w.consume(j), W) : F >= a ? (w.exit("codeFencedFenceSequence"), Oe(j) ? qe(w, Y, "whitespace")(j) : Y(j)) : T(j);
    }
    function Y(j) {
      return j === null || le(j) ? (w.exit("codeFencedFence"), C(j)) : T(j);
    }
  }
}
function g$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return a === null ? r(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
function D$(e, t, r) {
  let n = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), qe(e, o, "linePrefix", 5)(c);
  }
  function o(c) {
    let p = n.events[n.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? a(c) : r(c);
  }
  function a(c) {
    return c === null ? l(c) : le(c) ? e.attempt(y$, a, l)(c) : (e.enter("codeFlowValue"), u(c));
  }
  function u(c) {
    return c === null || le(c) ? (e.exit("codeFlowValue"), a(c)) : (e.consume(c), u);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function x$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return n.parser.lazy[n.now().line] ? r(a) : le(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : qe(e, o, "linePrefi\
x", 5)(a);
  }
  function o(a) {
    let u = n.events[n.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(a) : le(a) ? i(a) : r(a);
  }
}
function v$(e) {
  let t = e.length - 4, r = 3, n, i;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (n = r; ++n < t; )
      if (e[n][1].type === "codeTextData") {
        e[r][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (n = r - 1, t++; ++n <= t; )
    i === void 0 ? n !== t && e[n][1].type !== "lineEnding" && (i = n) : (n === t || e[n][1].type === "lineEnding") && (e[i][1].type = "code\
TextData", n !== i + 2 && (e[i][1].end = e[n - 1][1].end, e.splice(i + 2, n - i - 2), t -= n - i - 2, n = i + 2), i = void 0);
  return e;
}
function E$(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function C$(e, t, r) {
  let n = this, i = 0, o, a;
  return u;
  function u(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), l(f);
  }
  function l(f) {
    return f === 96 ? (e.consume(f), i++, l) : (e.exit("codeTextSequence"), c(f));
  }
  function c(f) {
    return f === null ? r(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), c) : f === 96 ? (a = e.enter("codeTextSequence"),
    o = 0, h(f)) : le(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), c) : (e.enter("codeTextData"), p(f));
  }
  function p(f) {
    return f === null || f === 32 || f === 96 || le(f) ? (e.exit("codeTextData"), c(f)) : (e.consume(f), p);
  }
  function h(f) {
    return f === 96 ? (e.consume(f), o++, h) : o === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", p(
    f));
  }
}
function I2(e) {
  let t = {}, r = -1, n, i, o, a, u, l, c;
  for (; ++r < e.length; ) {
    for (; r in t; )
      r = t[r];
    if (n = e[r], r && n[1].type === "chunkFlow" && e[r - 1][1].type === "listItemPrefix" && (l = n[1]._tokenizer.events, o = 0, o < l.length &&
    l[o][1].type === "lineEndingBlank" && (o += 2), o < l.length && l[o][1].type === "content"))
      for (; ++o < l.length && l[o][1].type !== "content"; )
        l[o][1].type === "chunkText" && (l[o][1]._isInFirstContentOfListItem = !0, o++);
    if (n[0] === "enter")
      n[1].contentType && (Object.assign(t, w$(e, r)), r = t[r], c = !0);
    else if (n[1]._container) {
      for (o = r, i = void 0; o-- && (a = e[o], a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (e[i][1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (n[1].end = Object.assign({}, e[i][1].start), u = e.slice(i, r), u.unshift(n), on(e, i, r - i + 1, u));
    }
  }
  return !c;
}
function w$(e, t) {
  let r = e[t][1], n = e[t][2], i = t - 1, o = [], a = r._tokenizer || n.parser[r.contentType](r.start), u = a.events, l = [], c = {}, p, h,
  f = -1, d = r, m = 0, g = 0, b = [g];
  for (; d; ) {
    for (; e[++i][1] !== d; )
      ;
    o.push(i), d._tokenizer || (p = n.sliceStream(d), d.next || p.push(null), h && a.defineSkip(d.start), d._isInFirstContentOfListItem && (a.
    _gfmTasklistFirstContentOfListItem = !0), a.write(p), d._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)),
    h = d, d = d.next;
  }
  for (d = r; ++f < u.length; )
    // Find a void token that includes a break.
    u[f][0] === "exit" && u[f - 1][0] === "enter" && u[f][1].type === u[f - 1][1].type && u[f][1].start.line !== u[f][1].end.line && (g = f +
    1, b.push(g), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (a.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : b.pop(), f = b.length; f--; ) {
    let y = u.slice(b[f], b[f + 1]), E = o.pop();
    l.unshift([E, E + y.length - 1]), on(e, E, 2, y);
  }
  for (f = -1; ++f < l.length; )
    c[m + l[f][0]] = m + l[f][1], m += l[f][1] - l[f][0] - 1;
  return c;
}
function F$(e) {
  return I2(e), e;
}
function _$(e, t) {
  let r;
  return n;
  function n(u) {
    return e.enter("content"), r = e.enter("chunkContent", {
      contentType: "content"
    }), i(u);
  }
  function i(u) {
    return u === null ? o(u) : le(u) ? e.check(
      A$,
      a,
      o
    )(u) : (e.consume(u), i);
  }
  function o(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function a(u) {
    return e.consume(u), e.exit("chunkContent"), r.next = e.enter("chunkContent", {
      contentType: "content",
      previous: r
    }), r = r.next, i;
  }
}
function k$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), qe(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || le(a))
      return r(a);
    let u = n.events[n.events.length - 1];
    return !n.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >=
    4 ? t(a) : e.interrupt(n.parser.constructs.flow, r, t)(a);
  }
}
function P2(e, t, r, n, i, o, a, u, l) {
  let c = l || Number.POSITIVE_INFINITY, p = 0;
  return h;
  function h(y) {
    return y === 60 ? (e.enter(n), e.enter(i), e.enter(o), e.consume(y), e.exit(o), f) : y === null || y === 32 || y === 41 || Om(y) ? r(y) :
    (e.enter(n), e.enter(a), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), g(y));
  }
  function f(y) {
    return y === 62 ? (e.enter(o), e.consume(y), e.exit(o), e.exit(i), e.exit(n), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), d(y));
  }
  function d(y) {
    return y === 62 ? (e.exit("chunkString"), e.exit(u), f(y)) : y === null || y === 60 || le(y) ? r(y) : (e.consume(y), y === 92 ? m : d);
  }
  function m(y) {
    return y === 60 || y === 62 || y === 92 ? (e.consume(y), d) : d(y);
  }
  function g(y) {
    return !p && (y === null || y === 41 || ht(y)) ? (e.exit("chunkString"), e.exit(u), e.exit(a), e.exit(n), t(y)) : p < c && y === 40 ? (e.
    consume(y), p++, g) : y === 41 ? (e.consume(y), p--, g) : y === null || y === 32 || y === 40 || Om(y) ? r(y) : (e.consume(y), y === 92 ?
    b : g);
  }
  function b(y) {
    return y === 40 || y === 41 || y === 92 ? (e.consume(y), g) : g(y);
  }
}
function B2(e, t, r, n, i, o) {
  let a = this, u = 0, l;
  return c;
  function c(d) {
    return e.enter(n), e.enter(i), e.consume(d), e.exit(i), e.enter(o), p;
  }
  function p(d) {
    return u > 999 || d === null || d === 91 || d === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !u && "_hiddenFootnoteSupport" in a.parser.constructs ? r(d) : d === 93 ? (e.exit(o), e.enter(i), e.consume(d), e.exit(i), e.
    exit(n), t) : le(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), p) : (e.enter("chunkString", {
      contentType: "string"
    }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || le(d) || u++ > 999 ? (e.exit("chunkString"), p(d)) : (e.consume(d), l || (l = !Oe(d)), d ===
    92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), u++, h) : h(d);
  }
}
function O2(e, t, r, n, i, o) {
  let a;
  return u;
  function u(f) {
    return f === 34 || f === 39 || f === 40 ? (e.enter(n), e.enter(i), e.consume(f), e.exit(i), a = f === 40 ? 41 : f, l) : r(f);
  }
  function l(f) {
    return f === a ? (e.enter(i), e.consume(f), e.exit(i), e.exit(n), t) : (e.enter(o), c(f));
  }
  function c(f) {
    return f === a ? (e.exit(o), l(a)) : f === null ? r(f) : le(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), qe(e, c, "l\
inePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), p(f));
  }
  function p(f) {
    return f === a || f === null || le(f) ? (e.exit("chunkString"), c(f)) : (e.consume(f), f === 92 ? h : p);
  }
  function h(f) {
    return f === a || f === 92 ? (e.consume(f), p) : p(f);
  }
}
function ya(e, t) {
  let r;
  return n;
  function n(i) {
    return le(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), r = !0, n) : Oe(i) ? qe(
      e,
      n,
      r ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
function Zs(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
function P$(e, t, r) {
  let n = this, i;
  return o;
  function o(d) {
    return e.enter("definition"), a(d);
  }
  function a(d) {
    return B2.call(
      n,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function u(d) {
    return i = Zs(
      n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)
    ), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), l) : r(d);
  }
  function l(d) {
    return ht(d) ? ya(e, c)(d) : c(d);
  }
  function c(d) {
    return P2(
      e,
      p,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function p(d) {
    return e.attempt(I$, h, h)(d);
  }
  function h(d) {
    return Oe(d) ? qe(e, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || le(d) ? (e.exit("definition"), n.parser.defined.push(i), t(d)) : r(d);
  }
}
function B$(e, t, r) {
  return n;
  function n(u) {
    return ht(u) ? ya(e, i)(u) : r(u);
  }
  function i(u) {
    return O2(
      e,
      o,
      r,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(u);
  }
  function o(u) {
    return Oe(u) ? qe(e, a, "whitespace")(u) : a(u);
  }
  function a(u) {
    return u === null || le(u) ? t(u) : r(u);
  }
}
function R$(e, t, r) {
  return n;
  function n(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return le(o) ? (e.exit("hardBreakEscape"), t(o)) : r(o);
  }
}
function L$(e, t) {
  let r = e.length - 2, n = 3, i, o;
  return e[n][1].type === "whitespace" && (n += 2), r - 2 > n && e[r][1].type === "whitespace" && (r -= 2), e[r][1].type === "atxHeadingSequ\
ence" && (n === r - 1 || r - 4 > n && e[r - 2][1].type === "whitespace") && (r -= n + 1 === r ? 2 : 4), r > n && (i = {
    type: "atxHeadingText",
    start: e[n][1].start,
    end: e[r][1].end
  }, o = {
    type: "chunkText",
    start: e[n][1].start,
    end: e[r][1].end,
    contentType: "text"
  }, on(e, n, r - n + 1, [
    ["enter", i, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", i, t]
  ])), e;
}
function j$(e, t, r) {
  let n = 0;
  return i;
  function i(p) {
    return e.enter("atxHeading"), o(p);
  }
  function o(p) {
    return e.enter("atxHeadingSequence"), a(p);
  }
  function a(p) {
    return p === 35 && n++ < 6 ? (e.consume(p), a) : p === null || ht(p) ? (e.exit("atxHeadingSequence"), u(p)) : r(p);
  }
  function u(p) {
    return p === 35 ? (e.enter("atxHeadingSequence"), l(p)) : p === null || le(p) ? (e.exit("atxHeading"), t(p)) : Oe(p) ? qe(e, u, "whitesp\
ace")(p) : (e.enter("atxHeadingText"), c(p));
  }
  function l(p) {
    return p === 35 ? (e.consume(p), l) : (e.exit("atxHeadingSequence"), u(p));
  }
  function c(p) {
    return p === null || p === 35 || ht(p) ? (e.exit("atxHeadingText"), u(p)) : (e.consume(p), c);
  }
}
function U$(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t -
  2, 2)), e;
}
function W$(e, t, r) {
  let n = this, i, o, a, u, l;
  return c;
  function c(L) {
    return p(L);
  }
  function p(L) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(L), h;
  }
  function h(L) {
    return L === 33 ? (e.consume(L), f) : L === 47 ? (e.consume(L), o = !0, g) : L === 63 ? (e.consume(L), i = 3, n.interrupt ? t : B) : qr(
    L) ? (e.consume(L), a = String.fromCharCode(L), b) : r(L);
  }
  function f(L) {
    return L === 45 ? (e.consume(L), i = 2, d) : L === 91 ? (e.consume(L), i = 5, u = 0, m) : qr(L) ? (e.consume(L), i = 4, n.interrupt ? t :
    B) : r(L);
  }
  function d(L) {
    return L === 45 ? (e.consume(L), n.interrupt ? t : B) : r(L);
  }
  function m(L) {
    let Ue = "CDATA[";
    return L === Ue.charCodeAt(u++) ? (e.consume(L), u === Ue.length ? n.interrupt ? t : U : m) : r(L);
  }
  function g(L) {
    return qr(L) ? (e.consume(L), a = String.fromCharCode(L), b) : r(L);
  }
  function b(L) {
    if (L === null || L === 47 || L === 62 || ht(L)) {
      let Ue = L === 47, $e = a.toLowerCase();
      return !Ue && !o && Lw.includes($e) ? (i = 1, n.interrupt ? t(L) : U(L)) : M$.includes(a.toLowerCase()) ? (i = 6, Ue ? (e.consume(L), y) :
      n.interrupt ? t(L) : U(L)) : (i = 7, n.interrupt && !n.parser.lazy[n.now().line] ? r(L) : o ? E(L) : A(L));
    }
    return L === 45 || er(L) ? (e.consume(L), a += String.fromCharCode(L), b) : r(L);
  }
  function y(L) {
    return L === 62 ? (e.consume(L), n.interrupt ? t : U) : r(L);
  }
  function E(L) {
    return Oe(L) ? (e.consume(L), E) : $(L);
  }
  function A(L) {
    return L === 47 ? (e.consume(L), $) : L === 58 || L === 95 || qr(L) ? (e.consume(L), k) : Oe(L) ? (e.consume(L), A) : $(L);
  }
  function k(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || er(L) ? (e.consume(L), k) : O(L);
  }
  function O(L) {
    return L === 61 ? (e.consume(L), w) : Oe(L) ? (e.consume(L), O) : A(L);
  }
  function w(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? r(L) : L === 34 || L === 39 ? (e.consume(L), l = L, C) : Oe(L) ? (e.
    consume(L), w) : T(L);
  }
  function C(L) {
    return L === l ? (e.consume(L), l = null, F) : L === null || le(L) ? r(L) : (e.consume(L), C);
  }
  function T(L) {
    return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || ht(L) ? O(L) : (e.consume(L), T);
  }
  function F(L) {
    return L === 47 || L === 62 || Oe(L) ? A(L) : r(L);
  }
  function $(L) {
    return L === 62 ? (e.consume(L), R) : r(L);
  }
  function R(L) {
    return L === null || le(L) ? U(L) : Oe(L) ? (e.consume(L), R) : r(L);
  }
  function U(L) {
    return L === 45 && i === 2 ? (e.consume(L), N) : L === 60 && i === 1 ? (e.consume(L), z) : L === 62 && i === 4 ? (e.consume(L), ce) : L ===
    63 && i === 3 ? (e.consume(L), B) : L === 93 && i === 5 ? (e.consume(L), ie) : le(L) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.
    check(
      $$,
      Je,
      W
    )(L)) : L === null || le(L) ? (e.exit("htmlFlowData"), W(L)) : (e.consume(L), U);
  }
  function W(L) {
    return e.check(
      V$,
      Y,
      Je
    )(L);
  }
  function Y(L) {
    return e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), j;
  }
  function j(L) {
    return L === null || le(L) ? W(L) : (e.enter("htmlFlowData"), U(L));
  }
  function N(L) {
    return L === 45 ? (e.consume(L), B) : U(L);
  }
  function z(L) {
    return L === 47 ? (e.consume(L), a = "", Q) : U(L);
  }
  function Q(L) {
    if (L === 62) {
      let Ue = a.toLowerCase();
      return Lw.includes(Ue) ? (e.consume(L), ce) : U(L);
    }
    return qr(L) && a.length < 8 ? (e.consume(L), a += String.fromCharCode(L), Q) : U(L);
  }
  function ie(L) {
    return L === 93 ? (e.consume(L), B) : U(L);
  }
  function B(L) {
    return L === 62 ? (e.consume(L), ce) : L === 45 && i === 2 ? (e.consume(L), B) : U(L);
  }
  function ce(L) {
    return L === null || le(L) ? (e.exit("htmlFlowData"), Je(L)) : (e.consume(L), ce);
  }
  function Je(L) {
    return e.exit("htmlFlow"), t(L);
  }
}
function z$(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return le(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : r(a);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
function H$(e, t, r) {
  return n;
  function n(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(va, t, r);
  }
}
function J$(e, t, r) {
  let n = this, i, o, a;
  return u;
  function u(B) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(B), l;
  }
  function l(B) {
    return B === 33 ? (e.consume(B), c) : B === 47 ? (e.consume(B), O) : B === 63 ? (e.consume(B), A) : qr(B) ? (e.consume(B), T) : r(B);
  }
  function c(B) {
    return B === 45 ? (e.consume(B), p) : B === 91 ? (e.consume(B), o = 0, m) : qr(B) ? (e.consume(B), E) : r(B);
  }
  function p(B) {
    return B === 45 ? (e.consume(B), d) : r(B);
  }
  function h(B) {
    return B === null ? r(B) : B === 45 ? (e.consume(B), f) : le(B) ? (a = h, z(B)) : (e.consume(B), h);
  }
  function f(B) {
    return B === 45 ? (e.consume(B), d) : h(B);
  }
  function d(B) {
    return B === 62 ? N(B) : B === 45 ? f(B) : h(B);
  }
  function m(B) {
    let ce = "CDATA[";
    return B === ce.charCodeAt(o++) ? (e.consume(B), o === ce.length ? g : m) : r(B);
  }
  function g(B) {
    return B === null ? r(B) : B === 93 ? (e.consume(B), b) : le(B) ? (a = g, z(B)) : (e.consume(B), g);
  }
  function b(B) {
    return B === 93 ? (e.consume(B), y) : g(B);
  }
  function y(B) {
    return B === 62 ? N(B) : B === 93 ? (e.consume(B), y) : g(B);
  }
  function E(B) {
    return B === null || B === 62 ? N(B) : le(B) ? (a = E, z(B)) : (e.consume(B), E);
  }
  function A(B) {
    return B === null ? r(B) : B === 63 ? (e.consume(B), k) : le(B) ? (a = A, z(B)) : (e.consume(B), A);
  }
  function k(B) {
    return B === 62 ? N(B) : A(B);
  }
  function O(B) {
    return qr(B) ? (e.consume(B), w) : r(B);
  }
  function w(B) {
    return B === 45 || er(B) ? (e.consume(B), w) : C(B);
  }
  function C(B) {
    return le(B) ? (a = C, z(B)) : Oe(B) ? (e.consume(B), C) : N(B);
  }
  function T(B) {
    return B === 45 || er(B) ? (e.consume(B), T) : B === 47 || B === 62 || ht(B) ? F(B) : r(B);
  }
  function F(B) {
    return B === 47 ? (e.consume(B), N) : B === 58 || B === 95 || qr(B) ? (e.consume(B), $) : le(B) ? (a = F, z(B)) : Oe(B) ? (e.consume(B),
    F) : N(B);
  }
  function $(B) {
    return B === 45 || B === 46 || B === 58 || B === 95 || er(B) ? (e.consume(B), $) : R(B);
  }
  function R(B) {
    return B === 61 ? (e.consume(B), U) : le(B) ? (a = R, z(B)) : Oe(B) ? (e.consume(B), R) : F(B);
  }
  function U(B) {
    return B === null || B === 60 || B === 61 || B === 62 || B === 96 ? r(B) : B === 34 || B === 39 ? (e.consume(B), i = B, W) : le(B) ? (a =
    U, z(B)) : Oe(B) ? (e.consume(B), U) : (e.consume(B), Y);
  }
  function W(B) {
    return B === i ? (e.consume(B), i = void 0, j) : B === null ? r(B) : le(B) ? (a = W, z(B)) : (e.consume(B), W);
  }
  function Y(B) {
    return B === null || B === 34 || B === 39 || B === 60 || B === 61 || B === 96 ? r(B) : B === 47 || B === 62 || ht(B) ? F(B) : (e.consume(
    B), Y);
  }
  function j(B) {
    return B === 47 || B === 62 || ht(B) ? F(B) : r(B);
  }
  function N(B) {
    return B === 62 ? (e.consume(B), e.exit("htmlTextData"), e.exit("htmlText"), t) : r(B);
  }
  function z(B) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), Q;
  }
  function Q(B) {
    return Oe(B) ? qe(
      e,
      ie,
      "linePrefix",
      n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(B) : ie(B);
  }
  function ie(B) {
    return e.enter("htmlTextData"), a(B);
  }
}
function Y$(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    let r = e[t][1];
    (r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") && (e.splice(t + 1, r.type === "labelImage" ? 4 : 2), r.type =
    "data", t++);
  }
  return e;
}
function Q$(e, t) {
  let r = e.length, n = 0, i, o, a, u;
  for (; r--; )
    if (i = e[r][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[r][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[r][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = r, i.type !== "labelLink")) {
        n = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = r);
  let l = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, p = {
    type: "labelText",
    start: Object.assign({}, e[o + n + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return u = [
    ["enter", l, t],
    ["enter", c, t]
  ], u = xr(u, e.slice(o + 1, o + n + 3)), u = xr(u, [["enter", p, t]]), u = xr(
    u,
    qm(
      t.parser.constructs.insideSpan.null,
      e.slice(o + n + 4, a - 3),
      t
    )
  ), u = xr(u, [
    ["exit", p, t],
    e[a - 2],
    e[a - 1],
    ["exit", c, t]
  ]), u = xr(u, e.slice(a + 1)), u = xr(u, [["exit", l, t]]), on(e, o, e.length, u), e;
}
function eV(e, t, r) {
  let n = this, i = n.events.length, o, a;
  for (; i--; )
    if ((n.events[i][1].type === "labelImage" || n.events[i][1].type === "labelLink") && !n.events[i][1]._balanced) {
      o = n.events[i][1];
      break;
    }
  return u;
  function u(f) {
    return o ? o._inactive ? h(f) : (a = n.parser.defined.includes(
      Zs(
        n.sliceSerialize({
          start: o.end,
          end: n.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(f), e.exit("labelMarker"), e.exit("labelEnd"), l) : r(f);
  }
  function l(f) {
    return f === 40 ? e.attempt(
      Z$,
      p,
      a ? p : h
    )(f) : f === 91 ? e.attempt(
      X$,
      p,
      a ? c : h
    )(f) : a ? p(f) : h(f);
  }
  function c(f) {
    return e.attempt(
      K$,
      p,
      h
    )(f);
  }
  function p(f) {
    return t(f);
  }
  function h(f) {
    return o._balanced = !0, r(f);
  }
}
function tV(e, t, r) {
  return n;
  function n(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), i;
  }
  function i(h) {
    return ht(h) ? ya(e, o)(h) : o(h);
  }
  function o(h) {
    return h === 41 ? p(h) : P2(
      e,
      a,
      u,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(h);
  }
  function a(h) {
    return ht(h) ? ya(e, l)(h) : p(h);
  }
  function u(h) {
    return r(h);
  }
  function l(h) {
    return h === 34 || h === 39 || h === 40 ? O2(
      e,
      c,
      r,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(h) : p(h);
  }
  function c(h) {
    return ht(h) ? ya(e, p)(h) : p(h);
  }
  function p(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : r(h);
  }
}
function rV(e, t, r) {
  let n = this;
  return i;
  function i(u) {
    return B2.call(
      n,
      e,
      o,
      a,
      "reference",
      "referenceMarker",
      "referenceString"
    )(u);
  }
  function o(u) {
    return n.parser.defined.includes(
      Zs(
        n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(u) : r(u);
  }
  function a(u) {
    return r(u);
  }
}
function nV(e, t, r) {
  return n;
  function n(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : r(o);
  }
}
function sV(e, t, r) {
  let n = this;
  return i;
  function i(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), o;
  }
  function o(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), a) : r(u);
  }
  function a(u) {
    return u === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(u) : t(u);
  }
}
function aV(e, t, r) {
  let n = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(a) : t(a);
  }
}
function uV(e, t) {
  return r;
  function r(n) {
    return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), qe(e, t, "linePrefix");
  }
}
function lV(e, t, r) {
  let n = 0, i;
  return o;
  function o(c) {
    return e.enter("thematicBreak"), a(c);
  }
  function a(c) {
    return i = c, u(c);
  }
  function u(c) {
    return c === i ? (e.enter("thematicBreakSequence"), l(c)) : n >= 3 && (c === null || le(c)) ? (e.exit("thematicBreak"), t(c)) : r(c);
  }
  function l(c) {
    return c === i ? (e.consume(c), n++, l) : (e.exit("thematicBreakSequence"), Oe(c) ? qe(e, u, "whitespace")(c) : u(c));
  }
}
function hV(e, t, r) {
  let n = this, i = n.events[n.events.length - 1], o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return u;
  function u(d) {
    let m = n.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !n.containerState.marker || d === n.containerState.marker : Rm(d)) {
      if (n.containerState.type || (n.containerState.type = m, e.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(Ul, r, c)(d) : c(d);
      if (!n.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(d);
    }
    return r(d);
  }
  function l(d) {
    return Rm(d) && ++a < 10 ? (e.consume(d), l) : (!n.interrupt || a < 2) && (n.containerState.marker ? d === n.containerState.marker : d ===
    41 || d === 46) ? (e.exit("listItemValue"), c(d)) : r(d);
  }
  function c(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), n.containerState.marker = n.containerState.marker || d, e.check(
      va,
      // Cant be empty when interrupting.
      n.interrupt ? r : p,
      e.attempt(
        cV,
        f,
        h
      )
    );
  }
  function p(d) {
    return n.containerState.initialBlankLine = !0, o++, f(d);
  }
  function h(d) {
    return Oe(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), f) : r(d);
  }
  function f(d) {
    return n.containerState.size = o + n.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function fV(e, t, r) {
  let n = this;
  return n.containerState._closeFlow = void 0, e.check(va, i, o);
  function i(u) {
    return n.containerState.furtherBlankLines = n.containerState.furtherBlankLines || n.containerState.initialBlankLine, qe(
      e,
      t,
      "listItemIndent",
      n.containerState.size + 1
    )(u);
  }
  s(i, "onBlank");
  function o(u) {
    return n.containerState.furtherBlankLines || !Oe(u) ? (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0,
    a(u)) : (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, e.attempt(pV, t, a)(u));
  }
  s(o, "notBlank");
  function a(u) {
    return n.containerState._closeFlow = !0, n.interrupt = void 0, qe(
      e,
      e.attempt(Wt, t, r),
      "linePrefix",
      n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(u);
  }
  s(a, "notInCurrentItem");
}
function dV(e, t, r) {
  let n = this;
  return qe(
    e,
    i,
    "listItemIndent",
    n.containerState.size + 1
  );
  function i(o) {
    let a = n.events[n.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === n.containerState.size ? t(o) : r(o);
  }
}
function mV(e) {
  e.exit(this.containerState.type);
}
function gV(e, t, r) {
  let n = this;
  return qe(
    e,
    i,
    "listItemPrefixWhitespace",
    n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function i(o) {
    let a = n.events[n.events.length - 1];
    return !Oe(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : r(o);
  }
}
function yV(e, t) {
  let r = e.length, n, i, o;
  for (; r--; )
    if (e[r][0] === "enter") {
      if (e[r][1].type === "content") {
        n = r;
        break;
      }
      e[r][1].type === "paragraph" && (i = r);
    } else
      e[r][1].type === "content" && e.splice(r, 1), !o && e[r][1].type === "definition" && (o = r);
  let a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[n][1], t]), e[n][1].end = Object.
  assign({}, e[o][1].end)) : e[n][1] = a, e.push(["exit", a, t]), e;
}
function DV(e, t, r) {
  let n = this, i;
  return o;
  function o(c) {
    let p = n.events.length, h;
    for (; p--; )
      if (n.events[p][1].type !== "lineEnding" && n.events[p][1].type !== "linePrefix" && n.events[p][1].type !== "content") {
        h = n.events[p][1].type === "paragraph";
        break;
      }
    return !n.parser.lazy[n.now().line] && (n.interrupt || h) ? (e.enter("setextHeadingLine"), i = c, a(c)) : r(c);
  }
  function a(c) {
    return e.enter("setextHeadingLineSequence"), u(c);
  }
  function u(c) {
    return c === i ? (e.consume(c), u) : (e.exit("setextHeadingLineSequence"), Oe(c) ? qe(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || le(c) ? (e.exit("setextHeadingLine"), t(c)) : r(c);
  }
}
function vV(e) {
  let t = {
    tokenize: i,
    concrete: !0
  };
  if (!e || !e.acorn || !e.acorn.parse)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  let r = e.acorn, n = Object.assign({
    ecmaVersion: 2024,
    sourceType: "module"
  }, e.acornOptions, {
    locations: !0
  });
  return {
    flow: {
      101: t,
      105: t
    }
  };
  function i(o, a, u) {
    let l = this, c = l.parser.definedModuleSpecifiers || (l.parser.definedModuleSpecifiers = []), p = this.events.length + 1, h = "";
    return l.interrupt ? u : f;
    function f(E) {
      return l.now().column > 1 ? u(E) : (o.enter("mdxjsEsm"), o.enter("mdxjsEsmData"), o.consume(E), h += String.fromCharCode(E), d);
    }
    function d(E) {
      return qr(E) ? (o.consume(E), h += String.fromCharCode(E), d) : (h === "import" || h === "export") && E === 32 ? (o.consume(E), m) : u(
      E);
    }
    function m(E) {
      return E === null || le(E) ? (o.exit("mdxjsEsmData"), g(E)) : (o.consume(E), m);
    }
    function g(E) {
      return E === null ? y(E) : le(E) ? o.check(xV, y, b)(E) : (o.enter("mdxjsEsmData"), m(E));
    }
    function b(E) {
      return o.enter("lineEnding"), o.consume(E), o.exit("lineEnding"), g;
    }
    function y(E) {
      let A = A2(l.events.slice(p), {
        acorn: r,
        acornOptions: n,
        tokenTypes: ["mdxjsEsmData"],
        prefix: c.length > 0 ? "var " + c.join(",") + `
` : ""
      });
      if (A.error) {
        if (E !== null && A.swallow)
          return b(E);
        let O = new Ne("Could not parse import/exports with acorn", {
          cause: A.error,
          place: {
            line: A.error.loc.line,
            column: A.error.loc.column + 1,
            offset: A.error.pos
          },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm"
        });
        throw O.url = Mw + "#could-not-parse-importexports-with-acorn", O;
      }
      if (c.length > 0) {
        let O = A.estree.body.shift();
      }
      let k = -1;
      for (; ++k < A.estree.body.length; ) {
        let O = A.estree.body[k];
        if (!bV.has(O.type)) {
          let w = new Ne("Unexpected `" + O.type + "` in code: only import/exports are supported", {
            place: Bn(O),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm"
          });
          throw w.url = Mw + "#unexpected-type-in-code-only-importexports-are-supported", w;
        }
        if (O.type === "ImportDeclaration" && !l.interrupt) {
          let w = -1;
          for (; ++w < O.specifiers.length; ) {
            let C = O.specifiers[w];
            c.push(C.local.name);
          }
        }
      }
      return Object.assign(o.exit("mdxjsEsm"), e.addResult ? {
        estree: A.estree
      } : void 0), a(E);
    }
  }
}
function EV(e, t, r) {
  return n;
  function n(i) {
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), e.attempt(va, t, r);
  }
}
function R2(e) {
  let t = {}, r = -1;
  for (; ++r < e.length; )
    CV(t, e[r]);
  return t;
}
function CV(e, t) {
  let r;
  for (r in t) {
    let i = (qw.call(e, r) ? e[r] : void 0) || (e[r] = {}), o = t[r], a;
    if (o)
      for (a in o) {
        qw.call(i, a) || (i[a] = []);
        let u = o[a];
        wV(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(u) ? u : u ? [u] : []
        );
      }
  }
}
function wV(e, t) {
  let r = -1, n = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : n).push(t[r]);
  on(e, 0, 0, n);
}
function SV(e) {
  let t = Object.assign(
    {
      acorn: gt.extend((0, Rq.default)()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: !0
    },
    e
  );
  return R2([
    vV(t),
    Qq(t),
    n$(t),
    i$()
  ]);
}
function FV(e) {
  let t = (
    /** @type {Processor} */
    this
  ), r = e || AV, n = t.data(), i = n.micromarkExtensions || (n.micromarkExtensions = []), o = n.fromMarkdownExtensions || (n.fromMarkdownExtensions =
  []), a = n.toMarkdownExtensions || (n.toMarkdownExtensions = []);
  i.push(SV(r)), o.push(Bq()), a.push(Oq(r));
}
function kV(e, t) {
  let r = t || _V, n = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml :
  !0;
  return N2(e, n, i);
}
function N2(e, t, r) {
  if (TV(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return $w(e.children, t, r);
  }
  return Array.isArray(e) ? $w(e, t, r) : "";
}
function $w(e, t, r) {
  let n = [], i = -1;
  for (; ++i < e.length; )
    n[i] = N2(e[i], t, r);
  return n.join("");
}
function TV(e) {
  return !!(e && typeof e == "object");
}
function L2(e, t) {
  let r = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    r < 9 || r === 11 || r > 13 && r < 32 || // Control character (DEL) of C0, and C1 controls.
    r > 126 && r < 160 || // Lone high surrogates and low surrogates.
    r > 55295 && r < 57344 || // Noncharacters.
    r > 64975 && r < 65008 || /* eslint-disable no-bitwise */
    (r & 65535) === 65535 || (r & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    r > 1114111 ? "\uFFFD" : String.fromCodePoint(r)
  );
}
function Xs(e) {
  let t = [], r = -1, n = 0, i = 0;
  for (; ++r < e.length; ) {
    let o = e.charCodeAt(r), a = "";
    if (o === 37 && er(e.charCodeAt(r + 1)) && er(e.charCodeAt(r + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      let u = e.charCodeAt(r + 1);
      o < 56320 && u > 56319 && u < 57344 ? (a = String.fromCharCode(o, u), i = 1) : a = "\uFFFD";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(n, r), encodeURIComponent(a)), n = r + i + 1, a = ""), i && (r += i, i = 0);
  }
  return t.join("") + e.slice(n);
}
function PV(e) {
  let t = e.attempt(
    this.parser.constructs.contentInitial,
    n,
    i
  ), r;
  return t;
  function n(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), qe(e, t, "linePrefix");
  }
  function i(u) {
    return e.enter("paragraph"), o(u);
  }
  function o(u) {
    let l = e.enter("chunkText", {
      contentType: "text",
      previous: r
    });
    return r && (r.next = l), r = l, a(u);
  }
  function a(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return le(u) ? (e.consume(u), e.exit("chunkText"), o) : (e.consume(u), a);
  }
}
function OV(e) {
  let t = this, r = [], n = 0, i, o, a;
  return u;
  function u(A) {
    if (n < r.length) {
      let k = r[n];
      return t.containerState = k[1], e.attempt(
        k[0].continuation,
        l,
        c
      )(A);
    }
    return c(A);
  }
  function l(A) {
    if (n++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && E();
      let k = t.events.length, O = k, w;
      for (; O--; )
        if (t.events[O][0] === "exit" && t.events[O][1].type === "chunkFlow") {
          w = t.events[O][1].end;
          break;
        }
      y(n);
      let C = k;
      for (; C < t.events.length; )
        t.events[C][1].end = Object.assign({}, w), C++;
      return on(
        t.events,
        O + 1,
        0,
        t.events.slice(k)
      ), t.events.length = C, c(A);
    }
    return u(A);
  }
  function c(A) {
    if (n === r.length) {
      if (!i)
        return f(A);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(A);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Vw,
      p,
      h
    )(A);
  }
  function p(A) {
    return i && E(), y(n), f(A);
  }
  function h(A) {
    return t.parser.lazy[t.now().line] = n !== r.length, a = t.now().offset, m(A);
  }
  function f(A) {
    return t.containerState = {}, e.attempt(
      Vw,
      d,
      m
    )(A);
  }
  function d(A) {
    return n++, r.push([t.currentConstruct, t.containerState]), f(A);
  }
  function m(A) {
    if (A === null) {
      i && E(), y(0), e.consume(A);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), g(A);
  }
  function g(A) {
    if (A === null) {
      b(e.exit("chunkFlow"), !0), y(0), e.consume(A);
      return;
    }
    return le(A) ? (e.consume(A), b(e.exit("chunkFlow")), n = 0, t.interrupt = void 0, u) : (e.consume(A), g);
  }
  function b(A, k) {
    let O = t.sliceStream(A);
    if (k && O.push(null), A.previous = o, o && (o.next = A), o = A, i.defineSkip(A.start), i.write(O), t.parser.lazy[A.start.line]) {
      let w = i.events.length;
      for (; w--; )
        if (
          // The token starts before the line ending
          i.events[w][1].start.offset < a && // and either is not ended yet
          (!i.events[w][1].end || // or ends after it.
          i.events[w][1].end.offset > a)
        )
          return;
      let C = t.events.length, T = C, F, $;
      for (; T--; )
        if (t.events[T][0] === "exit" && t.events[T][1].type === "chunkFlow") {
          if (F) {
            $ = t.events[T][1].end;
            break;
          }
          F = !0;
        }
      for (y(n), w = C; w < t.events.length; )
        t.events[w][1].end = Object.assign({}, $), w++;
      on(
        t.events,
        T + 1,
        0,
        t.events.slice(C)
      ), t.events.length = w;
    }
  }
  function y(A) {
    let k = r.length;
    for (; k-- > A; ) {
      let O = r[k];
      t.containerState = O[1], O[0].exit.call(t, e);
    }
    r.length = A;
  }
  function E() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function RV(e, t, r) {
  return qe(
    e,
    e.attempt(this.parser.constructs.document, t, r),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function LV(e) {
  let t = this, r = e.attempt(
    // Try to parse a blank line.
    va,
    n,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      qe(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(S$, i)
        ),
        "linePrefix"
      )
    )
  );
  return r;
  function n(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, r;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, r;
  }
}
function j2(e) {
  return {
    tokenize: t,
    resolveAll: M2(
      e === "text" ? $V : void 0
    )
  };
  function t(r) {
    let n = this, i = this.parser.constructs[e], o = r.attempt(i, a, u);
    return a;
    function a(p) {
      return c(p) ? o(p) : u(p);
    }
    function u(p) {
      if (p === null) {
        r.consume(p);
        return;
      }
      return r.enter("data"), r.consume(p), l;
    }
    function l(p) {
      return c(p) ? (r.exit("data"), o(p)) : (r.consume(p), l);
    }
    function c(p) {
      if (p === null)
        return !0;
      let h = i[p], f = -1;
      if (h)
        for (; ++f < h.length; ) {
          let d = h[f];
          if (!d.previous || d.previous.call(n, n.previous))
            return !0;
        }
      return !1;
    }
  }
}
function M2(e) {
  return t;
  function t(r, n) {
    let i = -1, o;
    for (; ++i <= r.length; )
      o === void 0 ? r[i] && r[i][1].type === "data" && (o = i, i++) : (!r[i] || r[i][1].type !== "data") && (i !== o + 2 && (r[o][1].end = r[i -
      1][1].end, r.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(r, n) : r;
  }
}
function $V(e, t) {
  let r = 0;
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === "lineEnding") && e[r - 1][1].type === "data") {
      let n = e[r - 1][1], i = t.sliceStream(n), o = i.length, a = -1, u = 0, l;
      for (; o--; ) {
        let c = i[o];
        if (typeof c == "string") {
          for (a = c.length; c.charCodeAt(a - 1) === 32; )
            u++, a--;
          if (a)
            break;
          a = -1;
        } else if (c === -2)
          l = !0, u++;
        else if (c !== -1) {
          o++;
          break;
        }
      }
      if (u) {
        let c = {
          type: r === e.length || l || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: n.end.line,
            column: n.end.column - u,
            offset: n.end.offset - u,
            _index: n.start._index + o,
            _bufferIndex: o ? a : n.start._bufferIndex + a
          },
          end: Object.assign({}, n.end)
        };
        n.end = Object.assign({}, c.start), n.start.offset === n.end.offset ? Object.assign(n, c) : (e.splice(
          r,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), r += 2);
      }
      r++;
    }
  return e;
}
function VV(e, t, r) {
  let n = Object.assign(
    r ? Object.assign({}, r) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  ), i = {}, o = [], a = [], u = [], l = !0, c = {
    consume: k,
    enter: O,
    exit: w,
    attempt: F(C),
    check: F(T),
    interrupt: F(T, {
      interrupt: !0
    })
  }, p = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: g,
    sliceSerialize: m,
    now: b,
    defineSkip: y,
    write: d
  }, h = t.tokenize.call(p, c), f;
  return t.resolveAll && o.push(t), p;
  function d(W) {
    return a = xr(a, W), E(), a[a.length - 1] !== null ? [] : ($(t, 0), p.events = qm(o, p.events, p), p.events);
  }
  s(d, "write");
  function m(W, Y) {
    return WV(g(W), Y);
  }
  s(m, "sliceSerialize");
  function g(W) {
    return UV(a, W);
  }
  s(g, "sliceStream");
  function b() {
    let { line: W, column: Y, offset: j, _index: N, _bufferIndex: z } = n;
    return {
      line: W,
      column: Y,
      offset: j,
      _index: N,
      _bufferIndex: z
    };
  }
  s(b, "now");
  function y(W) {
    i[W.line] = W.column, U();
  }
  s(y, "defineSkip");
  function E() {
    let W;
    for (; n._index < a.length; ) {
      let Y = a[n._index];
      if (typeof Y == "string")
        for (W = n._index, n._bufferIndex < 0 && (n._bufferIndex = 0); n._index === W && n._bufferIndex < Y.length; )
          A(Y.charCodeAt(n._bufferIndex));
      else
        A(Y);
    }
  }
  s(E, "main");
  function A(W) {
    l = void 0, f = W, h = h(W);
  }
  s(A, "go");
  function k(W) {
    le(W) ? (n.line++, n.column = 1, n.offset += W === -3 ? 2 : 1, U()) : W !== -1 && (n.column++, n.offset++), n._bufferIndex < 0 ? n._index++ :
    (n._bufferIndex++, n._bufferIndex === a[n._index].length && (n._bufferIndex = -1, n._index++)), p.previous = W, l = !0;
  }
  s(k, "consume");
  function O(W, Y) {
    let j = Y || {};
    return j.type = W, j.start = b(), p.events.push(["enter", j, p]), u.push(j), j;
  }
  s(O, "enter");
  function w(W) {
    let Y = u.pop();
    return Y.end = b(), p.events.push(["exit", Y, p]), Y;
  }
  s(w, "exit2");
  function C(W, Y) {
    $(W, Y.from);
  }
  s(C, "onsuccessfulconstruct");
  function T(W, Y) {
    Y.restore();
  }
  s(T, "onsuccessfulcheck");
  function F(W, Y) {
    return j;
    function j(N, z, Q) {
      let ie, B, ce, Je;
      return Array.isArray(N) ? Ue(N) : "tokenize" in N ? (
        // @ts-expect-error Looks like a construct.
        Ue([N])
      ) : L(N);
      function L(Me) {
        return re;
        function re(xe) {
          let K = xe !== null && Me[xe], se = xe !== null && Me.null, ge = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(K) ? K : K ? [K] : [],
            ...Array.isArray(se) ? se : se ? [se] : []
          ];
          return Ue(ge)(xe);
        }
      }
      function Ue(Me) {
        return ie = Me, B = 0, Me.length === 0 ? Q : $e(Me[B]);
      }
      function $e(Me) {
        return re;
        function re(xe) {
          return Je = R(), ce = Me, Me.partial || (p.currentConstruct = Me), Me.name && p.parser.constructs.disable.null.includes(Me.name) ?
          It(xe) : Me.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            Y ? Object.assign(Object.create(p), Y) : p,
            c,
            me,
            It
          )(xe);
        }
      }
      function me(Me) {
        return l = !0, W(ce, Je), z;
      }
      function It(Me) {
        return l = !0, Je.restore(), ++B < ie.length ? $e(ie[B]) : Q;
      }
    }
  }
  s(F, "constructFactory");
  function $(W, Y) {
    W.resolveAll && !o.includes(W) && o.push(W), W.resolve && on(
      p.events,
      Y,
      p.events.length - Y,
      W.resolve(p.events.slice(Y), p)
    ), W.resolveTo && (p.events = W.resolveTo(p.events, p));
  }
  s($, "addResult");
  function R() {
    let W = b(), Y = p.previous, j = p.currentConstruct, N = p.events.length, z = Array.from(u);
    return {
      restore: Q,
      from: N
    };
    function Q() {
      n = W, p.previous = Y, p.currentConstruct = j, p.events.length = N, u = z, U();
    }
  }
  s(R, "store");
  function U() {
    n.line in i && n.column < 2 && (n.column = i[n.line], n.offset += i[n.line] - 1);
  }
  s(U, "accountForPotentialSkip");
}
function UV(e, t) {
  let r = t.start._index, n = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex, a;
  if (r === i)
    a = [e[r].slice(n, o)];
  else {
    if (a = e.slice(r, i), n > -1) {
      let u = a[0];
      typeof u == "string" ? a[0] = u.slice(n) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function WV(e, t) {
  let r = -1, n = [], i;
  for (; ++r < e.length; ) {
    let o = e[r], a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, n.push(a);
  }
  return n.join("");
}
function eU(e) {
  let r = (
    /** @type {FullNormalizedExtension} */
    R2([q2, ...(e || {}).extensions || []])
  ), n = {
    defined: [],
    lazy: {},
    constructs: r,
    content: i(IV),
    document: i(BV),
    flow: i(NV),
    string: i(MV),
    text: i(qV)
  };
  return n;
  function i(o) {
    return a;
    function a(u) {
      return VV(n, o, u);
    }
  }
}
function tU(e) {
  for (; !I2(e); )
    ;
  return e;
}
function rU() {
  let e = 1, t = "", r = !0, n;
  return i;
  function i(o, a, u) {
    let l = [], c, p, h, f, d;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), h = 0, t = "", r && (o.charCodeAt(0) === 65279 &&
    h++, r = void 0); h < o.length; ) {
      if (Uw.lastIndex = h, c = Uw.exec(o), f = c && c.index !== void 0 ? c.index : o.length, d = o.charCodeAt(f), !c) {
        t = o.slice(h);
        break;
      }
      if (d === 10 && h === f && n)
        l.push(-3), n = void 0;
      else
        switch (n && (l.push(-5), n = void 0), h < f && (l.push(o.slice(h, f)), e += f - h), d) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (p = Math.ceil(e / 4) * 4, l.push(-2); e++ < p; )
              l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            n = !0, e = 1;
        }
      h = f + 1;
    }
    return u && (n && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
function iU(e) {
  return e.replace(nU, sU);
}
function sU(e, t, r) {
  if (t)
    return t;
  if (r.charCodeAt(0) === 35) {
    let i = r.charCodeAt(1), o = i === 120 || i === 88;
    return L2(r.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return xa(r) || e;
}
function oU(e, t, r) {
  return typeof t != "string" && (r = t, t = void 0), aU(r)(
    tU(
      eU(r).document().write(rU()(e, t, !0))
    )
  );
}
function aU(e) {
  let t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(We),
      autolinkProtocol: F,
      autolinkEmail: F,
      atxHeading: o(be),
      blockQuote: o(re),
      characterEscape: F,
      characterReference: F,
      codeFenced: o(xe),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(xe, a),
      codeText: o(K, a),
      codeTextData: F,
      data: F,
      codeFlowValue: F,
      definition: o(se),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(ge),
      hardBreakEscape: o(Ee),
      hardBreakTrailing: o(Ee),
      htmlFlow: o(rt, a),
      htmlFlowData: F,
      htmlText: o(rt, a),
      htmlTextData: F,
      image: o(Ct),
      label: a,
      link: o(We),
      listItem: o(or),
      listItemValue: f,
      listOrdered: o(sr, h),
      listUnordered: o(sr),
      paragraph: o(kr),
      reference: L,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o(be),
      strong: o(pe),
      thematicBreak: o(x)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: O,
      autolink: l(),
      autolinkEmail: Me,
      autolinkProtocol: It,
      blockQuote: l(),
      characterEscapeValue: $,
      characterReferenceMarkerHexadecimal: $e,
      characterReferenceMarkerNumeric: $e,
      characterReferenceValue: me,
      codeFenced: l(b),
      codeFencedFence: g,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: m,
      codeFlowValue: $,
      codeIndented: l(y),
      codeText: l(j),
      codeTextData: $,
      data: $,
      definition: l(),
      definitionDestinationString: k,
      definitionLabelString: E,
      definitionTitleString: A,
      emphasis: l(),
      hardBreakEscape: l(U),
      hardBreakTrailing: l(U),
      htmlFlow: l(W),
      htmlFlowData: $,
      htmlText: l(Y),
      htmlTextData: $,
      image: l(z),
      label: ie,
      labelText: Q,
      lineEnding: R,
      link: l(N),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Ue,
      resourceDestinationString: B,
      resourceTitleString: ce,
      resource: Je,
      setextHeading: l(T),
      setextHeadingLineSequence: C,
      setextHeadingText: w,
      strong: l(),
      thematicBreak: l()
    }
  };
  V2(t, (e || {}).mdastExtensions || []);
  let r = {};
  return n;
  function n(D) {
    let _ = {
      type: "root",
      children: []
    }, P = {
      stack: [_],
      tokenStack: [],
      config: t,
      enter: u,
      exit: c,
      buffer: a,
      resume: p,
      data: r
    }, v = [], M = -1;
    for (; ++M < D.length; )
      if (D[M][1].type === "listOrdered" || D[M][1].type === "listUnordered")
        if (D[M][0] === "enter")
          v.push(M);
        else {
          let H = v.pop();
          M = i(D, H, M);
        }
    for (M = -1; ++M < D.length; ) {
      let H = t[D[M][0]];
      $2.call(H, D[M][1].type) && H[D[M][1].type].call(
        Object.assign(
          {
            sliceSerialize: D[M][2].sliceSerialize
          },
          P
        ),
        D[M][1]
      );
    }
    if (P.tokenStack.length > 0) {
      let H = P.tokenStack[P.tokenStack.length - 1];
      (H[1] || Ww).call(P, void 0, H[0]);
    }
    for (_.position = {
      start: si(
        D.length > 0 ? D[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: si(
        D.length > 0 ? D[D.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, M = -1; ++M < t.transforms.length; )
      _ = t.transforms[M](_) || _;
    return _;
  }
  function i(D, _, P) {
    let v = _ - 1, M = -1, H = !1, G, Z, fe, Ae;
    for (; ++v <= P; ) {
      let he = D[v];
      switch (he[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          he[0] === "enter" ? M++ : M--, Ae = void 0;
          break;
        }
        case "lineEndingBlank": {
          he[0] === "enter" && (G && !Ae && !M && !fe && (fe = v), Ae = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ae = void 0;
      }
      if (!M && he[0] === "enter" && he[1].type === "listItemPrefix" || M === -1 && he[0] === "exit" && (he[1].type === "listUnordered" || he[1].
      type === "listOrdered")) {
        if (G) {
          let ke = v;
          for (Z = void 0; ke--; ) {
            let nt = D[ke];
            if (nt[1].type === "lineEnding" || nt[1].type === "lineEndingBlank") {
              if (nt[0] === "exit")
                continue;
              Z && (D[Z][1].type = "lineEndingBlank", H = !0), nt[1].type = "lineEnding", Z = ke;
            } else if (!(nt[1].type === "linePrefix" || nt[1].type === "blockQuotePrefix" || nt[1].type === "blockQuotePrefixWhitespace" || nt[1].
            type === "blockQuoteMarker" || nt[1].type === "listItemIndent"))
              break;
          }
          fe && (!Z || fe < Z) && (G._spread = !0), G.end = Object.assign(
            {},
            Z ? D[Z][1].start : he[1].end
          ), D.splice(Z || v, 0, ["exit", G, he[2]]), v++, P++;
        }
        if (he[1].type === "listItemPrefix") {
          let ke = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, he[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          G = ke, D.splice(v, 0, ["enter", ke, he[2]]), v++, P++, fe = void 0, Ae = !0;
        }
      }
    }
    return D[_][1]._spread = H, P;
  }
  function o(D, _) {
    return P;
    function P(v) {
      u.call(this, D(v), v), _ && _.call(this, v);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(D, _, P) {
    this.stack[this.stack.length - 1].children.push(D), this.stack.push(D), this.tokenStack.push([_, P]), D.position = {
      start: si(_.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(D) {
    return _;
    function _(P) {
      D && D.call(this, P), c.call(this, P);
    }
  }
  function c(D, _) {
    let P = this.stack.pop(), v = this.tokenStack.pop();
    if (v)
      v[0].type !== D.type && (_ ? _.call(this, D, v[0]) : (v[1] || Ww).call(this, D, v[0]));
    else throw new Error(
      "Cannot close `" + D.type + "` (" + br({
        start: D.start,
        end: D.end
      }) + "): it\u2019s not open"
    );
    P.position.end = si(D.end);
  }
  function p() {
    return kV(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(D) {
    if (this.data.expectingFirstListItemValue) {
      let _ = this.stack[this.stack.length - 2];
      _.start = Number.parseInt(this.sliceSerialize(D), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.lang = D;
  }
  function m() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.meta = D;
  }
  function g() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function b() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.value = D.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function y() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.value = D.replace(/(\r?\n|\r)$/g, "");
  }
  function E(D) {
    let _ = this.resume(), P = this.stack[this.stack.length - 1];
    P.label = _, P.identifier = Zs(
      this.sliceSerialize(D)
    ).toLowerCase();
  }
  function A() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.title = D;
  }
  function k() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.url = D;
  }
  function O(D) {
    let _ = this.stack[this.stack.length - 1];
    if (!_.depth) {
      let P = this.sliceSerialize(D).length;
      _.depth = P;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function C(D) {
    let _ = this.stack[this.stack.length - 1];
    _.depth = this.sliceSerialize(D).codePointAt(0) === 61 ? 1 : 2;
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function F(D) {
    let P = this.stack[this.stack.length - 1].children, v = P[P.length - 1];
    (!v || v.type !== "text") && (v = Ye(), v.position = {
      start: si(D.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, P.push(v)), this.stack.push(v);
  }
  function $(D) {
    let _ = this.stack.pop();
    _.value += this.sliceSerialize(D), _.position.end = si(D.end);
  }
  function R(D) {
    let _ = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      let P = _.children[_.children.length - 1];
      P.position.end = si(D.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(_.type) && (F.call(this, D), $.call(this, D));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function W() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.value = D;
  }
  function Y() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.value = D;
  }
  function j() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.value = D;
  }
  function N() {
    let D = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      let _ = this.data.referenceType || "shortcut";
      D.type += "Reference", D.referenceType = _, delete D.url, delete D.title;
    } else
      delete D.identifier, delete D.label;
    this.data.referenceType = void 0;
  }
  function z() {
    let D = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      let _ = this.data.referenceType || "shortcut";
      D.type += "Reference", D.referenceType = _, delete D.url, delete D.title;
    } else
      delete D.identifier, delete D.label;
    this.data.referenceType = void 0;
  }
  function Q(D) {
    let _ = this.sliceSerialize(D), P = this.stack[this.stack.length - 2];
    P.label = iU(_), P.identifier = Zs(_).toLowerCase();
  }
  function ie() {
    let D = this.stack[this.stack.length - 1], _ = this.resume(), P = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, P.type === "link") {
      let v = D.children;
      P.children = v;
    } else
      P.alt = _;
  }
  function B() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.url = D;
  }
  function ce() {
    let D = this.resume(), _ = this.stack[this.stack.length - 1];
    _.title = D;
  }
  function Je() {
    this.data.inReference = void 0;
  }
  function L() {
    this.data.referenceType = "collapsed";
  }
  function Ue(D) {
    let _ = this.resume(), P = this.stack[this.stack.length - 1];
    P.label = _, P.identifier = Zs(
      this.sliceSerialize(D)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function $e(D) {
    this.data.characterReferenceType = D.type;
  }
  function me(D) {
    let _ = this.sliceSerialize(D), P = this.data.characterReferenceType, v;
    P ? (v = L2(
      _,
      P === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : v = xa(_);
    let M = this.stack.pop();
    M.value += v, M.position.end = si(D.end);
  }
  function It(D) {
    $.call(this, D);
    let _ = this.stack[this.stack.length - 1];
    _.url = this.sliceSerialize(D);
  }
  function Me(D) {
    $.call(this, D);
    let _ = this.stack[this.stack.length - 1];
    _.url = "mailto:" + this.sliceSerialize(D);
  }
  function re() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function xe() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function K() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function se() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ge() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function be() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ee() {
    return {
      type: "break"
    };
  }
  function rt() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ct() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function We() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function sr(D) {
    return {
      type: "list",
      ordered: D.type === "listOrdered",
      start: null,
      spread: D._spread,
      children: []
    };
  }
  function or(D) {
    return {
      type: "listItem",
      spread: D._spread,
      checked: null,
      children: []
    };
  }
  function kr() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function pe() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ye() {
    return {
      type: "text",
      value: ""
    };
  }
  function x() {
    return {
      type: "thematicBreak"
    };
  }
}
function si(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function V2(e, t) {
  let r = -1;
  for (; ++r < t.length; ) {
    let n = t[r];
    Array.isArray(n) ? V2(e, n) : uU(e, n);
  }
}
function uU(e, t) {
  let r;
  for (r in t)
    if ($2.call(t, r))
      switch (r) {
        case "canContainEols": {
          let n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "transforms": {
          let n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "enter":
        case "exit": {
          let n = t[r];
          n && Object.assign(e[r], n);
          break;
        }
      }
}
function Ww(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + br({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + br({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + br({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function lU(e) {
  let t = this;
  t.parser = r;
  function r(n) {
    return oU(n, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
  s(r, "parser");
}
function cU(e, t) {
  let r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function pU(e, t) {
  let r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function hU(e, t) {
  let r = t.value ? t.value + `
` : "", n = {};
  t.lang && (n.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: n,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {},
  children: [i] }, e.patch(t, i), i;
}
function fU(e, t) {
  let r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function dU(e, t) {
  let r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function mU(e, t) {
  let r = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = String(t.identifier).toUpperCase(), i = Xs(
  n.toLowerCase()), o = e.footnoteOrder.indexOf(n), a, u = e.footnoteCounts.get(n);
  u === void 0 ? (u = 0, e.footnoteOrder.push(n), a = e.footnoteOrder.length) : a = o + 1, u += 1, e.footnoteCounts.set(n, u);
  let l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + r + "fn-" + i,
      id: r + "fnref-" + i + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, l);
  let c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function gU(e, t) {
  let r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function yU(e, t) {
  if (e.options.allowDangerousHtml) {
    let r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
}
function U2(e, t) {
  let r = t.referenceType, n = "]";
  if (r === "collapsed" ? n += "[]" : r === "full" && (n += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + n }];
  let i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  let a = i[i.length - 1];
  return a && a.type === "text" ? a.value += n : i.push({ type: "text", value: n }), i;
}
function DU(e, t) {
  let r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return U2(e, t);
  let i = { src: Xs(n.url || ""), alt: t.alt };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  let o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function xU(e, t) {
  let r = { src: Xs(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  let n = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, n), e.applyData(t, n);
}
function bU(e, t) {
  let r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  let n = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, n), e.applyData(t, n);
}
function vU(e, t) {
  let r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return U2(e, t);
  let i = { href: Xs(n.url || "") };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  let o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function EU(e, t) {
  let r = { href: Xs(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  let n = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function CU(e, t, r) {
  let n = e.all(t), i = r ? wU(r) : W2(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    let p = n[0], h;
    p && p.type === "element" && p.tagName === "p" ? h = p : (h = { type: "element", tagName: "p", properties: {}, children: [] }, n.unshift(
    h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < n.length; ) {
    let p = n[u];
    (i || u !== 0 || p.type !== "element" || p.tagName !== "p") && a.push({ type: "text", value: `
` }), p.type === "element" && p.tagName === "p" && !i ? a.push(...p.children) : a.push(p);
  }
  let l = n[n.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
  let c = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, c), e.applyData(t, c);
}
function wU(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    let r = e.children, n = -1;
    for (; !t && ++n < r.length; )
      t = W2(r[n]);
  }
  return t;
}
function W2(e) {
  let t = e.spread;
  return t ?? e.children.length > 1;
}
function SU(e, t) {
  let r = {}, n = e.all(t), i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++i < n.length; ) {
    let a = n[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes(
    "task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  let o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(n, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function AU(e, t) {
  let r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function FU(e, t) {
  let r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function _U(e, t) {
  let r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function kU(e, t) {
  let r = e.all(t), n = r.shift(), i = [];
  if (n) {
    let a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([n], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (r.length > 0) {
    let a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, u = em(t.children[1]), l = Qd(t.children[t.children.length - 1]);
    u && l && (a.position = { start: u, end: l }), i.push(a);
  }
  let o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function TU(e, t, r) {
  let n = r ? r.children : void 0, o = (n ? n.indexOf(t) : 1) === 0 ? "th" : "td", a = r && r.type === "table" ? r.align : void 0, u = a ? a.
  length : t.children.length, l = -1, c = [];
  for (; ++l < u; ) {
    let h = t.children[l], f = {}, d = a ? a[l] : void 0;
    d && (f.align = d);
    let m = { type: "element", tagName: o, properties: f, children: [] };
    h && (m.children = e.all(h), e.patch(h, m), m = e.applyData(h, m)), c.push(m);
  }
  let p = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, p), e.applyData(t, p);
}
function IU(e, t) {
  let r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function PU(e) {
  let t = String(e), r = /\r?\n|\r/g, n = r.exec(t), i = 0, o = [];
  for (; n; )
    o.push(
      Gw(t.slice(i, n.index), i > 0, !0),
      n[0]
    ), i = n.index + n[0].length, n = r.exec(t);
  return o.push(Gw(t.slice(i), i > 0, !1)), o.join("");
}
function Gw(e, t, r) {
  let n = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(n);
    for (; o === zw || o === Hw; )
      n++, o = e.codePointAt(n);
  }
  if (r) {
    let o = e.codePointAt(i - 1);
    for (; o === zw || o === Hw; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > n ? e.slice(n, i) : "";
}
function BU(e, t) {
  let r = { type: "text", value: PU(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function OU(e, t) {
  let r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
function jl() {
}
function qU(e, t) {
  let r = [{ type: "text", value: "\u21A9" }];
  return t > 1 && r.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), r;
}
function $U(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function VU(e) {
  let t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = e.options.footnoteBackContent || qU, n = e.
  options.footnoteBackLabel || $U, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties ||
  {
    className: ["sr-only"]
  }, u = [], l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    let c = e.footnoteById.get(e.footnoteOrder[l]);
    if (!c)
      continue;
    let p = e.all(c), h = String(c.identifier).toUpperCase(), f = Xs(h.toLowerCase()), d = 0, m = [], g = e.footnoteCounts.get(h);
    for (; g !== void 0 && ++d <= g; ) {
      m.length > 0 && m.push({ type: "text", value: " " });
      let E = typeof r == "string" ? r : r(l, d);
      typeof E == "string" && (E = { type: "text", value: E }), m.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + f + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof n == "string" ? n : n(l, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(E) ? E : [E]
      });
    }
    let b = p[p.length - 1];
    if (b && b.type === "element" && b.tagName === "p") {
      let E = b.children[b.children.length - 1];
      E && E.type === "text" ? E.value += " " : b.children.push({ type: "text", value: " " }), b.children.push(...m);
    } else
      p.push(...m);
    let y = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + f },
      children: e.wrap(p, !0)
    };
    e.patch(c, y), u.push(y);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...Gl(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function UU(e) {
  let t = [], r = -1;
  for (; ++r < e.length; )
    t[r] = J2(e[r]);
  return Xl(n);
  function n(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i))
        return !0;
    return !1;
  }
}
function WU(e) {
  let t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Xl(r);
  function r(n) {
    let i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      n
    ), o;
    for (o in e)
      if (i[o] !== t[o])
        return !1;
    return !0;
  }
}
function zU(e) {
  return Xl(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Xl(e) {
  return t;
  function t(r, n, i) {
    return !!(GU(r) && e.call(
      this,
      r,
      typeof n == "number" ? n : void 0,
      i || void 0
    ));
  }
}
function HU() {
  return !0;
}
function GU(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
function JU(e) {
  return "\x1B[33m" + e + "\x1B[39m";
}
function KU(e, t, r, n) {
  let i;
  typeof t == "function" && typeof r != "function" ? (n = r, r = t) : i = t;
  let o = J2(i), a = n ? -1 : 1;
  u(e, void 0, [])();
  function u(l, c, p) {
    let h = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof h.type == "string") {
      let d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + JU(l.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let d = Z2, m, g, b;
      if ((!t || o(l, c, p[p.length - 1] || void 0)) && (d = YU(r(l, p)), d[0] === Kw))
        return d;
      if ("children" in l && l.children) {
        let y = (
          /** @type {UnistParent} */
          l
        );
        if (y.children && d[0] !== XU)
          for (g = (n ? y.children.length : -1) + a, b = p.concat(y); g > -1 && g < y.children.length; ) {
            let E = y.children[g];
            if (m = u(E, g, b)(), m[0] === Kw)
              return m;
            g = typeof m[1] == "number" ? m[1] : g + a;
          }
      }
      return d;
    }
  }
  s(u, "factory");
}
function YU(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [ZU, e] : e == null ? Z2 : [e];
}
function Hm(e, t, r, n) {
  let i, o, a;
  typeof t == "function" && typeof r != "function" ? (o = void 0, a = t, i = r) : (o = t, a = r, i = n), KU(e, o, u, i);
  function u(l, c) {
    let p = c[c.length - 1], h = p ? p.children.indexOf(l) : void 0;
    return a(l, h, p);
  }
  s(u, "overload");
}
function eW(e, t) {
  let r = t || QU, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...RU, ...r.handlers },
  u = {
    all: c,
    applyData: rW,
    definitionById: n,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: l,
    options: r,
    patch: tW,
    wrap: iW
  };
  return Hm(e, function(p) {
    if (p.type === "definition" || p.type === "footnoteDefinition") {
      let h = p.type === "definition" ? n : i, f = String(p.identifier).toUpperCase();
      h.has(f) || h.set(f, p);
    }
  }), u;
  function l(p, h) {
    let f = p.type, d = u.handlers[f];
    if (Lm.call(u.handlers, f) && d)
      return d(u, p, h);
    if (u.options.passThrough && u.options.passThrough.includes(f)) {
      if ("children" in p) {
        let { children: g, ...b } = p, y = Gl(b);
        return y.children = u.all(p), y;
      }
      return Gl(p);
    }
    return (u.options.unknownHandler || nW)(u, p, h);
  }
  s(l, "one2");
  function c(p) {
    let h = [];
    if ("children" in p) {
      let f = p.children, d = -1;
      for (; ++d < f.length; ) {
        let m = u.one(f[d], p);
        if (m) {
          if (d && f[d - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = Yw(m.value)), !Array.isArray(m) && m.type ===
          "element")) {
            let g = m.children[0];
            g && g.type === "text" && (g.value = Yw(g.value));
          }
          Array.isArray(m) ? h.push(...m) : h.push(m);
        }
      }
    }
    return h;
  }
  s(c, "all2");
}
function tW(e, t) {
  e.position && (t.position = tm(e));
}
function rW(e, t) {
  let r = t;
  if (e && e.data) {
    let n = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof n == "string")
      if (r.type === "element")
        r.tagName = n;
      else {
        let a = "children" in r ? r.children : [r];
        r = { type: "element", tagName: n, properties: {}, children: a };
      }
    r.type === "element" && o && Object.assign(r.properties, Gl(o)), "children" in r && r.children && i !== null && i !== void 0 && (r.children =
    i);
  }
  return r;
}
function nW(e, t) {
  let r = t.data || {}, n = "value" in t && !(Lm.call(r, "hProperties") || Lm.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function iW(e, t) {
  let r = [], n = -1;
  for (t && r.push({ type: "text", value: `
` }); ++n < e.length; )
    n && r.push({ type: "text", value: `
` }), r.push(e[n]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
function Yw(e) {
  let t = 0, r = e.charCodeAt(t);
  for (; r === 9 || r === 32; )
    t++, r = e.charCodeAt(t);
  return e.slice(t);
}
function Qw(e, t) {
  let r = eW(e, t), n = r.one(e, void 0), i = VU(r), o = Array.isArray(n) ? { type: "root", children: n } : n || { type: "root", children: [] };
  return i && ("children" in o, o.children.push({ type: "text", value: `
` }, i)), o;
}
function sW(e, t) {
  return e && "run" in e ? async function(r, n) {
    let i = (
      /** @type {HastRoot} */
      Qw(r, t)
    );
    await e.run(i, n);
  } : function(r) {
    return (
      /** @type {HastRoot} */
      Qw(r, t || e)
    );
  };
}
function e2(e) {
  if (e)
    throw e;
}
function jm(e) {
  if (typeof e != "object" || e === null)
    return !1;
  let t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function oW() {
  let e = [], t = { run: r, use: n };
  return t;
  function r(...i) {
    let o = -1, a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    u(null, ...i);
    function u(l, ...c) {
      let p = e[++o], h = -1;
      if (l) {
        a(l);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, p ? aW(p, u)(...c) : a(null, ...c);
    }
    s(u, "next");
  }
  function n(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function aW(e, t) {
  let r;
  return n;
  function n(...a) {
    let u = e.length > a.length, l;
    u && a.push(i);
    try {
      l = e.apply(this, a);
    } catch (c) {
      let p = (
        /** @type {Error} */
        c
      );
      if (u && r)
        throw p;
      return i(p);
    }
    u || (l instanceof Promise ? l.then(o, i) : l instanceof Error ? i(l) : o(l));
  }
  function i(a, ...u) {
    r || (r = !0, t(a, ...u));
  }
  function o(a) {
    i(null, a);
  }
}
function Fm(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function _m(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function km(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function t2(e) {
  if (!jm(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function r2(e, t, r) {
  if (!r)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function ql(e) {
  return pW(e) ? e : new x2(e);
}
function pW(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function hW(e) {
  return typeof e == "string" || fW(e);
}
function fW(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
function n2(e) {
  return e !== null && typeof e == "object" && "type" in e && typeof e.type == "string";
}
function ba(e, { enter: t, leave: r }) {
  return new mW(t, r).visit(e, null);
}
function K2(e, t) {
  if (e.type === "MemberExpression")
    return !e.computed && K2(e.object, e);
  if (e.type === "Identifier") {
    if (!t)
      return !0;
    switch (t.type) {
      case "MemberExpression":
        return t.computed || e === t.object;
      case "MethodDefinition":
        return t.computed;
      case "PropertyDefinition":
        return t.computed || e === t.value;
      case "Property":
        return t.computed || e === t.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return e === t.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      default:
        return !0;
    }
  }
  return !1;
}
function Y2(e) {
  let t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new Map(), n = new Ws(null, !1), i = [], o = n;
  ba(e, {
    enter(a, u) {
      switch (a.type) {
        case "Identifier":
          u && K2(a, u) && i.push([o, a]);
          break;
        case "ImportDeclaration":
          a.specifiers.forEach((l) => {
            o.declarations.set(l.local.name, l);
          });
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ArrowFunctionExpression":
          a.type === "FunctionDeclaration" ? (a.id && o.declarations.set(a.id.name, a), t.set(a, o = new Ws(o, !1))) : (t.set(a, o = new Ws(
          o, !1)), a.type === "FunctionExpression" && a.id && o.declarations.set(a.id.name, a)), a.params.forEach((l) => {
            Mm(l).forEach((c) => {
              o.declarations.set(c, a);
            });
          });
          break;
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
          t.set(a, o = new Ws(o, !0));
          break;
        case "BlockStatement":
          t.set(a, o = new Ws(o, !0));
          break;
        case "ClassDeclaration":
        case "VariableDeclaration":
          o.add_declaration(a);
          break;
        case "CatchClause":
          t.set(a, o = new Ws(o, !0)), a.param && Mm(a.param).forEach((l) => {
            a.param && o.declarations.set(l, a.param);
          });
          break;
      }
    },
    leave(a) {
      t.has(a) && o !== null && o.parent && (o = o.parent);
    }
  });
  for (let a = i.length - 1; a >= 0; --a) {
    let [u, l] = i[a];
    u.references.has(l.name) || Q2(u, l.name), u.find_owner(l.name) || r.set(l.name, l);
  }
  return { map: t, scope: n, globals: r };
}
function Q2(e, t) {
  e.references.add(t), e.parent && Q2(e.parent, t);
}
function Mm(e) {
  return Gs(e).map((t) => t.name);
}
function Gs(e, t = []) {
  switch (e.type) {
    case "Identifier":
      t.push(e);
      break;
    case "MemberExpression":
      let r = e;
      for (; r.type === "MemberExpression"; )
        r = /** @type {any} */
        r.object;
      t.push(
        /** @type {any} */
        r
      );
      break;
    case "ObjectPattern":
      let n = /* @__PURE__ */ s((o) => {
        o.type === "RestElement" ? Gs(o.argument, t) : Gs(o.value, t);
      }, "handle_prop");
      e.properties.forEach(n);
      break;
    case "ArrayPattern":
      let i = /* @__PURE__ */ s((o) => {
        o && Gs(o, t);
      }, "handle_element");
      e.elements.forEach((o) => {
        o && i(o);
      });
      break;
    case "RestElement":
      Gs(e.argument, t);
      break;
    case "AssignmentPattern":
      Gs(e.left, t);
      break;
  }
  return t;
}
function oi(e, t) {
  let r = ["start", "end", "loc", "range", "comments"], n = -1;
  for (; ++n < r.length; ) {
    let i = r[n];
    i in e && (t[i] = e[i]);
  }
}
function gW(e) {
  return e.type === "FunctionDeclaration" ? { ...e, type: "FunctionExpression" } : (e.type, { ...e, type: "ClassExpression" });
}
function yW(e) {
  return e.type === "FunctionDeclaration" || e.type === "ClassDeclaration" || e.type === "VariableDeclaration";
}
function Gm(e, t) {
  let r = -1, n = [], i = [], o;
  for (; ++r < e.length; ) {
    let a = e[r];
    a.type === "ImportNamespaceSpecifier" ? o = a : i.push(a);
  }
  if (o) {
    let a = {
      type: "VariableDeclarator",
      id: o.local,
      init: t
    };
    oi(o, a), n.push(a);
  }
  return n.push({
    type: "VariableDeclarator",
    id: {
      type: "ObjectPattern",
      properties: i.map(function(a) {
        let u = a.type === "ImportSpecifier" ? a.imported : a.type === "ExportSpecifier" ? a.exported : { type: "Identifier", name: "default" },
        l = a.local;
        a.type === "ExportSpecifier" && (l = u, u = a.local);
        let c = {
          type: "Property",
          kind: "init",
          shorthand: u.name === l.name,
          method: !1,
          computed: !1,
          key: u,
          value: l
        };
        return oi(a, c), c;
      })
    },
    init: o ? { type: "Identifier", name: o.local.name } : t
  }), n;
}
function ai(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    let n = e[t], i = typeof n == "string" && Nr(n) ? { type: "Identifier", name: n } : { type: "Literal", value: n };
    r = r ? {
      type: "MemberExpression",
      object: r,
      property: i,
      computed: i.type === "Literal",
      optional: !1
    } : i;
  }
  return r.type, r;
}
function i2(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    let n = e[t];
    typeof n == "string" && Nr(n, { jsx: !0 }), "" + n;
    let i = { type: "JSXIdentifier", name: n };
    r = r ? { type: "JSXMemberExpression", object: r, property: i } : i;
  }
  return r;
}
function DW(e) {
  let t = e.baseUrl || void 0, r = typeof t == "object" ? t.href : t, n = e.outputFormat || "program", i = e.pragma === void 0 ? "React.crea\
teElement" : e.pragma, o = e.pragmaFrag === void 0 ? "React.Fragment" : e.pragmaFrag, a = e.pragmaImportSource || "react", u = e.jsxImportSource ||
  "react", l = e.jsxRuntime || "automatic";
  return function(p, h) {
    let f = [], d = [], m = [], g = 0, b, y, E;
    if (l && m.push("@jsxRuntime " + l), l === "automatic" && u && m.push("@jsxImportSource " + u), l === "classic" && i && m.push("@jsx " +
    i), l === "classic" && o && m.push("@jsxFrag " + o), p.comments || (p.comments = []), m.length > 0 && p.comments.unshift({
      type: "Block",
      value: m.join(" "),
      data: { _mdxIsPragmaComment: !0 }
    }), l === "classic" && a) {
      if (!i)
        throw new Error(
          "Missing `pragma` in classic runtime with `pragmaImportSource`"
        );
      w({
        type: "ImportDeclaration",
        specifiers: [
          {
            type: "ImportDefaultSpecifier",
            local: { type: "Identifier", name: i.split(".")[0] }
          }
        ],
        source: { type: "Literal", value: a }
      });
    }
    for (E of p.body)
      if (E.type === "ExportDefaultDeclaration")
        b && h.fail(
          "Unexpected duplicate layout, expected a single layout (previous: " + br(Bn(b)) + ")",
          {
            ancestors: [p, E],
            place: Bn(E),
            ruleId: "duplicate-layout",
            source: "recma-document"
          }
        ), b = E, d.push({
          type: "VariableDeclaration",
          kind: "const",
          declarations: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "MDXLayout" },
              init: yW(E.declaration) ? gW(E.declaration) : E.declaration
            }
          ]
        });
      else if (E.type === "ExportNamedDeclaration" && E.source) {
        let C = (
          /** @type {SimpleLiteral} */
          E.source
        );
        E.specifiers = E.specifiers.filter(function(T) {
          if (T.exported.name === "default") {
            b && h.fail(
              "Unexpected duplicate layout, expected a single layout (previous: " + br(Bn(b)) + ")",
              {
                ancestors: [p, E, T],
                place: Bn(E),
                ruleId: "duplicate-layout",
                source: "recma-document"
              }
            ), b = T;
            let F = [];
            if (T.local.name === "default")
              F.push({
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name: "MDXLayout" }
              });
            else {
              let U = {
                type: "ImportSpecifier",
                imported: T.local,
                local: { type: "Identifier", name: "MDXLayout" }
              };
              oi(T.local, U), F.push(U);
            }
            let $ = { type: "Literal", value: C.value };
            oi(C, $);
            let R = {
              type: "ImportDeclaration",
              specifiers: F,
              source: $
            };
            return oi(T, R), w(R), !1;
          }
          return !0;
        }), E.specifiers.length > 0 && O(E);
      } else E.type === "ExportNamedDeclaration" || E.type === "ExportAllDeclaration" ? O(E) : E.type === "ImportDeclaration" ? w(E) : E.type ===
      "ExpressionStatement" && (E.expression.type === "JSXElement" || // @ts-expect-error: `estree-jsx` does not register `JSXFragment` as an expression.
      E.expression.type === "JSXFragment") ? (y = !0, d.push(
        ...c(E.expression, n, !!b)
      )) : d.push(E);
    y || d.push(
      ...c(void 0, n, !!b)
    ), f.push(["MDXContent", "default"]), n === "function-body" && d.push({
      type: "ReturnStatement",
      argument: {
        type: "ObjectExpression",
        properties: [
          ...Array.from({ length: g }).map(
            /**
             * @param {undefined} _
             *   Nothing.
             * @param {number} index
             *   Index.
             * @returns {SpreadElement}
             *   Node.
             */
            function(C, T) {
              return {
                type: "SpreadElement",
                argument: {
                  type: "Identifier",
                  name: "_exportAll" + (T + 1)
                }
              };
            }
          ),
          ...f.map(function(C) {
            return {
              type: "Property",
              kind: "init",
              method: !1,
              computed: !1,
              shorthand: typeof C == "string",
              key: {
                type: "Identifier",
                name: typeof C == "string" ? C : C[1]
              },
              value: {
                type: "Identifier",
                name: typeof C == "string" ? C : C[0]
              }
            };
          })
        ]
      }
    }), p.body = d;
    let A = !1, k = !1;
    (r || n === "function-body") && ba(p, {
      enter(C) {
        if ((C.type === "ExportAllDeclaration" || C.type === "ExportNamedDeclaration" || C.type === "ImportDeclaration") && C.source) {
          let T = C.source.value;
          try {
            new URL(T);
          } catch {
            (T.startsWith("/") || T.startsWith("./") || T.startsWith("../")) && (T = new URL(T, r).href);
          }
          let F = { type: "Literal", value: T };
          oi(C.source, F), C.source = F;
          return;
        }
        if (C.type === "ImportExpression") {
          k = !0;
          let T = {
            type: "CallExpression",
            callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
            arguments: [C.source],
            optional: !1
          };
          C.source = T;
          return;
        }
        if (C.type === "MemberExpression" && "object" in C && C.object.type === "MetaProperty" && C.property.type === "Identifier" && C.object.
        meta.name === "import" && C.object.property.name === "meta" && C.property.name === "url") {
          A = !0;
          let T = { type: "Identifier", name: "_importMetaUrl" };
          oi(C, T), this.replace(T);
        }
      }
    }), k && (r || (A = !0), p.body.push(
      xW(
        r ? { type: "Literal", value: r } : { type: "Identifier", name: "_importMetaUrl" }
      )
    )), A && p.body.unshift(...bW());
    function O(C) {
      if (C.type === "ExportNamedDeclaration") {
        C.declaration && f.push(
          ...Y2(C.declaration).scope.declarations.keys()
        );
        for (E of C.specifiers)
          f.push(E.exported.name);
      }
      w(C);
    }
    s(O, "handleExport");
    function w(C) {
      let T, F;
      if (n === "function-body")
        if (
          // Always have a source:
          C.type === "ImportDeclaration" || C.type === "ExportAllDeclaration" || // Source optional:
          C.type === "ExportNamedDeclaration" && C.source
        ) {
          C.source;
          let $ = { type: "ImportExpression", source: C.source };
          oi(C, $), F = { type: "AwaitExpression", argument: $ }, (C.type === "ImportDeclaration" || C.type === "ExportNamedDeclaration") &&
          C.specifiers.length === 0 ? T = { type: "ExpressionStatement", expression: F } : T = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: C.type === "ExportAllDeclaration" ? [
              {
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: "_exportAll" + ++g
                },
                init: F
              }
            ] : Gm(C.specifiers, F)
          };
        } else if (C.declaration)
          T = C.declaration;
        else {
          let $ = C.specifiers.filter(function(R) {
            return R.local.name !== R.exported.name;
          }).map(function(R) {
            return {
              type: "VariableDeclarator",
              id: R.exported,
              init: R.local
            };
          });
          $.length > 0 && (T = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: $
          });
        }
      else
        T = C;
      T && d.push(T);
    }
    s(w, "handleEsm");
  };
  function c(p, h, f) {
    let m = {
      type: "JSXElement",
      openingElement: {
        type: "JSXOpeningElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" },
        attributes: [
          {
            type: "JSXSpreadAttribute",
            argument: { type: "Identifier", name: "props" }
          }
        ],
        selfClosing: !1
      },
      closingElement: {
        type: "JSXClosingElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" }
      },
      children: [
        {
          type: "JSXElement",
          openingElement: {
            type: "JSXOpeningElement",
            name: { type: "JSXIdentifier", name: "_createMdxContent" },
            attributes: [
              {
                type: "JSXSpreadAttribute",
                argument: { type: "Identifier", name: "props" }
              }
            ],
            selfClosing: !0
          },
          closingElement: null,
          children: []
        }
      ]
    };
    f || (m = {
      type: "ConditionalExpression",
      test: { type: "Identifier", name: "MDXLayout" },
      consequent: m,
      alternate: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "_createMdxContent" },
        arguments: [{ type: "Identifier", name: "props" }],
        optional: !1
      }
    });
    let g = (
      // Cast because TS otherwise does not think `JSXFragment`s are expressions.
      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */
      p || { type: "Identifier", name: "undefined" }
    );
    g.type === "JSXFragment" && g.children.length === 1 && g.children[0].type === "JSXElement" && (g = g.children[0]);
    let b = !1;
    ba(g, {
      enter(E) {
        if (E.type === "ArrowFunctionExpression" || E.type === "FunctionDeclaration" || E.type === "FunctionExpression")
          return this.skip();
        (E.type === "AwaitExpression" || /* c8 ignore next 2 -- can only occur in a function (which then can
        * only be async, so skipped it) */
        E.type === "ForOfStatement" && E.await) && (b = !0);
      }
    });
    let y = {
      type: "FunctionDeclaration",
      id: { type: "Identifier", name: "MDXContent" },
      params: [
        {
          type: "AssignmentPattern",
          left: { type: "Identifier", name: "props" },
          right: { type: "ObjectExpression", properties: [] }
        }
      ],
      body: {
        type: "BlockStatement",
        body: [{ type: "ReturnStatement", argument: m }]
      }
    };
    return [
      {
        type: "FunctionDeclaration",
        async: b,
        id: { type: "Identifier", name: "_createMdxContent" },
        params: [{ type: "Identifier", name: "props" }],
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ReturnStatement",
              // Cast because TS doesnt think `JSXFragment` is an expression.
              // eslint-disable-next-line object-shorthand
              argument: (
                /** @type {Expression} */
                g
              )
            }
          ]
        }
      },
      h === "program" ? { type: "ExportDefaultDeclaration", declaration: y } : y
    ];
  }
}
function xW(e) {
  return {
    type: "FunctionDeclaration",
    id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
    generator: !1,
    async: !1,
    params: [{ type: "Identifier", name: "d" }],
    body: {
      type: "BlockStatement",
      body: [
        {
          type: "IfStatement",
          test: {
            type: "BinaryExpression",
            left: {
              type: "UnaryExpression",
              operator: "typeof",
              prefix: !0,
              argument: { type: "Identifier", name: "d" }
            },
            operator: "!==",
            right: { type: "Literal", value: "string" }
          },
          consequent: {
            type: "ReturnStatement",
            argument: { type: "Identifier", name: "d" }
          },
          alternate: null
        },
        // To do: use `URL.canParse` when widely supported (see commented
        // out code below).
        {
          type: "TryStatement",
          block: {
            type: "BlockStatement",
            body: [
              {
                type: "ExpressionStatement",
                expression: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "URL" },
                  arguments: [{ type: "Identifier", name: "d" }]
                }
              },
              {
                type: "ReturnStatement",
                argument: { type: "Identifier", name: "d" }
              }
            ]
          },
          handler: {
            type: "CatchClause",
            param: null,
            body: { type: "BlockStatement", body: [] }
          },
          finalizer: null
        },
        // To do: use `URL.canParse` when widely supported.
        // {
        //   type: 'IfStatement',
        //   test: {
        //     type: 'CallExpression',
        //     callee: toIdOrMemberExpression(['URL', 'canParse']),
        //     arguments: [{type: 'Identifier', name: 'd'}],
        //     optional: false
        //   },
        //   consequent: {
        //     type: 'ReturnStatement',
        //     argument: {type: 'Identifier', name: 'd'}
        //   },
        //   alternate: null
        // },
        {
          type: "IfStatement",
          test: {
            type: "LogicalExpression",
            left: {
              type: "LogicalExpression",
              left: {
                type: "CallExpression",
                callee: ai(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "/" }],
                optional: !1
              },
              operator: "||",
              right: {
                type: "CallExpression",
                callee: ai(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "./" }],
                optional: !1
              }
            },
            operator: "||",
            right: {
              type: "CallExpression",
              callee: ai(["d", "startsWith"]),
              arguments: [{ type: "Literal", value: "../" }],
              optional: !1
            }
          },
          consequent: {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "URL" },
                arguments: [{ type: "Identifier", name: "d" }, e]
              },
              property: { type: "Identifier", name: "href" },
              computed: !1,
              optional: !1
            }
          },
          alternate: null
        },
        {
          type: "ReturnStatement",
          argument: { type: "Identifier", name: "d" }
        }
      ]
    }
  };
}
function bW() {
  return [
    {
      type: "VariableDeclaration",
      declarations: [
        {
          type: "VariableDeclarator",
          id: { type: "Identifier", name: "_importMetaUrl" },
          init: ai(["arguments", 0, "baseUrl"])
        }
      ],
      kind: "const"
    },
    {
      type: "IfStatement",
      test: {
        type: "UnaryExpression",
        operator: "!",
        prefix: !0,
        argument: { type: "Identifier", name: "_importMetaUrl" }
      },
      consequent: {
        type: "ThrowStatement",
        argument: {
          type: "NewExpression",
          callee: { type: "Identifier", name: "Error" },
          arguments: [
            {
              type: "Literal",
              value: "Unexpected missing `options.baseUrl` needed to support `export \u2026 from`, `import`, or `import.meta.url` when generating\
 `function-body`"
            }
          ]
        }
      },
      alternate: null
    }
  ];
}
function vW(e, t) {
  let r = t || {}, n = r.runtime === "automatic", i = {}, o = {};
  ba(e, {
    enter(a) {
      if (a.type === "Program") {
        let u = a.comments || [], l = -1;
        for (; ++l < u.length; ) {
          Tm.lastIndex = 0;
          let c = Tm.exec(u[l].value);
          for (; c; )
            i[c[1]] = c[2], c = Tm.exec(u[l].value);
        }
        if (i.jsxRuntime)
          if (i.jsxRuntime === "automatic") {
            if (n = !0, i.jsx)
              throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");
            if (i.jsxFrag)
              throw new Error(
                "Unexpected `@jsxFrag` pragma w/ automatic runtime"
              );
          } else if (i.jsxRuntime === "classic") {
            if (n = !1, i.jsxImportSource)
              throw new Error(
                "Unexpected `@jsxImportSource` w/ classic runtime"
              );
          } else
            throw new Error(
              "Unexpected `jsxRuntime` `" + i.jsxRuntime + "`, expected `automatic` or `classic`"
            );
      }
    },
    // eslint-disable-next-line complexity
    leave(a) {
      if (a.type === "Program") {
        let g = [];
        if (o.fragment && g.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "Fragment" },
          local: { type: "Identifier", name: "_Fragment" }
        }), o.jsx && g.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsx" },
          local: { type: "Identifier", name: "_jsx" }
        }), o.jsxs && g.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxs" },
          local: { type: "Identifier", name: "_jsxs" }
        }), o.jsxDEV && g.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxDEV" },
          local: { type: "Identifier", name: "_jsxDEV" }
        }), g.length > 0) {
          let b = 0;
          for (; b < a.body.length; ) {
            let y = a.body[b];
            if ("directive" in y && y.directive)
              b++;
            else
              break;
          }
          a.body.splice(b, 0, {
            type: "ImportDeclaration",
            specifiers: g,
            source: {
              type: "Literal",
              value: (i.jsxImportSource || r.importSource || "react") + (r.development ? "/jsx-dev-runtime" : "/jsx-runtime")
            }
          });
        }
      }
      if (a.type !== "JSXElement" && a.type !== "JSXFragment")
        return;
      let u = [], l = -1;
      for (; ++l < a.children.length; ) {
        let g = a.children[l];
        if (g.type === "JSXExpressionContainer")
          g.expression.type !== "JSXEmptyExpression" && u.push(g.expression);
        else if (g.type === "JSXText") {
          let b = g.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " ");
          if (b) {
            let y = { type: "Literal", value: b };
            Da(g, y), u.push(y);
          }
        } else
          g.type !== "JSXElement" && g.type !== "JSXFragment" && g.type, u.push(g);
      }
      let c, p = [], h = [], f;
      if (a.type === "JSXElement") {
        if (c = Jl(a.openingElement.name), c.type === "Identifier" && /^[a-z]/.test(c.name)) {
          let E = { type: "Literal", value: c.name };
          Da(c, E), c = E;
        }
        let g, b = a.openingElement.attributes, y = -1;
        for (; ++y < b.length; ) {
          let E = b[y];
          if (E.type === "JSXSpreadAttribute")
            E.argument.type === "ObjectExpression" ? p.push(...E.argument.properties) : p.push({ type: "SpreadElement", argument: E.argument }),
            g = !0;
          else {
            let A = EW(E);
            if (n && A.key.type === "Identifier" && A.key.name === "key") {
              if (g)
                throw new Error(
                  "Expected `key` to come before any spread expressions"
                );
              let k = A.value;
              k.type !== "AssignmentPattern" && k.type !== "ArrayPattern" && k.type !== "ObjectPattern" && k.type, f = k;
            } else
              p.push(A);
          }
        }
      } else n ? (o.fragment = !0, c = { type: "Identifier", name: "_Fragment" }) : c = s2(
        i.jsxFrag || r.pragmaFrag || "React.Fragment"
      );
      n ? u.length > 0 && p.push({
        type: "Property",
        key: { type: "Identifier", name: "children" },
        value: u.length > 1 ? { type: "ArrayExpression", elements: u } : u[0],
        kind: "init",
        method: !1,
        shorthand: !1,
        computed: !1
      }) : h = u;
      let d;
      if (n) {
        h.push({ type: "ObjectExpression", properties: p }), f ? h.push(f) : r.development && h.push({ type: "Identifier", name: "undefined" });
        let g = u.length > 1;
        if (r.development) {
          o.jsxDEV = !0, d = {
            type: "Identifier",
            name: "_jsxDEV"
          }, h.push({ type: "Literal", value: g });
          let b = {
            type: "ObjectExpression",
            properties: [
              {
                type: "Property",
                method: !1,
                shorthand: !1,
                computed: !1,
                kind: "init",
                key: { type: "Identifier", name: "fileName" },
                value: {
                  type: "Literal",
                  value: r.filePath || "<source.js>"
                }
              }
            ]
          };
          a.loc && b.properties.push(
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "lineNumber" },
              value: { type: "Literal", value: a.loc.start.line }
            },
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "columnNumber" },
              value: { type: "Literal", value: a.loc.start.column + 1 }
            }
          ), h.push(b, { type: "ThisExpression" });
        } else g ? (o.jsxs = !0, d = { type: "Identifier", name: "_jsxs" }) : (o.jsx = !0, d = { type: "Identifier", name: "_jsx" });
      } else
        p.length > 0 ? h.unshift({ type: "ObjectExpression", properties: p }) : h.length > 0 && h.unshift({ type: "Literal", value: null }),
        d = s2(
          i.jsx || r.pragma || "React.createElement"
        );
      h.unshift(c);
      let m = {
        type: "CallExpression",
        callee: d,
        arguments: h,
        optional: !1
      };
      Da(a, m), this.replace(m);
    }
  });
}
function EW(e) {
  let t;
  if (e.value)
    if (e.value.type === "JSXExpressionContainer") {
      let n = e.value.expression;
      n.type, t = n;
    } else {
      let n = e.value;
      n.type !== "JSXElement" && n.type, t = n, delete t.raw;
    }
  else
    t = { type: "Literal", value: !0 };
  let r = {
    type: "Property",
    key: Jl(e.name),
    value: t,
    kind: "init",
    method: !1,
    shorthand: !1,
    computed: !1
  };
  return Da(e, r), r;
}
function Jl(e) {
  let t;
  if (e.type === "JSXMemberExpression") {
    let r = Jl(e.property);
    t = {
      type: "MemberExpression",
      object: Jl(e.object),
      property: r,
      computed: r.type === "Literal",
      optional: !1
    };
  } else e.type === "JSXNamespacedName" ? t = {
    type: "Literal",
    value: e.namespace.name + ":" + e.name.name
  } : t = Nr(e.name) ? { type: "Identifier", name: e.name } : { type: "Literal", value: e.name };
  return Da(e, t), t;
}
function s2(e) {
  let t = e.split("."), r = -1, n;
  for (; ++r < t.length; ) {
    let i = Nr(t[r]) ? { type: "Identifier", name: t[r] } : { type: "Literal", value: t[r] };
    n = n ? {
      type: "MemberExpression",
      object: n,
      property: i,
      computed: !!(r && i.type === "Literal"),
      optional: !1
    } : i;
  }
  return n;
}
function Da(e, t) {
  let r = ["start", "end", "loc", "range", "comments"], n = -1;
  for (; ++n < r.length; ) {
    let i = r[n];
    i in e && (t[i] = e[i]);
  }
}
function CW(e) {
  let { development: t, outputFormat: r } = e || {};
  return function(n, i) {
    if (vW(n, { development: t, filePath: i.history[0] }), n.comments && n.comments[0].type === "Block" && n.comments[0].data && n.comments[0].
    data._mdxIsPragmaComment && n.comments.shift(), r === "function-body") {
      let o = 0;
      for (; o < n.body.length; ) {
        let u = n.body[o];
        if ("directive" in u && u.directive)
          o++;
        else
          break;
      }
      let a = n.body[o];
      a && a.type === "ImportDeclaration" && typeof a.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(a.source.value) && (n.body[o] =
      {
        type: "VariableDeclaration",
        kind: "const",
        declarations: Gm(
          a.specifiers,
          ai(["arguments", 0])
        )
      });
    }
  };
}
function o2(e) {
  let t = -1, r;
  for (; ++t < e.length; ) {
    let n = e[t];
    r = r ? { type: "BinaryExpression", left: r, operator: "+", right: n } : n;
  }
  return r;
}
function wW(e) {
  let { development: t, outputFormat: r, providerImportSource: n } = e;
  return function(i, o) {
    let a = Y2(i), u = [], l = !1, c = !1, p;
    if (ba(i, {
      enter(h) {
        let f = (
          /** @type {Scope | undefined} */
          a.map.get(h)
        );
        (h.type === "FunctionDeclaration" || h.type === "FunctionExpression" || h.type === "ArrowFunctionExpression") && (u.push({
          components: [],
          idToInvalidComponentName: /* @__PURE__ */ new Map(),
          node: h,
          objects: [],
          references: {},
          tags: []
        }), zs(h, "MDXContent") && f && !Im(f, "MDXLayout") && u[0].components.push("MDXLayout"));
        let d = u[0];
        if (!(!d || !zs(d.node, "_createMdxContent") && !n) && (f && (f.node = h, p = f), p && h.type === "JSXElement")) {
          let m = h.openingElement.name;
          if (m.type === "JSXMemberExpression") {
            let g = [];
            for (; m.type === "JSXMemberExpression"; )
              g.unshift(m.property.name), m = m.object;
            g.unshift(m.name);
            let b = g.join("."), y = m.name, E = Im(p, y);
            if (!Object.hasOwn(d.references, b)) {
              let A = (
                /** @type {Scope | undefined} */
                p.parent
              );
              (!E || // If the parent scope is `_createMdxContent`, then this
              // references a component we can add a check statement for.
              A && A.node.type === "FunctionDeclaration" && zs(A.node, "_createMdxContent")) && (d.references[b] = { component: !0, node: h });
            }
            !d.objects.includes(y) && !E && d.objects.push(y);
          } else if (m.type !== "JSXNamespacedName") {
            if (Nr(m.name) && !/^[a-z]/.test(m.name)) {
              let g = m.name;
              Im(p, g) || (g !== "MDXLayout" && !Object.hasOwn(d.references, g) && (d.references[g] = { component: !0, node: h }), d.components.
              includes(g) || d.components.push(g));
            } else if (!(h.data && h.data._mdxExplicitJsx)) {
              let g = m.name;
              d.tags.includes(g) || d.tags.push(g);
              let b = ["_components", g];
              if (Nr(g) === !1) {
                let y = d.idToInvalidComponentName.get(g);
                y === void 0 && (y = `_component${d.idToInvalidComponentName.size}`, d.idToInvalidComponentName.set(g, y)), b = [y];
              }
              h.openingElement.name = i2(b), h.closingElement && (h.closingElement.name = i2(b));
            }
          }
        }
      },
      leave(h) {
        let f = [], d = [], m = [], g = [];
        if (p && p.node === h && (p = /** @type {Scope} */
        p.parent), h.type === "FunctionDeclaration" || h.type === "FunctionExpression" || h.type === "ArrowFunctionExpression") {
          let b = h, y = u[u.length - 1], E;
          for (E of y.tags.sort())
            f.push({
              type: "Property",
              kind: "init",
              key: Nr(E) ? { type: "Identifier", name: E } : { type: "Literal", value: E },
              value: { type: "Literal", value: E },
              method: !1,
              shorthand: !1,
              computed: !1
            });
          d.push(...y.components);
          for (E of y.objects)
            d.includes(E) || d.push(E);
          d.sort();
          let A = [];
          if (f.length > 0 || d.length > 0 || y.idToInvalidComponentName.size > 0) {
            if (n && (l = !0, m.push({
              type: "CallExpression",
              callee: { type: "Identifier", name: "_provideComponents" },
              arguments: [],
              optional: !1
            })), (zs(y.node, "MDXContent") || zs(y.node, "_createMdxContent")) && m.push(ai(["props", "components"])), f.length > 0 || m.length >
            1)
              for (let F of m)
                f.push({ type: "SpreadElement", argument: F });
            let C = f.length > 0 ? { type: "ObjectExpression", properties: f } : (
              // If were only getting components from `props.components`,
              // make sure its defined.
              {
                type: "LogicalExpression",
                operator: "||",
                left: m[0],
                right: { type: "ObjectExpression", properties: [] }
              }
            ), T;
            if (d.length > 0 && (T = {
              type: "ObjectPattern",
              properties: d.map(function(F) {
                return {
                  type: "Property",
                  kind: "init",
                  key: {
                    type: "Identifier",
                    name: F === "MDXLayout" ? "wrapper" : F
                  },
                  value: { type: "Identifier", name: F },
                  method: !1,
                  shorthand: F !== "MDXLayout",
                  computed: !1
                };
              })
            }), y.tags.length > 0 && (g.push({
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "_components" },
              init: C
            }), C = { type: "Identifier", name: "_components" }), zs(y.node, "_createMdxContent"))
              for (let [F, $] of [
                ...y.idToInvalidComponentName
              ].sort(function([R], [U]) {
                return R.localeCompare(U);
              }))
                g.push({
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name: $
                  },
                  init: {
                    type: "MemberExpression",
                    object: { type: "Identifier", name: "_components" },
                    property: { type: "Literal", value: F },
                    computed: !0,
                    optional: !1
                  }
                });
            T && g.push({
              type: "VariableDeclarator",
              id: T,
              init: C
            }), g.length > 0 && A.push({
              type: "VariableDeclaration",
              kind: "const",
              declarations: g
            });
          }
          let k;
          for (k in y.references)
            if (Object.hasOwn(y.references, k)) {
              let C = k.split("."), T = 0;
              for (; ++T < C.length; ) {
                let F = C.slice(0, T).join(".");
                Object.hasOwn(y.references, F) || (y.references[F] = {
                  component: !1,
                  node: y.references[k].node
                });
              }
            }
          let O = Object.keys(y.references).sort(), w = -1;
          for (; ++w < O.length; ) {
            let C = O[w], T = y.references[C], F = br(Bn(T.node)), $ = [
              { type: "Literal", value: C },
              { type: "Literal", value: T.component }
            ];
            c = !0, t && F && $.push({ type: "Literal", value: F }), A.push({
              type: "IfStatement",
              test: {
                type: "UnaryExpression",
                operator: "!",
                prefix: !0,
                argument: ai(C.split("."))
              },
              consequent: {
                type: "ExpressionStatement",
                expression: {
                  type: "CallExpression",
                  callee: { type: "Identifier", name: "_missingMdxReference" },
                  arguments: $,
                  optional: !1
                }
              },
              alternate: void 0
            });
          }
          A.length > 0 && (b.body.type !== "BlockStatement" && (b.body = {
            type: "BlockStatement",
            body: [{ type: "ReturnStatement", argument: b.body }]
          }), b.body.body.unshift(...A)), u.pop();
        }
      }
    }), l && n && i.body.unshift(
      SW(n, r)
    ), c) {
      let h = [
        { type: "Literal", value: "Expected " },
        {
          type: "ConditionalExpression",
          test: { type: "Identifier", name: "component" },
          consequent: { type: "Literal", value: "component" },
          alternate: { type: "Literal", value: "object" }
        },
        { type: "Literal", value: " `" },
        { type: "Identifier", name: "id" },
        {
          type: "Literal",
          value: "` to be defined: you likely forgot to import, pass, or provide it."
        }
      ], f = [
        { type: "Identifier", name: "id" },
        { type: "Identifier", name: "component" }
      ];
      t && (h.push({
        type: "ConditionalExpression",
        test: { type: "Identifier", name: "place" },
        consequent: o2([
          { type: "Literal", value: "\nIt\u2019s referenced in your code at `" },
          { type: "Identifier", name: "place" },
          {
            type: "Literal",
            value: (o.path ? "` in `" + o.path : "") + "`"
          }
        ]),
        alternate: { type: "Literal", value: "" }
      }), f.push({ type: "Identifier", name: "place" })), i.body.push({
        type: "FunctionDeclaration",
        id: { type: "Identifier", name: "_missingMdxReference" },
        generator: !1,
        async: !1,
        params: f,
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ThrowStatement",
              argument: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "Error" },
                arguments: [o2(h)]
              }
            }
          ]
        }
      });
    }
    r === "function-body" && i.body.unshift({
      type: "ExpressionStatement",
      expression: { type: "Literal", value: "use strict" },
      directive: "use strict"
    });
  };
}
function SW(e, t) {
  let r = [
    {
      type: "ImportSpecifier",
      imported: { type: "Identifier", name: "useMDXComponents" },
      local: { type: "Identifier", name: "_provideComponents" }
    }
  ];
  return t === "function-body" ? {
    type: "VariableDeclaration",
    kind: "const",
    declarations: Gm(
      r,
      ai(["arguments", 0])
    )
  } : {
    type: "ImportDeclaration",
    specifiers: r,
    source: { type: "Literal", value: e }
  };
}
function zs(e, t) {
  return !!(e && "id" in e && e.id && e.id.name === t);
}
function Im(e, t) {
  let r = e;
  for (; r; ) {
    if (r.declarations.has(t))
      return !0;
    r = /** @type {Scope | undefined} */
    r.parent || void 0;
  }
  return !1;
}
function Hs(e, t) {
  let { generator: r } = e;
  if (e.write("("), t != null && t.length > 0) {
    r[t[0].type](t[0], e);
    let { length: n } = t;
    for (let i = 1; i < n; i++) {
      let o = t[i];
      e.write(", "), r[o.type](o, e);
    }
  }
  e.write(")");
}
function eS(e, t, r, n) {
  let i = e.expressionsPrecedence[t.type];
  if (i === Mr)
    return !0;
  let o = e.expressionsPrecedence[r.type];
  return i !== o ? !n && i === 15 && o === 14 && r.operator === "**" || i < o : i !== 13 && i !== 14 ? !1 : t.operator === "**" && r.operator ===
  "**" ? !n : i === 13 && o === 13 && (t.operator === "??" || r.operator === "??") ? !0 : n ? $l[t.operator] <= $l[r.operator] : $l[t.operator] <
  $l[r.operator];
}
function Vl(e, t, r, n) {
  let { generator: i } = e;
  eS(e, t, r, n) ? (e.write("("), i[t.type](t, e), e.write(")")) : i[t.type](t, e);
}
function _W(e, t, r, n) {
  let i = t.split(`
`), o = i.length - 1;
  if (e.write(i[0].trim()), o > 0) {
    e.write(n);
    for (let a = 1; a < o; a++)
      e.write(r + i[a].trim() + n);
    e.write(r + i[o].trim());
  }
}
function Nt(e, t, r, n) {
  let { length: i } = t;
  for (let o = 0; o < i; o++) {
    let a = t[o];
    e.write(r), a.type[0] === "L" ? e.write("// " + a.value.trim() + `
`, a) : (e.write("/*"), _W(e, a.value, r, n), e.write("*/" + n));
  }
}
function kW(e) {
  let t = e;
  for (; t != null; ) {
    let { type: r } = t;
    if (r[0] === "C" && r[1] === "a")
      return !0;
    if (r[0] === "M" && r[1] === "e" && r[2] === "m")
      t = t.object;
    else
      return !1;
  }
}
function Pm(e, t) {
  let { generator: r } = e, { declarations: n } = t;
  e.write(t.kind + " ");
  let { length: i } = n;
  if (i > 0) {
    r.VariableDeclarator(n[0], e);
    for (let o = 1; o < i; o++)
      e.write(", "), r.VariableDeclarator(n[o], e);
  }
}
function PW(e, t) {
  let r = new IW(t);
  return r.generator[e.type](e, r), r.output;
}
function f2(e, t) {
  let { SourceMapGenerator: r, filePath: n, handlers: i } = t || BW, o = r ? new r({ file: n || "<unknown>.js" }) : void 0, a = PW(
    e,
    // @ts-expect-error: `sourceMap` can be undefined, `astring` types are buggy.
    {
      comments: !0,
      generator: { ...tS, ...i },
      sourceMap: o || void 0
    }
  ), u = o ? o.toJSON() : void 0;
  return { value: a, map: u };
}
function OW(e, t) {
  this[e.name.type](e.name, t), e.value !== null && e.value !== void 0 && (t.write("="), e.value.type === "Literal" ? t.write(
    '"' + rS(String(e.value.value)).replace(/"/g, "&quot;") + '"',
    e
  ) : this[e.value.type](e.value, t));
}
function RW(e, t) {
  t.write("</"), this[e.name.type](e.name, t), t.write(">");
}
function NW(e, t) {
  t.write("</>", e);
}
function LW(e, t) {
  let r = -1;
  if (this[e.openingElement.type](e.openingElement, t), e.children)
    for (; ++r < e.children.length; ) {
      let n = e.children[r];
      if (n.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[n.type](n, t);
    }
  e.closingElement && this[e.closingElement.type](e.closingElement, t);
}
function jW() {
}
function MW(e, t) {
  t.write("{"), this[e.expression.type](e.expression, t), t.write("}");
}
function qW(e, t) {
  let r = -1;
  if (this[e.openingFragment.type](e.openingFragment, t), e.children)
    for (; ++r < e.children.length; ) {
      let n = e.children[r];
      if (n.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[n.type](n, t);
    }
  this[e.closingFragment.type](e.closingFragment, t);
}
function $W(e, t) {
  t.write(e.name, e);
}
function VW(e, t) {
  this[e.object.type](e.object, t), t.write("."), this[e.property.type](e.property, t);
}
function UW(e, t) {
  this[e.namespace.type](e.namespace, t), t.write(":"), this[e.name.type](e.name, t);
}
function WW(e, t) {
  let r = -1;
  if (t.write("<"), this[e.name.type](e.name, t), e.attributes)
    for (; ++r < e.attributes.length; )
      t.write(" "), this[e.attributes[r].type](e.attributes[r], t);
  t.write(e.selfClosing ? " />" : ">");
}
function zW(e, t) {
  t.write("<>", e);
}
function HW(e, t) {
  t.write("{"), this.SpreadElement(e, t), t.write("}");
}
function GW(e, t) {
  t.write(rS(e.value).replace(/[<>{}]/g, JW), e);
}
function rS(e) {
  return e.replace(/&(?=[#a-z])/gi, "&amp;");
}
function JW(e) {
  return e === "<" ? "&lt;" : e === ">" ? "&gt;" : e === "{" ? "&#123;" : "&#125;";
}
function ZW(e) {
  let t = (
    /** @type {Processor} */
    this
  ), { SourceMapGenerator: r } = e;
  t.compiler = n;
  function n(i, o) {
    let a = r ? f2(i, {
      SourceMapGenerator: r,
      filePath: o.path || "unknown.mdx",
      handlers: d2
    }) : f2(i, { handlers: d2 });
    return o.map = a.map, a.value;
  }
  s(n, "compiler2");
}
function XW(e) {
  return function(t) {
    return Al(t, e);
  };
}
function KW() {
  return function(e) {
    Hm(e, "raw", function(t, r, n) {
      if (n && typeof r == "number")
        return n.children.splice(r, 1), r;
    });
  };
}
function ez(e, t) {
  t ? typeof t == "string" && (t = { style: t }) : t = {};
  let r = t.preserveLineEndings ? tz : rz;
  return String(e).replace(
    t.style === "html" ? QW : YW,
    t.trim ? nz(r) : r
  );
}
function tz(e) {
  let t = /\r?\n|\r/.exec(e);
  return t ? t[0] : " ";
}
function rz() {
  return " ";
}
function nz(e) {
  return t;
  function t(r, n, i) {
    return n === 0 || n + r.length === i.length ? "" : e(r);
  }
}
function iz() {
  return function(e) {
    Hm(e, function(t, r, n) {
      let i = -1, o = !0, a = !1;
      if (n && typeof r == "number" && t.type === "paragraph") {
        let u = t.children;
        for (; ++i < u.length; ) {
          let l = u[i];
          if (l.type === "mdxJsxTextElement" || l.type === "mdxTextExpression")
            a = !0;
          else if (!(l.type === "text" && ez(l.value, { style: "html", trim: !0 }) === "")) {
            o = !1;
            break;
          }
        }
        if (o && a) {
          i = -1;
          let l = [];
          for (; ++i < u.length; ) {
            let c = u[i];
            c.type === "mdxJsxTextElement" && (c.type = "mdxJsxFlowElement"), c.type === "mdxTextExpression" && (c.type = "mdxFlowExpression"),
            c.type === "text" && /^[\t\r\n ]+$/.test(String(c.value)) || l.push(c);
          }
          return n.children.splice(r, 1, ...l), r;
        }
      }
      if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") {
        let u = t.data || (t.data = {});
        u._mdxExplicitJsx = !0;
      }
    });
  };
}
function Jm(e) {
  let t = e || {}, r = -1;
  for (; ++r < m2.length; ) {
    let o = m2[r];
    o in t && ("" + o, void 0);
  }
  t.format === "detect" && void 0, (t.jsxRuntime === "classic" || t.pragma || t.pragmaFrag || t.pragmaImportSource) && !g2 && (g2 = !0, console.
  warn(
    "Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating\
/v3/> on how to migrate"
  ));
  let n = cW().use(lU);
  t.format !== "md" && n.use(FV);
  let i = t.remarkRehypeOptions || {};
  return n.use(iz).use(t.remarkPlugins || []).use(sW, {
    ...i,
    allowDangerousHtml: !0,
    passThrough: [...i.passThrough || [], ...nS]
  }).use(t.rehypePlugins || []), t.format === "md" && n.use(KW), n.use(XW, t).use(DW, t).use(wW, t), t.jsx || n.use(CW, t), n.use(ZW, t).use(
  t.recmaPlugins || []), n;
}
function iS(e, t) {
  let { file: r, options: n } = b2(e, t);
  return Jm(n).process(r);
}
function sS(e, t) {
  let { file: r, options: n } = b2(e, t);
  return Jm(n).processSync(r);
}
function oS(e) {
  let {
    Fragment: t,
    baseUrl: r,
    development: n,
    jsx: i,
    jsxDEV: o,
    jsxs: a,
    useMDXComponents: u,
    ...l
  } = e || {};
  if (!t)
    throw new Error("Expected `Fragment` given to `evaluate`");
  if (n) {
    if (!o)
      throw new Error("Expected `jsxDEV` given to `evaluate`");
  } else {
    if (!i)
      throw new Error("Expected `jsx` given to `evaluate`");
    if (!a)
      throw new Error("Expected `jsxs` given to `evaluate`");
  }
  return {
    compiletime: {
      ...l,
      development: n,
      outputFormat: "function-body",
      providerImportSource: u ? "#" : void 0
    },
    runtime: { Fragment: t, baseUrl: r, jsx: i, jsxDEV: o, jsxs: a, useMDXComponents: u }
  };
}
async function Zm(e, t) {
  return new sz(String(e))(t);
}
function aS(e, t) {
  return new Function(String(e))(t);
}
async function oz(e, t) {
  let { compiletime: r, runtime: n } = oS(t);
  return Zm(await iS(e, r), n);
}
function az(e, t) {
  let { compiletime: r, runtime: n } = oS(t);
  return aS(sS(e, r), n);
}
var jr, y2, D2, QM, eq, tq, Ne, Dm, x2, nq, iq, sq, pq, Sw, Fw, dq, Vs, mq, E2, Rq, Nq, qr, er, Lq, Rm, jq, S2, Pn, $q, Vq, vm, Uq, Js, Jq, Zq,
Iw, Xq, Kq, Pw, Nm, a$, va, _2, k2, T2, Rw, Nw, wm, y$, b$, S$, A$, T$, I$, O$, N$, M$, Lw, q$, $$, V$, G$, $m, Z$, X$, K$, iV, oV, Sm, Ul, Wt,
cV, pV, jw, xV, Mw, bV, qw, AV, _V, IV, BV, Vw, NV, jV, MV, qV, q2, zV, HV, GV, JV, ZV, XV, KV, YV, QV, Uw, nU, $2, zw, Hw, RU, z2, Zl, zl, Hl,
Vm, Um, Wm, zm, H2, G2, Jw, NU, Zw, Us, LU, jU, ga, Ml, MU, Xw, Gl, J2, Z2, ZU, Kw, XU, Lm, QU, Am, uW, lW, X2, cW, dW, mW, Ws, Tm, AW, $l, Mr,
FW, a2, u2, l2, c2, p2, h2, tS, TW, IW, BW, d2, YW, QW, nS, m2, g2, sz, lS = wt(() => {
  nm();
  jr = J(require("path"), 1), y2 = J(require("process"), 1), D2 = require("url");
  gw();
  QM = Os({
    "node_modules/micromark-extension-mdxjs/node_modules/acorn-jsx/xhtml.js"(e, t) {
      t.exports = {
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
    }
  }), eq = Os({
    "node_modules/micromark-extension-mdxjs/node_modules/acorn-jsx/index.js"(e, t) {
      "use strict";
      var r = QM(), n = /^[\da-fA-F]+$/, i = /^\d+$/, o = /* @__PURE__ */ new WeakMap();
      function a(c) {
        c = c.Parser.acorn || c;
        let p = o.get(c);
        if (!p) {
          let h = c.tokTypes, f = c.TokContext, d = c.TokenType, m = new f("<tag", !1), g = new f("</tag", !1), b = new f("<tag>...</tag>", !0,
          !0), y = {
            tc_oTag: m,
            tc_cTag: g,
            tc_expr: b
          }, E = {
            jsxName: new d("jsxName"),
            jsxText: new d("jsxText", { beforeExpr: !0 }),
            jsxTagStart: new d("jsxTagStart", { startsExpr: !0 }),
            jsxTagEnd: new d("jsxTagEnd")
          };
          E.jsxTagStart.updateContext = function() {
            this.context.push(b), this.context.push(m), this.exprAllowed = !1;
          }, E.jsxTagEnd.updateContext = function(A) {
            let k = this.context.pop();
            k === m && A === h.slash || k === g ? (this.context.pop(), this.exprAllowed = this.curContext() === b) : this.exprAllowed = !0;
          }, p = { tokContexts: y, tokTypes: E }, o.set(c, p);
        }
        return p;
      }
      s(a, "getJsxTokens");
      function u(c) {
        if (!c)
          return c;
        if (c.type === "JSXIdentifier")
          return c.name;
        if (c.type === "JSXNamespacedName")
          return c.namespace.name + ":" + c.name.name;
        if (c.type === "JSXMemberExpression")
          return u(c.object) + "." + u(c.property);
      }
      s(u, "getQualifiedJSXName"), t.exports = function(c) {
        return c = c || {}, function(p) {
          return l({
            allowNamespaces: c.allowNamespaces !== !1,
            allowNamespacedObjects: !!c.allowNamespacedObjects
          }, p);
        };
      }, Object.defineProperty(t.exports, "tokTypes", {
        get: /* @__PURE__ */ s(function() {
          return a(Zd("acorn")).tokTypes;
        }, "get_tokTypes"),
        configurable: !0,
        enumerable: !0
      });
      function l(c, p) {
        let h = p.acorn || Zd("acorn"), f = a(h), d = h.tokTypes, m = f.tokTypes, g = h.tokContexts, b = f.tokContexts.tc_oTag, y = f.tokContexts.
        tc_cTag, E = f.tokContexts.tc_expr, A = h.isNewLine, k = h.isIdentifierStart, O = h.isIdentifierChar;
        return class extends p {
          // Expose actual `tokTypes` and `tokContexts` to other plugins.
          static get acornJsx() {
            return f;
          }
          // Reads inline JSX contents token.
          jsx_readToken() {
            let w = "", C = this.pos;
            for (; ; ) {
              this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
              let T = this.input.charCodeAt(this.pos);
              switch (T) {
                case 60:
                case 123:
                  return this.pos === this.start ? T === 60 && this.exprAllowed ? (++this.pos, this.finishToken(m.jsxTagStart)) : this.getTokenFromCode(
                  T) : (w += this.input.slice(C, this.pos), this.finishToken(m.jsxText, w));
                case 38:
                  w += this.input.slice(C, this.pos), w += this.jsx_readEntity(), C = this.pos;
                  break;
                case 62:
                case 125:
                  this.raise(
                    this.pos,
                    "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (T === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.
                    input[this.pos] + '"}`?'
                  );
                default:
                  A(T) ? (w += this.input.slice(C, this.pos), w += this.jsx_readNewLine(!0), C = this.pos) : ++this.pos;
              }
            }
          }
          jsx_readNewLine(w) {
            let C = this.input.charCodeAt(this.pos), T;
            return ++this.pos, C === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, T = w ? `
` : `\r
`) : T = String.fromCharCode(C), this.options.locations && (++this.curLine, this.lineStart = this.pos), T;
          }
          jsx_readString(w) {
            let C = "", T = ++this.pos;
            for (; ; ) {
              this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
              let F = this.input.charCodeAt(this.pos);
              if (F === w)
                break;
              F === 38 ? (C += this.input.slice(T, this.pos), C += this.jsx_readEntity(), T = this.pos) : A(F) ? (C += this.input.slice(T, this.
              pos), C += this.jsx_readNewLine(!1), T = this.pos) : ++this.pos;
            }
            return C += this.input.slice(T, this.pos++), this.finishToken(d.string, C);
          }
          jsx_readEntity() {
            let w = "", C = 0, T, F = this.input[this.pos];
            F !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
            let $ = ++this.pos;
            for (; this.pos < this.input.length && C++ < 10; ) {
              if (F = this.input[this.pos++], F === ";") {
                w[0] === "#" ? w[1] === "x" ? (w = w.substr(2), n.test(w) && (T = String.fromCharCode(parseInt(w, 16)))) : (w = w.substr(1),
                i.test(w) && (T = String.fromCharCode(parseInt(w, 10)))) : T = r[w];
                break;
              }
              w += F;
            }
            return T || (this.pos = $, "&");
          }
          // Read a JSX identifier (valid tag or attribute name).
          //
          // Optimized version since JSX identifiers can't contain
          // escape characters and so can be read as single slice.
          // Also assumes that first character was already checked
          // by isIdentifierStart in readToken.
          jsx_readWord() {
            let w, C = this.pos;
            do
              w = this.input.charCodeAt(++this.pos);
            while (O(w) || w === 45);
            return this.finishToken(m.jsxName, this.input.slice(C, this.pos));
          }
          // Parse next token as JSX identifier
          jsx_parseIdentifier() {
            let w = this.startNode();
            return this.type === m.jsxName ? w.name = this.value : this.type.keyword ? w.name = this.type.keyword : this.unexpected(), this.
            next(), this.finishNode(w, "JSXIdentifier");
          }
          // Parse namespaced identifier.
          jsx_parseNamespacedName() {
            let w = this.start, C = this.startLoc, T = this.jsx_parseIdentifier();
            if (!c.allowNamespaces || !this.eat(d.colon))
              return T;
            var F = this.startNodeAt(w, C);
            return F.namespace = T, F.name = this.jsx_parseIdentifier(), this.finishNode(F, "JSXNamespacedName");
          }
          // Parses element name in any form - namespaced, member
          // or single identifier.
          jsx_parseElementName() {
            if (this.type === m.jsxTagEnd)
              return "";
            let w = this.start, C = this.startLoc, T = this.jsx_parseNamespacedName();
            for (this.type === d.dot && T.type === "JSXNamespacedName" && !c.allowNamespacedObjects && this.unexpected(); this.eat(d.dot); ) {
              let F = this.startNodeAt(w, C);
              F.object = T, F.property = this.jsx_parseIdentifier(), T = this.finishNode(F, "JSXMemberExpression");
            }
            return T;
          }
          // Parses any type of JSX attribute value.
          jsx_parseAttributeValue() {
            switch (this.type) {
              case d.braceL:
                let w = this.jsx_parseExpressionContainer();
                return w.expression.type === "JSXEmptyExpression" && this.raise(w.start, "JSX attributes must only be assigned a non-empty e\
xpression"), w;
              case m.jsxTagStart:
              case d.string:
                return this.parseExprAtom();
              default:
                this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
            }
          }
          // JSXEmptyExpression is unique type since it doesn't actually parse anything,
          // and so it should start at the end of last read token (left brace) and finish
          // at the beginning of the next one (right brace).
          jsx_parseEmptyExpression() {
            let w = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
            return this.finishNodeAt(w, "JSXEmptyExpression", this.start, this.startLoc);
          }
          // Parses JSX expression enclosed into curly brackets.
          jsx_parseExpressionContainer() {
            let w = this.startNode();
            return this.next(), w.expression = this.type === d.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(
            d.braceR), this.finishNode(w, "JSXExpressionContainer");
          }
          // Parses following JSX attribute name-value pair.
          jsx_parseAttribute() {
            let w = this.startNode();
            return this.eat(d.braceL) ? (this.expect(d.ellipsis), w.argument = this.parseMaybeAssign(), this.expect(d.braceR), this.finishNode(
            w, "JSXSpreadAttribute")) : (w.name = this.jsx_parseNamespacedName(), w.value = this.eat(d.eq) ? this.jsx_parseAttributeValue() :
            null, this.finishNode(w, "JSXAttribute"));
          }
          // Parses JSX opening tag starting after '<'.
          jsx_parseOpeningElementAt(w, C) {
            let T = this.startNodeAt(w, C);
            T.attributes = [];
            let F = this.jsx_parseElementName();
            for (F && (T.name = F); this.type !== d.slash && this.type !== m.jsxTagEnd; )
              T.attributes.push(this.jsx_parseAttribute());
            return T.selfClosing = this.eat(d.slash), this.expect(m.jsxTagEnd), this.finishNode(T, F ? "JSXOpeningElement" : "JSXOpeningFrag\
ment");
          }
          // Parses JSX closing tag starting after '</'.
          jsx_parseClosingElementAt(w, C) {
            let T = this.startNodeAt(w, C), F = this.jsx_parseElementName();
            return F && (T.name = F), this.expect(m.jsxTagEnd), this.finishNode(T, F ? "JSXClosingElement" : "JSXClosingFragment");
          }
          // Parses entire JSX element, including it's opening tag
          // (starting after '<'), attributes, contents and closing tag.
          jsx_parseElementAt(w, C) {
            let T = this.startNodeAt(w, C), F = [], $ = this.jsx_parseOpeningElementAt(w, C), R = null;
            if (!$.selfClosing) {
              e:
                for (; ; )
                  switch (this.type) {
                    case m.jsxTagStart:
                      if (w = this.start, C = this.startLoc, this.next(), this.eat(d.slash)) {
                        R = this.jsx_parseClosingElementAt(w, C);
                        break e;
                      }
                      F.push(this.jsx_parseElementAt(w, C));
                      break;
                    case m.jsxText:
                      F.push(this.parseExprAtom());
                      break;
                    case d.braceL:
                      F.push(this.jsx_parseExpressionContainer());
                      break;
                    default:
                      this.unexpected();
                  }
              u(R.name) !== u($.name) && this.raise(
                R.start,
                "Expected corresponding JSX closing tag for <" + u($.name) + ">"
              );
            }
            let U = $.name ? "Element" : "Fragment";
            return T["opening" + U] = $, T["closing" + U] = R, T.children = F, this.type === d.relational && this.value === "<" && this.raise(
            this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(T, "JSX" + U);
          }
          // Parse JSX text
          jsx_parseText() {
            let w = this.parseLiteral(this.value);
            return w.type = "JSXText", w;
          }
          // Parses entire JSX element from current position.
          jsx_parseElement() {
            let w = this.start, C = this.startLoc;
            return this.next(), this.jsx_parseElementAt(w, C);
          }
          parseExprAtom(w) {
            return this.type === m.jsxText ? this.jsx_parseText() : this.type === m.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(
            w);
          }
          readToken(w) {
            let C = this.curContext();
            if (C === E)
              return this.jsx_readToken();
            if (C === b || C === y) {
              if (k(w))
                return this.jsx_readWord();
              if (w == 62)
                return ++this.pos, this.finishToken(m.jsxTagEnd);
              if ((w === 34 || w === 39) && C == b)
                return this.jsx_readString(w);
            }
            return w === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(m.jsxTagStart)) :
            super.readToken(w);
          }
          updateContext(w) {
            if (this.type == d.braceL) {
              var C = this.curContext();
              C == b ? this.context.push(g.b_expr) : C == E ? this.context.push(g.b_tmpl) : super.updateContext(w), this.exprAllowed = !0;
            } else if (this.type === d.slash && w === m.jsxTagStart)
              this.context.length -= 2, this.context.push(y), this.exprAllowed = !1;
            else
              return super.updateContext(w);
          }
        };
      }
      s(l, "plugin");
    }
  }), tq = Os({
    "node_modules/extend/index.js"(e, t) {
      "use strict";
      var r = Object.prototype.hasOwnProperty, n = Object.prototype.toString, i = Object.defineProperty, o = Object.getOwnPropertyDescriptor,
      a = /* @__PURE__ */ s(function(h) {
        return typeof Array.isArray == "function" ? Array.isArray(h) : n.call(h) === "[object Array]";
      }, "isArray2"), u = /* @__PURE__ */ s(function(h) {
        if (!h || n.call(h) !== "[object Object]")
          return !1;
        var f = r.call(h, "constructor"), d = h.constructor && h.constructor.prototype && r.call(h.constructor.prototype, "isPrototypeOf");
        if (h.constructor && !f && !d)
          return !1;
        var m;
        for (m in h)
          ;
        return typeof m > "u" || r.call(h, m);
      }, "isPlainObject3"), l = /* @__PURE__ */ s(function(h, f) {
        i && f.name === "__proto__" ? i(h, f.name, {
          enumerable: !0,
          configurable: !0,
          value: f.newValue,
          writable: !0
        }) : h[f.name] = f.newValue;
      }, "setProperty2"), c = /* @__PURE__ */ s(function(h, f) {
        if (f === "__proto__")
          if (r.call(h, f)) {
            if (o)
              return o(h, f).value;
          } else return;
        return h[f];
      }, "getProperty2");
      t.exports = /* @__PURE__ */ s(function p() {
        var h, f, d, m, g, b, y = arguments[0], E = 1, A = arguments.length, k = !1;
        for (typeof y == "boolean" && (k = y, y = arguments[1] || {}, E = 2), (y == null || typeof y != "object" && typeof y != "function") &&
        (y = {}); E < A; ++E)
          if (h = arguments[E], h != null)
            for (f in h)
              d = c(y, f), m = c(h, f), y !== m && (k && m && (u(m) || (g = a(m))) ? (g ? (g = !1, b = d && a(d) ? d : []) : b = d && u(d) ?
              d : {}, l(y, { name: f, newValue: p(k, b, m) })) : typeof m < "u" && l(y, { name: f, newValue: m }));
        return y;
      }, "extend2");
    }
  });
  s(br, "stringifyPosition");
  s(Bm, "point");
  s(yw, "position2");
  s(Dw, "index");
  Ne = class extends Error {
    static {
      s(this, "VFileMessage");
    }
    /**
     * Create a message for `reason`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(e, t, r) {
      super(), typeof t == "string" && (r = t, t = void 0);
      let n = "", i = {}, o = !1;
      if (t && ("line" in t && "column" in t ? i = { place: t } : "start" in t && "end" in t ? i = { place: t } : "type" in t ? i = {
        ancestors: [t],
        place: t.position
      } : i = { ...t }), typeof e == "string" ? n = e : !i.cause && e && (o = !0, n = e.message, i.cause = e), !i.ruleId && !i.source && typeof r ==
      "string") {
        let u = r.indexOf(":");
        u === -1 ? i.ruleId = r : (i.source = r.slice(0, u), i.ruleId = r.slice(u + 1));
      }
      if (!i.place && i.ancestors && i.ancestors) {
        let u = i.ancestors[i.ancestors.length - 1];
        u && (i.place = u.position);
      }
      let a = i.place && "start" in i.place ? i.place.start : i.place;
      this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.
      file, this.message = n, this.line = a ? a.line : void 0, this.name = br(i.place) || "1:1", this.place = i.place || void 0, this.reason =
      this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = o && i.cause && typeof i.cause.stack ==
      "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
    }
  };
  Ne.prototype.file = "";
  Ne.prototype.name = "";
  Ne.prototype.reason = "";
  Ne.prototype.message = "";
  Ne.prototype.stack = "";
  Ne.prototype.column = void 0;
  Ne.prototype.line = void 0;
  Ne.prototype.ancestors = void 0;
  Ne.prototype.cause = void 0;
  Ne.prototype.fatal = void 0;
  Ne.prototype.place = void 0;
  Ne.prototype.ruleId = void 0;
  Ne.prototype.source = void 0;
  s(xw, "isUrl");
  Dm = /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ], x2 = class {
    static {
      s(this, "VFile");
    }
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array`  `{value: options}`
     * *   `URL`  `{path: options}`
     * *   `VFile`  shallow copies its data over to the new file
     * *   `object`  all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(e) {
      let t;
      e ? xw(e) ? t = { path: e } : typeof e == "string" || rq(e) ? t = { value: e } : t = e : t = {}, this.cwd = y2.default.cwd(), this.data =
      {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
      let r = -1;
      for (; ++r < Dm.length; ) {
        let i = Dm[r];
        i in t && t[i] !== void 0 && t[i] !== null && (this[i] = i === "history" ? [...t[i]] : t[i]);
      }
      let n;
      for (n in t)
        Dm.includes(n) || (this[n] = t[n]);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path == "string" ? jr.default.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(e) {
      bm(e, "basename"), xm(e, "basename"), this.path = jr.default.join(this.dirname || "", e);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path == "string" ? jr.default.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(e) {
      bw(this.basename, "dirname"), this.path = jr.default.join(e || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path == "string" ? jr.default.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(e) {
      if (xm(e, "extname"), bw(this.dirname, "extname"), e) {
        if (e.codePointAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (e.includes(".", 1))
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = jr.default.join(this.dirname, this.stem + (e || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(e) {
      xw(e) && (e = (0, D2.fileURLToPath)(e)), bm(e, "path"), this.path !== e && this.history.push(e);
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path == "string" ? jr.default.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(e) {
      bm(e, "stem"), xm(e, "stem"), this.path = jr.default.join(this.dirname || "", e + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(e, t, r) {
      let n = this.message(e, t, r);
      throw n.fatal = !0, n;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(e, t, r) {
      let n = this.message(e, t, r);
      return n.fatal = void 0, n;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(e, t, r) {
      let n = new Ne(
        // @ts-expect-error: the overloads are fine.
        e,
        t,
        r
      );
      return this.path && (n.name = this.path + ":" + n.name, n.file = this.path), n.fatal = !1, this.messages.push(n), n;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when its a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(e) {
      return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
    }
  };
  s(xm, "assertPart");
  s(bm, "assertNonEmpty");
  s(bw, "assertPath");
  s(rq, "isUint8Array");
  nq = [
    "md",
    "markdown",
    "mdown",
    "mkdn",
    "mkd",
    "mdwn",
    "mkdown",
    "ron"
  ], iq = nq, sq = iq.map(function(e) {
    return "." + e;
  });
  s(b2, "resolveFileAndOptions");
  s(oq, "looksLikeAVFile");
  s(aq, "mdxExpressionFromMarkdown");
  s(uq, "mdxExpressionToMarkdown");
  s(lq, "enterMdxFlowExpression");
  s(cq, "enterMdxTextExpression");
  s(vw, "exitMdxExpression");
  s(Ew, "exitMdxExpressionData");
  s(Cw, "handleMdxExpression");
  s(ww, "ccount");
  pq = [
    "AElig",
    "AMP",
    "Aacute",
    "Acirc",
    "Agrave",
    "Aring",
    "Atilde",
    "Auml",
    "COPY",
    "Ccedil",
    "ETH",
    "Eacute",
    "Ecirc",
    "Egrave",
    "Euml",
    "GT",
    "Iacute",
    "Icirc",
    "Igrave",
    "Iuml",
    "LT",
    "Ntilde",
    "Oacute",
    "Ocirc",
    "Ograve",
    "Oslash",
    "Otilde",
    "Ouml",
    "QUOT",
    "REG",
    "THORN",
    "Uacute",
    "Ucirc",
    "Ugrave",
    "Uuml",
    "Yacute",
    "aacute",
    "acirc",
    "acute",
    "aelig",
    "agrave",
    "amp",
    "aring",
    "atilde",
    "auml",
    "brvbar",
    "ccedil",
    "cedil",
    "cent",
    "copy",
    "curren",
    "deg",
    "divide",
    "eacute",
    "ecirc",
    "egrave",
    "eth",
    "euml",
    "frac12",
    "frac14",
    "frac34",
    "gt",
    "iacute",
    "icirc",
    "iexcl",
    "igrave",
    "iquest",
    "iuml",
    "laquo",
    "lt",
    "macr",
    "micro",
    "middot",
    "nbsp",
    "not",
    "ntilde",
    "oacute",
    "ocirc",
    "ograve",
    "ordf",
    "ordm",
    "oslash",
    "otilde",
    "ouml",
    "para",
    "plusmn",
    "pound",
    "quot",
    "raquo",
    "reg",
    "sect",
    "shy",
    "sup1",
    "sup2",
    "sup3",
    "szlig",
    "thorn",
    "times",
    "uacute",
    "ucirc",
    "ugrave",
    "uml",
    "uuml",
    "yacute",
    "yen",
    "yuml"
  ], Sw = {
    0: "\uFFFD",
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  s(v2, "isDecimal");
  s(hq, "isHexadecimal");
  s(fq, "isAlphabetical");
  s(Aw, "isAlphanumerical");
  Fw = {
    AElig: "\xC6",
    AMP: "&",
    Aacute: "\xC1",
    Abreve: "\u0102",
    Acirc: "\xC2",
    Acy: "\u0410",
    Afr: "\u{1D504}",
    Agrave: "\xC0",
    Alpha: "\u0391",
    Amacr: "\u0100",
    And: "\u2A53",
    Aogon: "\u0104",
    Aopf: "\u{1D538}",
    ApplyFunction: "\u2061",
    Aring: "\xC5",
    Ascr: "\u{1D49C}",
    Assign: "\u2254",
    Atilde: "\xC3",
    Auml: "\xC4",
    Backslash: "\u2216",
    Barv: "\u2AE7",
    Barwed: "\u2306",
    Bcy: "\u0411",
    Because: "\u2235",
    Bernoullis: "\u212C",
    Beta: "\u0392",
    Bfr: "\u{1D505}",
    Bopf: "\u{1D539}",
    Breve: "\u02D8",
    Bscr: "\u212C",
    Bumpeq: "\u224E",
    CHcy: "\u0427",
    COPY: "\xA9",
    Cacute: "\u0106",
    Cap: "\u22D2",
    CapitalDifferentialD: "\u2145",
    Cayleys: "\u212D",
    Ccaron: "\u010C",
    Ccedil: "\xC7",
    Ccirc: "\u0108",
    Cconint: "\u2230",
    Cdot: "\u010A",
    Cedilla: "\xB8",
    CenterDot: "\xB7",
    Cfr: "\u212D",
    Chi: "\u03A7",
    CircleDot: "\u2299",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201D",
    CloseCurlyQuote: "\u2019",
    Colon: "\u2237",
    Colone: "\u2A74",
    Congruent: "\u2261",
    Conint: "\u222F",
    ContourIntegral: "\u222E",
    Copf: "\u2102",
    Coproduct: "\u2210",
    CounterClockwiseContourIntegral: "\u2233",
    Cross: "\u2A2F",
    Cscr: "\u{1D49E}",
    Cup: "\u22D3",
    CupCap: "\u224D",
    DD: "\u2145",
    DDotrahd: "\u2911",
    DJcy: "\u0402",
    DScy: "\u0405",
    DZcy: "\u040F",
    Dagger: "\u2021",
    Darr: "\u21A1",
    Dashv: "\u2AE4",
    Dcaron: "\u010E",
    Dcy: "\u0414",
    Del: "\u2207",
    Delta: "\u0394",
    Dfr: "\u{1D507}",
    DiacriticalAcute: "\xB4",
    DiacriticalDot: "\u02D9",
    DiacriticalDoubleAcute: "\u02DD",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02DC",
    Diamond: "\u22C4",
    DifferentialD: "\u2146",
    Dopf: "\u{1D53B}",
    Dot: "\xA8",
    DotDot: "\u20DC",
    DotEqual: "\u2250",
    DoubleContourIntegral: "\u222F",
    DoubleDot: "\xA8",
    DoubleDownArrow: "\u21D3",
    DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4",
    DoubleLeftTee: "\u2AE4",
    DoubleLongLeftArrow: "\u27F8",
    DoubleLongLeftRightArrow: "\u27FA",
    DoubleLongRightArrow: "\u27F9",
    DoubleRightArrow: "\u21D2",
    DoubleRightTee: "\u22A8",
    DoubleUpArrow: "\u21D1",
    DoubleUpDownArrow: "\u21D5",
    DoubleVerticalBar: "\u2225",
    DownArrow: "\u2193",
    DownArrowBar: "\u2913",
    DownArrowUpArrow: "\u21F5",
    DownBreve: "\u0311",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295E",
    DownLeftVector: "\u21BD",
    DownLeftVectorBar: "\u2956",
    DownRightTeeVector: "\u295F",
    DownRightVector: "\u21C1",
    DownRightVectorBar: "\u2957",
    DownTee: "\u22A4",
    DownTeeArrow: "\u21A7",
    Downarrow: "\u21D3",
    Dscr: "\u{1D49F}",
    Dstrok: "\u0110",
    ENG: "\u014A",
    ETH: "\xD0",
    Eacute: "\xC9",
    Ecaron: "\u011A",
    Ecirc: "\xCA",
    Ecy: "\u042D",
    Edot: "\u0116",
    Efr: "\u{1D508}",
    Egrave: "\xC8",
    Element: "\u2208",
    Emacr: "\u0112",
    EmptySmallSquare: "\u25FB",
    EmptyVerySmallSquare: "\u25AB",
    Eogon: "\u0118",
    Eopf: "\u{1D53C}",
    Epsilon: "\u0395",
    Equal: "\u2A75",
    EqualTilde: "\u2242",
    Equilibrium: "\u21CC",
    Escr: "\u2130",
    Esim: "\u2A73",
    Eta: "\u0397",
    Euml: "\xCB",
    Exists: "\u2203",
    ExponentialE: "\u2147",
    Fcy: "\u0424",
    Ffr: "\u{1D509}",
    FilledSmallSquare: "\u25FC",
    FilledVerySmallSquare: "\u25AA",
    Fopf: "\u{1D53D}",
    ForAll: "\u2200",
    Fouriertrf: "\u2131",
    Fscr: "\u2131",
    GJcy: "\u0403",
    GT: ">",
    Gamma: "\u0393",
    Gammad: "\u03DC",
    Gbreve: "\u011E",
    Gcedil: "\u0122",
    Gcirc: "\u011C",
    Gcy: "\u0413",
    Gdot: "\u0120",
    Gfr: "\u{1D50A}",
    Gg: "\u22D9",
    Gopf: "\u{1D53E}",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22DB",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2AA2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2A7E",
    GreaterTilde: "\u2273",
    Gscr: "\u{1D4A2}",
    Gt: "\u226B",
    HARDcy: "\u042A",
    Hacek: "\u02C7",
    Hat: "^",
    Hcirc: "\u0124",
    Hfr: "\u210C",
    HilbertSpace: "\u210B",
    Hopf: "\u210D",
    HorizontalLine: "\u2500",
    Hscr: "\u210B",
    Hstrok: "\u0126",
    HumpDownHump: "\u224E",
    HumpEqual: "\u224F",
    IEcy: "\u0415",
    IJlig: "\u0132",
    IOcy: "\u0401",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Icy: "\u0418",
    Idot: "\u0130",
    Ifr: "\u2111",
    Igrave: "\xCC",
    Im: "\u2111",
    Imacr: "\u012A",
    ImaginaryI: "\u2148",
    Implies: "\u21D2",
    Int: "\u222C",
    Integral: "\u222B",
    Intersection: "\u22C2",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    Iogon: "\u012E",
    Iopf: "\u{1D540}",
    Iota: "\u0399",
    Iscr: "\u2110",
    Itilde: "\u0128",
    Iukcy: "\u0406",
    Iuml: "\xCF",
    Jcirc: "\u0134",
    Jcy: "\u0419",
    Jfr: "\u{1D50D}",
    Jopf: "\u{1D541}",
    Jscr: "\u{1D4A5}",
    Jsercy: "\u0408",
    Jukcy: "\u0404",
    KHcy: "\u0425",
    KJcy: "\u040C",
    Kappa: "\u039A",
    Kcedil: "\u0136",
    Kcy: "\u041A",
    Kfr: "\u{1D50E}",
    Kopf: "\u{1D542}",
    Kscr: "\u{1D4A6}",
    LJcy: "\u0409",
    LT: "<",
    Lacute: "\u0139",
    Lambda: "\u039B",
    Lang: "\u27EA",
    Laplacetrf: "\u2112",
    Larr: "\u219E",
    Lcaron: "\u013D",
    Lcedil: "\u013B",
    Lcy: "\u041B",
    LeftAngleBracket: "\u27E8",
    LeftArrow: "\u2190",
    LeftArrowBar: "\u21E4",
    LeftArrowRightArrow: "\u21C6",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27E6",
    LeftDownTeeVector: "\u2961",
    LeftDownVector: "\u21C3",
    LeftDownVectorBar: "\u2959",
    LeftFloor: "\u230A",
    LeftRightArrow: "\u2194",
    LeftRightVector: "\u294E",
    LeftTee: "\u22A3",
    LeftTeeArrow: "\u21A4",
    LeftTeeVector: "\u295A",
    LeftTriangle: "\u22B2",
    LeftTriangleBar: "\u29CF",
    LeftTriangleEqual: "\u22B4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVector: "\u21BF",
    LeftUpVectorBar: "\u2958",
    LeftVector: "\u21BC",
    LeftVectorBar: "\u2952",
    Leftarrow: "\u21D0",
    Leftrightarrow: "\u21D4",
    LessEqualGreater: "\u22DA",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    LessLess: "\u2AA1",
    LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272",
    Lfr: "\u{1D50F}",
    Ll: "\u22D8",
    Lleftarrow: "\u21DA",
    Lmidot: "\u013F",
    LongLeftArrow: "\u27F5",
    LongLeftRightArrow: "\u27F7",
    LongRightArrow: "\u27F6",
    Longleftarrow: "\u27F8",
    Longleftrightarrow: "\u27FA",
    Longrightarrow: "\u27F9",
    Lopf: "\u{1D543}",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    Lscr: "\u2112",
    Lsh: "\u21B0",
    Lstrok: "\u0141",
    Lt: "\u226A",
    Map: "\u2905",
    Mcy: "\u041C",
    MediumSpace: "\u205F",
    Mellintrf: "\u2133",
    Mfr: "\u{1D510}",
    MinusPlus: "\u2213",
    Mopf: "\u{1D544}",
    Mscr: "\u2133",
    Mu: "\u039C",
    NJcy: "\u040A",
    Nacute: "\u0143",
    Ncaron: "\u0147",
    Ncedil: "\u0145",
    Ncy: "\u041D",
    NegativeMediumSpace: "\u200B",
    NegativeThickSpace: "\u200B",
    NegativeThinSpace: "\u200B",
    NegativeVeryThinSpace: "\u200B",
    NestedGreaterGreater: "\u226B",
    NestedLessLess: "\u226A",
    NewLine: `
`,
    Nfr: "\u{1D511}",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xA0",
    Nopf: "\u2115",
    Not: "\u2AEC",
    NotCongruent: "\u2262",
    NotCupCap: "\u226D",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226F",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226B\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2A7E\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224E\u0338",
    NotHumpEqual: "\u224F\u0338",
    NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338",
    NotLeftTriangleEqual: "\u22EC",
    NotLess: "\u226E",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338",
    NotLessSlantEqual: "\u2A7D\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2AA2\u0338",
    NotNestedLessLess: "\u2AA1\u0338",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0",
    NotReverseElement: "\u220C",
    NotRightTriangle: "\u22EB",
    NotRightTriangleBar: "\u29D0\u0338",
    NotRightTriangleEqual: "\u22ED",
    NotSquareSubset: "\u228F\u0338",
    NotSquareSubsetEqual: "\u22E2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2AB0\u0338",
    NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338",
    NotSuperset: "\u2283\u20D2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    Nscr: "\u{1D4A9}",
    Ntilde: "\xD1",
    Nu: "\u039D",
    OElig: "\u0152",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Ocy: "\u041E",
    Odblac: "\u0150",
    Ofr: "\u{1D512}",
    Ograve: "\xD2",
    Omacr: "\u014C",
    Omega: "\u03A9",
    Omicron: "\u039F",
    Oopf: "\u{1D546}",
    OpenCurlyDoubleQuote: "\u201C",
    OpenCurlyQuote: "\u2018",
    Or: "\u2A54",
    Oscr: "\u{1D4AA}",
    Oslash: "\xD8",
    Otilde: "\xD5",
    Otimes: "\u2A37",
    Ouml: "\xD6",
    OverBar: "\u203E",
    OverBrace: "\u23DE",
    OverBracket: "\u23B4",
    OverParenthesis: "\u23DC",
    PartialD: "\u2202",
    Pcy: "\u041F",
    Pfr: "\u{1D513}",
    Phi: "\u03A6",
    Pi: "\u03A0",
    PlusMinus: "\xB1",
    Poincareplane: "\u210C",
    Popf: "\u2119",
    Pr: "\u2ABB",
    Precedes: "\u227A",
    PrecedesEqual: "\u2AAF",
    PrecedesSlantEqual: "\u227C",
    PrecedesTilde: "\u227E",
    Prime: "\u2033",
    Product: "\u220F",
    Proportion: "\u2237",
    Proportional: "\u221D",
    Pscr: "\u{1D4AB}",
    Psi: "\u03A8",
    QUOT: '"',
    Qfr: "\u{1D514}",
    Qopf: "\u211A",
    Qscr: "\u{1D4AC}",
    RBarr: "\u2910",
    REG: "\xAE",
    Racute: "\u0154",
    Rang: "\u27EB",
    Rarr: "\u21A0",
    Rarrtl: "\u2916",
    Rcaron: "\u0158",
    Rcedil: "\u0156",
    Rcy: "\u0420",
    Re: "\u211C",
    ReverseElement: "\u220B",
    ReverseEquilibrium: "\u21CB",
    ReverseUpEquilibrium: "\u296F",
    Rfr: "\u211C",
    Rho: "\u03A1",
    RightAngleBracket: "\u27E9",
    RightArrow: "\u2192",
    RightArrowBar: "\u21E5",
    RightArrowLeftArrow: "\u21C4",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27E7",
    RightDownTeeVector: "\u295D",
    RightDownVector: "\u21C2",
    RightDownVectorBar: "\u2955",
    RightFloor: "\u230B",
    RightTee: "\u22A2",
    RightTeeArrow: "\u21A6",
    RightTeeVector: "\u295B",
    RightTriangle: "\u22B3",
    RightTriangleBar: "\u29D0",
    RightTriangleEqual: "\u22B5",
    RightUpDownVector: "\u294F",
    RightUpTeeVector: "\u295C",
    RightUpVector: "\u21BE",
    RightUpVectorBar: "\u2954",
    RightVector: "\u21C0",
    RightVectorBar: "\u2953",
    Rightarrow: "\u21D2",
    Ropf: "\u211D",
    RoundImplies: "\u2970",
    Rrightarrow: "\u21DB",
    Rscr: "\u211B",
    Rsh: "\u21B1",
    RuleDelayed: "\u29F4",
    SHCHcy: "\u0429",
    SHcy: "\u0428",
    SOFTcy: "\u042C",
    Sacute: "\u015A",
    Sc: "\u2ABC",
    Scaron: "\u0160",
    Scedil: "\u015E",
    Scirc: "\u015C",
    Scy: "\u0421",
    Sfr: "\u{1D516}",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    Sigma: "\u03A3",
    SmallCircle: "\u2218",
    Sopf: "\u{1D54A}",
    Sqrt: "\u221A",
    Square: "\u25A1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228F",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    Sscr: "\u{1D4AE}",
    Star: "\u22C6",
    Sub: "\u22D0",
    Subset: "\u22D0",
    SubsetEqual: "\u2286",
    Succeeds: "\u227B",
    SucceedsEqual: "\u2AB0",
    SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F",
    SuchThat: "\u220B",
    Sum: "\u2211",
    Sup: "\u22D1",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    Supset: "\u22D1",
    THORN: "\xDE",
    TRADE: "\u2122",
    TSHcy: "\u040B",
    TScy: "\u0426",
    Tab: "	",
    Tau: "\u03A4",
    Tcaron: "\u0164",
    Tcedil: "\u0162",
    Tcy: "\u0422",
    Tfr: "\u{1D517}",
    Therefore: "\u2234",
    Theta: "\u0398",
    ThickSpace: "\u205F\u200A",
    ThinSpace: "\u2009",
    Tilde: "\u223C",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    Topf: "\u{1D54B}",
    TripleDot: "\u20DB",
    Tscr: "\u{1D4AF}",
    Tstrok: "\u0166",
    Uacute: "\xDA",
    Uarr: "\u219F",
    Uarrocir: "\u2949",
    Ubrcy: "\u040E",
    Ubreve: "\u016C",
    Ucirc: "\xDB",
    Ucy: "\u0423",
    Udblac: "\u0170",
    Ufr: "\u{1D518}",
    Ugrave: "\xD9",
    Umacr: "\u016A",
    UnderBar: "_",
    UnderBrace: "\u23DF",
    UnderBracket: "\u23B5",
    UnderParenthesis: "\u23DD",
    Union: "\u22C3",
    UnionPlus: "\u228E",
    Uogon: "\u0172",
    Uopf: "\u{1D54C}",
    UpArrow: "\u2191",
    UpArrowBar: "\u2912",
    UpArrowDownArrow: "\u21C5",
    UpDownArrow: "\u2195",
    UpEquilibrium: "\u296E",
    UpTee: "\u22A5",
    UpTeeArrow: "\u21A5",
    Uparrow: "\u21D1",
    Updownarrow: "\u21D5",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    Upsi: "\u03D2",
    Upsilon: "\u03A5",
    Uring: "\u016E",
    Uscr: "\u{1D4B0}",
    Utilde: "\u0168",
    Uuml: "\xDC",
    VDash: "\u22AB",
    Vbar: "\u2AEB",
    Vcy: "\u0412",
    Vdash: "\u22A9",
    Vdashl: "\u2AE6",
    Vee: "\u22C1",
    Verbar: "\u2016",
    Vert: "\u2016",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200A",
    Vfr: "\u{1D519}",
    Vopf: "\u{1D54D}",
    Vscr: "\u{1D4B1}",
    Vvdash: "\u22AA",
    Wcirc: "\u0174",
    Wedge: "\u22C0",
    Wfr: "\u{1D51A}",
    Wopf: "\u{1D54E}",
    Wscr: "\u{1D4B2}",
    Xfr: "\u{1D51B}",
    Xi: "\u039E",
    Xopf: "\u{1D54F}",
    Xscr: "\u{1D4B3}",
    YAcy: "\u042F",
    YIcy: "\u0407",
    YUcy: "\u042E",
    Yacute: "\xDD",
    Ycirc: "\u0176",
    Ycy: "\u042B",
    Yfr: "\u{1D51C}",
    Yopf: "\u{1D550}",
    Yscr: "\u{1D4B4}",
    Yuml: "\u0178",
    ZHcy: "\u0416",
    Zacute: "\u0179",
    Zcaron: "\u017D",
    Zcy: "\u0417",
    Zdot: "\u017B",
    ZeroWidthSpace: "\u200B",
    Zeta: "\u0396",
    Zfr: "\u2128",
    Zopf: "\u2124",
    Zscr: "\u{1D4B5}",
    aacute: "\xE1",
    abreve: "\u0103",
    ac: "\u223E",
    acE: "\u223E\u0333",
    acd: "\u223F",
    acirc: "\xE2",
    acute: "\xB4",
    acy: "\u0430",
    aelig: "\xE6",
    af: "\u2061",
    afr: "\u{1D51E}",
    agrave: "\xE0",
    alefsym: "\u2135",
    aleph: "\u2135",
    alpha: "\u03B1",
    amacr: "\u0101",
    amalg: "\u2A3F",
    amp: "&",
    and: "\u2227",
    andand: "\u2A55",
    andd: "\u2A5C",
    andslope: "\u2A58",
    andv: "\u2A5A",
    ang: "\u2220",
    ange: "\u29A4",
    angle: "\u2220",
    angmsd: "\u2221",
    angmsdaa: "\u29A8",
    angmsdab: "\u29A9",
    angmsdac: "\u29AA",
    angmsdad: "\u29AB",
    angmsdae: "\u29AC",
    angmsdaf: "\u29AD",
    angmsdag: "\u29AE",
    angmsdah: "\u29AF",
    angrt: "\u221F",
    angrtvb: "\u22BE",
    angrtvbd: "\u299D",
    angsph: "\u2222",
    angst: "\xC5",
    angzarr: "\u237C",
    aogon: "\u0105",
    aopf: "\u{1D552}",
    ap: "\u2248",
    apE: "\u2A70",
    apacir: "\u2A6F",
    ape: "\u224A",
    apid: "\u224B",
    apos: "'",
    approx: "\u2248",
    approxeq: "\u224A",
    aring: "\xE5",
    ascr: "\u{1D4B6}",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224D",
    atilde: "\xE3",
    auml: "\xE4",
    awconint: "\u2233",
    awint: "\u2A11",
    bNot: "\u2AED",
    backcong: "\u224C",
    backepsilon: "\u03F6",
    backprime: "\u2035",
    backsim: "\u223D",
    backsimeq: "\u22CD",
    barvee: "\u22BD",
    barwed: "\u2305",
    barwedge: "\u2305",
    bbrk: "\u23B5",
    bbrktbrk: "\u23B6",
    bcong: "\u224C",
    bcy: "\u0431",
    bdquo: "\u201E",
    becaus: "\u2235",
    because: "\u2235",
    bemptyv: "\u29B0",
    bepsi: "\u03F6",
    bernou: "\u212C",
    beta: "\u03B2",
    beth: "\u2136",
    between: "\u226C",
    bfr: "\u{1D51F}",
    bigcap: "\u22C2",
    bigcirc: "\u25EF",
    bigcup: "\u22C3",
    bigodot: "\u2A00",
    bigoplus: "\u2A01",
    bigotimes: "\u2A02",
    bigsqcup: "\u2A06",
    bigstar: "\u2605",
    bigtriangledown: "\u25BD",
    bigtriangleup: "\u25B3",
    biguplus: "\u2A04",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    bkarow: "\u290D",
    blacklozenge: "\u29EB",
    blacksquare: "\u25AA",
    blacktriangle: "\u25B4",
    blacktriangledown: "\u25BE",
    blacktriangleleft: "\u25C2",
    blacktriangleright: "\u25B8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20E5",
    bnequiv: "\u2261\u20E5",
    bnot: "\u2310",
    bopf: "\u{1D553}",
    bot: "\u22A5",
    bottom: "\u22A5",
    bowtie: "\u22C8",
    boxDL: "\u2557",
    boxDR: "\u2554",
    boxDl: "\u2556",
    boxDr: "\u2553",
    boxH: "\u2550",
    boxHD: "\u2566",
    boxHU: "\u2569",
    boxHd: "\u2564",
    boxHu: "\u2567",
    boxUL: "\u255D",
    boxUR: "\u255A",
    boxUl: "\u255C",
    boxUr: "\u2559",
    boxV: "\u2551",
    boxVH: "\u256C",
    boxVL: "\u2563",
    boxVR: "\u2560",
    boxVh: "\u256B",
    boxVl: "\u2562",
    boxVr: "\u255F",
    boxbox: "\u29C9",
    boxdL: "\u2555",
    boxdR: "\u2552",
    boxdl: "\u2510",
    boxdr: "\u250C",
    boxh: "\u2500",
    boxhD: "\u2565",
    boxhU: "\u2568",
    boxhd: "\u252C",
    boxhu: "\u2534",
    boxminus: "\u229F",
    boxplus: "\u229E",
    boxtimes: "\u22A0",
    boxuL: "\u255B",
    boxuR: "\u2558",
    boxul: "\u2518",
    boxur: "\u2514",
    boxv: "\u2502",
    boxvH: "\u256A",
    boxvL: "\u2561",
    boxvR: "\u255E",
    boxvh: "\u253C",
    boxvl: "\u2524",
    boxvr: "\u251C",
    bprime: "\u2035",
    breve: "\u02D8",
    brvbar: "\xA6",
    bscr: "\u{1D4B7}",
    bsemi: "\u204F",
    bsim: "\u223D",
    bsime: "\u22CD",
    bsol: "\\",
    bsolb: "\u29C5",
    bsolhsub: "\u27C8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224E",
    bumpE: "\u2AAE",
    bumpe: "\u224F",
    bumpeq: "\u224F",
    cacute: "\u0107",
    cap: "\u2229",
    capand: "\u2A44",
    capbrcup: "\u2A49",
    capcap: "\u2A4B",
    capcup: "\u2A47",
    capdot: "\u2A40",
    caps: "\u2229\uFE00",
    caret: "\u2041",
    caron: "\u02C7",
    ccaps: "\u2A4D",
    ccaron: "\u010D",
    ccedil: "\xE7",
    ccirc: "\u0109",
    ccups: "\u2A4C",
    ccupssm: "\u2A50",
    cdot: "\u010B",
    cedil: "\xB8",
    cemptyv: "\u29B2",
    cent: "\xA2",
    centerdot: "\xB7",
    cfr: "\u{1D520}",
    chcy: "\u0447",
    check: "\u2713",
    checkmark: "\u2713",
    chi: "\u03C7",
    cir: "\u25CB",
    cirE: "\u29C3",
    circ: "\u02C6",
    circeq: "\u2257",
    circlearrowleft: "\u21BA",
    circlearrowright: "\u21BB",
    circledR: "\xAE",
    circledS: "\u24C8",
    circledast: "\u229B",
    circledcirc: "\u229A",
    circleddash: "\u229D",
    cire: "\u2257",
    cirfnint: "\u2A10",
    cirmid: "\u2AEF",
    cirscir: "\u29C2",
    clubs: "\u2663",
    clubsuit: "\u2663",
    colon: ":",
    colone: "\u2254",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2A6D",
    conint: "\u222E",
    copf: "\u{1D554}",
    coprod: "\u2210",
    copy: "\xA9",
    copysr: "\u2117",
    crarr: "\u21B5",
    cross: "\u2717",
    cscr: "\u{1D4B8}",
    csub: "\u2ACF",
    csube: "\u2AD1",
    csup: "\u2AD0",
    csupe: "\u2AD2",
    ctdot: "\u22EF",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22DE",
    cuesc: "\u22DF",
    cularr: "\u21B6",
    cularrp: "\u293D",
    cup: "\u222A",
    cupbrcap: "\u2A48",
    cupcap: "\u2A46",
    cupcup: "\u2A4A",
    cupdot: "\u228D",
    cupor: "\u2A45",
    cups: "\u222A\uFE00",
    curarr: "\u21B7",
    curarrm: "\u293C",
    curlyeqprec: "\u22DE",
    curlyeqsucc: "\u22DF",
    curlyvee: "\u22CE",
    curlywedge: "\u22CF",
    curren: "\xA4",
    curvearrowleft: "\u21B6",
    curvearrowright: "\u21B7",
    cuvee: "\u22CE",
    cuwed: "\u22CF",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232D",
    dArr: "\u21D3",
    dHar: "\u2965",
    dagger: "\u2020",
    daleth: "\u2138",
    darr: "\u2193",
    dash: "\u2010",
    dashv: "\u22A3",
    dbkarow: "\u290F",
    dblac: "\u02DD",
    dcaron: "\u010F",
    dcy: "\u0434",
    dd: "\u2146",
    ddagger: "\u2021",
    ddarr: "\u21CA",
    ddotseq: "\u2A77",
    deg: "\xB0",
    delta: "\u03B4",
    demptyv: "\u29B1",
    dfisht: "\u297F",
    dfr: "\u{1D521}",
    dharl: "\u21C3",
    dharr: "\u21C2",
    diam: "\u22C4",
    diamond: "\u22C4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xA8",
    digamma: "\u03DD",
    disin: "\u22F2",
    div: "\xF7",
    divide: "\xF7",
    divideontimes: "\u22C7",
    divonx: "\u22C7",
    djcy: "\u0452",
    dlcorn: "\u231E",
    dlcrop: "\u230D",
    dollar: "$",
    dopf: "\u{1D555}",
    dot: "\u02D9",
    doteq: "\u2250",
    doteqdot: "\u2251",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22A1",
    doublebarwedge: "\u2306",
    downarrow: "\u2193",
    downdownarrows: "\u21CA",
    downharpoonleft: "\u21C3",
    downharpoonright: "\u21C2",
    drbkarow: "\u2910",
    drcorn: "\u231F",
    drcrop: "\u230C",
    dscr: "\u{1D4B9}",
    dscy: "\u0455",
    dsol: "\u29F6",
    dstrok: "\u0111",
    dtdot: "\u22F1",
    dtri: "\u25BF",
    dtrif: "\u25BE",
    duarr: "\u21F5",
    duhar: "\u296F",
    dwangle: "\u29A6",
    dzcy: "\u045F",
    dzigrarr: "\u27FF",
    eDDot: "\u2A77",
    eDot: "\u2251",
    eacute: "\xE9",
    easter: "\u2A6E",
    ecaron: "\u011B",
    ecir: "\u2256",
    ecirc: "\xEA",
    ecolon: "\u2255",
    ecy: "\u044D",
    edot: "\u0117",
    ee: "\u2147",
    efDot: "\u2252",
    efr: "\u{1D522}",
    eg: "\u2A9A",
    egrave: "\xE8",
    egs: "\u2A96",
    egsdot: "\u2A98",
    el: "\u2A99",
    elinters: "\u23E7",
    ell: "\u2113",
    els: "\u2A95",
    elsdot: "\u2A97",
    emacr: "\u0113",
    empty: "\u2205",
    emptyset: "\u2205",
    emptyv: "\u2205",
    emsp13: "\u2004",
    emsp14: "\u2005",
    emsp: "\u2003",
    eng: "\u014B",
    ensp: "\u2002",
    eogon: "\u0119",
    eopf: "\u{1D556}",
    epar: "\u22D5",
    eparsl: "\u29E3",
    eplus: "\u2A71",
    epsi: "\u03B5",
    epsilon: "\u03B5",
    epsiv: "\u03F5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2A96",
    eqslantless: "\u2A95",
    equals: "=",
    equest: "\u225F",
    equiv: "\u2261",
    equivDD: "\u2A78",
    eqvparsl: "\u29E5",
    erDot: "\u2253",
    erarr: "\u2971",
    escr: "\u212F",
    esdot: "\u2250",
    esim: "\u2242",
    eta: "\u03B7",
    eth: "\xF0",
    euml: "\xEB",
    euro: "\u20AC",
    excl: "!",
    exist: "\u2203",
    expectation: "\u2130",
    exponentiale: "\u2147",
    fallingdotseq: "\u2252",
    fcy: "\u0444",
    female: "\u2640",
    ffilig: "\uFB03",
    fflig: "\uFB00",
    ffllig: "\uFB04",
    ffr: "\u{1D523}",
    filig: "\uFB01",
    fjlig: "fj",
    flat: "\u266D",
    fllig: "\uFB02",
    fltns: "\u25B1",
    fnof: "\u0192",
    fopf: "\u{1D557}",
    forall: "\u2200",
    fork: "\u22D4",
    forkv: "\u2AD9",
    fpartint: "\u2A0D",
    frac12: "\xBD",
    frac13: "\u2153",
    frac14: "\xBC",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215B",
    frac23: "\u2154",
    frac25: "\u2156",
    frac34: "\xBE",
    frac35: "\u2157",
    frac38: "\u215C",
    frac45: "\u2158",
    frac56: "\u215A",
    frac58: "\u215D",
    frac78: "\u215E",
    frasl: "\u2044",
    frown: "\u2322",
    fscr: "\u{1D4BB}",
    gE: "\u2267",
    gEl: "\u2A8C",
    gacute: "\u01F5",
    gamma: "\u03B3",
    gammad: "\u03DD",
    gap: "\u2A86",
    gbreve: "\u011F",
    gcirc: "\u011D",
    gcy: "\u0433",
    gdot: "\u0121",
    ge: "\u2265",
    gel: "\u22DB",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2A7E",
    ges: "\u2A7E",
    gescc: "\u2AA9",
    gesdot: "\u2A80",
    gesdoto: "\u2A82",
    gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00",
    gesles: "\u2A94",
    gfr: "\u{1D524}",
    gg: "\u226B",
    ggg: "\u22D9",
    gimel: "\u2137",
    gjcy: "\u0453",
    gl: "\u2277",
    glE: "\u2A92",
    gla: "\u2AA5",
    glj: "\u2AA4",
    gnE: "\u2269",
    gnap: "\u2A8A",
    gnapprox: "\u2A8A",
    gne: "\u2A88",
    gneq: "\u2A88",
    gneqq: "\u2269",
    gnsim: "\u22E7",
    gopf: "\u{1D558}",
    grave: "`",
    gscr: "\u210A",
    gsim: "\u2273",
    gsime: "\u2A8E",
    gsiml: "\u2A90",
    gt: ">",
    gtcc: "\u2AA7",
    gtcir: "\u2A7A",
    gtdot: "\u22D7",
    gtlPar: "\u2995",
    gtquest: "\u2A7C",
    gtrapprox: "\u2A86",
    gtrarr: "\u2978",
    gtrdot: "\u22D7",
    gtreqless: "\u22DB",
    gtreqqless: "\u2A8C",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\uFE00",
    gvnE: "\u2269\uFE00",
    hArr: "\u21D4",
    hairsp: "\u200A",
    half: "\xBD",
    hamilt: "\u210B",
    hardcy: "\u044A",
    harr: "\u2194",
    harrcir: "\u2948",
    harrw: "\u21AD",
    hbar: "\u210F",
    hcirc: "\u0125",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22B9",
    hfr: "\u{1D525}",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21FF",
    homtht: "\u223B",
    hookleftarrow: "\u21A9",
    hookrightarrow: "\u21AA",
    hopf: "\u{1D559}",
    horbar: "\u2015",
    hscr: "\u{1D4BD}",
    hslash: "\u210F",
    hstrok: "\u0127",
    hybull: "\u2043",
    hyphen: "\u2010",
    iacute: "\xED",
    ic: "\u2063",
    icirc: "\xEE",
    icy: "\u0438",
    iecy: "\u0435",
    iexcl: "\xA1",
    iff: "\u21D4",
    ifr: "\u{1D526}",
    igrave: "\xEC",
    ii: "\u2148",
    iiiint: "\u2A0C",
    iiint: "\u222D",
    iinfin: "\u29DC",
    iiota: "\u2129",
    ijlig: "\u0133",
    imacr: "\u012B",
    image: "\u2111",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    imof: "\u22B7",
    imped: "\u01B5",
    in: "\u2208",
    incare: "\u2105",
    infin: "\u221E",
    infintie: "\u29DD",
    inodot: "\u0131",
    int: "\u222B",
    intcal: "\u22BA",
    integers: "\u2124",
    intercal: "\u22BA",
    intlarhk: "\u2A17",
    intprod: "\u2A3C",
    iocy: "\u0451",
    iogon: "\u012F",
    iopf: "\u{1D55A}",
    iota: "\u03B9",
    iprod: "\u2A3C",
    iquest: "\xBF",
    iscr: "\u{1D4BE}",
    isin: "\u2208",
    isinE: "\u22F9",
    isindot: "\u22F5",
    isins: "\u22F4",
    isinsv: "\u22F3",
    isinv: "\u2208",
    it: "\u2062",
    itilde: "\u0129",
    iukcy: "\u0456",
    iuml: "\xEF",
    jcirc: "\u0135",
    jcy: "\u0439",
    jfr: "\u{1D527}",
    jmath: "\u0237",
    jopf: "\u{1D55B}",
    jscr: "\u{1D4BF}",
    jsercy: "\u0458",
    jukcy: "\u0454",
    kappa: "\u03BA",
    kappav: "\u03F0",
    kcedil: "\u0137",
    kcy: "\u043A",
    kfr: "\u{1D528}",
    kgreen: "\u0138",
    khcy: "\u0445",
    kjcy: "\u045C",
    kopf: "\u{1D55C}",
    kscr: "\u{1D4C0}",
    lAarr: "\u21DA",
    lArr: "\u21D0",
    lAtail: "\u291B",
    lBarr: "\u290E",
    lE: "\u2266",
    lEg: "\u2A8B",
    lHar: "\u2962",
    lacute: "\u013A",
    laemptyv: "\u29B4",
    lagran: "\u2112",
    lambda: "\u03BB",
    lang: "\u27E8",
    langd: "\u2991",
    langle: "\u27E8",
    lap: "\u2A85",
    laquo: "\xAB",
    larr: "\u2190",
    larrb: "\u21E4",
    larrbfs: "\u291F",
    larrfs: "\u291D",
    larrhk: "\u21A9",
    larrlp: "\u21AB",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21A2",
    lat: "\u2AAB",
    latail: "\u2919",
    late: "\u2AAD",
    lates: "\u2AAD\uFE00",
    lbarr: "\u290C",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298B",
    lbrksld: "\u298F",
    lbrkslu: "\u298D",
    lcaron: "\u013E",
    lcedil: "\u013C",
    lceil: "\u2308",
    lcub: "{",
    lcy: "\u043B",
    ldca: "\u2936",
    ldquo: "\u201C",
    ldquor: "\u201E",
    ldrdhar: "\u2967",
    ldrushar: "\u294B",
    ldsh: "\u21B2",
    le: "\u2264",
    leftarrow: "\u2190",
    leftarrowtail: "\u21A2",
    leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC",
    leftleftarrows: "\u21C7",
    leftrightarrow: "\u2194",
    leftrightarrows: "\u21C6",
    leftrightharpoons: "\u21CB",
    leftrightsquigarrow: "\u21AD",
    leftthreetimes: "\u22CB",
    leg: "\u22DA",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2A7D",
    les: "\u2A7D",
    lescc: "\u2AA8",
    lesdot: "\u2A7F",
    lesdoto: "\u2A81",
    lesdotor: "\u2A83",
    lesg: "\u22DA\uFE00",
    lesges: "\u2A93",
    lessapprox: "\u2A85",
    lessdot: "\u22D6",
    lesseqgtr: "\u22DA",
    lesseqqgtr: "\u2A8B",
    lessgtr: "\u2276",
    lesssim: "\u2272",
    lfisht: "\u297C",
    lfloor: "\u230A",
    lfr: "\u{1D529}",
    lg: "\u2276",
    lgE: "\u2A91",
    lhard: "\u21BD",
    lharu: "\u21BC",
    lharul: "\u296A",
    lhblk: "\u2584",
    ljcy: "\u0459",
    ll: "\u226A",
    llarr: "\u21C7",
    llcorner: "\u231E",
    llhard: "\u296B",
    lltri: "\u25FA",
    lmidot: "\u0140",
    lmoust: "\u23B0",
    lmoustache: "\u23B0",
    lnE: "\u2268",
    lnap: "\u2A89",
    lnapprox: "\u2A89",
    lne: "\u2A87",
    lneq: "\u2A87",
    lneqq: "\u2268",
    lnsim: "\u22E6",
    loang: "\u27EC",
    loarr: "\u21FD",
    lobrk: "\u27E6",
    longleftarrow: "\u27F5",
    longleftrightarrow: "\u27F7",
    longmapsto: "\u27FC",
    longrightarrow: "\u27F6",
    looparrowleft: "\u21AB",
    looparrowright: "\u21AC",
    lopar: "\u2985",
    lopf: "\u{1D55D}",
    loplus: "\u2A2D",
    lotimes: "\u2A34",
    lowast: "\u2217",
    lowbar: "_",
    loz: "\u25CA",
    lozenge: "\u25CA",
    lozf: "\u29EB",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21C6",
    lrcorner: "\u231F",
    lrhar: "\u21CB",
    lrhard: "\u296D",
    lrm: "\u200E",
    lrtri: "\u22BF",
    lsaquo: "\u2039",
    lscr: "\u{1D4C1}",
    lsh: "\u21B0",
    lsim: "\u2272",
    lsime: "\u2A8D",
    lsimg: "\u2A8F",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201A",
    lstrok: "\u0142",
    lt: "<",
    ltcc: "\u2AA6",
    ltcir: "\u2A79",
    ltdot: "\u22D6",
    lthree: "\u22CB",
    ltimes: "\u22C9",
    ltlarr: "\u2976",
    ltquest: "\u2A7B",
    ltrPar: "\u2996",
    ltri: "\u25C3",
    ltrie: "\u22B4",
    ltrif: "\u25C2",
    lurdshar: "\u294A",
    luruhar: "\u2966",
    lvertneqq: "\u2268\uFE00",
    lvnE: "\u2268\uFE00",
    mDDot: "\u223A",
    macr: "\xAF",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    map: "\u21A6",
    mapsto: "\u21A6",
    mapstodown: "\u21A7",
    mapstoleft: "\u21A4",
    mapstoup: "\u21A5",
    marker: "\u25AE",
    mcomma: "\u2A29",
    mcy: "\u043C",
    mdash: "\u2014",
    measuredangle: "\u2221",
    mfr: "\u{1D52A}",
    mho: "\u2127",
    micro: "\xB5",
    mid: "\u2223",
    midast: "*",
    midcir: "\u2AF0",
    middot: "\xB7",
    minus: "\u2212",
    minusb: "\u229F",
    minusd: "\u2238",
    minusdu: "\u2A2A",
    mlcp: "\u2ADB",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22A7",
    mopf: "\u{1D55E}",
    mp: "\u2213",
    mscr: "\u{1D4C2}",
    mstpos: "\u223E",
    mu: "\u03BC",
    multimap: "\u22B8",
    mumap: "\u22B8",
    nGg: "\u22D9\u0338",
    nGt: "\u226B\u20D2",
    nGtv: "\u226B\u0338",
    nLeftarrow: "\u21CD",
    nLeftrightarrow: "\u21CE",
    nLl: "\u22D8\u0338",
    nLt: "\u226A\u20D2",
    nLtv: "\u226A\u0338",
    nRightarrow: "\u21CF",
    nVDash: "\u22AF",
    nVdash: "\u22AE",
    nabla: "\u2207",
    nacute: "\u0144",
    nang: "\u2220\u20D2",
    nap: "\u2249",
    napE: "\u2A70\u0338",
    napid: "\u224B\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natur: "\u266E",
    natural: "\u266E",
    naturals: "\u2115",
    nbsp: "\xA0",
    nbump: "\u224E\u0338",
    nbumpe: "\u224F\u0338",
    ncap: "\u2A43",
    ncaron: "\u0148",
    ncedil: "\u0146",
    ncong: "\u2247",
    ncongdot: "\u2A6D\u0338",
    ncup: "\u2A42",
    ncy: "\u043D",
    ndash: "\u2013",
    ne: "\u2260",
    neArr: "\u21D7",
    nearhk: "\u2924",
    nearr: "\u2197",
    nearrow: "\u2197",
    nedot: "\u2250\u0338",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    nexist: "\u2204",
    nexists: "\u2204",
    nfr: "\u{1D52B}",
    ngE: "\u2267\u0338",
    nge: "\u2271",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338",
    nges: "\u2A7E\u0338",
    ngsim: "\u2275",
    ngt: "\u226F",
    ngtr: "\u226F",
    nhArr: "\u21CE",
    nharr: "\u21AE",
    nhpar: "\u2AF2",
    ni: "\u220B",
    nis: "\u22FC",
    nisd: "\u22FA",
    niv: "\u220B",
    njcy: "\u045A",
    nlArr: "\u21CD",
    nlE: "\u2266\u0338",
    nlarr: "\u219A",
    nldr: "\u2025",
    nle: "\u2270",
    nleftarrow: "\u219A",
    nleftrightarrow: "\u21AE",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2A7D\u0338",
    nles: "\u2A7D\u0338",
    nless: "\u226E",
    nlsim: "\u2274",
    nlt: "\u226E",
    nltri: "\u22EA",
    nltrie: "\u22EC",
    nmid: "\u2224",
    nopf: "\u{1D55F}",
    not: "\xAC",
    notin: "\u2209",
    notinE: "\u22F9\u0338",
    notindot: "\u22F5\u0338",
    notinva: "\u2209",
    notinvb: "\u22F7",
    notinvc: "\u22F6",
    notni: "\u220C",
    notniva: "\u220C",
    notnivb: "\u22FE",
    notnivc: "\u22FD",
    npar: "\u2226",
    nparallel: "\u2226",
    nparsl: "\u2AFD\u20E5",
    npart: "\u2202\u0338",
    npolint: "\u2A14",
    npr: "\u2280",
    nprcue: "\u22E0",
    npre: "\u2AAF\u0338",
    nprec: "\u2280",
    npreceq: "\u2AAF\u0338",
    nrArr: "\u21CF",
    nrarr: "\u219B",
    nrarrc: "\u2933\u0338",
    nrarrw: "\u219D\u0338",
    nrightarrow: "\u219B",
    nrtri: "\u22EB",
    nrtrie: "\u22ED",
    nsc: "\u2281",
    nsccue: "\u22E1",
    nsce: "\u2AB0\u0338",
    nscr: "\u{1D4C3}",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22E2",
    nsqsupe: "\u22E3",
    nsub: "\u2284",
    nsubE: "\u2AC5\u0338",
    nsube: "\u2288",
    nsubset: "\u2282\u20D2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2AC5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2AB0\u0338",
    nsup: "\u2285",
    nsupE: "\u2AC6\u0338",
    nsupe: "\u2289",
    nsupset: "\u2283\u20D2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2AC6\u0338",
    ntgl: "\u2279",
    ntilde: "\xF1",
    ntlg: "\u2278",
    ntriangleleft: "\u22EA",
    ntrianglelefteq: "\u22EC",
    ntriangleright: "\u22EB",
    ntrianglerighteq: "\u22ED",
    nu: "\u03BD",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvDash: "\u22AD",
    nvHarr: "\u2904",
    nvap: "\u224D\u20D2",
    nvdash: "\u22AC",
    nvge: "\u2265\u20D2",
    nvgt: ">\u20D2",
    nvinfin: "\u29DE",
    nvlArr: "\u2902",
    nvle: "\u2264\u20D2",
    nvlt: "<\u20D2",
    nvltrie: "\u22B4\u20D2",
    nvrArr: "\u2903",
    nvrtrie: "\u22B5\u20D2",
    nvsim: "\u223C\u20D2",
    nwArr: "\u21D6",
    nwarhk: "\u2923",
    nwarr: "\u2196",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    oS: "\u24C8",
    oacute: "\xF3",
    oast: "\u229B",
    ocir: "\u229A",
    ocirc: "\xF4",
    ocy: "\u043E",
    odash: "\u229D",
    odblac: "\u0151",
    odiv: "\u2A38",
    odot: "\u2299",
    odsold: "\u29BC",
    oelig: "\u0153",
    ofcir: "\u29BF",
    ofr: "\u{1D52C}",
    ogon: "\u02DB",
    ograve: "\xF2",
    ogt: "\u29C1",
    ohbar: "\u29B5",
    ohm: "\u03A9",
    oint: "\u222E",
    olarr: "\u21BA",
    olcir: "\u29BE",
    olcross: "\u29BB",
    oline: "\u203E",
    olt: "\u29C0",
    omacr: "\u014D",
    omega: "\u03C9",
    omicron: "\u03BF",
    omid: "\u29B6",
    ominus: "\u2296",
    oopf: "\u{1D560}",
    opar: "\u29B7",
    operp: "\u29B9",
    oplus: "\u2295",
    or: "\u2228",
    orarr: "\u21BB",
    ord: "\u2A5D",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xAA",
    ordm: "\xBA",
    origof: "\u22B6",
    oror: "\u2A56",
    orslope: "\u2A57",
    orv: "\u2A5B",
    oscr: "\u2134",
    oslash: "\xF8",
    osol: "\u2298",
    otilde: "\xF5",
    otimes: "\u2297",
    otimesas: "\u2A36",
    ouml: "\xF6",
    ovbar: "\u233D",
    par: "\u2225",
    para: "\xB6",
    parallel: "\u2225",
    parsim: "\u2AF3",
    parsl: "\u2AFD",
    part: "\u2202",
    pcy: "\u043F",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22A5",
    pertenk: "\u2031",
    pfr: "\u{1D52D}",
    phi: "\u03C6",
    phiv: "\u03D5",
    phmmat: "\u2133",
    phone: "\u260E",
    pi: "\u03C0",
    pitchfork: "\u22D4",
    piv: "\u03D6",
    planck: "\u210F",
    planckh: "\u210E",
    plankv: "\u210F",
    plus: "+",
    plusacir: "\u2A23",
    plusb: "\u229E",
    pluscir: "\u2A22",
    plusdo: "\u2214",
    plusdu: "\u2A25",
    pluse: "\u2A72",
    plusmn: "\xB1",
    plussim: "\u2A26",
    plustwo: "\u2A27",
    pm: "\xB1",
    pointint: "\u2A15",
    popf: "\u{1D561}",
    pound: "\xA3",
    pr: "\u227A",
    prE: "\u2AB3",
    prap: "\u2AB7",
    prcue: "\u227C",
    pre: "\u2AAF",
    prec: "\u227A",
    precapprox: "\u2AB7",
    preccurlyeq: "\u227C",
    preceq: "\u2AAF",
    precnapprox: "\u2AB9",
    precneqq: "\u2AB5",
    precnsim: "\u22E8",
    precsim: "\u227E",
    prime: "\u2032",
    primes: "\u2119",
    prnE: "\u2AB5",
    prnap: "\u2AB9",
    prnsim: "\u22E8",
    prod: "\u220F",
    profalar: "\u232E",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221D",
    propto: "\u221D",
    prsim: "\u227E",
    prurel: "\u22B0",
    pscr: "\u{1D4C5}",
    psi: "\u03C8",
    puncsp: "\u2008",
    qfr: "\u{1D52E}",
    qint: "\u2A0C",
    qopf: "\u{1D562}",
    qprime: "\u2057",
    qscr: "\u{1D4C6}",
    quaternions: "\u210D",
    quatint: "\u2A16",
    quest: "?",
    questeq: "\u225F",
    quot: '"',
    rAarr: "\u21DB",
    rArr: "\u21D2",
    rAtail: "\u291C",
    rBarr: "\u290F",
    rHar: "\u2964",
    race: "\u223D\u0331",
    racute: "\u0155",
    radic: "\u221A",
    raemptyv: "\u29B3",
    rang: "\u27E9",
    rangd: "\u2992",
    range: "\u29A5",
    rangle: "\u27E9",
    raquo: "\xBB",
    rarr: "\u2192",
    rarrap: "\u2975",
    rarrb: "\u21E5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarrfs: "\u291E",
    rarrhk: "\u21AA",
    rarrlp: "\u21AC",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    rarrtl: "\u21A3",
    rarrw: "\u219D",
    ratail: "\u291A",
    ratio: "\u2236",
    rationals: "\u211A",
    rbarr: "\u290D",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298C",
    rbrksld: "\u298E",
    rbrkslu: "\u2990",
    rcaron: "\u0159",
    rcedil: "\u0157",
    rceil: "\u2309",
    rcub: "}",
    rcy: "\u0440",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201D",
    rdquor: "\u201D",
    rdsh: "\u21B3",
    real: "\u211C",
    realine: "\u211B",
    realpart: "\u211C",
    reals: "\u211D",
    rect: "\u25AD",
    reg: "\xAE",
    rfisht: "\u297D",
    rfloor: "\u230B",
    rfr: "\u{1D52F}",
    rhard: "\u21C1",
    rharu: "\u21C0",
    rharul: "\u296C",
    rho: "\u03C1",
    rhov: "\u03F1",
    rightarrow: "\u2192",
    rightarrowtail: "\u21A3",
    rightharpoondown: "\u21C1",
    rightharpoonup: "\u21C0",
    rightleftarrows: "\u21C4",
    rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9",
    rightsquigarrow: "\u219D",
    rightthreetimes: "\u22CC",
    ring: "\u02DA",
    risingdotseq: "\u2253",
    rlarr: "\u21C4",
    rlhar: "\u21CC",
    rlm: "\u200F",
    rmoust: "\u23B1",
    rmoustache: "\u23B1",
    rnmid: "\u2AEE",
    roang: "\u27ED",
    roarr: "\u21FE",
    robrk: "\u27E7",
    ropar: "\u2986",
    ropf: "\u{1D563}",
    roplus: "\u2A2E",
    rotimes: "\u2A35",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2A12",
    rrarr: "\u21C9",
    rsaquo: "\u203A",
    rscr: "\u{1D4C7}",
    rsh: "\u21B1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22CC",
    rtimes: "\u22CA",
    rtri: "\u25B9",
    rtrie: "\u22B5",
    rtrif: "\u25B8",
    rtriltri: "\u29CE",
    ruluhar: "\u2968",
    rx: "\u211E",
    sacute: "\u015B",
    sbquo: "\u201A",
    sc: "\u227B",
    scE: "\u2AB4",
    scap: "\u2AB8",
    scaron: "\u0161",
    sccue: "\u227D",
    sce: "\u2AB0",
    scedil: "\u015F",
    scirc: "\u015D",
    scnE: "\u2AB6",
    scnap: "\u2ABA",
    scnsim: "\u22E9",
    scpolint: "\u2A13",
    scsim: "\u227F",
    scy: "\u0441",
    sdot: "\u22C5",
    sdotb: "\u22A1",
    sdote: "\u2A66",
    seArr: "\u21D8",
    searhk: "\u2925",
    searr: "\u2198",
    searrow: "\u2198",
    sect: "\xA7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    sfr: "\u{1D530}",
    sfrown: "\u2322",
    sharp: "\u266F",
    shchcy: "\u0449",
    shcy: "\u0448",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    shy: "\xAD",
    sigma: "\u03C3",
    sigmaf: "\u03C2",
    sigmav: "\u03C2",
    sim: "\u223C",
    simdot: "\u2A6A",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2A9E",
    simgE: "\u2AA0",
    siml: "\u2A9D",
    simlE: "\u2A9F",
    simne: "\u2246",
    simplus: "\u2A24",
    simrarr: "\u2972",
    slarr: "\u2190",
    smallsetminus: "\u2216",
    smashp: "\u2A33",
    smeparsl: "\u29E4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2AAA",
    smte: "\u2AAC",
    smtes: "\u2AAC\uFE00",
    softcy: "\u044C",
    sol: "/",
    solb: "\u29C4",
    solbar: "\u233F",
    sopf: "\u{1D564}",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\uFE00",
    sqcup: "\u2294",
    sqcups: "\u2294\uFE00",
    sqsub: "\u228F",
    sqsube: "\u2291",
    sqsubset: "\u228F",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    squ: "\u25A1",
    square: "\u25A1",
    squarf: "\u25AA",
    squf: "\u25AA",
    srarr: "\u2192",
    sscr: "\u{1D4C8}",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22C6",
    star: "\u2606",
    starf: "\u2605",
    straightepsilon: "\u03F5",
    straightphi: "\u03D5",
    strns: "\xAF",
    sub: "\u2282",
    subE: "\u2AC5",
    subdot: "\u2ABD",
    sube: "\u2286",
    subedot: "\u2AC3",
    submult: "\u2AC1",
    subnE: "\u2ACB",
    subne: "\u228A",
    subplus: "\u2ABF",
    subrarr: "\u2979",
    subset: "\u2282",
    subseteq: "\u2286",
    subseteqq: "\u2AC5",
    subsetneq: "\u228A",
    subsetneqq: "\u2ACB",
    subsim: "\u2AC7",
    subsub: "\u2AD5",
    subsup: "\u2AD3",
    succ: "\u227B",
    succapprox: "\u2AB8",
    succcurlyeq: "\u227D",
    succeq: "\u2AB0",
    succnapprox: "\u2ABA",
    succneqq: "\u2AB6",
    succnsim: "\u22E9",
    succsim: "\u227F",
    sum: "\u2211",
    sung: "\u266A",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    sup: "\u2283",
    supE: "\u2AC6",
    supdot: "\u2ABE",
    supdsub: "\u2AD8",
    supe: "\u2287",
    supedot: "\u2AC4",
    suphsol: "\u27C9",
    suphsub: "\u2AD7",
    suplarr: "\u297B",
    supmult: "\u2AC2",
    supnE: "\u2ACC",
    supne: "\u228B",
    supplus: "\u2AC0",
    supset: "\u2283",
    supseteq: "\u2287",
    supseteqq: "\u2AC6",
    supsetneq: "\u228B",
    supsetneqq: "\u2ACC",
    supsim: "\u2AC8",
    supsub: "\u2AD4",
    supsup: "\u2AD6",
    swArr: "\u21D9",
    swarhk: "\u2926",
    swarr: "\u2199",
    swarrow: "\u2199",
    swnwar: "\u292A",
    szlig: "\xDF",
    target: "\u2316",
    tau: "\u03C4",
    tbrk: "\u23B4",
    tcaron: "\u0165",
    tcedil: "\u0163",
    tcy: "\u0442",
    tdot: "\u20DB",
    telrec: "\u2315",
    tfr: "\u{1D531}",
    there4: "\u2234",
    therefore: "\u2234",
    theta: "\u03B8",
    thetasym: "\u03D1",
    thetav: "\u03D1",
    thickapprox: "\u2248",
    thicksim: "\u223C",
    thinsp: "\u2009",
    thkap: "\u2248",
    thksim: "\u223C",
    thorn: "\xFE",
    tilde: "\u02DC",
    times: "\xD7",
    timesb: "\u22A0",
    timesbar: "\u2A31",
    timesd: "\u2A30",
    tint: "\u222D",
    toea: "\u2928",
    top: "\u22A4",
    topbot: "\u2336",
    topcir: "\u2AF1",
    topf: "\u{1D565}",
    topfork: "\u2ADA",
    tosa: "\u2929",
    tprime: "\u2034",
    trade: "\u2122",
    triangle: "\u25B5",
    triangledown: "\u25BF",
    triangleleft: "\u25C3",
    trianglelefteq: "\u22B4",
    triangleq: "\u225C",
    triangleright: "\u25B9",
    trianglerighteq: "\u22B5",
    tridot: "\u25EC",
    trie: "\u225C",
    triminus: "\u2A3A",
    triplus: "\u2A39",
    trisb: "\u29CD",
    tritime: "\u2A3B",
    trpezium: "\u23E2",
    tscr: "\u{1D4C9}",
    tscy: "\u0446",
    tshcy: "\u045B",
    tstrok: "\u0167",
    twixt: "\u226C",
    twoheadleftarrow: "\u219E",
    twoheadrightarrow: "\u21A0",
    uArr: "\u21D1",
    uHar: "\u2963",
    uacute: "\xFA",
    uarr: "\u2191",
    ubrcy: "\u045E",
    ubreve: "\u016D",
    ucirc: "\xFB",
    ucy: "\u0443",
    udarr: "\u21C5",
    udblac: "\u0171",
    udhar: "\u296E",
    ufisht: "\u297E",
    ufr: "\u{1D532}",
    ugrave: "\xF9",
    uharl: "\u21BF",
    uharr: "\u21BE",
    uhblk: "\u2580",
    ulcorn: "\u231C",
    ulcorner: "\u231C",
    ulcrop: "\u230F",
    ultri: "\u25F8",
    umacr: "\u016B",
    uml: "\xA8",
    uogon: "\u0173",
    uopf: "\u{1D566}",
    uparrow: "\u2191",
    updownarrow: "\u2195",
    upharpoonleft: "\u21BF",
    upharpoonright: "\u21BE",
    uplus: "\u228E",
    upsi: "\u03C5",
    upsih: "\u03D2",
    upsilon: "\u03C5",
    upuparrows: "\u21C8",
    urcorn: "\u231D",
    urcorner: "\u231D",
    urcrop: "\u230E",
    uring: "\u016F",
    urtri: "\u25F9",
    uscr: "\u{1D4CA}",
    utdot: "\u22F0",
    utilde: "\u0169",
    utri: "\u25B5",
    utrif: "\u25B4",
    uuarr: "\u21C8",
    uuml: "\xFC",
    uwangle: "\u29A7",
    vArr: "\u21D5",
    vBar: "\u2AE8",
    vBarv: "\u2AE9",
    vDash: "\u22A8",
    vangrt: "\u299C",
    varepsilon: "\u03F5",
    varkappa: "\u03F0",
    varnothing: "\u2205",
    varphi: "\u03D5",
    varpi: "\u03D6",
    varpropto: "\u221D",
    varr: "\u2195",
    varrho: "\u03F1",
    varsigma: "\u03C2",
    varsubsetneq: "\u228A\uFE00",
    varsubsetneqq: "\u2ACB\uFE00",
    varsupsetneq: "\u228B\uFE00",
    varsupsetneqq: "\u2ACC\uFE00",
    vartheta: "\u03D1",
    vartriangleleft: "\u22B2",
    vartriangleright: "\u22B3",
    vcy: "\u0432",
    vdash: "\u22A2",
    vee: "\u2228",
    veebar: "\u22BB",
    veeeq: "\u225A",
    vellip: "\u22EE",
    verbar: "|",
    vert: "|",
    vfr: "\u{1D533}",
    vltri: "\u22B2",
    vnsub: "\u2282\u20D2",
    vnsup: "\u2283\u20D2",
    vopf: "\u{1D567}",
    vprop: "\u221D",
    vrtri: "\u22B3",
    vscr: "\u{1D4CB}",
    vsubnE: "\u2ACB\uFE00",
    vsubne: "\u228A\uFE00",
    vsupnE: "\u2ACC\uFE00",
    vsupne: "\u228B\uFE00",
    vzigzag: "\u299A",
    wcirc: "\u0175",
    wedbar: "\u2A5F",
    wedge: "\u2227",
    wedgeq: "\u2259",
    weierp: "\u2118",
    wfr: "\u{1D534}",
    wopf: "\u{1D568}",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    wscr: "\u{1D4CC}",
    xcap: "\u22C2",
    xcirc: "\u25EF",
    xcup: "\u22C3",
    xdtri: "\u25BD",
    xfr: "\u{1D535}",
    xhArr: "\u27FA",
    xharr: "\u27F7",
    xi: "\u03BE",
    xlArr: "\u27F8",
    xlarr: "\u27F5",
    xmap: "\u27FC",
    xnis: "\u22FB",
    xodot: "\u2A00",
    xopf: "\u{1D569}",
    xoplus: "\u2A01",
    xotime: "\u2A02",
    xrArr: "\u27F9",
    xrarr: "\u27F6",
    xscr: "\u{1D4CD}",
    xsqcup: "\u2A06",
    xuplus: "\u2A04",
    xutri: "\u25B3",
    xvee: "\u22C1",
    xwedge: "\u22C0",
    yacute: "\xFD",
    yacy: "\u044F",
    ycirc: "\u0177",
    ycy: "\u044B",
    yen: "\xA5",
    yfr: "\u{1D536}",
    yicy: "\u0457",
    yopf: "\u{1D56A}",
    yscr: "\u{1D4CE}",
    yucy: "\u044E",
    yuml: "\xFF",
    zacute: "\u017A",
    zcaron: "\u017E",
    zcy: "\u0437",
    zdot: "\u017C",
    zeetrf: "\u2128",
    zeta: "\u03B6",
    zfr: "\u{1D537}",
    zhcy: "\u0436",
    zigrarr: "\u21DD",
    zopf: "\u{1D56B}",
    zscr: "\u{1D4CF}",
    zwj: "\u200D",
    zwnj: "\u200C"
  }, dq = {}.hasOwnProperty;
  s(xa, "decodeNamedCharacterReference");
  Vs = String.fromCharCode, mq = [
    "",
    /* 1: Non terminated (named) */
    "Named character references must be terminated by a semicolon",
    /* 2: Non terminated (numeric) */
    "Numeric character references must be terminated by a semicolon",
    /* 3: Empty (named) */
    "Named character references cannot be empty",
    /* 4: Empty (numeric) */
    "Numeric character references cannot be empty",
    /* 5: Unknown (named) */
    "Named character references must be known",
    /* 6: Disallowed (numeric) */
    "Numeric character references cannot be disallowed",
    /* 7: Prohibited (numeric) */
    "Numeric character references cannot be outside the permissible Unicode range"
  ];
  s(gq, "parseEntities");
  s(yq, "prohibited");
  s(Dq, "disallowed");
  s(xq, "core");
  s(bq, "charactersToExpression");
  s(vq, "formatBasic");
  s(Eq, "stringifyEntitiesLight");
  E2 = "  ";
  s(Cq, "mdxJsxFromMarkdown");
  s(wq, "mdxJsxToMarkdown");
  s(Sq, "containerFlow");
  s(C2, "inferDepth");
  s(w2, "createIndent");
  s(Aq, "peekElement");
  s(Fq, "mdxjsEsmFromMarkdown");
  s(_q, "mdxjsEsmToMarkdown");
  s(kq, "enterMdxjsEsm");
  s(Tq, "exitMdxjsEsm");
  s(Iq, "exitMdxjsEsmData");
  s(Pq, "handleMdxjsEsm");
  s(Bq, "mdxFromMarkdown");
  s(Oq, "mdxToMarkdown");
  Rq = Sl(eq(), 1), Nq = ui(/\p{P}/u), qr = ui(/[A-Za-z]/), er = ui(/[\dA-Za-z]/), Lq = ui(/[#-'*+\--9=?A-Z^-~]/);
  s(Om, "asciiControl");
  Rm = ui(/\d/), jq = ui(/[\dA-Fa-f]/), S2 = ui(/[!-/:-@[-`{-~]/);
  s(le, "markdownLineEnding");
  s(ht, "markdownLineEndingOrSpace");
  s(Oe, "markdownSpace");
  s(Mq, "unicodePunctuation");
  Pn = ui(/\s/);
  s(ui, "regexCheck");
  s(qq, "color");
  $q = {}.hasOwnProperty, Vq = Symbol("continue"), vm = Symbol("exit"), Uq = Symbol("skip");
  s(Wq, "visit");
  s(_w, "toResult");
  s(Em, "nodelike");
  s(A2, "eventsToAcorn");
  s(kw, "empty");
  s(zq, "collect");
  s(Hq, "relativeToPoint");
  s(Gq, "serializeChunks");
  s(Bn, "positionFromEstree");
  s(Tw, "pointOrUndefined");
  s(Cm, "numberOrUndefined");
  Js = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", Jq = "#unexp\
ected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", Zq = "#unexpected-lazy-line-in-expression-in-container-expecte\
d-line-to-be-prefixed", Iw = "#unexpected-type-in-code-expected-an-object-spread-spread", Xq = "#unexpected-extra-content-in-spread-only-a-s\
ingle-spread-is-supported", Kq = "#could-not-parse-expression-with-acorn";
  s(Wl, "factoryMdxExpression");
  s(Yq, "mdxExpressionParse");
  s(qe, "factorySpace");
  s(Qq, "mdxExpression");
  Pw = "https://github.com/micromark/micromark-extension-mdx-jsx";
  s(F2, "factoryTag");
  s(e$, "serializeCharCode");
  s(t$, "jsxText");
  s(r$, "jsxFlow");
  s(n$, "mdxJsx");
  s(i$, "mdxMd");
  s(on, "splice");
  s(xr, "push");
  s(Bw, "classifyCharacter");
  s(qm, "resolveAll");
  Nm = {
    name: "attention",
    tokenize: o$,
    resolveAll: s$
  };
  s(s$, "resolveAllAttention");
  s(o$, "tokenizeAttention");
  s(Ow, "movePoint");
  a$ = {
    name: "autolink",
    tokenize: u$
  };
  s(u$, "tokenizeAutolink");
  va = {
    tokenize: l$,
    partial: !0
  };
  s(l$, "tokenizeBlankLine");
  _2 = {
    name: "blockQuote",
    tokenize: c$,
    continuation: {
      tokenize: p$
    },
    exit: h$
  };
  s(c$, "tokenizeBlockQuoteStart");
  s(p$, "tokenizeBlockQuoteContinuation");
  s(h$, "exit");
  k2 = {
    name: "characterEscape",
    tokenize: f$
  };
  s(f$, "tokenizeCharacterEscape");
  T2 = {
    name: "characterReference",
    tokenize: d$
  };
  s(d$, "tokenizeCharacterReference");
  Rw = {
    tokenize: g$,
    partial: !0
  }, Nw = {
    name: "codeFenced",
    tokenize: m$,
    concrete: !0
  };
  s(m$, "tokenizeCodeFenced");
  s(g$, "tokenizeNonLazyContinuation");
  wm = {
    name: "codeIndented",
    tokenize: D$
  }, y$ = {
    tokenize: x$,
    partial: !0
  };
  s(D$, "tokenizeCodeIndented");
  s(x$, "tokenizeFurtherStart");
  b$ = {
    name: "codeText",
    tokenize: C$,
    resolve: v$,
    previous: E$
  };
  s(v$, "resolveCodeText");
  s(E$, "previous");
  s(C$, "tokenizeCodeText");
  s(I2, "subtokenize");
  s(w$, "subcontent");
  S$ = {
    tokenize: _$,
    resolve: F$
  }, A$ = {
    tokenize: k$,
    partial: !0
  };
  s(F$, "resolveContent");
  s(_$, "tokenizeContent");
  s(k$, "tokenizeContinuation");
  s(P2, "factoryDestination");
  s(B2, "factoryLabel");
  s(O2, "factoryTitle");
  s(ya, "factoryWhitespace");
  s(Zs, "normalizeIdentifier");
  T$ = {
    name: "definition",
    tokenize: P$
  }, I$ = {
    tokenize: B$,
    partial: !0
  };
  s(P$, "tokenizeDefinition");
  s(B$, "tokenizeTitleBefore");
  O$ = {
    name: "hardBreakEscape",
    tokenize: R$
  };
  s(R$, "tokenizeHardBreakEscape");
  N$ = {
    name: "headingAtx",
    tokenize: j$,
    resolve: L$
  };
  s(L$, "resolveHeadingAtx");
  s(j$, "tokenizeHeadingAtx");
  M$ = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ], Lw = ["pre", "script", "style", "textarea"], q$ = {
    name: "htmlFlow",
    tokenize: W$,
    resolveTo: U$,
    concrete: !0
  }, $$ = {
    tokenize: H$,
    partial: !0
  }, V$ = {
    tokenize: z$,
    partial: !0
  };
  s(U$, "resolveToHtmlFlow");
  s(W$, "tokenizeHtmlFlow");
  s(z$, "tokenizeNonLazyContinuationStart");
  s(H$, "tokenizeBlankLineBefore");
  G$ = {
    name: "htmlText",
    tokenize: J$
  };
  s(J$, "tokenizeHtmlText");
  $m = {
    name: "labelEnd",
    tokenize: eV,
    resolveTo: Q$,
    resolveAll: Y$
  }, Z$ = {
    tokenize: tV
  }, X$ = {
    tokenize: rV
  }, K$ = {
    tokenize: nV
  };
  s(Y$, "resolveAllLabelEnd");
  s(Q$, "resolveToLabelEnd");
  s(eV, "tokenizeLabelEnd");
  s(tV, "tokenizeResource");
  s(rV, "tokenizeReferenceFull");
  s(nV, "tokenizeReferenceCollapsed");
  iV = {
    name: "labelStartImage",
    tokenize: sV,
    resolveAll: $m.resolveAll
  };
  s(sV, "tokenizeLabelStartImage");
  oV = {
    name: "labelStartLink",
    tokenize: aV,
    resolveAll: $m.resolveAll
  };
  s(aV, "tokenizeLabelStartLink");
  Sm = {
    name: "lineEnding",
    tokenize: uV
  };
  s(uV, "tokenizeLineEnding");
  Ul = {
    name: "thematicBreak",
    tokenize: lV
  };
  s(lV, "tokenizeThematicBreak");
  Wt = {
    name: "list",
    tokenize: hV,
    continuation: {
      tokenize: fV
    },
    exit: mV
  }, cV = {
    tokenize: gV,
    partial: !0
  }, pV = {
    tokenize: dV,
    partial: !0
  };
  s(hV, "tokenizeListStart");
  s(fV, "tokenizeListContinuation");
  s(dV, "tokenizeIndent");
  s(mV, "tokenizeListEnd");
  s(gV, "tokenizeListItemPrefixWhitespace");
  jw = {
    name: "setextUnderline",
    tokenize: DV,
    resolveTo: yV
  };
  s(yV, "resolveToSetextUnderline");
  s(DV, "tokenizeSetextUnderline");
  xV = {
    tokenize: EV,
    partial: !0
  }, Mw = "https://github.com/micromark/micromark-extension-mdxjs-esm", bV = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportDefault\
Declaration", "ExportNamedDeclaration", "ImportDeclaration"]);
  s(vV, "mdxjsEsm");
  s(EV, "tokenizeNextBlank");
  qw = {}.hasOwnProperty;
  s(R2, "combineExtensions");
  s(CV, "syntaxExtension");
  s(wV, "constructs");
  s(SV, "mdxjs");
  AV = {};
  s(FV, "remarkMdx");
  _V = {};
  s(kV, "toString");
  s(N2, "one");
  s($w, "all");
  s(TV, "node");
  s(L2, "decodeNumericCharacterReference");
  s(Xs, "normalizeUri");
  IV = {
    tokenize: PV
  };
  s(PV, "initializeContent");
  BV = {
    tokenize: OV
  }, Vw = {
    tokenize: RV
  };
  s(OV, "initializeDocument");
  s(RV, "tokenizeContainer");
  NV = {
    tokenize: LV
  };
  s(LV, "initializeFlow");
  jV = {
    resolveAll: M2()
  }, MV = j2("string"), qV = j2("text");
  s(j2, "initializeFactory");
  s(M2, "createResolver");
  s($V, "resolveAllLineSuffixes");
  s(VV, "createTokenizer");
  s(UV, "sliceChunks");
  s(WV, "serializeChunks2");
  q2 = {};
  Xd(q2, {
    attentionMarkers: /* @__PURE__ */ s(() => YV, "attentionMarkers"),
    contentInitial: /* @__PURE__ */ s(() => HV, "contentInitial"),
    disable: /* @__PURE__ */ s(() => QV, "disable"),
    document: /* @__PURE__ */ s(() => zV, "document"),
    flow: /* @__PURE__ */ s(() => JV, "flow"),
    flowInitial: /* @__PURE__ */ s(() => GV, "flowInitial"),
    insideSpan: /* @__PURE__ */ s(() => KV, "insideSpan"),
    string: /* @__PURE__ */ s(() => ZV, "string"),
    text: /* @__PURE__ */ s(() => XV, "text")
  });
  zV = {
    42: Wt,
    43: Wt,
    45: Wt,
    48: Wt,
    49: Wt,
    50: Wt,
    51: Wt,
    52: Wt,
    53: Wt,
    54: Wt,
    55: Wt,
    56: Wt,
    57: Wt,
    62: _2
  }, HV = {
    91: T$
  }, GV = {
    [-2]: wm,
    [-1]: wm,
    32: wm
  }, JV = {
    35: N$,
    42: Ul,
    45: [jw, Ul],
    60: q$,
    61: jw,
    95: Ul,
    96: Nw,
    126: Nw
  }, ZV = {
    38: T2,
    92: k2
  }, XV = {
    [-5]: Sm,
    [-4]: Sm,
    [-3]: Sm,
    33: iV,
    38: T2,
    42: Nm,
    60: [a$, G$],
    91: oV,
    92: [O$, k2],
    93: $m,
    95: Nm,
    96: b$
  }, KV = {
    null: [Nm, jV]
  }, YV = {
    null: [42, 95]
  }, QV = {
    null: []
  };
  s(eU, "parse");
  s(tU, "postprocess");
  Uw = /[\0\t\n\r]/g;
  s(rU, "preprocess");
  nU = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  s(iU, "decodeString");
  s(sU, "decode");
  $2 = {}.hasOwnProperty;
  s(oU, "fromMarkdown");
  s(aU, "compiler");
  s(si, "point2");
  s(V2, "configure");
  s(uU, "extension");
  s(Ww, "defaultOnError");
  s(lU, "remarkParse");
  s(cU, "blockquote");
  s(pU, "hardBreak");
  s(hU, "code");
  s(fU, "strikethrough");
  s(dU, "emphasis");
  s(mU, "footnoteReference");
  s(gU, "heading");
  s(yU, "html");
  s(U2, "revert");
  s(DU, "imageReference");
  s(xU, "image");
  s(bU, "inlineCode");
  s(vU, "linkReference");
  s(EU, "link");
  s(CU, "listItem");
  s(wU, "listLoose");
  s(W2, "listItemLoose");
  s(SU, "list2");
  s(AU, "paragraph");
  s(FU, "root");
  s(_U, "strong");
  s(kU, "table");
  s(TU, "tableRow");
  s(IU, "tableCell");
  zw = 9, Hw = 32;
  s(PU, "trimLines");
  s(Gw, "trimLine");
  s(BU, "text3");
  s(OU, "thematicBreak2");
  RU = {
    blockquote: cU,
    break: pU,
    code: hU,
    delete: fU,
    emphasis: dU,
    footnoteReference: mU,
    heading: gU,
    html: yU,
    imageReference: DU,
    image: xU,
    inlineCode: bU,
    linkReference: vU,
    link: EU,
    listItem: CU,
    list: SU,
    paragraph: AU,
    // @ts-expect-error: root is different, but hard to type.
    root: FU,
    strong: _U,
    table: kU,
    tableCell: IU,
    tableRow: TU,
    text: BU,
    thematicBreak: OU,
    toml: jl,
    yaml: jl,
    definition: jl,
    footnoteDefinition: jl
  };
  s(jl, "ignore");
  z2 = -1, Zl = 0, zl = 1, Hl = 2, Vm = 3, Um = 4, Wm = 5, zm = 6, H2 = 7, G2 = 8, Jw = typeof self == "object" ? self : globalThis, NU = /* @__PURE__ */ s(
  (e, t) => {
    let r = /* @__PURE__ */ s((i, o) => (e.set(o, i), i), "as"), n = /* @__PURE__ */ s((i) => {
      if (e.has(i))
        return e.get(i);
      let [o, a] = t[i];
      switch (o) {
        case Zl:
        case z2:
          return r(a, i);
        case zl: {
          let u = r([], i);
          for (let l of a)
            u.push(n(l));
          return u;
        }
        case Hl: {
          let u = r({}, i);
          for (let [l, c] of a)
            u[n(l)] = n(c);
          return u;
        }
        case Vm:
          return r(new Date(a), i);
        case Um: {
          let { source: u, flags: l } = a;
          return r(new RegExp(u, l), i);
        }
        case Wm: {
          let u = r(/* @__PURE__ */ new Map(), i);
          for (let [l, c] of a)
            u.set(n(l), n(c));
          return u;
        }
        case zm: {
          let u = r(/* @__PURE__ */ new Set(), i);
          for (let l of a)
            u.add(n(l));
          return u;
        }
        case H2: {
          let { name: u, message: l } = a;
          return r(new Jw[u](l), i);
        }
        case G2:
          return r(BigInt(a), i);
        case "BigInt":
          return r(Object(BigInt(a)), i);
      }
      return r(new Jw[o](a), i);
    }, "unpair");
    return n;
  }, "deserializer"), Zw = /* @__PURE__ */ s((e) => NU(/* @__PURE__ */ new Map(), e)(0), "deserialize"), Us = "", { toString: LU } = {}, { keys: jU } =
  Object, ga = /* @__PURE__ */ s((e) => {
    let t = typeof e;
    if (t !== "object" || !e)
      return [Zl, t];
    let r = LU.call(e).slice(8, -1);
    switch (r) {
      case "Array":
        return [zl, Us];
      case "Object":
        return [Hl, Us];
      case "Date":
        return [Vm, Us];
      case "RegExp":
        return [Um, Us];
      case "Map":
        return [Wm, Us];
      case "Set":
        return [zm, Us];
    }
    return r.includes("Array") ? [zl, r] : r.includes("Error") ? [H2, r] : [Hl, r];
  }, "typeOf"), Ml = /* @__PURE__ */ s(([e, t]) => e === Zl && (t === "function" || t === "symbol"), "shouldSkip"), MU = /* @__PURE__ */ s((e, t, r, n) => {
    let i = /* @__PURE__ */ s((a, u) => {
      let l = n.push(a) - 1;
      return r.set(u, l), l;
    }, "as"), o = /* @__PURE__ */ s((a) => {
      if (r.has(a))
        return r.get(a);
      let [u, l] = ga(a);
      switch (u) {
        case Zl: {
          let p = a;
          switch (l) {
            case "bigint":
              u = G2, p = a.toString();
              break;
            case "function":
            case "symbol":
              if (e)
                throw new TypeError("unable to serialize " + l);
              p = null;
              break;
            case "undefined":
              return i([z2], a);
          }
          return i([u, p], a);
        }
        case zl: {
          if (l)
            return i([l, [...a]], a);
          let p = [], h = i([u, p], a);
          for (let f of a)
            p.push(o(f));
          return h;
        }
        case Hl: {
          if (l)
            switch (l) {
              case "BigInt":
                return i([l, a.toString()], a);
              case "Boolean":
              case "Number":
              case "String":
                return i([l, a.valueOf()], a);
            }
          if (t && "toJSON" in a)
            return o(a.toJSON());
          let p = [], h = i([u, p], a);
          for (let f of jU(a))
            (e || !Ml(ga(a[f]))) && p.push([o(f), o(a[f])]);
          return h;
        }
        case Vm:
          return i([u, a.toISOString()], a);
        case Um: {
          let { source: p, flags: h } = a;
          return i([u, { source: p, flags: h }], a);
        }
        case Wm: {
          let p = [], h = i([u, p], a);
          for (let [f, d] of a)
            (e || !(Ml(ga(f)) || Ml(ga(d)))) && p.push([o(f), o(d)]);
          return h;
        }
        case zm: {
          let p = [], h = i([u, p], a);
          for (let f of a)
            (e || !Ml(ga(f))) && p.push(o(f));
          return h;
        }
      }
      let { message: c } = a;
      return i([u, { name: l, message: c }], a);
    }, "pair");
    return o;
  }, "serializer"), Xw = /* @__PURE__ */ s((e, { json: t, lossy: r } = {}) => {
    let n = [];
    return MU(!(t || r), !!t, /* @__PURE__ */ new Map(), n)(e), n;
  }, "serialize"), Gl = typeof structuredClone == "function" ? (
    /* c8 ignore start */
    (e, t) => t && ("json" in t || "lossy" in t) ? Zw(Xw(e, t)) : structuredClone(e)
  ) : (e, t) => Zw(Xw(e, t));
  s(qU, "defaultFootnoteBackContent");
  s($U, "defaultFootnoteBackLabel");
  s(VU, "footer");
  J2 = // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  /* @__PURE__ */ s(function(e) {
    if (e == null)
      return HU;
    if (typeof e == "function")
      return Xl(e);
    if (typeof e == "object")
      return Array.isArray(e) ? UU(e) : WU(e);
    if (typeof e == "string")
      return zU(e);
    throw new Error("Expected function, string, or object as test");
  }, "convert");
  s(UU, "anyFactory");
  s(WU, "propsFactory");
  s(zU, "typeFactory");
  s(Xl, "castFactory");
  s(HU, "ok2");
  s(GU, "looksLikeANode");
  s(JU, "color2");
  Z2 = [], ZU = !0, Kw = !1, XU = "skip";
  s(KU, "visitParents");
  s(YU, "toResult2");
  s(Hm, "visit2");
  Lm = {}.hasOwnProperty, QU = {};
  s(eW, "createState");
  s(tW, "patch");
  s(rW, "applyData");
  s(nW, "defaultUnknownHandler");
  s(iW, "wrap");
  s(Yw, "trimMarkdownSpaceStart");
  s(Qw, "toHast");
  s(sW, "remarkRehype");
  s(e2, "bail");
  Am = Sl(tq(), 1);
  s(jm, "isPlainObject");
  s(oW, "trough");
  s(aW, "wrap2");
  uW = /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  /* @__PURE__ */ s(function(e) {
    let n = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = n[e], o = /* @__PURE__ */ s(function() {
      return i.apply(o, arguments);
    }, "apply");
    Object.setPrototypeOf(o, n);
    let a = Object.getOwnPropertyNames(i);
    for (let u of a) {
      let l = Object.getOwnPropertyDescriptor(i, u);
      l && Object.defineProperty(o, u, l);
    }
    return o;
  }, "CallableInstance"), lW = {}.hasOwnProperty, X2 = class extends uW {
    static {
      s(this, "Processor");
    }
    /**
     * Create a processor.
     */
    constructor() {
      super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.
      frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = oW();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@link Processor `Processor`}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      let e = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new X2()
      ), t = -1;
      for (; ++t < this.attachers.length; ) {
        let r = this.attachers[t];
        e.use(...r);
      }
      return e.data((0, Am.default)(!0, {}, this.namespace)), e;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * >  **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * >  **Note**: to register custom data in TypeScript, augment the
     * > {@link Data `Data`} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(e, t) {
      return typeof e == "string" ? arguments.length === 2 ? (km("data", this.frozen), this.namespace[e] = t, this) : lW.call(this.namespace,
      e) && this.namespace[e] || void 0 : e ? (km("data", this.frozen), this.namespace = e, this) : this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * Its possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen)
        return this;
      let e = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      for (; ++this.freezeIndex < this.attachers.length; ) {
        let [t, ...r] = this.attachers[this.freezeIndex];
        if (r[0] === !1)
          continue;
        r[0] === !0 && (r[0] = void 0);
        let n = t.call(e, ...r);
        typeof n == "function" && this.transformers.use(n);
      }
      return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * >  **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(e) {
      this.freeze();
      let t = ql(e), r = this.parser || this.Parser;
      return Fm("parse", r), r(String(t), t);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * >  **Note**: `process` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   >  **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@link CompileResultMap `CompileResultMap`}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(e, t) {
      let r = this;
      return this.freeze(), Fm("process", this.parser || this.Parser), _m("process", this.compiler || this.Compiler), t ? n(void 0, t) : new Promise(
      n);
      function n(i, o) {
        let a = ql(e), u = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          r.parse(a)
        );
        r.run(u, a, function(c, p, h) {
          if (c || !p || !h)
            return l(c);
          let f = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            p
          ), d = r.stringify(f, h);
          hW(d) ? h.value = d : h.result = d, l(
            c,
            /** @type {VFileWithOutput<CompileResult>} */
            h
          );
        });
        function l(c, p) {
          c || !p ? o(c) : i ? i(p) : t(void 0, p);
        }
        s(l, "realDone");
      }
      s(n, "executor");
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * >  **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   >  **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@link CompileResultMap `CompileResultMap`}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(e) {
      let t = !1, r;
      return this.freeze(), Fm("processSync", this.parser || this.Parser), _m("processSync", this.compiler || this.Compiler), this.process(e,
      n), r2("processSync", "process", t), r;
      function n(i, o) {
        t = !0, e2(i), r = o;
      }
      s(n, "realDone");
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * >  **Note**: `run` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(e, t, r) {
      t2(e), this.freeze();
      let n = this.transformers;
      return !r && typeof t == "function" && (r = t, t = void 0), r ? i(void 0, r) : new Promise(i);
      function i(o, a) {
        let u = ql(t);
        n.run(e, u, l);
        function l(c, p, h) {
          let f = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            p || e
          );
          c ? a(c) : o ? o(f) : r(void 0, f, h);
        }
        s(l, "realDone");
      }
      s(i, "executor");
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * >  **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(e, t) {
      let r = !1, n;
      return this.run(e, t, i), r2("runSync", "run", r), n;
      function i(o, a) {
        e2(o), n = a, r = !0;
      }
      s(i, "realDone");
    }
    /**
     * Compile a syntax tree.
     *
     * >  **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * >  **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   >  **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@link CompileResultMap `CompileResultMap`}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(e, t) {
      this.freeze();
      let r = ql(t), n = this.compiler || this.Compiler;
      return _m("stringify", n), t2(e), n(e, r);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * >  **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(e, ...t) {
      let r = this.attachers, n = this.namespace;
      if (km("use", this.frozen), e != null)
        if (typeof e == "function")
          u(e, t);
        else if (typeof e == "object")
          Array.isArray(e) ? a(e) : o(e);
        else
          throw new TypeError("Expected usable value, not `" + e + "`");
      return this;
      function i(l) {
        if (typeof l == "function")
          u(l, []);
        else if (typeof l == "object")
          if (Array.isArray(l)) {
            let [c, ...p] = (
              /** @type {PluginTuple<Array<unknown>>} */
              l
            );
            u(c, p);
          } else
            o(l);
        else
          throw new TypeError("Expected usable value, not `" + l + "`");
      }
      function o(l) {
        if (!("plugins" in l) && !("settings" in l))
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and some\
times with `settings`, but this has neither"
          );
        a(l.plugins), l.settings && (n.settings = (0, Am.default)(!0, n.settings, l.settings));
      }
      function a(l) {
        let c = -1;
        if (l != null)
          if (Array.isArray(l))
            for (; ++c < l.length; ) {
              let p = l[c];
              i(p);
            }
          else
            throw new TypeError("Expected a list of plugins, not `" + l + "`");
      }
      function u(l, c) {
        let p = -1, h = -1;
        for (; ++p < r.length; )
          if (r[p][0] === l) {
            h = p;
            break;
          }
        if (h === -1)
          r.push([l, ...c]);
        else if (c.length > 0) {
          let [f, ...d] = c, m = r[h][1];
          jm(m) && jm(f) && (f = (0, Am.default)(!0, m, f)), r[h] = [l, f, ...d];
        }
      }
    }
  }, cW = new X2().freeze();
  s(Fm, "assertParser");
  s(_m, "assertCompiler");
  s(km, "assertUnfrozen");
  s(t2, "assertNode");
  s(r2, "assertDone");
  s(ql, "vfile");
  s(pW, "looksLikeAVFile2");
  s(hW, "looksLikeAValue");
  s(fW, "isUint8Array2");
  dW = class {
    static {
      s(this, "WalkerBase");
    }
    constructor() {
      this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
        skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
        remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
        replace: /* @__PURE__ */ s((e) => this.replacement = e, "replace")
      };
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     * @param {Node} node
     */
    replace(e, t, r, n) {
      e && t && (r != null ? e[t][r] = n : e[t] = n);
    }
    /**
     * @template {Node} Parent
     * @param {Parent | null | undefined} parent
     * @param {keyof Parent | null | undefined} prop
     * @param {number | null | undefined} index
     */
    remove(e, t, r) {
      e && t && (r != null ? e[t].splice(r, 1) : delete e[t]);
    }
  }, mW = class extends dW {
    static {
      s(this, "SyncWalker");
    }
    /**
     *
     * @param {SyncHandler} [enter]
     * @param {SyncHandler} [leave]
     */
    constructor(e, t) {
      super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
        skip: /* @__PURE__ */ s(() => this.should_skip = !0, "skip"),
        remove: /* @__PURE__ */ s(() => this.should_remove = !0, "remove"),
        replace: /* @__PURE__ */ s((r) => this.replacement = r, "replace")
      }, this.enter = e, this.leave = t;
    }
    /**
     * @template {Node} Parent
     * @param {Node} node
     * @param {Parent | null} parent
     * @param {keyof Parent} [prop]
     * @param {number | null} [index]
     * @returns {Node | null}
     */
    visit(e, t, r, n) {
      if (e) {
        if (this.enter) {
          let o = this.should_skip, a = this.should_remove, u = this.replacement;
          this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, e, t, r, n), this.replacement &&
          (e = this.replacement, this.replace(t, r, n, e)), this.should_remove && this.remove(t, r, n);
          let l = this.should_skip, c = this.should_remove;
          if (this.should_skip = o, this.should_remove = a, this.replacement = u, l)
            return e;
          if (c)
            return null;
        }
        let i;
        for (i in e) {
          let o = e[i];
          if (o && typeof o == "object")
            if (Array.isArray(o)) {
              let a = (
                /** @type {Array<unknown>} */
                o
              );
              for (let u = 0; u < a.length; u += 1) {
                let l = a[u];
                n2(l) && (this.visit(l, e, i, u) || u--);
              }
            } else n2(o) && this.visit(o, e, i, null);
        }
        if (this.leave) {
          let o = this.replacement, a = this.should_remove;
          this.replacement = null, this.should_remove = !1, this.leave.call(this.context, e, t, r, n), this.replacement && (e = this.replacement,
          this.replace(t, r, n, e)), this.should_remove && this.remove(t, r, n);
          let u = this.should_remove;
          if (this.replacement = o, this.should_remove = a, u)
            return null;
        }
      }
      return e;
    }
  };
  s(n2, "isNode");
  s(ba, "walk");
  s(K2, "is_reference");
  s(Y2, "analyze");
  s(Q2, "add_reference");
  Ws = class {
    static {
      s(this, "Scope");
    }
    /**
     * @param {Scope | null} parent 
     * @param {boolean} block 
     */
    constructor(e, t) {
      this.parent = e, this.block = t, this.declarations = /* @__PURE__ */ new Map(), this.initialised_declarations = /* @__PURE__ */ new Set(),
      this.references = /* @__PURE__ */ new Set();
    }
    /**
     * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node
     */
    add_declaration(e) {
      if (e.type === "VariableDeclaration")
        if (e.kind === "var" && this.block && this.parent)
          this.parent.add_declaration(e);
        else {
          let t = /* @__PURE__ */ s((r) => {
            Mm(r.id).forEach((n) => {
              this.declarations.set(n, e), r.init && this.initialised_declarations.add(n);
            });
          }, "handle_declarator");
          e.declarations.forEach(t);
        }
      else e.id && this.declarations.set(e.id.name, e);
    }
    /**
     * @param {string} name
     * @returns {Scope | null}
     */
    find_owner(e) {
      return this.declarations.has(e) ? this : this.parent && this.parent.find_owner(e);
    }
    /**
     * @param {string} name
     * @returns {boolean}
     */
    has(e) {
      return this.declarations.has(e) || !!this.parent && this.parent.has(e);
    }
  };
  s(Mm, "extract_names");
  s(Gs, "extract_identifiers");
  s(oi, "create");
  s(gW, "declarationToExpression");
  s(yW, "isDeclaration");
  s(Gm, "specifiersToDeclarations");
  s(ai, "toIdOrMemberExpression");
  s(i2, "toJsxIdOrMemberExpression");
  s(DW, "recmaDocument");
  s(xW, "resolveDynamicMdxSpecifier");
  s(bW, "createImportMetaUrlVariable");
  Tm = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;
  s(vW, "buildJsx");
  s(EW, "toProperty");
  s(Jl, "toIdentifier");
  s(s2, "toMemberExpression");
  s(Da, "create2");
  s(CW, "recmaJsxBuild");
  s(o2, "toBinaryAddition");
  s(wW, "recmaJsxRewrite");
  s(SW, "createImportProvider");
  s(zs, "isNamedFunction");
  s(Im, "inScope");
  ({ stringify: AW } = JSON);
  if (!String.prototype.repeat)
    throw new Error(
      "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
    );
  if (!String.prototype.endsWith)
    throw new Error(
      "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
    );
  $l = {
    "||": 2,
    "??": 3,
    "&&": 4,
    "|": 5,
    "^": 6,
    "&": 7,
    "==": 8,
    "!=": 8,
    "===": 8,
    "!==": 8,
    "<": 9,
    ">": 9,
    "<=": 9,
    ">=": 9,
    in: 9,
    instanceof: 9,
    "<<": 10,
    ">>": 10,
    ">>>": 10,
    "+": 11,
    "-": 11,
    "*": 12,
    "%": 12,
    "/": 12,
    "**": 13
  }, Mr = 17, FW = {
    // Definitions
    ArrayExpression: 20,
    TaggedTemplateExpression: 20,
    ThisExpression: 20,
    Identifier: 20,
    PrivateIdentifier: 20,
    Literal: 18,
    TemplateLiteral: 20,
    Super: 20,
    SequenceExpression: 20,
    // Operations
    MemberExpression: 19,
    ChainExpression: 19,
    CallExpression: 19,
    NewExpression: 19,
    // Other definitions
    ArrowFunctionExpression: Mr,
    ClassExpression: Mr,
    FunctionExpression: Mr,
    ObjectExpression: Mr,
    // Other operations
    UpdateExpression: 16,
    UnaryExpression: 15,
    AwaitExpression: 15,
    BinaryExpression: 14,
    LogicalExpression: 13,
    ConditionalExpression: 4,
    AssignmentExpression: 3,
    YieldExpression: 2,
    RestElement: 1
  };
  s(Hs, "formatSequence");
  s(eS, "expressionNeedsParenthesis");
  s(Vl, "formatExpression");
  s(_W, "reindent");
  s(Nt, "formatComments");
  s(kW, "hasCallExpression");
  s(Pm, "formatVariableDeclaration");
  tS = {
    /*
    Default generator.
    */
    Program(e, t) {
      let r = t.indent.repeat(t.indentLevel), { lineEnd: n, writeComments: i } = t;
      i && e.comments != null && Nt(t, e.comments, r, n);
      let o = e.body, { length: a } = o;
      for (let u = 0; u < a; u++) {
        let l = o[u];
        i && l.comments != null && Nt(t, l.comments, r, n), t.write(r), this[l.type](l, t), t.write(n);
      }
      i && e.trailingComments != null && Nt(t, e.trailingComments, r, n);
    },
    BlockStatement: h2 = /* @__PURE__ */ s(function(e, t) {
      let r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: i } = t, o = r + t.indent;
      t.write("{");
      let a = e.body;
      if (a != null && a.length > 0) {
        t.write(n), i && e.comments != null && Nt(t, e.comments, o, n);
        let { length: u } = a;
        for (let l = 0; l < u; l++) {
          let c = a[l];
          i && c.comments != null && Nt(t, c.comments, o, n), t.write(o), this[c.type](c, t), t.write(n);
        }
        t.write(r);
      } else
        i && e.comments != null && (t.write(n), Nt(t, e.comments, o, n), t.write(r));
      i && e.trailingComments != null && Nt(t, e.trailingComments, o, n), t.write("}"), t.indentLevel--;
    }, "BlockStatement"),
    ClassBody: h2,
    StaticBlock(e, t) {
      t.write("static "), this.BlockStatement(e, t);
    },
    EmptyStatement(e, t) {
      t.write(";");
    },
    ExpressionStatement(e, t) {
      let r = t.expressionsPrecedence[e.expression.type];
      r === Mr || r === 3 && e.expression.left.type[0] === "O" ? (t.write("("), this[e.expression.type](e.expression, t), t.write(")")) : this[e.
      expression.type](e.expression, t), t.write(";");
    },
    IfStatement(e, t) {
      t.write("if ("), this[e.test.type](e.test, t), t.write(") "), this[e.consequent.type](e.consequent, t), e.alternate != null && (t.write(
      " else "), this[e.alternate.type](e.alternate, t));
    },
    LabeledStatement(e, t) {
      this[e.label.type](e.label, t), t.write(": "), this[e.body.type](e.body, t);
    },
    BreakStatement(e, t) {
      t.write("break"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
    },
    ContinueStatement(e, t) {
      t.write("continue"), e.label != null && (t.write(" "), this[e.label.type](e.label, t)), t.write(";");
    },
    WithStatement(e, t) {
      t.write("with ("), this[e.object.type](e.object, t), t.write(") "), this[e.body.type](e.body, t);
    },
    SwitchStatement(e, t) {
      let r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: i } = t;
      t.indentLevel++;
      let o = r + t.indent, a = o + t.indent;
      t.write("switch ("), this[e.discriminant.type](e.discriminant, t), t.write(") {" + n);
      let { cases: u } = e, { length: l } = u;
      for (let c = 0; c < l; c++) {
        let p = u[c];
        i && p.comments != null && Nt(t, p.comments, o, n), p.test ? (t.write(o + "case "), this[p.test.type](p.test, t), t.write(":" + n)) :
        t.write(o + "default:" + n);
        let { consequent: h } = p, { length: f } = h;
        for (let d = 0; d < f; d++) {
          let m = h[d];
          i && m.comments != null && Nt(t, m.comments, a, n), t.write(a), this[m.type](m, t), t.write(n);
        }
      }
      t.indentLevel -= 2, t.write(r + "}");
    },
    ReturnStatement(e, t) {
      t.write("return"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t)), t.write(";");
    },
    ThrowStatement(e, t) {
      t.write("throw "), this[e.argument.type](e.argument, t), t.write(";");
    },
    TryStatement(e, t) {
      if (t.write("try "), this[e.block.type](e.block, t), e.handler) {
        let { handler: r } = e;
        r.param == null ? t.write(" catch ") : (t.write(" catch ("), this[r.param.type](r.param, t), t.write(") ")), this[r.body.type](r.body,
        t);
      }
      e.finalizer && (t.write(" finally "), this[e.finalizer.type](e.finalizer, t));
    },
    WhileStatement(e, t) {
      t.write("while ("), this[e.test.type](e.test, t), t.write(") "), this[e.body.type](e.body, t);
    },
    DoWhileStatement(e, t) {
      t.write("do "), this[e.body.type](e.body, t), t.write(" while ("), this[e.test.type](e.test, t), t.write(");");
    },
    ForStatement(e, t) {
      if (t.write("for ("), e.init != null) {
        let { init: r } = e;
        r.type[0] === "V" ? Pm(t, r) : this[r.type](r, t);
      }
      t.write("; "), e.test && this[e.test.type](e.test, t), t.write("; "), e.update && this[e.update.type](e.update, t), t.write(") "), this[e.
      body.type](e.body, t);
    },
    ForInStatement: a2 = /* @__PURE__ */ s(function(e, t) {
      t.write(`for ${e.await ? "await " : ""}(`);
      let { left: r } = e;
      r.type[0] === "V" ? Pm(t, r) : this[r.type](r, t), t.write(e.type[3] === "I" ? " in " : " of "), this[e.right.type](e.right, t), t.write(
      ") "), this[e.body.type](e.body, t);
    }, "ForInStatement"),
    ForOfStatement: a2,
    DebuggerStatement(e, t) {
      t.write("debugger;", e);
    },
    FunctionDeclaration: u2 = /* @__PURE__ */ s(function(e, t) {
      t.write(
        (e.async ? "async " : "") + (e.generator ? "function* " : "function ") + (e.id ? e.id.name : ""),
        e
      ), Hs(t, e.params), t.write(" "), this[e.body.type](e.body, t);
    }, "FunctionDeclaration"),
    FunctionExpression: u2,
    VariableDeclaration(e, t) {
      Pm(t, e), t.write(";");
    },
    VariableDeclarator(e, t) {
      this[e.id.type](e.id, t), e.init != null && (t.write(" = "), this[e.init.type](e.init, t));
    },
    ClassDeclaration(e, t) {
      if (t.write("class " + (e.id ? `${e.id.name} ` : ""), e), e.superClass) {
        t.write("extends ");
        let { superClass: r } = e, { type: n } = r, i = t.expressionsPrecedence[n];
        (n[0] !== "C" || n[1] !== "l" || n[5] !== "E") && (i === Mr || i < t.expressionsPrecedence.ClassExpression) ? (t.write("("), this[e.
        superClass.type](r, t), t.write(")")) : this[r.type](r, t), t.write(" ");
      }
      this.ClassBody(e.body, t);
    },
    ImportDeclaration(e, t) {
      t.write("import ");
      let { specifiers: r } = e, { length: n } = r, i = 0;
      if (n > 0) {
        for (; i < n; ) {
          i > 0 && t.write(", ");
          let o = r[i], a = o.type[6];
          if (a === "D")
            t.write(o.local.name, o), i++;
          else if (a === "N")
            t.write("* as " + o.local.name, o), i++;
          else
            break;
        }
        if (i < n) {
          for (t.write("{"); ; ) {
            let o = r[i], { name: a } = o.imported;
            if (t.write(a, o), a !== o.local.name && t.write(" as " + o.local.name), ++i < n)
              t.write(", ");
            else
              break;
          }
          t.write("}");
        }
        t.write(" from ");
      }
      this.Literal(e.source, t), t.write(";");
    },
    ImportExpression(e, t) {
      t.write("import("), this[e.source.type](e.source, t), t.write(")");
    },
    ExportDefaultDeclaration(e, t) {
      t.write("export default "), this[e.declaration.type](e.declaration, t), t.expressionsPrecedence[e.declaration.type] != null && e.declaration.
      type[0] !== "F" && t.write(";");
    },
    ExportNamedDeclaration(e, t) {
      if (t.write("export "), e.declaration)
        this[e.declaration.type](e.declaration, t);
      else {
        t.write("{");
        let { specifiers: r } = e, { length: n } = r;
        if (n > 0)
          for (let i = 0; ; ) {
            let o = r[i], { name: a } = o.local;
            if (t.write(a, o), a !== o.exported.name && t.write(" as " + o.exported.name), ++i < n)
              t.write(", ");
            else
              break;
          }
        t.write("}"), e.source && (t.write(" from "), this.Literal(e.source, t)), t.write(";");
      }
    },
    ExportAllDeclaration(e, t) {
      e.exported != null ? t.write("export * as " + e.exported.name + " from ") : t.write("export * from "), this.Literal(e.source, t), t.write(
      ";");
    },
    MethodDefinition(e, t) {
      e.static && t.write("static ");
      let r = e.kind[0];
      (r === "g" || r === "s") && t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed ?
      (t.write("["), this[e.key.type](e.key, t), t.write("]")) : this[e.key.type](e.key, t), Hs(t, e.value.params), t.write(" "), this[e.value.
      body.type](e.value.body, t);
    },
    ClassExpression(e, t) {
      this.ClassDeclaration(e, t);
    },
    ArrowFunctionExpression(e, t) {
      t.write(e.async ? "async " : "", e);
      let { params: r } = e;
      r != null && (r.length === 1 && r[0].type[0] === "I" ? t.write(r[0].name, r[0]) : Hs(t, e.params)), t.write(" => "), e.body.type[0] ===
      "O" ? (t.write("("), this.ObjectExpression(e.body, t), t.write(")")) : this[e.body.type](e.body, t);
    },
    ThisExpression(e, t) {
      t.write("this", e);
    },
    Super(e, t) {
      t.write("super", e);
    },
    RestElement: l2 = /* @__PURE__ */ s(function(e, t) {
      t.write("..."), this[e.argument.type](e.argument, t);
    }, "RestElement"),
    SpreadElement: l2,
    YieldExpression(e, t) {
      t.write(e.delegate ? "yield*" : "yield"), e.argument && (t.write(" "), this[e.argument.type](e.argument, t));
    },
    AwaitExpression(e, t) {
      t.write("await ", e), Vl(t, e.argument, e);
    },
    TemplateLiteral(e, t) {
      let { quasis: r, expressions: n } = e;
      t.write("`");
      let { length: i } = n;
      for (let a = 0; a < i; a++) {
        let u = n[a], l = r[a];
        t.write(l.value.raw, l), t.write("${"), this[u.type](u, t), t.write("}");
      }
      let o = r[r.length - 1];
      t.write(o.value.raw, o), t.write("`");
    },
    TemplateElement(e, t) {
      t.write(e.value.raw, e);
    },
    TaggedTemplateExpression(e, t) {
      Vl(t, e.tag, e), this[e.quasi.type](e.quasi, t);
    },
    ArrayExpression: p2 = /* @__PURE__ */ s(function(e, t) {
      if (t.write("["), e.elements.length > 0) {
        let { elements: r } = e, { length: n } = r;
        for (let i = 0; ; ) {
          let o = r[i];
          if (o != null && this[o.type](o, t), ++i < n)
            t.write(", ");
          else {
            o == null && t.write(", ");
            break;
          }
        }
      }
      t.write("]");
    }, "ArrayExpression"),
    ArrayPattern: p2,
    ObjectExpression(e, t) {
      let r = t.indent.repeat(t.indentLevel++), { lineEnd: n, writeComments: i } = t, o = r + t.indent;
      if (t.write("{"), e.properties.length > 0) {
        t.write(n), i && e.comments != null && Nt(t, e.comments, o, n);
        let a = "," + n, { properties: u } = e, { length: l } = u;
        for (let c = 0; ; ) {
          let p = u[c];
          if (i && p.comments != null && Nt(t, p.comments, o, n), t.write(o), this[p.type](p, t), ++c < l)
            t.write(a);
          else
            break;
        }
        t.write(n), i && e.trailingComments != null && Nt(t, e.trailingComments, o, n), t.write(r + "}");
      } else i ? e.comments != null ? (t.write(n), Nt(t, e.comments, o, n), e.trailingComments != null && Nt(t, e.trailingComments, o, n), t.
      write(r + "}")) : e.trailingComments != null ? (t.write(n), Nt(t, e.trailingComments, o, n), t.write(r + "}")) : t.write("}") : t.write(
      "}");
      t.indentLevel--;
    },
    Property(e, t) {
      e.method || e.kind[0] !== "i" ? this.MethodDefinition(e, t) : (e.shorthand || (e.computed ? (t.write("["), this[e.key.type](e.key, t),
      t.write("]")) : this[e.key.type](e.key, t), t.write(": ")), this[e.value.type](e.value, t));
    },
    PropertyDefinition(e, t) {
      if (e.static && t.write("static "), e.computed && t.write("["), this[e.key.type](e.key, t), e.computed && t.write("]"), e.value == null) {
        e.key.type[0] !== "F" && t.write(";");
        return;
      }
      t.write(" = "), this[e.value.type](e.value, t), t.write(";");
    },
    ObjectPattern(e, t) {
      if (t.write("{"), e.properties.length > 0) {
        let { properties: r } = e, { length: n } = r;
        for (let i = 0; this[r[i].type](r[i], t), ++i < n; )
          t.write(", ");
      }
      t.write("}");
    },
    SequenceExpression(e, t) {
      Hs(t, e.expressions);
    },
    UnaryExpression(e, t) {
      if (e.prefix) {
        let {
          operator: r,
          argument: n,
          argument: { type: i }
        } = e;
        t.write(r);
        let o = eS(t, n, e);
        !o && (r.length > 1 || i[0] === "U" && (i[1] === "n" || i[1] === "p") && n.prefix && n.operator[0] === r && (r === "+" || r === "-")) &&
        t.write(" "), o ? (t.write(r.length > 1 ? " (" : "("), this[i](n, t), t.write(")")) : this[i](n, t);
      } else
        this[e.argument.type](e.argument, t), t.write(e.operator);
    },
    UpdateExpression(e, t) {
      e.prefix ? (t.write(e.operator), this[e.argument.type](e.argument, t)) : (this[e.argument.type](e.argument, t), t.write(e.operator));
    },
    AssignmentExpression(e, t) {
      this[e.left.type](e.left, t), t.write(" " + e.operator + " "), this[e.right.type](e.right, t);
    },
    AssignmentPattern(e, t) {
      this[e.left.type](e.left, t), t.write(" = "), this[e.right.type](e.right, t);
    },
    BinaryExpression: c2 = /* @__PURE__ */ s(function(e, t) {
      let r = e.operator === "in";
      r && t.write("("), Vl(t, e.left, e, !1), t.write(" " + e.operator + " "), Vl(t, e.right, e, !0), r && t.write(")");
    }, "BinaryExpression"),
    LogicalExpression: c2,
    ConditionalExpression(e, t) {
      let { test: r } = e, n = t.expressionsPrecedence[r.type];
      n === Mr || n <= t.expressionsPrecedence.ConditionalExpression ? (t.write("("), this[r.type](r, t), t.write(")")) : this[r.type](r, t),
      t.write(" ? "), this[e.consequent.type](e.consequent, t), t.write(" : "), this[e.alternate.type](e.alternate, t);
    },
    NewExpression(e, t) {
      t.write("new ");
      let r = t.expressionsPrecedence[e.callee.type];
      r === Mr || r < t.expressionsPrecedence.CallExpression || kW(e.callee) ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) :
      this[e.callee.type](e.callee, t), Hs(t, e.arguments);
    },
    CallExpression(e, t) {
      let r = t.expressionsPrecedence[e.callee.type];
      r === Mr || r < t.expressionsPrecedence.CallExpression ? (t.write("("), this[e.callee.type](e.callee, t), t.write(")")) : this[e.callee.
      type](e.callee, t), e.optional && t.write("?."), Hs(t, e.arguments);
    },
    ChainExpression(e, t) {
      this[e.expression.type](e.expression, t);
    },
    MemberExpression(e, t) {
      let r = t.expressionsPrecedence[e.object.type];
      r === Mr || r < t.expressionsPrecedence.MemberExpression ? (t.write("("), this[e.object.type](e.object, t), t.write(")")) : this[e.object.
      type](e.object, t), e.computed ? (e.optional && t.write("?."), t.write("["), this[e.property.type](e.property, t), t.write("]")) : (e.
      optional ? t.write("?.") : t.write("."), this[e.property.type](e.property, t));
    },
    MetaProperty(e, t) {
      t.write(e.meta.name + "." + e.property.name, e);
    },
    Identifier(e, t) {
      t.write(e.name, e);
    },
    PrivateIdentifier(e, t) {
      t.write(`#${e.name}`, e);
    },
    Literal(e, t) {
      e.raw != null ? t.write(e.raw, e) : e.regex != null ? this.RegExpLiteral(e, t) : e.bigint != null ? t.write(e.bigint + "n", e) : t.write(
      AW(e.value), e);
    },
    RegExpLiteral(e, t) {
      let { regex: r } = e;
      t.write(`/${r.pattern}/${r.flags}`, e);
    }
  }, TW = {}, IW = class {
    static {
      s(this, "State");
    }
    constructor(e) {
      let t = e ?? TW;
      this.output = "", t.output != null ? (this.output = t.output, this.write = this.writeToStream) : this.output = "", this.generator = t.
      generator != null ? t.generator : tS, this.expressionsPrecedence = t.expressionsPrecedence != null ? t.expressionsPrecedence : FW, this.
      indent = t.indent != null ? t.indent : "  ", this.lineEnd = t.lineEnd != null ? t.lineEnd : `
`, this.indentLevel = t.startingIndentLevel != null ? t.startingIndentLevel : 0, this.writeComments = t.comments ? t.comments : !1, t.sourceMap !=
      null && (this.write = t.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = t.sourceMap, this.line = 1, this.
      column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = {
        original: null,
        // Uses the entire state to avoid generating ephemeral objects
        generated: this,
        name: void 0,
        source: t.sourceMap.file || t.sourceMap._file
      });
    }
    write(e) {
      this.output += e;
    }
    writeToStream(e) {
      this.output.write(e);
    }
    writeAndMap(e, t) {
      this.output += e, this.map(e, t);
    }
    writeToStreamAndMap(e, t) {
      this.output.write(e), this.map(e, t);
    }
    map(e, t) {
      if (t != null) {
        let { type: i } = t;
        if (i[0] === "L" && i[2] === "n") {
          this.column = 0, this.line++;
          return;
        }
        if (t.loc != null) {
          let { mapping: o } = this;
          o.original = t.loc.start, o.name = t.name, this.sourceMap.addMapping(o);
        }
        if (i[0] === "T" && i[8] === "E" || i[0] === "L" && i[1] === "i" && typeof t.value == "string") {
          let { length: o } = e, { column: a, line: u } = this;
          for (let l = 0; l < o; l++)
            e[l] === `
` ? (a = 0, u++) : a++;
          this.column = a, this.line = u;
          return;
        }
      }
      let { length: r } = e, { lineEnd: n } = this;
      r > 0 && (this.lineEndSize > 0 && (n.length === 1 ? e[r - 1] === n : e.endsWith(n)) ? (this.line += this.lineEndSize, this.column = 0) :
      this.column += r);
    }
    toString() {
      return this.output;
    }
  };
  s(PW, "generate");
  BW = {};
  s(f2, "toJs");
  d2 = {
    JSXAttribute: OW,
    JSXClosingElement: RW,
    JSXClosingFragment: NW,
    JSXElement: LW,
    JSXEmptyExpression: jW,
    JSXExpressionContainer: MW,
    JSXFragment: qW,
    JSXIdentifier: $W,
    JSXMemberExpression: VW,
    JSXNamespacedName: UW,
    JSXOpeningElement: WW,
    JSXOpeningFragment: zW,
    JSXSpreadAttribute: HW,
    JSXText: GW
  };
  s(OW, "jsxAttribute");
  s(RW, "jsxClosingElement");
  s(NW, "jsxClosingFragment");
  s(LW, "jsxElement");
  s(jW, "jsxEmptyExpression");
  s(MW, "jsxExpressionContainer");
  s(qW, "jsxFragment");
  s($W, "jsxIdentifier");
  s(VW, "jsxMemberExpression");
  s(UW, "jsxNamespacedName");
  s(WW, "jsxOpeningElement");
  s(zW, "jsxOpeningFragment");
  s(HW, "jsxSpreadAttribute");
  s(GW, "jsxText2");
  s(rS, "encodeJsx");
  s(JW, "replaceJsxChar");
  s(ZW, "recmaStringify");
  s(XW, "rehypeRecma");
  s(KW, "rehypeRemoveRaw");
  YW = /\s+/g, QW = /[\t\n\v\f\r ]+/g;
  s(ez, "collapseWhiteSpace");
  s(tz, "replaceLineEnding");
  s(rz, "replaceSpace");
  s(nz, "trimFactory");
  s(iz, "remarkMarkAndUnravel");
  nS = /** @type {const} */
  [
    "mdxFlowExpression",
    "mdxJsxFlowElement",
    "mdxJsxTextElement",
    "mdxTextExpression",
    "mdxjsEsm"
  ], m2 = [
    "compilers",
    "filepath",
    "hastPlugins",
    "mdPlugins",
    "skipExport",
    "wrapExport"
  ], g2 = !1;
  s(Jm, "createProcessor");
  s(iS, "compile");
  s(sS, "compileSync");
  s(oS, "resolveEvaluateOptions");
  sz = Object.getPrototypeOf(Zm).constructor;
  s(Zm, "run");
  s(aS, "runSync");
  s(oz, "evaluate");
  s(az, "evaluateSync");
});

// ../node_modules/@storybook/docs-mdx/dist/index.js
var dS = {};
Gn(dS, {
  analyze: () => hz,
  extractImports: () => hS,
  plugin: () => fS
});
var Xm, pS, cS, uz, lz, cz, pz, hS, fS, hz, mS = wt(() => {
  nm();
  Xm = /* @__PURE__ */ s((e, t) => e.attributes.find((r) => r.type === "JSXAttribute" && r.name.name === t), "getAttr"), pS = /* @__PURE__ */ s(
  (e, t) => Xm(e, t)?.value, "getAttrValue"), cS = /* @__PURE__ */ s((e, t) => {
    let r = pS(e, t);
    if (r) {
      if (r.type === "Literal")
        return r.value;
      throw new Error(`Expected string literal ${t}, received ${r.type}`);
    }
  }, "getAttrLiteral"), uz = /* @__PURE__ */ s((e, t) => {
    let r = pS(e, "of");
    if (r)
      if (r.type === "JSXExpressionContainer") {
        let n = r.expression;
        if (n?.type === "Identifier") {
          let i = t[n.name];
          if (i)
            return i;
          throw new Error(`Unknown identifier ${n.name}`);
        } else
          throw new Error(`Expected identifier, received ${n.type}`);
      } else
        throw new Error(`Expected JSX expression, received ${r.type}`);
  }, "getOf"), lz = /* @__PURE__ */ s((e) => {
    let t = Xm(e, "tags");
    if (!t)
      return;
    let r = t.value;
    if (r.type === "JSXExpressionContainer") {
      let n = r.expression;
      if (n.type === "ArrayExpression")
        return n.elements.map((o) => {
          if (o.type === "Literal" && typeof o.value == "string")
            return o.value;
          throw new Error(`Expected string literal tag, received ${o.type}`);
        });
      throw new Error(`Expected tags array, received ${n.type}`);
    } else
      throw new Error(`Expected JSX expression tags, received ${r.type}`);
  }, "getTags"), cz = /* @__PURE__ */ s((e) => {
    let t = Xm(e, "isTemplate");
    if (!t)
      return !1;
    let r = t.value;
    if (r == null)
      return !0;
    if (r.type === "JSXExpressionContainer") {
      let n = r.expression;
      if (n.type === "Literal" && typeof n.value == "boolean")
        return n.value;
      throw new Error(`Expected boolean isTemplate, received ${typeof n.value}`);
    } else
      throw new Error(`Expected expression isTemplate, received ${r.type}`);
  }, "getIsTemplate"), pz = /* @__PURE__ */ s((e, t) => {
    let r = { title: void 0, of: void 0, name: void 0, isTemplate: !1 }, n = e.body.filter(
      (o) => o.type === "ExpressionStatement" && o.expression.type === "JSXFragment"
    );
    if (n.length > 1)
      throw new Error("duplicate contents");
    return n.length === 0 || n[0].expression.children.forEach((o) => {
      if (o.type === "JSXElement") {
        let { openingElement: a } = o;
        if (a.name.name === "Meta") {
          if (r.title || r.name || r.of)
            throw new Error("Meta can only be declared once");
          r.title = cS(a, "title"), r.name = cS(a, "name"), r.of = uz(a, t), r.isTemplate = cz(a), r.metaTags = lz(a);
        }
      } else if (o.type !== "JSXExpressionContainer")
        throw new Error(`Unexpected JSX child: ${o.type}`);
    }), r;
  }, "extractTitle"), hS = /* @__PURE__ */ s((e) => {
    let t = {};
    return e.body.forEach((r) => {
      if (r.type === "ImportDeclaration") {
        let { source: n, specifiers: i } = r;
        if (n.type === "Literal")
          i.forEach((o) => {
            t[o.local.name] = n.value.toString();
          });
        else
          throw new Error("MDX: unexpected import source");
      }
    }), t;
  }, "extractImports"), fS = /* @__PURE__ */ s((e) => (t) => {
    let r = Al(t), n = hS(r), { title: i, of: o, name: a, isTemplate: u, metaTags: l } = pz(r, n);
    return e.title = i, e.of = o, e.name = a, e.isTemplate = u, e.metaTags = l, e.imports = Array.from(new Set(Object.values(n))), t;
  }, "plugin"), hz = /* @__PURE__ */ s(async (e) => {
    let t = {
      title: void 0,
      of: void 0,
      name: void 0,
      isTemplate: !1,
      metaTags: void 0,
      imports: void 0
    }, { compile: r } = await Promise.resolve().then(() => (lS(), uS));
    await r(e, {
      rehypePlugins: [[fS, t]]
    });
    let { title: n, of: i, name: o, isTemplate: a, metaTags: u, imports: l = [] } = t;
    return { title: n, of: i, name: o, isTemplate: a, metaTags: u, imports: l };
  }, "analyze");
});

// ../node_modules/totalist/sync/index.mjs
var vS = {};
Gn(vS, {
  totalist: () => bS
});
function bS(e, t, r = "") {
  e = (0, Ys.resolve)(".", e);
  let n = (0, ec.readdirSync)(e), i = 0, o, a;
  for (; i < n.length; i++)
    o = (0, Ys.join)(e, n[i]), a = (0, ec.statSync)(o), a.isDirectory() ? bS(o, t, (0, Ys.join)(r, n[i])) : t((0, Ys.join)(r, n[i]), o, a);
}
var Ys, ec, ES = wt(() => {
  Ys = require("path"), ec = require("fs");
  s(bS, "totalist");
});

// ../node_modules/@polka/url/build.mjs
var wS = {};
Gn(wS, {
  parse: () => tg
});
function tg(e) {
  let t = e.url;
  if (t == null) return;
  let r = e._parsedUrl;
  if (r && r.raw === t) return r;
  let n = t, i = "", o, a;
  if (t.length > 1) {
    let u = t.indexOf("#", 1);
    u !== -1 && (a = t.substring(u), n = t.substring(0, u)), u = n.indexOf("?", 1), u !== -1 && (i = n.substring(u), n = n.substring(0, u), i.
    length > 1 && (o = CS.parse(i.substring(1))));
  }
  return e._parsedUrl = { pathname: n, search: i, query: o, hash: a, raw: t };
}
var CS, rg = wt(() => {
  CS = J(require("node:querystring"), 1);
  s(tg, "parse");
});

// ../node_modules/mrmime/index.mjs
var AS = {};
Gn(AS, {
  lookup: () => mz,
  mimes: () => SS
});
function mz(e) {
  let t = ("" + e).trim().toLowerCase(), r = t.lastIndexOf(".");
  return SS[~r ? t.substring(++r) : t];
}
var SS, FS = wt(() => {
  SS = {
    "3g2": "video/3gpp2",
    "3gp": "video/3gpp",
    "3gpp": "video/3gpp",
    "3mf": "model/3mf",
    aac: "audio/aac",
    ac: "application/pkix-attr-cert",
    adp: "audio/adpcm",
    adts: "audio/aac",
    ai: "application/postscript",
    aml: "application/automationml-aml+xml",
    amlx: "application/automationml-amlx+zip",
    amr: "audio/amr",
    apng: "image/apng",
    appcache: "text/cache-manifest",
    appinstaller: "application/appinstaller",
    appx: "application/appx",
    appxbundle: "application/appxbundle",
    asc: "application/pgp-keys",
    atom: "application/atom+xml",
    atomcat: "application/atomcat+xml",
    atomdeleted: "application/atomdeleted+xml",
    atomsvc: "application/atomsvc+xml",
    au: "audio/basic",
    avci: "image/avci",
    avcs: "image/avcs",
    avif: "image/avif",
    aw: "application/applixware",
    bdoc: "application/bdoc",
    bin: "application/octet-stream",
    bmp: "image/bmp",
    bpk: "application/octet-stream",
    btf: "image/prs.btif",
    btif: "image/prs.btif",
    buffer: "application/octet-stream",
    ccxml: "application/ccxml+xml",
    cdfx: "application/cdfx+xml",
    cdmia: "application/cdmi-capability",
    cdmic: "application/cdmi-container",
    cdmid: "application/cdmi-domain",
    cdmio: "application/cdmi-object",
    cdmiq: "application/cdmi-queue",
    cer: "application/pkix-cert",
    cgm: "image/cgm",
    cjs: "application/node",
    class: "application/java-vm",
    coffee: "text/coffeescript",
    conf: "text/plain",
    cpl: "application/cpl+xml",
    cpt: "application/mac-compactpro",
    crl: "application/pkix-crl",
    css: "text/css",
    csv: "text/csv",
    cu: "application/cu-seeme",
    cwl: "application/cwl",
    cww: "application/prs.cww",
    davmount: "application/davmount+xml",
    dbk: "application/docbook+xml",
    deb: "application/octet-stream",
    def: "text/plain",
    deploy: "application/octet-stream",
    dib: "image/bmp",
    "disposition-notification": "message/disposition-notification",
    dist: "application/octet-stream",
    distz: "application/octet-stream",
    dll: "application/octet-stream",
    dmg: "application/octet-stream",
    dms: "application/octet-stream",
    doc: "application/msword",
    dot: "application/msword",
    dpx: "image/dpx",
    drle: "image/dicom-rle",
    dsc: "text/prs.lines.tag",
    dssc: "application/dssc+der",
    dtd: "application/xml-dtd",
    dump: "application/octet-stream",
    dwd: "application/atsc-dwd+xml",
    ear: "application/java-archive",
    ecma: "application/ecmascript",
    elc: "application/octet-stream",
    emf: "image/emf",
    eml: "message/rfc822",
    emma: "application/emma+xml",
    emotionml: "application/emotionml+xml",
    eps: "application/postscript",
    epub: "application/epub+zip",
    exe: "application/octet-stream",
    exi: "application/exi",
    exp: "application/express",
    exr: "image/aces",
    ez: "application/andrew-inset",
    fdf: "application/fdf",
    fdt: "application/fdt+xml",
    fits: "image/fits",
    g3: "image/g3fax",
    gbr: "application/rpki-ghostbusters",
    geojson: "application/geo+json",
    gif: "image/gif",
    glb: "model/gltf-binary",
    gltf: "model/gltf+json",
    gml: "application/gml+xml",
    gpx: "application/gpx+xml",
    gram: "application/srgs",
    grxml: "application/srgs+xml",
    gxf: "application/gxf",
    gz: "application/gzip",
    h261: "video/h261",
    h263: "video/h263",
    h264: "video/h264",
    heic: "image/heic",
    heics: "image/heic-sequence",
    heif: "image/heif",
    heifs: "image/heif-sequence",
    hej2: "image/hej2k",
    held: "application/atsc-held+xml",
    hjson: "application/hjson",
    hlp: "application/winhlp",
    hqx: "application/mac-binhex40",
    hsj2: "image/hsj2",
    htm: "text/html",
    html: "text/html",
    ics: "text/calendar",
    ief: "image/ief",
    ifb: "text/calendar",
    iges: "model/iges",
    igs: "model/iges",
    img: "application/octet-stream",
    in: "text/plain",
    ini: "text/plain",
    ink: "application/inkml+xml",
    inkml: "application/inkml+xml",
    ipfix: "application/ipfix",
    iso: "application/octet-stream",
    its: "application/its+xml",
    jade: "text/jade",
    jar: "application/java-archive",
    jhc: "image/jphc",
    jls: "image/jls",
    jp2: "image/jp2",
    jpe: "image/jpeg",
    jpeg: "image/jpeg",
    jpf: "image/jpx",
    jpg: "image/jpeg",
    jpg2: "image/jp2",
    jpgm: "image/jpm",
    jpgv: "video/jpeg",
    jph: "image/jph",
    jpm: "image/jpm",
    jpx: "image/jpx",
    js: "text/javascript",
    json: "application/json",
    json5: "application/json5",
    jsonld: "application/ld+json",
    jsonml: "application/jsonml+json",
    jsx: "text/jsx",
    jt: "model/jt",
    jxl: "image/jxl",
    jxr: "image/jxr",
    jxra: "image/jxra",
    jxrs: "image/jxrs",
    jxs: "image/jxs",
    jxsc: "image/jxsc",
    jxsi: "image/jxsi",
    jxss: "image/jxss",
    kar: "audio/midi",
    ktx: "image/ktx",
    ktx2: "image/ktx2",
    less: "text/less",
    lgr: "application/lgr+xml",
    list: "text/plain",
    litcoffee: "text/coffeescript",
    log: "text/plain",
    lostxml: "application/lost+xml",
    lrf: "application/octet-stream",
    m1v: "video/mpeg",
    m21: "application/mp21",
    m2a: "audio/mpeg",
    m2t: "video/mp2t",
    m2ts: "video/mp2t",
    m2v: "video/mpeg",
    m3a: "audio/mpeg",
    m4a: "audio/mp4",
    m4p: "application/mp4",
    m4s: "video/iso.segment",
    ma: "application/mathematica",
    mads: "application/mads+xml",
    maei: "application/mmt-aei+xml",
    man: "text/troff",
    manifest: "text/cache-manifest",
    map: "application/json",
    mar: "application/octet-stream",
    markdown: "text/markdown",
    mathml: "application/mathml+xml",
    mb: "application/mathematica",
    mbox: "application/mbox",
    md: "text/markdown",
    mdx: "text/mdx",
    me: "text/troff",
    mesh: "model/mesh",
    meta4: "application/metalink4+xml",
    metalink: "application/metalink+xml",
    mets: "application/mets+xml",
    mft: "application/rpki-manifest",
    mid: "audio/midi",
    midi: "audio/midi",
    mime: "message/rfc822",
    mj2: "video/mj2",
    mjp2: "video/mj2",
    mjs: "text/javascript",
    mml: "text/mathml",
    mods: "application/mods+xml",
    mov: "video/quicktime",
    mp2: "audio/mpeg",
    mp21: "application/mp21",
    mp2a: "audio/mpeg",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mp4a: "audio/mp4",
    mp4s: "application/mp4",
    mp4v: "video/mp4",
    mpd: "application/dash+xml",
    mpe: "video/mpeg",
    mpeg: "video/mpeg",
    mpf: "application/media-policy-dataset+xml",
    mpg: "video/mpeg",
    mpg4: "video/mp4",
    mpga: "audio/mpeg",
    mpp: "application/dash-patch+xml",
    mrc: "application/marc",
    mrcx: "application/marcxml+xml",
    ms: "text/troff",
    mscml: "application/mediaservercontrol+xml",
    msh: "model/mesh",
    msi: "application/octet-stream",
    msix: "application/msix",
    msixbundle: "application/msixbundle",
    msm: "application/octet-stream",
    msp: "application/octet-stream",
    mtl: "model/mtl",
    mts: "video/mp2t",
    musd: "application/mmt-usd+xml",
    mxf: "application/mxf",
    mxmf: "audio/mobile-xmf",
    mxml: "application/xv+xml",
    n3: "text/n3",
    nb: "application/mathematica",
    nq: "application/n-quads",
    nt: "application/n-triples",
    obj: "model/obj",
    oda: "application/oda",
    oga: "audio/ogg",
    ogg: "audio/ogg",
    ogv: "video/ogg",
    ogx: "application/ogg",
    omdoc: "application/omdoc+xml",
    onepkg: "application/onenote",
    onetmp: "application/onenote",
    onetoc: "application/onenote",
    onetoc2: "application/onenote",
    opf: "application/oebps-package+xml",
    opus: "audio/ogg",
    otf: "font/otf",
    owl: "application/rdf+xml",
    oxps: "application/oxps",
    p10: "application/pkcs10",
    p7c: "application/pkcs7-mime",
    p7m: "application/pkcs7-mime",
    p7s: "application/pkcs7-signature",
    p8: "application/pkcs8",
    pdf: "application/pdf",
    pfr: "application/font-tdpfr",
    pgp: "application/pgp-encrypted",
    pkg: "application/octet-stream",
    pki: "application/pkixcmp",
    pkipath: "application/pkix-pkipath",
    pls: "application/pls+xml",
    png: "image/png",
    prc: "model/prc",
    prf: "application/pics-rules",
    provx: "application/provenance+xml",
    ps: "application/postscript",
    pskcxml: "application/pskc+xml",
    pti: "image/prs.pti",
    qt: "video/quicktime",
    raml: "application/raml+yaml",
    rapd: "application/route-apd+xml",
    rdf: "application/rdf+xml",
    relo: "application/p2p-overlay+xml",
    rif: "application/reginfo+xml",
    rl: "application/resource-lists+xml",
    rld: "application/resource-lists-diff+xml",
    rmi: "audio/midi",
    rnc: "application/relax-ng-compact-syntax",
    rng: "application/xml",
    roa: "application/rpki-roa",
    roff: "text/troff",
    rq: "application/sparql-query",
    rs: "application/rls-services+xml",
    rsat: "application/atsc-rsat+xml",
    rsd: "application/rsd+xml",
    rsheet: "application/urc-ressheet+xml",
    rss: "application/rss+xml",
    rtf: "text/rtf",
    rtx: "text/richtext",
    rusd: "application/route-usd+xml",
    s3m: "audio/s3m",
    sbml: "application/sbml+xml",
    scq: "application/scvp-cv-request",
    scs: "application/scvp-cv-response",
    sdp: "application/sdp",
    senmlx: "application/senml+xml",
    sensmlx: "application/sensml+xml",
    ser: "application/java-serialized-object",
    setpay: "application/set-payment-initiation",
    setreg: "application/set-registration-initiation",
    sgi: "image/sgi",
    sgm: "text/sgml",
    sgml: "text/sgml",
    shex: "text/shex",
    shf: "application/shf+xml",
    shtml: "text/html",
    sieve: "application/sieve",
    sig: "application/pgp-signature",
    sil: "audio/silk",
    silo: "model/mesh",
    siv: "application/sieve",
    slim: "text/slim",
    slm: "text/slim",
    sls: "application/route-s-tsid+xml",
    smi: "application/smil+xml",
    smil: "application/smil+xml",
    snd: "audio/basic",
    so: "application/octet-stream",
    spdx: "text/spdx",
    spp: "application/scvp-vp-response",
    spq: "application/scvp-vp-request",
    spx: "audio/ogg",
    sql: "application/sql",
    sru: "application/sru+xml",
    srx: "application/sparql-results+xml",
    ssdl: "application/ssdl+xml",
    ssml: "application/ssml+xml",
    stk: "application/hyperstudio",
    stl: "model/stl",
    stpx: "model/step+xml",
    stpxz: "model/step-xml+zip",
    stpz: "model/step+zip",
    styl: "text/stylus",
    stylus: "text/stylus",
    svg: "image/svg+xml",
    svgz: "image/svg+xml",
    swidtag: "application/swid+xml",
    t: "text/troff",
    t38: "image/t38",
    td: "application/urc-targetdesc+xml",
    tei: "application/tei+xml",
    teicorpus: "application/tei+xml",
    text: "text/plain",
    tfi: "application/thraud+xml",
    tfx: "image/tiff-fx",
    tif: "image/tiff",
    tiff: "image/tiff",
    toml: "application/toml",
    tr: "text/troff",
    trig: "application/trig",
    ts: "video/mp2t",
    tsd: "application/timestamped-data",
    tsv: "text/tab-separated-values",
    ttc: "font/collection",
    ttf: "font/ttf",
    ttl: "text/turtle",
    ttml: "application/ttml+xml",
    txt: "text/plain",
    u3d: "model/u3d",
    u8dsn: "message/global-delivery-status",
    u8hdr: "message/global-headers",
    u8mdn: "message/global-disposition-notification",
    u8msg: "message/global",
    ubj: "application/ubjson",
    uri: "text/uri-list",
    uris: "text/uri-list",
    urls: "text/uri-list",
    vcard: "text/vcard",
    vrml: "model/vrml",
    vtt: "text/vtt",
    vxml: "application/voicexml+xml",
    war: "application/java-archive",
    wasm: "application/wasm",
    wav: "audio/wav",
    weba: "audio/webm",
    webm: "video/webm",
    webmanifest: "application/manifest+json",
    webp: "image/webp",
    wgsl: "text/wgsl",
    wgt: "application/widget",
    wif: "application/watcherinfo+xml",
    wmf: "image/wmf",
    woff: "font/woff",
    woff2: "font/woff2",
    wrl: "model/vrml",
    wsdl: "application/wsdl+xml",
    wspolicy: "application/wspolicy+xml",
    x3d: "model/x3d+xml",
    x3db: "model/x3d+fastinfoset",
    x3dbz: "model/x3d+binary",
    x3dv: "model/x3d-vrml",
    x3dvz: "model/x3d+vrml",
    x3dz: "model/x3d+xml",
    xaml: "application/xaml+xml",
    xav: "application/xcap-att+xml",
    xca: "application/xcap-caps+xml",
    xcs: "application/calendar+xml",
    xdf: "application/xcap-diff+xml",
    xdssc: "application/dssc+xml",
    xel: "application/xcap-el+xml",
    xenc: "application/xenc+xml",
    xer: "application/patch-ops-error+xml",
    xfdf: "application/xfdf",
    xht: "application/xhtml+xml",
    xhtml: "application/xhtml+xml",
    xhvml: "application/xv+xml",
    xlf: "application/xliff+xml",
    xm: "audio/xm",
    xml: "text/xml",
    xns: "application/xcap-ns+xml",
    xop: "application/xop+xml",
    xpl: "application/xproc+xml",
    xsd: "application/xml",
    xsf: "application/prs.xsf+xml",
    xsl: "application/xml",
    xslt: "application/xml",
    xspf: "application/xspf+xml",
    xvm: "application/xv+xml",
    xvml: "application/xv+xml",
    yaml: "text/yaml",
    yang: "application/yang",
    yin: "application/yin+xml",
    yml: "text/yaml",
    zip: "application/zip"
  };
  s(mz, "lookup");
});

// ../node_modules/sirv/build.js
var IS = I((ipe, TS) => {
  var ng = require("fs"), { join: gz, normalize: yz, resolve: Dz } = require("path"), { totalist: xz } = (ES(), Fu(vS)), { parse: bz } = (rg(), Fu(wS)),
  { lookup: vz } = (FS(), Fu(AS)), Ez = /* @__PURE__ */ s(() => {
  }, "noop");
  function Cz(e, t) {
    for (let r = 0; r < t.length; r++)
      if (t[r].test(e)) return !0;
  }
  s(Cz, "isMatch");
  function _S(e, t) {
    let r = 0, n, i = e.length - 1;
    e.charCodeAt(i) === 47 && (e = e.substring(0, i));
    let o = [], a = `${e}/index`;
    for (; r < t.length; r++)
      n = t[r] ? `.${t[r]}` : "", e && o.push(e + n), o.push(a + n);
    return o;
  }
  s(_S, "toAssume");
  function wz(e, t, r) {
    let n = 0, i, o = _S(t, r);
    for (; n < o.length; n++)
      if (i = e[o[n]]) return i;
  }
  s(wz, "viaCache");
  function Sz(e, t, r, n) {
    let i = 0, o = _S(r, n), a, u, l, c;
    for (; i < o.length; i++)
      if (a = yz(gz(e, l = o[i])), a.startsWith(e) && ng.existsSync(a)) {
        if (u = ng.statSync(a), u.isDirectory()) continue;
        return c = kS(l, u, t), c["Cache-Control"] = t ? "no-cache" : "no-store", { abs: a, stats: u, headers: c };
      }
  }
  s(Sz, "viaLocal");
  function Az(e, t) {
    return t.statusCode = 404, t.end();
  }
  s(Az, "is404");
  function Fz(e, t, r, n, i) {
    let o = 200, a, u = {};
    i = { ...i };
    for (let l in i)
      a = t.getHeader(l), a && (i[l] = a);
    if ((a = t.getHeader("content-type")) && (i["Content-Type"] = a), e.headers.range) {
      o = 206;
      let [l, c] = e.headers.range.replace("bytes=", "").split("-"), p = u.end = parseInt(c, 10) || n.size - 1, h = u.start = parseInt(l, 10) ||
      0;
      if (p >= n.size && (p = n.size - 1), h >= n.size)
        return t.setHeader("Content-Range", `bytes */${n.size}`), t.statusCode = 416, t.end();
      i["Content-Range"] = `bytes ${h}-${p}/${n.size}`, i["Content-Length"] = p - h + 1, i["Accept-Ranges"] = "bytes";
    }
    t.writeHead(o, i), ng.createReadStream(r, u).pipe(t);
  }
  s(Fz, "send");
  var _z = {
    ".br": "br",
    ".gz": "gzip"
  };
  function kS(e, t, r) {
    let n = _z[e.slice(-3)], i = vz(e.slice(0, n && -3)) || "";
    i === "text/html" && (i += ";charset=utf-8");
    let o = {
      "Content-Length": t.size,
      "Content-Type": i,
      "Last-Modified": t.mtime.toUTCString()
    };
    return n && (o["Content-Encoding"] = n), r && (o.ETag = `W/"${t.size}-${t.mtime.getTime()}"`), o;
  }
  s(kS, "toHeaders");
  TS.exports = function(e, t = {}) {
    e = Dz(e || ".");
    let r = t.onNoMatch || Az, n = t.setHeaders || Ez, i = t.extensions || ["html", "htm"], o = t.gzip && i.map((m) => `${m}.gz`).concat("gz"),
    a = t.brotli && i.map((m) => `${m}.br`).concat("br"), u = {}, l = "/", c = !!t.etag, p = !!t.single;
    if (typeof t.single == "string") {
      let m = t.single.lastIndexOf(".");
      l += ~m ? t.single.substring(0, m) : t.single;
    }
    let h = [];
    t.ignores !== !1 && (h.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/), t.dotfiles ? h.push(/\/\.\w/) : h.push(/\/\.well-known/), [].concat(t.
    ignores || []).forEach((m) => {
      h.push(new RegExp(m, "i"));
    }));
    let f = t.maxAge != null && `public,max-age=${t.maxAge}`;
    f && t.immutable ? f += ",immutable" : f && t.maxAge === 0 && (f += ",must-revalidate"), t.dev || xz(e, (m, g, b) => {
      if (!/\.well-known[\\+\/]/.test(m)) {
        if (!t.dotfiles && /(^\.|[\\+|\/+]\.)/.test(m)) return;
      }
      let y = kS(m, b, c);
      f && (y["Cache-Control"] = f), u["/" + m.normalize().replace(/\\+/g, "/")] = { abs: g, stats: b, headers: y };
    });
    let d = t.dev ? Sz.bind(0, e, c) : wz.bind(0, u);
    return function(m, g, b) {
      let y = [""], E = bz(m).pathname, A = m.headers["accept-encoding"] || "";
      if (o && A.includes("gzip") && y.unshift(...o), a && /(br|brotli)/i.test(A) && y.unshift(...a), y.push(...i), E.indexOf("%") !== -1)
        try {
          E = decodeURI(E);
        } catch {
        }
      let k = d(E, y) || p && !Cz(E, h) && d(l, y);
      if (!k) return b ? b() : r(m, g);
      if (c && m.headers["if-none-match"] === k.headers.ETag)
        return g.writeHead(304), g.end();
      (o || a) && g.setHeader("Vary", "Accept-Encoding"), n(g, E, k.stats), Fz(m, g, k.abs, k.stats, k.headers);
    };
  };
});

// ../node_modules/@discoveryjs/json-ext/package.json
var GS = I((mpe, Pz) => {
  Pz.exports = {
    name: "@discoveryjs/json-ext",
    version: "0.5.7",
    description: "A set of utilities that extend the use of JSON",
    keywords: [
      "json",
      "utils",
      "stream",
      "async",
      "promise",
      "stringify",
      "info"
    ],
    author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
    license: "MIT",
    repository: "discoveryjs/json-ext",
    main: "./src/index",
    browser: {
      "./src/stringify-stream.js": "./src/stringify-stream-browser.js",
      "./src/text-decoder.js": "./src/text-decoder-browser.js",
      "./src/version.js": "./dist/version.js"
    },
    types: "./index.d.ts",
    scripts: {
      test: "mocha --reporter progress",
      lint: "eslint src test",
      "lint-and-test": "npm run lint && npm test",
      build: "rollup --config",
      "test:all": "npm run test:src && npm run test:dist",
      "test:src": "npm test",
      "test:dist": "cross-env MODE=dist npm test && cross-env MODE=dist-min npm test",
      "build-and-test": "npm run build && npm run test:dist",
      coverage: "c8 --reporter=lcovonly npm test",
      prepublishOnly: "npm run lint && npm test && npm run build-and-test"
    },
    devDependencies: {
      "@rollup/plugin-commonjs": "^15.1.0",
      "@rollup/plugin-json": "^4.1.0",
      "@rollup/plugin-node-resolve": "^9.0.0",
      c8: "^7.10.0",
      chalk: "^4.1.0",
      "cross-env": "^7.0.3",
      eslint: "^8.10.0",
      mocha: "^8.4.0",
      rollup: "^2.28.2",
      "rollup-plugin-terser": "^7.0.2"
    },
    engines: {
      node: ">=10.0.0"
    },
    files: [
      "dist",
      "src",
      "index.d.ts"
    ]
  };
});

// ../node_modules/@discoveryjs/json-ext/src/version.js
var ZS = I((gpe, JS) => {
  JS.exports = GS().version;
});

// ../node_modules/@discoveryjs/json-ext/src/utils.js
var ic = I((ype, KS) => {
  var Bz = {
    // JSON Single Character Escape Sequences
    8: "\\b",
    9: "\\t",
    10: "\\n",
    12: "\\f",
    13: "\\r",
    34: '\\"',
    92: "\\\\"
  };
  function Oz(e) {
    return e >= 55296 && e <= 56319;
  }
  s(Oz, "isLeadingSurrogate");
  function Rz(e) {
    return e >= 56320 && e <= 57343;
  }
  s(Rz, "isTrailingSurrogate");
  function XS(e) {
    return typeof e.pipe == "function" && typeof e._read == "function" && typeof e._readableState == "object" && e._readableState !== null;
  }
  s(XS, "isReadableStream");
  function Nz(e, t, r, n) {
    switch (r && typeof r.toJSON == "function" && (r = r.toJSON()), n !== null && (r = n.call(e, String(t), r)), typeof r) {
      case "function":
      case "symbol":
        r = void 0;
        break;
      case "object":
        if (r !== null) {
          let i = r.constructor;
          (i === String || i === Number || i === Boolean) && (r = r.valueOf());
        }
        break;
    }
    return r;
  }
  s(Nz, "replaceValue");
  function Lz(e) {
    return e === null || typeof e != "object" ? 1 : Array.isArray(e) ? 3 : 2;
  }
  s(Lz, "getTypeNative");
  function jz(e) {
    return e === null || typeof e != "object" ? 1 : typeof e.then == "function" ? 4 : XS(e) ? e._readableState.objectMode ? 6 : 5 : Array.isArray(
    e) ? 3 : 2;
  }
  s(jz, "getTypeAsync");
  function Mz(e) {
    return typeof e == "function" ? e : Array.isArray(e) ? [...new Set(
      e.map((r) => {
        let n = r && r.constructor;
        return n === String || n === Number ? String(r) : null;
      }).filter((r) => typeof r == "string")
    )] : null;
  }
  s(Mz, "normalizeReplacer");
  function qz(e) {
    return typeof e == "number" ? !Number.isFinite(e) || e < 1 ? !1 : " ".repeat(Math.min(e, 10)) : typeof e == "string" && e.slice(0, 10) ||
    !1;
  }
  s(qz, "normalizeSpace");
  KS.exports = {
    escapableCharCodeSubstitution: Bz,
    isLeadingSurrogate: Oz,
    isTrailingSurrogate: Rz,
    type: {
      PRIMITIVE: 1,
      PROMISE: 4,
      ARRAY: 3,
      OBJECT: 2,
      STRING_STREAM: 5,
      OBJECT_STREAM: 6
    },
    isReadableStream: XS,
    replaceValue: Nz,
    getTypeNative: Lz,
    getTypeAsync: jz,
    normalizeReplacer: Mz,
    normalizeSpace: qz
  };
});

// ../node_modules/@discoveryjs/json-ext/src/stringify-info.js
var tA = I((xpe, eA) => {
  var {
    normalizeReplacer: $z,
    normalizeSpace: Vz,
    replaceValue: Uz,
    getTypeNative: Wz,
    getTypeAsync: zz,
    isLeadingSurrogate: Hz,
    isTrailingSurrogate: Gz,
    escapableCharCodeSubstitution: Jz,
    type: {
      PRIMITIVE: YS,
      OBJECT: Zz,
      ARRAY: Xz,
      PROMISE: Kz,
      STRING_STREAM: Yz,
      OBJECT_STREAM: Qz
    }
  } = ic(), eH = Array.from({ length: 2048 }).map((e, t) => Jz.hasOwnProperty(t) ? 2 : t < 32 ? 6 : t < 128 ? 1 : 2);
  function QS(e) {
    let t = 0, r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e.charCodeAt(n);
      if (i < 2048)
        t += eH[i];
      else if (Hz(i)) {
        t += 6, r = !0;
        continue;
      } else Gz(i) ? t = r ? t - 2 : t + 6 : t += 3;
      r = !1;
    }
    return t + 2;
  }
  s(QS, "stringLength");
  function tH(e) {
    switch (typeof e) {
      case "string":
        return QS(e);
      case "number":
        return Number.isFinite(e) ? String(e).length : 4;
      case "boolean":
        return e ? 4 : 5;
      case "undefined":
      case "object":
        return 4;
      /* null */
      default:
        return 0;
    }
  }
  s(tH, "primitiveLength");
  function rH(e) {
    return e = Vz(e), typeof e == "string" ? e.length : 0;
  }
  s(rH, "spaceLength");
  eA.exports = /* @__PURE__ */ s(function(t, r, n, i) {
    function o(b, y, E) {
      if (m)
        return;
      E = Uz(b, y, E, r);
      let A = f(E);
      if (A !== YS && l.has(E)) {
        p.add(E), g += 4, i.continueOnCircular || (m = !0);
        return;
      }
      switch (A) {
        case YS:
          E !== void 0 || Array.isArray(b) ? g += tH(E) : b === d && (g += 9);
          break;
        case Zz: {
          if (u.has(E)) {
            c.add(E), g += u.get(E);
            break;
          }
          let k = g, O = 0;
          g += 2, l.add(E);
          for (let w in E)
            if (hasOwnProperty.call(E, w) && (a === null || a.has(w))) {
              let C = g;
              o(E, w, E[w]), C !== g && (g += QS(w) + 1, O++);
            }
          O > 1 && (g += O - 1), l.delete(E), n > 0 && O > 0 && (g += (1 + (l.size + 1) * n + 1) * O, g += 1 + l.size * n), u.set(E, g - k);
          break;
        }
        case Xz: {
          if (u.has(E)) {
            c.add(E), g += u.get(E);
            break;
          }
          let k = g;
          g += 2, l.add(E);
          for (let O = 0; O < E.length; O++)
            o(E, O, E[O]);
          E.length > 1 && (g += E.length - 1), l.delete(E), n > 0 && E.length > 0 && (g += (1 + (l.size + 1) * n) * E.length, g += 1 + l.size *
          n), u.set(E, g - k);
          break;
        }
        case Kz:
        case Yz:
          h.add(E);
          break;
        case Qz:
          g += 2, h.add(E);
          break;
      }
    }
    s(o, "walk");
    let a = null;
    r = $z(r), Array.isArray(r) && (a = new Set(r), r = null), n = rH(n), i = i || {};
    let u = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(),
    f = i.async ? zz : Wz, d = { "": t }, m = !1, g = 0;
    return o(d, "", t), {
      minLength: isNaN(g) ? 1 / 0 : g,
      circular: [...p],
      duplicate: [...c],
      async: [...h]
    };
  }, "jsonStringifyInfo");
});

// ../node_modules/@discoveryjs/json-ext/src/stringify-stream.js
var cA = I((vpe, lA) => {
  var { Readable: nH } = require("stream"), {
    normalizeReplacer: iH,
    normalizeSpace: sH,
    replaceValue: oH,
    getTypeAsync: aH,
    type: {
      PRIMITIVE: uH,
      OBJECT: lH,
      ARRAY: cH,
      PROMISE: pH,
      STRING_STREAM: hH,
      OBJECT_STREAM: cg
    }
  } = ic(), rA = /* @__PURE__ */ s(() => {
  }, "noop"), fH = Object.prototype.hasOwnProperty, dH = JSON.stringify("\uD800") === '"\\ud800"' ? JSON.stringify : (e) => JSON.stringify(e).
  replace(
    /\p{Surrogate}/gu,
    (t) => `\\u${t.charCodeAt(0).toString(16)}`
  );
  function mH() {
    this.push(this._stack.value), this.popStack();
  }
  s(mH, "push");
  function gH(e) {
    switch (typeof e) {
      case "string":
        this.push(this.encodeString(e));
        break;
      case "number":
        this.push(Number.isFinite(e) ? this.encodeNumber(e) : "null");
        break;
      case "boolean":
        this.push(e ? "true" : "false");
        break;
      case "undefined":
      case "object":
        this.push("null");
        break;
      default:
        this.destroy(new TypeError(`Do not know how to serialize a ${e.constructor && e.constructor.name || typeof e}`));
    }
  }
  s(gH, "pushPrimitive");
  function oA(e) {
    let t = this._stack;
    t.first ? this.push(",") : t.first = !0, this.space ? this.push(`
${this.space.repeat(this._depth)}${this.encodeString(e)}: `) : this.push(this.encodeString(e) + ":");
  }
  s(oA, "processObjectEntry");
  function nA() {
    let e = this._stack;
    if (e.index === e.keys.length) {
      this.space && e.first ? this.push(`
${this.space.repeat(this._depth - 1)}}`) : this.push("}"), this.popStack();
      return;
    }
    let t = e.keys[e.index];
    this.processValue(e.value, t, e.value[t], oA), e.index++;
  }
  s(nA, "processObject");
  function aA(e) {
    e !== 0 && this.push(","), this.space && this.push(`
${this.space.repeat(this._depth)}`);
  }
  s(aA, "processArrayItem");
  function iA() {
    let e = this._stack;
    if (e.index === e.value.length) {
      this.space && e.index > 0 ? this.push(`
${this.space.repeat(this._depth - 1)}]`) : this.push("]"), this.popStack();
      return;
    }
    this.processValue(e.value, e.index, e.value[e.index], aA), e.index++;
  }
  s(iA, "processArray");
  function uA(e) {
    return function() {
      let t = this._stack, r = t.value.read(this._readSize);
      r !== null ? (t.first = !1, e.call(this, r, t)) : t.first && !t.value._readableState.reading || t.ended ? this.popStack() : (t.first =
      !0, t.awaiting = !0);
    };
  }
  s(uA, "createStreamReader");
  var sA = uA(function(e, t) {
    this.processValue(t.value, t.index, e, aA), t.index++;
  }), yH = uA(function(e) {
    this.push(e);
  }), pg = class extends nH {
    static {
      s(this, "JsonStringifyStream");
    }
    constructor(t, r, n) {
      if (super({
        autoDestroy: !0
      }), this.getKeys = Object.keys, this.replacer = iH(r), Array.isArray(this.replacer)) {
        let i = this.replacer;
        this.getKeys = (o) => i.filter((a) => fH.call(o, a)), this.replacer = null;
      }
      this.space = sH(n), this._depth = 0, this.error = null, this._processing = !1, this._ended = !1, this._readSize = 0, this._buffer = "",
      this._stack = null, this._visited = /* @__PURE__ */ new WeakSet(), this.pushStack({
        handler: /* @__PURE__ */ s(() => {
          this.popStack(), this.processValue({ "": t }, "", t, rA);
        }, "handler")
      });
    }
    encodeString(t) {
      return /[^\x20-\uD799]|[\x22\x5c]/.test(t) ? dH(t) : '"' + t + '"';
    }
    encodeNumber(t) {
      return t;
    }
    processValue(t, r, n, i) {
      n = oH(t, r, n, this.replacer);
      let o = aH(n);
      switch (o) {
        case uH:
          (i !== oA || n !== void 0) && (i.call(this, r), gH.call(this, n));
          break;
        case lH:
          if (i.call(this, r), this._visited.has(n))
            return this.destroy(new TypeError("Converting circular structure to JSON"));
          this._visited.add(n), this._depth++, this.push("{"), this.pushStack({
            handler: nA,
            value: n,
            index: 0,
            first: !1,
            keys: this.getKeys(n)
          });
          break;
        case cH:
          if (i.call(this, r), this._visited.has(n))
            return this.destroy(new TypeError("Converting circular structure to JSON"));
          this._visited.add(n), this.push("["), this.pushStack({
            handler: iA,
            value: n,
            index: 0
          }), this._depth++;
          break;
        case pH:
          this.pushStack({
            handler: rA,
            awaiting: !0
          }), Promise.resolve(n).then((l) => {
            this.popStack(), this.processValue(t, r, l, i), this.processStack();
          }).catch((l) => {
            this.destroy(l);
          });
          break;
        case hH:
        case cg:
          if (i.call(this, r), n.readableEnded || n._readableState.endEmitted)
            return this.destroy(new Error("Readable Stream has ended before it was serialized. All stream data have been lost"));
          if (n.readableFlowing)
            return this.destroy(new Error("Readable Stream is in flowing mode, data may have been lost. Trying to pause stream."));
          o === cg && (this.push("["), this.pushStack({
            handler: mH,
            value: this.space ? `
` + this.space.repeat(this._depth) + "]" : "]"
          }), this._depth++);
          let a = this.pushStack({
            handler: o === cg ? sA : yH,
            value: n,
            index: 0,
            first: !1,
            ended: !1,
            awaiting: !n.readable || n.readableLength === 0
          }), u = /* @__PURE__ */ s(() => {
            a.awaiting && (a.awaiting = !1, this.processStack());
          }, "continueProcessing");
          n.once("error", (l) => this.destroy(l)), n.once("end", () => {
            a.ended = !0, u();
          }), n.on("readable", u);
          break;
      }
    }
    pushStack(t) {
      return t.prev = this._stack, this._stack = t;
    }
    popStack() {
      let { handler: t, value: r } = this._stack;
      (t === nA || t === iA || t === sA) && (this._visited.delete(r), this._depth--), this._stack = this._stack.prev;
    }
    processStack() {
      if (!(this._processing || this._ended)) {
        try {
          for (this._processing = !0; this._stack !== null && !this._stack.awaiting; )
            if (this._stack.handler.call(this), !this._processing)
              return;
          this._processing = !1;
        } catch (t) {
          this.destroy(t);
          return;
        }
        this._stack === null && !this._ended && (this._finish(), this.push(null));
      }
    }
    push(t) {
      if (t !== null) {
        if (this._buffer += t, this._buffer.length < this._readSize)
          return;
        t = this._buffer, this._buffer = "", this._processing = !1;
      }
      super.push(t);
    }
    _read(t) {
      this._readSize = t || this.readableHighWaterMark, this.processStack();
    }
    _finish() {
      this._ended = !0, this._processing = !1, this._stack = null, this._visited = null, this._buffer && this._buffer.length && super.push(this.
      _buffer), this._buffer = "";
    }
    _destroy(t, r) {
      this.error = this.error || t, this._finish(), r(t);
    }
  };
  lA.exports = /* @__PURE__ */ s(function(t, r, n) {
    return new pg(t, r, n);
  }, "createJsonStringifyStream");
});

// ../node_modules/@discoveryjs/json-ext/src/text-decoder.js
var hA = I((Cpe, pA) => {
  pA.exports = require("util").TextDecoder;
});

// ../node_modules/@discoveryjs/json-ext/src/parse-chunked.js
var mA = I((wpe, dA) => {
  var { isReadableStream: DH } = ic(), xH = hA(), Aa = 1, bH = 2, vH = new xH();
  function fA(e) {
    return e !== null && typeof e == "object";
  }
  s(fA, "isObject");
  function hg(e, t) {
    return e.name === "SyntaxError" && t.jsonParseOffset && (e.message = e.message.replace(
      /at position (\d+)/,
      (r, n) => "at position " + (Number(n) + t.jsonParseOffset)
    )), e;
  }
  s(hg, "adjustPosition");
  function EH(e, t) {
    let r = e.length;
    e.length += t.length;
    for (let n = 0; n < t.length; n++)
      e[r + n] = t[n];
  }
  s(EH, "append");
  dA.exports = function(e) {
    let t = new fg();
    if (fA(e) && DH(e))
      return new Promise((r, n) => {
        e.on("data", (i) => {
          try {
            t.push(i);
          } catch (o) {
            n(hg(o, t)), t = null;
          }
        }).on("error", (i) => {
          t = null, n(i);
        }).on("end", () => {
          try {
            r(t.finish());
          } catch (i) {
            n(hg(i, t));
          } finally {
            t = null;
          }
        });
      });
    if (typeof e == "function") {
      let r = e();
      if (fA(r) && (Symbol.iterator in r || Symbol.asyncIterator in r))
        return new Promise(async (n, i) => {
          try {
            for await (let o of r)
              t.push(o);
            n(t.finish());
          } catch (o) {
            i(hg(o, t));
          } finally {
            t = null;
          }
        });
    }
    throw new Error(
      "Chunk emitter should be readable stream, generator, async generator or function returning an iterable object"
    );
  };
  var fg = class {
    static {
      s(this, "ChunkParser");
    }
    constructor() {
      this.value = void 0, this.valueStack = null, this.stack = new Array(100), this.lastFlushDepth = 0, this.flushDepth = 0, this.stateString =
      !1, this.stateStringEscape = !1, this.pendingByteSeq = null, this.pendingChunk = null, this.chunkOffset = 0, this.jsonParseOffset = 0;
    }
    parseAndAppend(t, r) {
      this.stack[this.lastFlushDepth - 1] === Aa ? (r && (this.jsonParseOffset--, t = "{" + t + "}"), Object.assign(this.valueStack.value, JSON.
      parse(t))) : (r && (this.jsonParseOffset--, t = "[" + t + "]"), EH(this.valueStack.value, JSON.parse(t)));
    }
    prepareAddition(t) {
      let { value: r } = this.valueStack;
      if (Array.isArray(r) ? r.length !== 0 : Object.keys(r).length !== 0) {
        if (t[0] === ",")
          return this.jsonParseOffset++, t.slice(1);
        if (t[0] !== "}" && t[0] !== "]")
          return this.jsonParseOffset -= 3, "[[]" + t;
      }
      return t;
    }
    flush(t, r, n) {
      let i = t.slice(r, n);
      if (this.jsonParseOffset = this.chunkOffset + r, this.pendingChunk !== null && (i = this.pendingChunk + i, this.jsonParseOffset -= this.
      pendingChunk.length, this.pendingChunk = null), this.flushDepth === this.lastFlushDepth)
        this.flushDepth > 0 ? this.parseAndAppend(this.prepareAddition(i), !0) : (this.value = JSON.parse(i), this.valueStack = {
          value: this.value,
          prev: null
        });
      else if (this.flushDepth > this.lastFlushDepth) {
        for (let o = this.flushDepth - 1; o >= this.lastFlushDepth; o--)
          i += this.stack[o] === Aa ? "}" : "]";
        this.lastFlushDepth === 0 ? (this.value = JSON.parse(i), this.valueStack = {
          value: this.value,
          prev: null
        }) : this.parseAndAppend(this.prepareAddition(i), !0);
        for (let o = this.lastFlushDepth || 1; o < this.flushDepth; o++) {
          let a = this.valueStack.value;
          if (this.stack[o - 1] === Aa) {
            let u;
            for (u in a) ;
            a = a[u];
          } else
            a = a[a.length - 1];
          this.valueStack = {
            value: a,
            prev: this.valueStack
          };
        }
      } else {
        i = this.prepareAddition(i);
        for (let o = this.lastFlushDepth - 1; o >= this.flushDepth; o--)
          this.jsonParseOffset--, i = (this.stack[o] === Aa ? "{" : "[") + i;
        this.parseAndAppend(i, !1);
        for (let o = this.lastFlushDepth - 1; o >= this.flushDepth; o--)
          this.valueStack = this.valueStack.prev;
      }
      this.lastFlushDepth = this.flushDepth;
    }
    push(t) {
      if (typeof t != "string") {
        if (this.pendingByteSeq !== null) {
          let o = t;
          t = new Uint8Array(this.pendingByteSeq.length + o.length), t.set(this.pendingByteSeq), t.set(o, this.pendingByteSeq.length), this.
          pendingByteSeq = null;
        }
        if (t[t.length - 1] > 127)
          for (let o = 0; o < t.length; o++) {
            let a = t[t.length - 1 - o];
            if (a >> 6 === 3) {
              o++, (o !== 4 && a >> 3 === 30 || o !== 3 && a >> 4 === 14 || o !== 2 && a >> 5 === 6) && (this.pendingByteSeq = t.slice(t.length -
              o), t = t.slice(0, -o));
              break;
            }
          }
        t = vH.decode(t);
      }
      let r = t.length, n = 0, i = 0;
      e: for (let o = 0; o < r; o++) {
        if (this.stateString) {
          for (; o < r; o++)
            if (this.stateStringEscape)
              this.stateStringEscape = !1;
            else
              switch (t.charCodeAt(o)) {
                case 34:
                  this.stateString = !1;
                  continue e;
                case 92:
                  this.stateStringEscape = !0;
              }
          break;
        }
        switch (t.charCodeAt(o)) {
          case 34:
            this.stateString = !0, this.stateStringEscape = !1;
            break;
          case 44:
            i = o;
            break;
          case 123:
            i = o + 1, this.stack[this.flushDepth++] = Aa;
            break;
          case 91:
            i = o + 1, this.stack[this.flushDepth++] = bH;
            break;
          case 93:
          /* ] */
          case 125:
            i = o + 1, this.flushDepth--, this.flushDepth < this.lastFlushDepth && (this.flush(t, n, i), n = i);
            break;
          case 9:
          /* \t */
          case 10:
          /* \n */
          case 13:
          /* \r */
          case 32:
            n === o && n++, i === o && i++;
            break;
        }
      }
      i > n && this.flush(t, n, i), i < r && (this.pendingChunk !== null ? this.pendingChunk += t : this.pendingChunk = t.slice(i, r)), this.
      chunkOffset += r;
    }
    finish() {
      return this.pendingChunk !== null && (this.flush("", 0, 0), this.pendingChunk = null), this.value;
    }
  };
});

// ../node_modules/@discoveryjs/json-ext/src/index.js
var yA = I((Ape, gA) => {
  gA.exports = {
    version: ZS(),
    stringifyInfo: tA(),
    stringifyStream: cA(),
    parseChunked: mA()
  };
});

// ../node_modules/graceful-fs/polyfills.js
var wA = I((Npe, CA) => {
  var li = require("constants"), CH = process.cwd, oc = null, wH = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return oc || (oc = CH.call(process)), oc;
  };
  try {
    process.cwd();
  } catch {
  }
  typeof process.chdir == "function" && (yg = process.chdir, process.chdir = function(e) {
    oc = null, yg.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, yg));
  var yg;
  CA.exports = SH;
  function SH(e) {
    li.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || r(e), e.chown = o(e.chown), e.fchown =
    o(e.fchown), e.lchown = o(e.lchown), e.chmod = n(e.chmod), e.fchmod = n(e.fchmod), e.lchmod = n(e.lchmod), e.chownSync = a(e.chownSync),
    e.fchownSync = a(e.fchownSync), e.lchownSync = a(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync =
    i(e.lchmodSync), e.stat = u(e.stat), e.fstat = u(e.fstat), e.lstat = u(e.lstat), e.statSync = l(e.statSync), e.fstatSync = l(e.fstatSync),
    e.lstatSync = l(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(p, h, f) {
      f && process.nextTick(f);
    }, e.lchmodSync = function() {
    }), e.chown && !e.lchown && (e.lchown = function(p, h, f, d) {
      d && process.nextTick(d);
    }, e.lchownSync = function() {
    }), wH === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(p) {
      function h(f, d, m) {
        var g = Date.now(), b = 0;
        p(f, d, /* @__PURE__ */ s(function y(E) {
          if (E && (E.code === "EACCES" || E.code === "EPERM" || E.code === "EBUSY") && Date.now() - g < 6e4) {
            setTimeout(function() {
              e.stat(d, function(A, k) {
                A && A.code === "ENOENT" ? p(f, d, y) : m(E);
              });
            }, b), b < 100 && (b += 10);
            return;
          }
          m && m(E);
        }, "CB"));
      }
      return s(h, "rename"), Object.setPrototypeOf && Object.setPrototypeOf(h, p), h;
    }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(p) {
      function h(f, d, m, g, b, y) {
        var E;
        if (y && typeof y == "function") {
          var A = 0;
          E = /* @__PURE__ */ s(function(k, O, w) {
            if (k && k.code === "EAGAIN" && A < 10)
              return A++, p.call(e, f, d, m, g, b, E);
            y.apply(this, arguments);
          }, "callback");
        }
        return p.call(e, f, d, m, g, b, E);
      }
      return s(h, "read"), Object.setPrototypeOf && Object.setPrototypeOf(h, p), h;
    }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(p) {
      return function(h, f, d, m, g) {
        for (var b = 0; ; )
          try {
            return p.call(e, h, f, d, m, g);
          } catch (y) {
            if (y.code === "EAGAIN" && b < 10) {
              b++;
              continue;
            }
            throw y;
          }
      };
    }(e.readSync);
    function t(p) {
      p.lchmod = function(h, f, d) {
        p.open(
          h,
          li.O_WRONLY | li.O_SYMLINK,
          f,
          function(m, g) {
            if (m) {
              d && d(m);
              return;
            }
            p.fchmod(g, f, function(b) {
              p.close(g, function(y) {
                d && d(b || y);
              });
            });
          }
        );
      }, p.lchmodSync = function(h, f) {
        var d = p.openSync(h, li.O_WRONLY | li.O_SYMLINK, f), m = !0, g;
        try {
          g = p.fchmodSync(d, f), m = !1;
        } finally {
          if (m)
            try {
              p.closeSync(d);
            } catch {
            }
          else
            p.closeSync(d);
        }
        return g;
      };
    }
    s(t, "patchLchmod");
    function r(p) {
      li.hasOwnProperty("O_SYMLINK") && p.futimes ? (p.lutimes = function(h, f, d, m) {
        p.open(h, li.O_SYMLINK, function(g, b) {
          if (g) {
            m && m(g);
            return;
          }
          p.futimes(b, f, d, function(y) {
            p.close(b, function(E) {
              m && m(y || E);
            });
          });
        });
      }, p.lutimesSync = function(h, f, d) {
        var m = p.openSync(h, li.O_SYMLINK), g, b = !0;
        try {
          g = p.futimesSync(m, f, d), b = !1;
        } finally {
          if (b)
            try {
              p.closeSync(m);
            } catch {
            }
          else
            p.closeSync(m);
        }
        return g;
      }) : p.futimes && (p.lutimes = function(h, f, d, m) {
        m && process.nextTick(m);
      }, p.lutimesSync = function() {
      });
    }
    s(r, "patchLutimes");
    function n(p) {
      return p && function(h, f, d) {
        return p.call(e, h, f, function(m) {
          c(m) && (m = null), d && d.apply(this, arguments);
        });
      };
    }
    s(n, "chmodFix");
    function i(p) {
      return p && function(h, f) {
        try {
          return p.call(e, h, f);
        } catch (d) {
          if (!c(d)) throw d;
        }
      };
    }
    s(i, "chmodFixSync");
    function o(p) {
      return p && function(h, f, d, m) {
        return p.call(e, h, f, d, function(g) {
          c(g) && (g = null), m && m.apply(this, arguments);
        });
      };
    }
    s(o, "chownFix");
    function a(p) {
      return p && function(h, f, d) {
        try {
          return p.call(e, h, f, d);
        } catch (m) {
          if (!c(m)) throw m;
        }
      };
    }
    s(a, "chownFixSync");
    function u(p) {
      return p && function(h, f, d) {
        typeof f == "function" && (d = f, f = null);
        function m(g, b) {
          b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), d && d.apply(this, arguments);
        }
        return s(m, "callback"), f ? p.call(e, h, f, m) : p.call(e, h, m);
      };
    }
    s(u, "statFix");
    function l(p) {
      return p && function(h, f) {
        var d = f ? p.call(e, h, f) : p.call(e, h);
        return d && (d.uid < 0 && (d.uid += 4294967296), d.gid < 0 && (d.gid += 4294967296)), d;
      };
    }
    s(l, "statFixSync");
    function c(p) {
      if (!p || p.code === "ENOSYS")
        return !0;
      var h = !process.getuid || process.getuid() !== 0;
      return !!(h && (p.code === "EINVAL" || p.code === "EPERM"));
    }
    s(c, "chownErOk");
  }
  s(SH, "patch");
});

// ../node_modules/graceful-fs/legacy-streams.js
var FA = I((jpe, AA) => {
  var SA = require("stream").Stream;
  AA.exports = AH;
  function AH(e) {
    return {
      ReadStream: t,
      WriteStream: r
    };
    function t(n, i) {
      if (!(this instanceof t)) return new t(n, i);
      SA.call(this);
      var o = this;
      this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i =
      i || {};
      for (var a = Object.keys(i), u = 0, l = a.length; u < l; u++) {
        var c = a[u];
        this[c] = i[c];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      e.open(this.path, this.flags, this.mode, function(p, h) {
        if (p) {
          o.emit("error", p), o.readable = !1;
          return;
        }
        o.fd = h, o.emit("open", h), o._read();
      });
    }
    function r(n, i) {
      if (!(this instanceof r)) return new r(n, i);
      SA.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten =
      0, i = i || {};
      for (var o = Object.keys(i), a = 0, u = o.length; a < u; a++) {
        var l = o[a];
        this[l] = i[l];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.
      mode, void 0]), this.flush());
    }
  }
  s(AH, "legacy");
});

// ../node_modules/graceful-fs/clone.js
var kA = I((qpe, _A) => {
  "use strict";
  _A.exports = _H;
  var FH = Object.getPrototypeOf || function(e) {
    return e.__proto__;
  };
  function _H(e) {
    if (e === null || typeof e != "object")
      return e;
    if (e instanceof Object)
      var t = { __proto__: FH(e) };
    else
      var t = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(e).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
    }), t;
  }
  s(_H, "clone");
});

// ../node_modules/graceful-fs/graceful-fs.js
var BA = I((Vpe, bg) => {
  var st = require("fs"), kH = wA(), TH = FA(), IH = kA(), ac = require("util"), St, lc;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (St = Symbol.for("graceful-fs.queue"), lc = Symbol.for("graceful-fs.previ\
ous")) : (St = "___graceful-fs.queue", lc = "___graceful-fs.previous");
  function PH() {
  }
  s(PH, "noop");
  function PA(e, t) {
    Object.defineProperty(e, St, {
      get: /* @__PURE__ */ s(function() {
        return t;
      }, "get")
    });
  }
  s(PA, "publishQueue");
  var $i = PH;
  ac.debuglog ? $i = ac.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && ($i = /* @__PURE__ */ s(function() {
    var e = ac.format.apply(ac, arguments);
    e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
  }, "debug"));
  st[St] || (TA = global[St] || [], PA(st, TA), st.close = function(e) {
    function t(r, n) {
      return e.call(st, r, function(i) {
        i || IA(), typeof n == "function" && n.apply(this, arguments);
      });
    }
    return s(t, "close"), Object.defineProperty(t, lc, {
      value: e
    }), t;
  }(st.close), st.closeSync = function(e) {
    function t(r) {
      e.apply(st, arguments), IA();
    }
    return s(t, "closeSync"), Object.defineProperty(t, lc, {
      value: e
    }), t;
  }(st.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    $i(st[St]), require("assert").equal(st[St].length, 0);
  }));
  var TA;
  global[St] || PA(global, st[St]);
  bg.exports = Dg(IH(st));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !st.__patched && (bg.exports = Dg(st), st.__patched = !0);
  function Dg(e) {
    kH(e), e.gracefulify = Dg, e.createReadStream = O, e.createWriteStream = w;
    var t = e.readFile;
    e.readFile = r;
    function r(F, $, R) {
      return typeof $ == "function" && (R = $, $ = null), U(F, $, R);
      function U(W, Y, j, N) {
        return t(W, Y, function(z) {
          z && (z.code === "EMFILE" || z.code === "ENFILE") ? eo([U, [W, Y, j], z, N || Date.now(), Date.now()]) : typeof j == "function" &&
          j.apply(this, arguments);
        });
      }
      s(U, "go$readFile");
    }
    s(r, "readFile");
    var n = e.writeFile;
    e.writeFile = i;
    function i(F, $, R, U) {
      return typeof R == "function" && (U = R, R = null), W(F, $, R, U);
      function W(Y, j, N, z, Q) {
        return n(Y, j, N, function(ie) {
          ie && (ie.code === "EMFILE" || ie.code === "ENFILE") ? eo([W, [Y, j, N, z], ie, Q || Date.now(), Date.now()]) : typeof z == "funct\
ion" && z.apply(this, arguments);
        });
      }
      s(W, "go$writeFile");
    }
    s(i, "writeFile");
    var o = e.appendFile;
    o && (e.appendFile = a);
    function a(F, $, R, U) {
      return typeof R == "function" && (U = R, R = null), W(F, $, R, U);
      function W(Y, j, N, z, Q) {
        return o(Y, j, N, function(ie) {
          ie && (ie.code === "EMFILE" || ie.code === "ENFILE") ? eo([W, [Y, j, N, z], ie, Q || Date.now(), Date.now()]) : typeof z == "funct\
ion" && z.apply(this, arguments);
        });
      }
      s(W, "go$appendFile");
    }
    s(a, "appendFile");
    var u = e.copyFile;
    u && (e.copyFile = l);
    function l(F, $, R, U) {
      return typeof R == "function" && (U = R, R = 0), W(F, $, R, U);
      function W(Y, j, N, z, Q) {
        return u(Y, j, N, function(ie) {
          ie && (ie.code === "EMFILE" || ie.code === "ENFILE") ? eo([W, [Y, j, N, z], ie, Q || Date.now(), Date.now()]) : typeof z == "funct\
ion" && z.apply(this, arguments);
        });
      }
      s(W, "go$copyFile");
    }
    s(l, "copyFile");
    var c = e.readdir;
    e.readdir = h;
    var p = /^v[0-5]\./;
    function h(F, $, R) {
      typeof $ == "function" && (R = $, $ = null);
      var U = p.test(process.version) ? /* @__PURE__ */ s(function(j, N, z, Q) {
        return c(j, W(
          j,
          N,
          z,
          Q
        ));
      }, "go$readdir") : /* @__PURE__ */ s(function(j, N, z, Q) {
        return c(j, N, W(
          j,
          N,
          z,
          Q
        ));
      }, "go$readdir");
      return U(F, $, R);
      function W(Y, j, N, z) {
        return function(Q, ie) {
          Q && (Q.code === "EMFILE" || Q.code === "ENFILE") ? eo([
            U,
            [Y, j, N],
            Q,
            z || Date.now(),
            Date.now()
          ]) : (ie && ie.sort && ie.sort(), typeof N == "function" && N.call(this, Q, ie));
        };
      }
    }
    if (s(h, "readdir"), process.version.substr(0, 4) === "v0.8") {
      var f = TH(e);
      y = f.ReadStream, A = f.WriteStream;
    }
    var d = e.ReadStream;
    d && (y.prototype = Object.create(d.prototype), y.prototype.open = E);
    var m = e.WriteStream;
    m && (A.prototype = Object.create(m.prototype), A.prototype.open = k), Object.defineProperty(e, "ReadStream", {
      get: /* @__PURE__ */ s(function() {
        return y;
      }, "get"),
      set: /* @__PURE__ */ s(function(F) {
        y = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e, "WriteStream", {
      get: /* @__PURE__ */ s(function() {
        return A;
      }, "get"),
      set: /* @__PURE__ */ s(function(F) {
        A = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var g = y;
    Object.defineProperty(e, "FileReadStream", {
      get: /* @__PURE__ */ s(function() {
        return g;
      }, "get"),
      set: /* @__PURE__ */ s(function(F) {
        g = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var b = A;
    Object.defineProperty(e, "FileWriteStream", {
      get: /* @__PURE__ */ s(function() {
        return b;
      }, "get"),
      set: /* @__PURE__ */ s(function(F) {
        b = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    function y(F, $) {
      return this instanceof y ? (d.apply(this, arguments), this) : y.apply(Object.create(y.prototype), arguments);
    }
    s(y, "ReadStream");
    function E() {
      var F = this;
      T(F.path, F.flags, F.mode, function($, R) {
        $ ? (F.autoClose && F.destroy(), F.emit("error", $)) : (F.fd = R, F.emit("open", R), F.read());
      });
    }
    s(E, "ReadStream$open");
    function A(F, $) {
      return this instanceof A ? (m.apply(this, arguments), this) : A.apply(Object.create(A.prototype), arguments);
    }
    s(A, "WriteStream");
    function k() {
      var F = this;
      T(F.path, F.flags, F.mode, function($, R) {
        $ ? (F.destroy(), F.emit("error", $)) : (F.fd = R, F.emit("open", R));
      });
    }
    s(k, "WriteStream$open");
    function O(F, $) {
      return new e.ReadStream(F, $);
    }
    s(O, "createReadStream");
    function w(F, $) {
      return new e.WriteStream(F, $);
    }
    s(w, "createWriteStream");
    var C = e.open;
    e.open = T;
    function T(F, $, R, U) {
      return typeof R == "function" && (U = R, R = null), W(F, $, R, U);
      function W(Y, j, N, z, Q) {
        return C(Y, j, N, function(ie, B) {
          ie && (ie.code === "EMFILE" || ie.code === "ENFILE") ? eo([W, [Y, j, N, z], ie, Q || Date.now(), Date.now()]) : typeof z == "funct\
ion" && z.apply(this, arguments);
        });
      }
      s(W, "go$open");
    }
    return s(T, "open"), e;
  }
  s(Dg, "patch");
  function eo(e) {
    $i("ENQUEUE", e[0].name, e[1]), st[St].push(e), xg();
  }
  s(eo, "enqueue");
  var uc;
  function IA() {
    for (var e = Date.now(), t = 0; t < st[St].length; ++t)
      st[St][t].length > 2 && (st[St][t][3] = e, st[St][t][4] = e);
    xg();
  }
  s(IA, "resetQueue");
  function xg() {
    if (clearTimeout(uc), uc = void 0, st[St].length !== 0) {
      var e = st[St].shift(), t = e[0], r = e[1], n = e[2], i = e[3], o = e[4];
      if (i === void 0)
        $i("RETRY", t.name, r), t.apply(null, r);
      else if (Date.now() - i >= 6e4) {
        $i("TIMEOUT", t.name, r);
        var a = r.pop();
        typeof a == "function" && a.call(null, n);
      } else {
        var u = Date.now() - o, l = Math.max(o - i, 1), c = Math.min(l * 1.2, 100);
        u >= c ? ($i("RETRY", t.name, r), t.apply(null, r.concat([i]))) : st[St].push(e);
      }
      uc === void 0 && (uc = setTimeout(xg, 0));
    }
  }
  s(xg, "retry");
});

// ../node_modules/watchpack/lib/reducePlan.js
var RA = I((Wpe, OA) => {
  "use strict";
  var BH = require("path");
  OA.exports = (e, t) => {
    let r = /* @__PURE__ */ new Map();
    for (let [o, a] of e)
      r.set(o, {
        filePath: o,
        parent: void 0,
        children: void 0,
        entries: 1,
        active: !0,
        value: a
      });
    let n = r.size;
    for (let o of r.values()) {
      let a = BH.dirname(o.filePath);
      if (a !== o.filePath) {
        let u = r.get(a);
        if (u === void 0)
          u = {
            filePath: a,
            parent: void 0,
            children: [o],
            entries: o.entries,
            active: !1,
            value: void 0
          }, r.set(a, u), o.parent = u;
        else {
          o.parent = u, u.children === void 0 ? u.children = [o] : u.children.push(o);
          do
            u.entries += o.entries, u = u.parent;
          while (u);
        }
      }
    }
    for (; n > t; ) {
      let o = n - t, a, u = 1 / 0;
      for (let h of r.values()) {
        if (h.entries <= 1 || !h.children || !h.parent || h.children.length === 0 || h.children.length === 1 && !h.value) continue;
        let f = h.entries - 1 >= o ? h.entries - 1 - o : o - h.entries + 1 + t * 0.3;
        f < u && (a = h, u = f);
      }
      if (!a) break;
      let l = a.entries - 1;
      a.active = !0, a.entries = 1, n -= l;
      let c = a.parent;
      for (; c; )
        c.entries -= l, c = c.parent;
      let p = new Set(a.children);
      for (let h of p)
        if (h.active = !1, h.entries = 0, h.children)
          for (let f of h.children) p.add(f);
    }
    let i = /* @__PURE__ */ new Map();
    for (let o of r.values()) {
      if (!o.active) continue;
      let a = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set([o]);
      for (let l of u)
        if (!(l.active && l !== o)) {
          if (l.value)
            if (Array.isArray(l.value))
              for (let c of l.value)
                a.set(c, l.filePath);
            else
              a.set(l.value, l.filePath);
          if (l.children)
            for (let c of l.children)
              u.add(c);
        }
      i.set(o.filePath, a);
    }
    return i;
  };
});

// ../node_modules/watchpack/lib/watchEventSource.js
var Ag = I((hc) => {
  "use strict";
  var LA = require("fs"), pc = require("path"), { EventEmitter: OH } = require("events"), RH = RA(), jA = require("os").platform() === "darw\
in", NH = require("os").platform() === "win32", LH = jA || NH, NA = +process.env.WATCHPACK_WATCHER_LIMIT || (jA ? 2e3 : 1e4), cc = !!process.
  env.WATCHPACK_RECURSIVE_WATCHER_LOGGING, Eg = !1, to = 0, Fa = /* @__PURE__ */ new Map(), _a = /* @__PURE__ */ new Map(), ka = /* @__PURE__ */ new Map(),
  Vi = /* @__PURE__ */ new Map(), Cg = class {
    static {
      s(this, "DirectWatcher");
    }
    constructor(t) {
      this.filePath = t, this.watchers = /* @__PURE__ */ new Set(), this.watcher = void 0;
      try {
        let r = LA.watch(t);
        this.watcher = r, r.on("change", (n, i) => {
          for (let o of this.watchers)
            o.emit("change", n, i);
        }), r.on("error", (n) => {
          for (let i of this.watchers)
            i.emit("error", n);
        });
      } catch (r) {
        process.nextTick(() => {
          for (let n of this.watchers)
            n.emit("error", r);
        });
      }
      to++;
    }
    add(t) {
      Vi.set(t, this), this.watchers.add(t);
    }
    remove(t) {
      this.watchers.delete(t), this.watchers.size === 0 && (ka.delete(this.filePath), to--, this.watcher && this.watcher.close());
    }
    getWatchers() {
      return this.watchers;
    }
  }, wg = class {
    static {
      s(this, "RecursiveWatcher");
    }
    constructor(t) {
      this.rootPath = t, this.mapWatcherToPath = /* @__PURE__ */ new Map(), this.mapPathToWatchers = /* @__PURE__ */ new Map(), this.watcher =
      void 0;
      try {
        let r = LA.watch(t, {
          recursive: !0
        });
        this.watcher = r, r.on("change", (n, i) => {
          if (i) {
            let o = pc.dirname(i), a = this.mapPathToWatchers.get(o);
            if (cc && process.stderr.write(
              `[watchpack] dispatch ${n} event in recursive watcher (${this.rootPath}) for '${i}' to ${a ? a.size : 0} watchers
`
            ), a === void 0) return;
            for (let u of a)
              u.emit("change", n, pc.basename(i));
          } else {
            cc && process.stderr.write(
              `[watchpack] dispatch ${n} event in recursive watcher (${this.rootPath}) to all watchers
`
            );
            for (let o of this.mapWatcherToPath.keys())
              o.emit("change", n);
          }
        }), r.on("error", (n) => {
          for (let i of this.mapWatcherToPath.keys())
            i.emit("error", n);
        });
      } catch (r) {
        process.nextTick(() => {
          for (let n of this.mapWatcherToPath.keys())
            n.emit("error", r);
        });
      }
      to++, cc && process.stderr.write(
        `[watchpack] created recursive watcher at ${t}
`
      );
    }
    add(t, r) {
      Vi.set(r, this);
      let n = t.slice(this.rootPath.length + 1) || ".";
      this.mapWatcherToPath.set(r, n);
      let i = this.mapPathToWatchers.get(n);
      if (i === void 0) {
        let o = /* @__PURE__ */ new Set();
        o.add(r), this.mapPathToWatchers.set(n, o);
      } else
        i.add(r);
    }
    remove(t) {
      let r = this.mapWatcherToPath.get(t);
      if (!r) return;
      this.mapWatcherToPath.delete(t);
      let n = this.mapPathToWatchers.get(r);
      n.delete(t), n.size === 0 && this.mapPathToWatchers.delete(r), this.mapWatcherToPath.size === 0 && (_a.delete(this.rootPath), to--, this.
      watcher && this.watcher.close(), cc && process.stderr.write(
        `[watchpack] closed recursive watcher at ${this.rootPath}
`
      ));
    }
    getWatchers() {
      return this.mapWatcherToPath;
    }
  }, Sg = class extends OH {
    static {
      s(this, "Watcher");
    }
    close() {
      if (Fa.has(this)) {
        Fa.delete(this);
        return;
      }
      Vi.get(this).remove(this), Vi.delete(this);
    }
  }, vg = /* @__PURE__ */ s((e) => {
    let t = ka.get(e);
    if (t !== void 0) return t;
    let r = new Cg(e);
    return ka.set(e, r), r;
  }, "createDirectWatcher"), jH = /* @__PURE__ */ s((e) => {
    let t = _a.get(e);
    if (t !== void 0) return t;
    let r = new wg(e);
    return _a.set(e, r), r;
  }, "createRecursiveWatcher"), MA = /* @__PURE__ */ s(() => {
    let e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ s((n, i) => {
      let o = e.get(i);
      o === void 0 ? e.set(i, n) : Array.isArray(o) ? o.push(n) : e.set(i, [o, n]);
    }, "addWatcher");
    for (let [n, i] of Fa)
      t(n, i);
    if (Fa.clear(), !LH || NA - to >= e.size) {
      for (let [n, i] of e) {
        let o = vg(n);
        if (Array.isArray(i))
          for (let a of i) o.add(a);
        else
          o.add(i);
      }
      return;
    }
    for (let n of _a.values())
      for (let [i, o] of n.getWatchers())
        t(i, pc.join(n.rootPath, o));
    for (let n of ka.values())
      for (let i of n.getWatchers())
        t(i, n.filePath);
    let r = RH(e, NA * 0.9);
    for (let [n, i] of r)
      if (i.size === 1)
        for (let [o, a] of i) {
          let u = vg(a), l = Vi.get(o);
          l !== u && (u.add(o), l !== void 0 && l.remove(o));
        }
      else {
        let o = new Set(i.values());
        if (o.size > 1) {
          let a = jH(n);
          for (let [u, l] of i) {
            let c = Vi.get(u);
            c !== a && (a.add(l, u), c !== void 0 && c.remove(u));
          }
        } else
          for (let a of o) {
            let u = vg(a);
            for (let l of i.keys()) {
              let c = Vi.get(l);
              c !== u && (u.add(l), c !== void 0 && c.remove(l));
            }
          }
      }
  }, "execute");
  hc.watch = (e) => {
    let t = new Sg(), r = ka.get(e);
    if (r !== void 0)
      return r.add(t), t;
    let n = e;
    for (; ; ) {
      let i = _a.get(n);
      if (i !== void 0)
        return i.add(e, t), t;
      let o = pc.dirname(n);
      if (o === n) break;
      n = o;
    }
    return Fa.set(t, e), Eg || MA(), t;
  };
  hc.batch = (e) => {
    Eg = !0;
    try {
      e();
    } finally {
      Eg = !1, MA();
    }
  };
  hc.getNumberOfWatchers = () => to;
});

// ../node_modules/watchpack/lib/DirectoryWatcher.js
var WA = I((Gpe, kg) => {
  "use strict";
  var UA = require("events").EventEmitter, fc = BA(), Ta = require("path"), MH = Ag(), no = Object.freeze({}), Lt = 2e3, qA = require("os").
  platform() === "darwin", Ia = process.env.WATCHPACK_POLLING, $A = `${+Ia}` === Ia ? +Ia : !!Ia && Ia !== "false";
  function ro(e) {
    return e.toLowerCase();
  }
  s(ro, "withoutCase");
  function qH(e, t) {
    return function() {
      if (--e === 0)
        return t();
    };
  }
  s(qH, "needCalls");
  var Fg = class extends UA {
    static {
      s(this, "Watcher");
    }
    constructor(t, r, n) {
      super(), this.directoryWatcher = t, this.path = r, this.startTime = n && +n;
    }
    checkStartTime(t, r) {
      let n = this.startTime;
      return typeof n != "number" ? !r : n <= t;
    }
    close() {
      this.emit("closed");
    }
  }, _g = class extends UA {
    static {
      s(this, "DirectoryWatcher");
    }
    constructor(t, r, n) {
      super(), $A && (n.poll = $A), this.watcherManager = t, this.options = n, this.path = r, this.files = /* @__PURE__ */ new Map(), this.filesWithoutCase =
      /* @__PURE__ */ new Map(), this.directories = /* @__PURE__ */ new Map(), this.lastWatchEvent = 0, this.initialScan = !0, this.ignored =
      n.ignored || (() => !1), this.nestedWatching = !1, this.polledWatching = typeof n.poll == "number" ? n.poll : n.poll ? 5007 : !1, this.
      timeout = void 0, this.initialScanRemoved = /* @__PURE__ */ new Set(), this.initialScanFinished = void 0, this.watchers = /* @__PURE__ */ new Map(),
      this.parentWatcher = null, this.refs = 0, this._activeEvents = /* @__PURE__ */ new Map(), this.closed = !1, this.scanning = !1, this.scanAgain =
      !1, this.scanAgainInitial = !1, this.createWatcher(), this.doScan(!0);
    }
    createWatcher() {
      try {
        this.polledWatching ? this.watcher = {
          close: /* @__PURE__ */ s(() => {
            this.timeout && (clearTimeout(this.timeout), this.timeout = void 0);
          }, "close")
        } : (qA && this.watchInParentDirectory(), this.watcher = MH.watch(this.path), this.watcher.on("change", this.onWatchEvent.bind(this)),
        this.watcher.on("error", this.onWatcherError.bind(this)));
      } catch (t) {
        this.onWatcherError(t);
      }
    }
    forEachWatcher(t, r) {
      let n = this.watchers.get(ro(t));
      if (n !== void 0)
        for (let i of n)
          r(i);
    }
    setMissing(t, r, n) {
      this.initialScan && this.initialScanRemoved.add(t);
      let i = this.directories.get(t);
      if (i && (this.nestedWatching && i.close(), this.directories.delete(t), this.forEachWatcher(t, (a) => a.emit("remove", n)), r || this.
      forEachWatcher(
        this.path,
        (a) => a.emit("change", t, null, n, r)
      )), this.files.get(t)) {
        this.files.delete(t);
        let a = ro(t), u = this.filesWithoutCase.get(a) - 1;
        u <= 0 ? (this.filesWithoutCase.delete(a), this.forEachWatcher(t, (l) => l.emit("remove", n))) : this.filesWithoutCase.set(a, u), r ||
        this.forEachWatcher(
          this.path,
          (l) => l.emit("change", t, null, n, r)
        );
      }
    }
    setFileTime(t, r, n, i, o) {
      let a = Date.now();
      if (this.ignored(t)) return;
      let u = this.files.get(t), l, c;
      if (n)
        l = Math.min(a, r) + Lt, c = Lt;
      else if (l = a, c = 0, u && u.timestamp === r && r + Lt < a)
        return;
      if (!(i && u && u.timestamp === r)) {
        if (this.files.set(t, {
          safeTime: l,
          accuracy: c,
          timestamp: r
        }), u)
          n || this.forEachWatcher(t, (p) => p.emit("change", r, o));
        else {
          let p = ro(t), h = this.filesWithoutCase.get(p);
          this.filesWithoutCase.set(p, (h || 0) + 1), h !== void 0 && this.doScan(!1), this.forEachWatcher(t, (f) => {
            (!n || f.checkStartTime(l, n)) && f.emit("change", r, o);
          });
        }
        this.forEachWatcher(this.path, (p) => {
          (!n || p.checkStartTime(l, n)) && p.emit("change", t, l, o, n);
        });
      }
    }
    setDirectory(t, r, n, i) {
      if (!this.ignored(t)) {
        if (t === this.path)
          n || this.forEachWatcher(
            this.path,
            (o) => o.emit("change", t, r, i, n)
          );
        else if (!this.directories.get(t)) {
          let a = Date.now();
          this.nestedWatching ? this.createNestedWatcher(t) : this.directories.set(t, !0);
          let u;
          n ? u = Math.min(a, r) + Lt : u = a, this.forEachWatcher(t, (l) => {
            (!n || l.checkStartTime(u, !1)) && l.emit("change", r, i);
          }), this.forEachWatcher(this.path, (l) => {
            (!n || l.checkStartTime(u, n)) && l.emit("change", t, u, i, n);
          });
        }
      }
    }
    createNestedWatcher(t) {
      let r = this.watcherManager.watchDirectory(t, 1);
      r.on("change", (n, i, o, a) => {
        this.forEachWatcher(this.path, (u) => {
          (!a || u.checkStartTime(i, a)) && u.emit("change", n, i, o, a);
        });
      }), this.directories.set(t, r);
    }
    setNestedWatching(t) {
      if (this.nestedWatching !== !!t)
        if (this.nestedWatching = !!t, this.nestedWatching)
          for (let r of this.directories.keys())
            this.createNestedWatcher(r);
        else
          for (let [r, n] of this.directories)
            n.close(), this.directories.set(r, !0);
    }
    watch(t, r) {
      let n = ro(t), i = this.watchers.get(n);
      i === void 0 && (i = /* @__PURE__ */ new Set(), this.watchers.set(n, i)), this.refs++;
      let o = new Fg(this, t, r);
      o.on("closed", () => {
        if (--this.refs <= 0) {
          this.close();
          return;
        }
        i.delete(o), i.size === 0 && (this.watchers.delete(n), this.path === t && this.setNestedWatching(!1));
      }), i.add(o);
      let a;
      if (t === this.path) {
        this.setNestedWatching(!0), a = this.lastWatchEvent;
        for (let u of this.files.values())
          dc(u), a = Math.max(a, u.safeTime);
      } else {
        let u = this.files.get(t);
        u ? (dc(u), a = u.safeTime) : a = 0;
      }
      return a ? a >= r && process.nextTick(() => {
        this.closed || (t === this.path ? o.emit(
          "change",
          t,
          a,
          "watch (outdated on attach)",
          !0
        ) : o.emit(
          "change",
          a,
          "watch (outdated on attach)",
          !0
        ));
      }) : this.initialScan ? this.initialScanRemoved.has(t) && process.nextTick(() => {
        this.closed || o.emit("remove");
      }) : t !== this.path && !this.directories.has(t) && o.checkStartTime(this.initialScanFinished, !1) && process.nextTick(() => {
        this.closed || o.emit("initial-missing", "watch (missing on attach)");
      }), o;
    }
    onWatchEvent(t, r) {
      if (this.closed) return;
      if (!r) {
        this.doScan(!1);
        return;
      }
      let n = Ta.join(this.path, r);
      if (!this.ignored(n))
        if (this._activeEvents.get(r) === void 0) {
          this._activeEvents.set(r, !1);
          let i = /* @__PURE__ */ s(() => {
            this.closed || (this._activeEvents.set(r, !1), fc.lstat(n, (o, a) => {
              if (!this.closed) {
                if (this._activeEvents.get(r) === !0) {
                  process.nextTick(i);
                  return;
                }
                this._activeEvents.delete(r), o && (o.code !== "ENOENT" && o.code !== "EPERM" && o.code !== "EBUSY" ? this.onStatsError(o) :
                r === Ta.basename(this.path) && (fc.existsSync(this.path) || this.onDirectoryRemoved("stat failed"))), this.lastWatchEvent =
                Date.now(), a ? a.isDirectory() ? this.setDirectory(
                  n,
                  +a.birthtime || 1,
                  !1,
                  t
                ) : (a.isFile() || a.isSymbolicLink()) && (a.mtime && VA(a.mtime), this.setFileTime(
                  n,
                  +a.mtime || +a.ctime || 1,
                  !1,
                  !1,
                  t
                )) : this.setMissing(n, !1, t);
              }
            }));
          }, "checkStats");
          process.nextTick(i);
        } else
          this._activeEvents.set(r, !0);
    }
    onWatcherError(t) {
      this.closed || t && (t.code !== "EPERM" && t.code !== "ENOENT" && console.error("Watchpack Error (watcher): " + t), this.onDirectoryRemoved(
      "watch error"));
    }
    onStatsError(t) {
      t && console.error("Watchpack Error (stats): " + t);
    }
    onScanError(t) {
      t && console.error("Watchpack Error (initial scan): " + t), this.onScanFinished();
    }
    onScanFinished() {
      this.polledWatching && (this.timeout = setTimeout(() => {
        this.closed || this.doScan(!1);
      }, this.polledWatching));
    }
    onDirectoryRemoved(t) {
      this.watcher && (this.watcher.close(), this.watcher = null), this.watchInParentDirectory();
      let r = `directory-removed (${t})`;
      for (let n of this.directories.keys())
        this.setMissing(n, null, r);
      for (let n of this.files.keys())
        this.setMissing(n, null, r);
    }
    watchInParentDirectory() {
      if (!this.parentWatcher) {
        let t = Ta.dirname(this.path);
        if (Ta.dirname(t) === t) return;
        this.parentWatcher = this.watcherManager.watchFile(this.path, 1), this.parentWatcher.on("change", (r, n) => {
          this.closed || ((!qA || this.polledWatching) && this.parentWatcher && (this.parentWatcher.close(), this.parentWatcher = null), this.
          watcher || (this.createWatcher(), this.doScan(!1), this.forEachWatcher(
            this.path,
            (i) => i.emit("change", this.path, r, n, !1)
          )));
        }), this.parentWatcher.on("remove", () => {
          this.onDirectoryRemoved("parent directory removed");
        });
      }
    }
    doScan(t) {
      if (this.scanning) {
        this.scanAgain ? t || (this.scanAgainInitial = !1) : (this.scanAgain = !0, this.scanAgainInitial = t);
        return;
      }
      this.scanning = !0, this.timeout && (clearTimeout(this.timeout), this.timeout = void 0), process.nextTick(() => {
        this.closed || fc.readdir(this.path, (r, n) => {
          if (this.closed) return;
          if (r) {
            if (r.code === "ENOENT" || r.code === "EPERM" ? this.onDirectoryRemoved("scan readdir failed") : this.onScanError(r), this.initialScan =
            !1, this.initialScanFinished = Date.now(), t)
              for (let a of this.watchers.values())
                for (let u of a)
                  u.checkStartTime(this.initialScanFinished, !1) && u.emit(
                    "initial-missing",
                    "scan (parent directory missing in initial scan)"
                  );
            this.scanAgain ? (this.scanAgain = !1, this.doScan(this.scanAgainInitial)) : this.scanning = !1;
            return;
          }
          let i = new Set(
            n.map((a) => Ta.join(this.path, a.normalize("NFC")))
          );
          for (let a of this.files.keys())
            i.has(a) || this.setMissing(a, t, "scan (missing)");
          for (let a of this.directories.keys())
            i.has(a) || this.setMissing(a, t, "scan (missing)");
          if (this.scanAgain) {
            this.scanAgain = !1, this.doScan(t);
            return;
          }
          let o = qH(i.size + 1, () => {
            if (!this.closed) {
              if (this.initialScan = !1, this.initialScanRemoved = null, this.initialScanFinished = Date.now(), t) {
                let a = new Map(this.watchers);
                a.delete(ro(this.path));
                for (let u of i)
                  a.delete(ro(u));
                for (let u of a.values())
                  for (let l of u)
                    l.checkStartTime(this.initialScanFinished, !1) && l.emit(
                      "initial-missing",
                      "scan (missing in initial scan)"
                    );
              }
              this.scanAgain ? (this.scanAgain = !1, this.doScan(this.scanAgainInitial)) : (this.scanning = !1, this.onScanFinished());
            }
          });
          for (let a of i)
            fc.lstat(a, (u, l) => {
              if (!this.closed) {
                if (u) {
                  u.code === "ENOENT" || u.code === "EPERM" || u.code === "EACCES" || u.code === "EBUSY" ? this.setMissing(a, t, "scan (" + u.
                  code + ")") : this.onScanError(u), o();
                  return;
                }
                l.isFile() || l.isSymbolicLink() ? (l.mtime && VA(l.mtime), this.setFileTime(
                  a,
                  +l.mtime || +l.ctime || 1,
                  t,
                  !0,
                  "scan (file)"
                )) : l.isDirectory() && (!t || !this.directories.has(a)) && this.setDirectory(
                  a,
                  +l.birthtime || 1,
                  t,
                  "scan (dir)"
                ), o();
              }
            });
          o();
        });
      });
    }
    getTimes() {
      let t = /* @__PURE__ */ Object.create(null), r = this.lastWatchEvent;
      for (let [n, i] of this.files)
        dc(i), r = Math.max(r, i.safeTime), t[n] = Math.max(i.safeTime, i.timestamp);
      if (this.nestedWatching) {
        for (let n of this.directories.values()) {
          let i = n.directoryWatcher.getTimes();
          for (let o of Object.keys(i)) {
            let a = i[o];
            r = Math.max(r, a), t[o] = a;
          }
        }
        t[this.path] = r;
      }
      if (!this.initialScan)
        for (let n of this.watchers.values())
          for (let i of n) {
            let o = i.path;
            Object.prototype.hasOwnProperty.call(t, o) || (t[o] = null);
          }
      return t;
    }
    collectTimeInfoEntries(t, r) {
      let n = this.lastWatchEvent;
      for (let [i, o] of this.files)
        dc(o), n = Math.max(n, o.safeTime), t.set(i, o);
      if (this.nestedWatching) {
        for (let i of this.directories.values())
          n = Math.max(
            n,
            i.directoryWatcher.collectTimeInfoEntries(
              t,
              r
            )
          );
        t.set(this.path, no), r.set(this.path, {
          safeTime: n
        });
      } else {
        for (let i of this.directories.keys())
          t.set(i, no), r.has(i) || r.set(i, no);
        t.set(this.path, no), r.set(this.path, no);
      }
      if (!this.initialScan)
        for (let i of this.watchers.values())
          for (let o of i) {
            let a = o.path;
            t.has(a) || t.set(a, null);
          }
      return n;
    }
    close() {
      if (this.closed = !0, this.initialScan = !1, this.watcher && (this.watcher.close(), this.watcher = null), this.nestedWatching) {
        for (let t of this.directories.values())
          t.close();
        this.directories.clear();
      }
      this.parentWatcher && (this.parentWatcher.close(), this.parentWatcher = null), this.emit("closed");
    }
  };
  kg.exports = _g;
  kg.exports.EXISTANCE_ONLY_TIME_ENTRY = no;
  function dc(e) {
    e.accuracy > Lt && (e.safeTime = e.safeTime - e.accuracy + Lt, e.accuracy = Lt);
  }
  s(dc, "fixupEntryAccuracy");
  function VA(e) {
    e && (Lt > 1 && e % 1 !== 0 ? Lt = 1 : Lt > 10 && e % 10 !== 0 ? Lt = 10 : Lt > 100 && e % 100 !== 0 ? Lt = 100 : Lt > 1e3 && e % 1e3 !==
    0 && (Lt = 1e3));
  }
  s(VA, "ensureFsAccuracy");
});

// ../node_modules/watchpack/lib/getWatcherManager.js
var HA = I((Zpe, Tg) => {
  "use strict";
  var $H = require("path"), VH = WA(), mc = class {
    static {
      s(this, "WatcherManager");
    }
    constructor(t) {
      this.options = t, this.directoryWatchers = /* @__PURE__ */ new Map();
    }
    getDirectoryWatcher(t) {
      let r = this.directoryWatchers.get(t);
      if (r === void 0) {
        let n = new VH(this, t, this.options);
        return this.directoryWatchers.set(t, n), n.on("closed", () => {
          this.directoryWatchers.delete(t);
        }), n;
      }
      return r;
    }
    watchFile(t, r) {
      let n = $H.dirname(t);
      return n === t ? null : this.getDirectoryWatcher(n).watch(t, r);
    }
    watchDirectory(t, r) {
      return this.getDirectoryWatcher(t).watch(t, r);
    }
  }, zA = /* @__PURE__ */ new WeakMap();
  Tg.exports = (e) => {
    let t = zA.get(e);
    if (t !== void 0) return t;
    let r = new mc(e);
    return zA.set(e, r), r;
  };
  Tg.exports.WatcherManager = mc;
});

// ../node_modules/watchpack/lib/LinkResolver.js
var ZA = I((Kpe, JA) => {
  "use strict";
  var UH = require("fs"), gc = require("path"), GA = /* @__PURE__ */ new Set(["EINVAL", "ENOENT"]);
  process.platform === "win32" && GA.add("UNKNOWN");
  var Ig = class {
    static {
      s(this, "LinkResolver");
    }
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    /**
     * @param {string} file path to file or directory
     * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)
     */
    resolve(t) {
      let r = this.cache.get(t);
      if (r !== void 0)
        return r;
      let n = gc.dirname(t);
      if (n === t) {
        let a = Object.freeze([t]);
        return this.cache.set(t, a), a;
      }
      let i = this.resolve(n), o = t;
      if (i[0] !== n) {
        let a = gc.basename(t);
        o = gc.resolve(i[0], a);
      }
      try {
        let a = UH.readlinkSync(o), u = gc.resolve(i[0], a), l = this.resolve(u), c;
        if (l.length > 1 && i.length > 1) {
          let p = new Set(l);
          p.add(o);
          for (let h = 1; h < i.length; h++)
            p.add(i[h]);
          c = Object.freeze(Array.from(p));
        } else i.length > 1 ? (c = i.slice(), c[0] = l[0], c.push(o), Object.freeze(c)) : l.length > 1 ? (c = l.slice(), c.push(o), Object.freeze(
        c)) : c = Object.freeze([
          // the resolve real location
          l[0],
          // add the link
          o
        ]);
        return this.cache.set(t, c), c;
      } catch (a) {
        if (!GA.has(a.code))
          throw a;
        let u = i.slice();
        return u[0] = o, Object.freeze(u), this.cache.set(t, u), u;
      }
    }
  };
  JA.exports = Ig;
});

// ../node_modules/glob-to-regexp/index.js
var KA = I((Qpe, XA) => {
  XA.exports = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    for (var r = String(e), n = "", i = t ? !!t.extended : !1, o = t ? !!t.globstar : !1, a = !1, u = t && typeof t.flags == "string" ? t.flags :
    "", l, c = 0, p = r.length; c < p; c++)
      switch (l = r[c], l) {
        case "/":
        case "$":
        case "^":
        case "+":
        case ".":
        case "(":
        case ")":
        case "=":
        case "!":
        case "|":
          n += "\\" + l;
          break;
        case "?":
          if (i) {
            n += ".";
            break;
          }
        case "[":
        case "]":
          if (i) {
            n += l;
            break;
          }
        case "{":
          if (i) {
            a = !0, n += "(";
            break;
          }
        case "}":
          if (i) {
            a = !1, n += ")";
            break;
          }
        case ",":
          if (a) {
            n += "|";
            break;
          }
          n += "\\" + l;
          break;
        case "*":
          for (var h = r[c - 1], f = 1; r[c + 1] === "*"; )
            f++, c++;
          var d = r[c + 1];
          if (!o)
            n += ".*";
          else {
            var m = f > 1 && (h === "/" || h === void 0) && (d === "/" || d === void 0);
            m ? (n += "((?:[^/]*(?:/|$))*)", c++) : n += "([^/]*)";
          }
          break;
        default:
          n += l;
      }
    return (!u || !~u.indexOf("g")) && (n = "^" + n + "$"), new RegExp(n, u);
  };
});

// ../node_modules/watchpack/lib/watchpack.js
var Rg = I((ehe, eF) => {
  "use strict";
  var WH = HA(), zH = ZA(), HH = require("events").EventEmitter, GH = KA(), JH = Ag(), yc = [], ZH = {};
  function Dc(e, t) {
    for (let r of e) {
      let n = r.watcher;
      t.has(n.directoryWatcher) || t.add(n.directoryWatcher);
    }
  }
  s(Dc, "addWatchersToSet");
  var YA = /* @__PURE__ */ s((e) => {
    if (e.length === 0)
      return;
    let t = GH(e, { globstar: !0, extended: !0 }).source;
    return t.slice(0, t.length - 1) + "(?:$|\\/)";
  }, "stringToRegexp"), XH = /* @__PURE__ */ s((e) => {
    if (Array.isArray(e)) {
      let t = e.map((n) => YA(n)).filter(Boolean);
      if (t.length === 0)
        return () => !1;
      let r = new RegExp(t.join("|"));
      return (n) => r.test(n.replace(/\\/g, "/"));
    } else if (typeof e == "string") {
      let t = YA(e);
      if (!t)
        return () => !1;
      let r = new RegExp(t);
      return (n) => r.test(n.replace(/\\/g, "/"));
    } else {
      if (e instanceof RegExp)
        return (t) => e.test(t.replace(/\\/g, "/"));
      if (e instanceof Function)
        return e;
      if (e)
        throw new Error(`Invalid option for 'ignored': ${e}`);
      return () => !1;
    }
  }, "ignoredToFunction"), KH = /* @__PURE__ */ s((e) => ({
    followSymlinks: !!e.followSymlinks,
    ignored: XH(e.ignored),
    poll: e.poll
  }), "normalizeOptions"), QA = /* @__PURE__ */ new WeakMap(), YH = /* @__PURE__ */ s((e) => {
    let t = QA.get(e);
    if (t !== void 0) return t;
    let r = KH(e);
    return QA.set(e, r), r;
  }, "cachedNormalizeOptions"), Pg = class {
    static {
      s(this, "WatchpackFileWatcher");
    }
    constructor(t, r, n) {
      this.files = Array.isArray(n) ? n : [n], this.watcher = r, r.on("initial-missing", (i) => {
        for (let o of this.files)
          t._missing.has(o) || t._onRemove(o, o, i);
      }), r.on("change", (i, o) => {
        for (let a of this.files)
          t._onChange(a, i, a, o);
      }), r.on("remove", (i) => {
        for (let o of this.files)
          t._onRemove(o, o, i);
      });
    }
    update(t) {
      Array.isArray(t) ? this.files = t : this.files.length !== 1 ? this.files = [t] : this.files[0] !== t && (this.files[0] = t);
    }
    close() {
      this.watcher.close();
    }
  }, Bg = class {
    static {
      s(this, "WatchpackDirectoryWatcher");
    }
    constructor(t, r, n) {
      this.directories = Array.isArray(n) ? n : [n], this.watcher = r, r.on("initial-missing", (i) => {
        for (let o of this.directories)
          t._onRemove(o, o, i);
      }), r.on("change", (i, o, a) => {
        for (let u of this.directories)
          t._onChange(u, o, i, a);
      }), r.on("remove", (i) => {
        for (let o of this.directories)
          t._onRemove(o, o, i);
      });
    }
    update(t) {
      Array.isArray(t) ? this.directories = t : this.directories.length !== 1 ? this.directories = [t] : this.directories[0] !== t && (this.
      directories[0] = t);
    }
    close() {
      this.watcher.close();
    }
  }, Og = class extends HH {
    static {
      s(this, "Watchpack");
    }
    constructor(t) {
      super(), t || (t = ZH), this.options = t, this.aggregateTimeout = typeof t.aggregateTimeout == "number" ? t.aggregateTimeout : 200, this.
      watcherOptions = YH(t), this.watcherManager = WH(this.watcherOptions), this.fileWatchers = /* @__PURE__ */ new Map(), this.directoryWatchers =
      /* @__PURE__ */ new Map(), this._missing = /* @__PURE__ */ new Set(), this.startTime = void 0, this.paused = !1, this.aggregatedChanges =
      /* @__PURE__ */ new Set(), this.aggregatedRemovals = /* @__PURE__ */ new Set(), this.aggregateTimer = void 0, this._onTimeout = this._onTimeout.
      bind(this);
    }
    watch(t, r, n) {
      let i, o, a, u;
      r ? (i = t, o = r, a = yc, u = n) : {
        files: i = yc,
        directories: o = yc,
        missing: a = yc,
        startTime: u
      } = t, this.paused = !1;
      let l = this.fileWatchers, c = this.directoryWatchers, p = this.watcherOptions.ignored, h = /* @__PURE__ */ s((b) => !p(b), "filter"),
      f = /* @__PURE__ */ s((b, y, E) => {
        let A = b.get(y);
        A === void 0 ? b.set(y, E) : Array.isArray(A) ? A.push(E) : b.set(y, [A, E]);
      }, "addToMap"), d = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set();
      if (this.watcherOptions.followSymlinks) {
        let b = new zH();
        for (let y of i)
          if (h(y))
            for (let E of b.resolve(y))
              (y === E || h(E)) && f(d, E, y);
        for (let y of a)
          if (h(y))
            for (let E of b.resolve(y))
              (y === E || h(E)) && (g.add(y), f(d, E, y));
        for (let y of o)
          if (h(y)) {
            let E = !0;
            for (let A of b.resolve(y))
              h(A) && f(
                E ? m : d,
                A,
                y
              ), E = !1;
          }
      } else {
        for (let b of i)
          h(b) && f(d, b, b);
        for (let b of a)
          h(b) && (g.add(b), f(d, b, b));
        for (let b of o)
          h(b) && f(m, b, b);
      }
      for (let [b, y] of l) {
        let E = d.get(b);
        E === void 0 ? (y.close(), l.delete(b)) : (y.update(E), d.delete(b));
      }
      for (let [b, y] of c) {
        let E = m.get(b);
        E === void 0 ? (y.close(), c.delete(b)) : (y.update(E), m.delete(b));
      }
      JH.batch(() => {
        for (let [b, y] of d) {
          let E = this.watcherManager.watchFile(b, u);
          E && l.set(b, new Pg(this, E, y));
        }
        for (let [b, y] of m) {
          let E = this.watcherManager.watchDirectory(b, u);
          E && c.set(
            b,
            new Bg(this, E, y)
          );
        }
      }), this._missing = g, this.startTime = u;
    }
    close() {
      this.paused = !0, this.aggregateTimer && clearTimeout(this.aggregateTimer);
      for (let t of this.fileWatchers.values()) t.close();
      for (let t of this.directoryWatchers.values()) t.close();
      this.fileWatchers.clear(), this.directoryWatchers.clear();
    }
    pause() {
      this.paused = !0, this.aggregateTimer && clearTimeout(this.aggregateTimer);
    }
    getTimes() {
      let t = /* @__PURE__ */ new Set();
      Dc(this.fileWatchers.values(), t), Dc(this.directoryWatchers.values(), t);
      let r = /* @__PURE__ */ Object.create(null);
      for (let n of t) {
        let i = n.getTimes();
        for (let o of Object.keys(i)) r[o] = i[o];
      }
      return r;
    }
    getTimeInfoEntries() {
      let t = /* @__PURE__ */ new Map();
      return this.collectTimeInfoEntries(t, t), t;
    }
    collectTimeInfoEntries(t, r) {
      let n = /* @__PURE__ */ new Set();
      Dc(this.fileWatchers.values(), n), Dc(this.directoryWatchers.values(), n);
      let i = { value: 0 };
      for (let o of n)
        o.collectTimeInfoEntries(t, r, i);
    }
    getAggregated() {
      this.aggregateTimer && (clearTimeout(this.aggregateTimer), this.aggregateTimer = void 0);
      let t = this.aggregatedChanges, r = this.aggregatedRemovals;
      return this.aggregatedChanges = /* @__PURE__ */ new Set(), this.aggregatedRemovals = /* @__PURE__ */ new Set(), { changes: t, removals: r };
    }
    _onChange(t, r, n, i) {
      n = n || t, this.paused || (this.emit("change", n, r, i), this.aggregateTimer && clearTimeout(this.aggregateTimer), this.aggregateTimer =
      setTimeout(this._onTimeout, this.aggregateTimeout)), this.aggregatedRemovals.delete(t), this.aggregatedChanges.add(t);
    }
    _onRemove(t, r, n) {
      r = r || t, this.paused || (this.emit("remove", r, n), this.aggregateTimer && clearTimeout(this.aggregateTimer), this.aggregateTimer =
      setTimeout(this._onTimeout, this.aggregateTimeout)), this.aggregatedChanges.delete(t), this.aggregatedRemovals.add(t);
    }
    _onTimeout() {
      this.aggregateTimer = void 0;
      let t = this.aggregatedChanges, r = this.aggregatedRemovals;
      this.aggregatedChanges = /* @__PURE__ */ new Set(), this.aggregatedRemovals = /* @__PURE__ */ new Set(), this.emit("aggregated", t, r);
    }
  };
  eF.exports = Og;
});

// ../node_modules/kleur/index.js
var ot = I((She, yF) => {
  "use strict";
  var { FORCE_COLOR: iG, NODE_DISABLE_COLORS: sG, TERM: oG } = process.env, je = {
    enabled: !sG && oG !== "dumb" && iG !== "0",
    // modifiers
    reset: He(0, 0),
    bold: He(1, 22),
    dim: He(2, 22),
    italic: He(3, 23),
    underline: He(4, 24),
    inverse: He(7, 27),
    hidden: He(8, 28),
    strikethrough: He(9, 29),
    // colors
    black: He(30, 39),
    red: He(31, 39),
    green: He(32, 39),
    yellow: He(33, 39),
    blue: He(34, 39),
    magenta: He(35, 39),
    cyan: He(36, 39),
    white: He(37, 39),
    gray: He(90, 39),
    grey: He(90, 39),
    // background colors
    bgBlack: He(40, 49),
    bgRed: He(41, 49),
    bgGreen: He(42, 49),
    bgYellow: He(43, 49),
    bgBlue: He(44, 49),
    bgMagenta: He(45, 49),
    bgCyan: He(46, 49),
    bgWhite: He(47, 49)
  };
  function gF(e, t) {
    let r = 0, n, i = "", o = "";
    for (; r < e.length; r++)
      n = e[r], i += n.open, o += n.close, t.includes(n.close) && (t = t.replace(n.rgx, n.close + n.open));
    return i + t + o;
  }
  s(gF, "run");
  function aG(e, t) {
    let r = { has: e, keys: t };
    return r.reset = je.reset.bind(r), r.bold = je.bold.bind(r), r.dim = je.dim.bind(r), r.italic = je.italic.bind(r), r.underline = je.underline.
    bind(r), r.inverse = je.inverse.bind(r), r.hidden = je.hidden.bind(r), r.strikethrough = je.strikethrough.bind(r), r.black = je.black.bind(
    r), r.red = je.red.bind(r), r.green = je.green.bind(r), r.yellow = je.yellow.bind(r), r.blue = je.blue.bind(r), r.magenta = je.magenta.bind(
    r), r.cyan = je.cyan.bind(r), r.white = je.white.bind(r), r.gray = je.gray.bind(r), r.grey = je.grey.bind(r), r.bgBlack = je.bgBlack.bind(
    r), r.bgRed = je.bgRed.bind(r), r.bgGreen = je.bgGreen.bind(r), r.bgYellow = je.bgYellow.bind(r), r.bgBlue = je.bgBlue.bind(r), r.bgMagenta =
    je.bgMagenta.bind(r), r.bgCyan = je.bgCyan.bind(r), r.bgWhite = je.bgWhite.bind(r), r;
  }
  s(aG, "chain");
  function He(e, t) {
    let r = {
      open: `\x1B[${e}m`,
      close: `\x1B[${t}m`,
      rgx: new RegExp(`\\x1b\\[${t}m`, "g")
    };
    return function(n) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(e) || (this.has.push(e), this.keys.push(r)), n === void 0 ? this : je.
      enabled ? gF(this.keys, n + "") : n + "") : n === void 0 ? aG([e], [r]) : je.enabled ? gF([r], n + "") : n + "";
    };
  }
  s(He, "init");
  yF.exports = je;
});

// ../node_modules/prompts/dist/util/action.js
var xF = I((Fhe, DF) => {
  "use strict";
  DF.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var vc = I((_he, bF) => {
  "use strict";
  bF.exports = (e) => {
    let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/sisteransi/src/index.js
var ut = I((khe, vF) => {
  "use strict";
  var Lg = "\x1B", at = `${Lg}[`, uG = "\x07", jg = {
    to(e, t) {
      return t ? `${at}${t + 1};${e + 1}H` : `${at}${e + 1}G`;
    },
    move(e, t) {
      let r = "";
      return e < 0 ? r += `${at}${-e}D` : e > 0 && (r += `${at}${e}C`), t < 0 ? r += `${at}${-t}A` : t > 0 && (r += `${at}${t}B`), r;
    },
    up: /* @__PURE__ */ s((e = 1) => `${at}${e}A`, "up"),
    down: /* @__PURE__ */ s((e = 1) => `${at}${e}B`, "down"),
    forward: /* @__PURE__ */ s((e = 1) => `${at}${e}C`, "forward"),
    backward: /* @__PURE__ */ s((e = 1) => `${at}${e}D`, "backward"),
    nextLine: /* @__PURE__ */ s((e = 1) => `${at}E`.repeat(e), "nextLine"),
    prevLine: /* @__PURE__ */ s((e = 1) => `${at}F`.repeat(e), "prevLine"),
    left: `${at}G`,
    hide: `${at}?25l`,
    show: `${at}?25h`,
    save: `${Lg}7`,
    restore: `${Lg}8`
  }, lG = {
    up: /* @__PURE__ */ s((e = 1) => `${at}S`.repeat(e), "up"),
    down: /* @__PURE__ */ s((e = 1) => `${at}T`.repeat(e), "down")
  }, cG = {
    screen: `${at}2J`,
    up: /* @__PURE__ */ s((e = 1) => `${at}1J`.repeat(e), "up"),
    down: /* @__PURE__ */ s((e = 1) => `${at}J`.repeat(e), "down"),
    line: `${at}2K`,
    lineEnd: `${at}K`,
    lineStart: `${at}1K`,
    lines(e) {
      let t = "";
      for (let r = 0; r < e; r++)
        t += this.line + (r < e - 1 ? jg.up() : "");
      return e && (t += jg.left), t;
    }
  };
  vF.exports = { cursor: jg, scroll: lG, erase: cG, beep: uG };
});

// ../node_modules/prompts/dist/util/clear.js
var AF = I((Ihe, SF) => {
  "use strict";
  function pG(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = hG(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ s(function() {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ s(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, a = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var c = r.next();
      return o = c.done, c;
    }, "n"), e: /* @__PURE__ */ s(function(c) {
      a = !0, u = c;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a) throw u;
      }
    }, "f") };
  }
  s(pG, "_createForOfIteratorHelper");
  function hG(e, t) {
    if (e) {
      if (typeof e == "string") return EF(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return EF(e, t);
    }
  }
  s(hG, "_unsupportedIterableToArray");
  function EF(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  s(EF, "_arrayLikeToArray");
  var fG = vc(), wF = ut(), CF = wF.erase, dG = wF.cursor, mG = /* @__PURE__ */ s((e) => [...fG(e)].length, "width");
  SF.exports = function(e, t) {
    if (!t) return CF.line + dG.to(0);
    let r = 0, n = e.split(/\r?\n/);
    var i = pG(n), o;
    try {
      for (i.s(); !(o = i.n()).done; ) {
        let a = o.value;
        r += 1 + Math.floor(Math.max(mG(a) - 1, 0) / t);
      }
    } catch (a) {
      i.e(a);
    } finally {
      i.f();
    }
    return CF.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var Mg = I((Bhe, FF) => {
  "use strict";
  var Ba = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, gG = {
    arrowUp: Ba.arrowUp,
    arrowDown: Ba.arrowDown,
    arrowLeft: Ba.arrowLeft,
    arrowRight: Ba.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, yG = process.platform === "win32" ? gG : Ba;
  FF.exports = yG;
});

// ../node_modules/prompts/dist/util/style.js
var kF = I((Ohe, _F) => {
  "use strict";
  var so = ot(), Ui = Mg(), qg = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ s((e) => "*".repeat(e.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ s((e) => "\u{1F603}".repeat(e.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ s((e) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ s((e) => `${e}`, "render")
    }
  }), DG = /* @__PURE__ */ s((e) => qg[e] || qg.default, "render"), Oa = Object.freeze({
    aborted: so.red(Ui.cross),
    done: so.green(Ui.tick),
    exited: so.yellow(Ui.cross),
    default: so.cyan("?")
  }), xG = /* @__PURE__ */ s((e, t, r) => t ? Oa.aborted : r ? Oa.exited : e ? Oa.done : Oa.default, "symbol"), bG = /* @__PURE__ */ s((e) => so.
  gray(e ? Ui.ellipsis : Ui.pointerSmall), "delimiter"), vG = /* @__PURE__ */ s((e, t) => so.gray(e ? t ? Ui.pointerSmall : "+" : Ui.line), "\
item");
  _F.exports = {
    styles: qg,
    render: DG,
    symbols: Oa,
    symbol: xG,
    delimiter: bG,
    item: vG
  };
});

// ../node_modules/prompts/dist/util/lines.js
var IF = I((Nhe, TF) => {
  "use strict";
  var EG = vc();
  TF.exports = function(e, t) {
    let r = String(EG(e) || "").split(/\r?\n/);
    return t ? r.map((n) => Math.ceil(n.length / t)).reduce((n, i) => n + i) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var BF = I((Lhe, PF) => {
  "use strict";
  PF.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", n = t.width;
    return (e || "").split(/\r?\n/g).map((i) => i.split(/\s+/g).reduce((o, a) => (a.length + r.length >= n || o[o.length - 1].length + a.length +
    1 < n ? o[o.length - 1] += ` ${a}` : o.push(`${r}${a}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var RF = I((jhe, OF) => {
  "use strict";
  OF.exports = (e, t, r) => {
    r = r || t;
    let n = Math.min(t - r, e - Math.floor(r / 2));
    n < 0 && (n = 0);
    let i = Math.min(n + r, t);
    return {
      startIndex: n,
      endIndex: i
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var Ur = I((Mhe, NF) => {
  "use strict";
  NF.exports = {
    action: xF(),
    clear: AF(),
    style: kF(),
    strip: vc(),
    figures: Mg(),
    lines: IF(),
    wrap: BF(),
    entriesToDisplay: RF()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var Nn = I((qhe, MF) => {
  "use strict";
  var LF = require("readline"), CG = Ur(), wG = CG.action, SG = require("events"), jF = ut(), AG = jF.beep, FG = jF.cursor, _G = ot(), $g = class extends SG {
    static {
      s(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = LF.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      LF.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let n = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, i = /* @__PURE__ */ s((o, a) => {
        let u = wG(a, n);
        u === !1 ? this._ && this._(o, a) : typeof this[u] == "function" ? this[u](a) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(FG.show), this.in.removeListener("keypress", i), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", i);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(AG);
    }
    render() {
      this.onRender(_G), this.firstRender && (this.firstRender = !1);
    }
  };
  MF.exports = $g;
});

// ../node_modules/prompts/dist/elements/text.js
var WF = I((Vhe, UF) => {
  "use strict";
  function qF(e, t, r, n, i, o, a) {
    try {
      var u = e[o](a), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  s(qF, "asyncGeneratorStep");
  function $F(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var o = e.apply(t, r);
        function a(l) {
          qF(o, n, i, a, u, "next", l);
        }
        s(a, "_next");
        function u(l) {
          qF(o, n, i, a, u, "throw", l);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s($F, "_asyncToGenerator");
  var Ec = ot(), kG = Nn(), VF = ut(), TG = VF.erase, Ra = VF.cursor, Cc = Ur(), Vg = Cc.style, Ug = Cc.clear, IG = Cc.lines, PG = Cc.figures,
  Wg = class extends kG {
    static {
      s(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Vg.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = Ug("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = Ec.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return $F(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return $F(function* () {
        if (t.value = t.value || t.initial, t.cursorOffset = 0, t.cursor = t.rendered.length, yield t.validate(), t.error) {
          t.red = !0, t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let n = this.value.slice(0, this.cursor), i = this.value.slice(this.cursor);
      this.value = `${n}${t}${i}`, this.red = !1, this.cursor = this.placeholder ? 0 : n.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Ra.down(IG(this.outputError, this.out.columns) - 1) + Ug(this.
      outputError, this.out.columns)), this.out.write(Ug(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [Vg.symbol(this.done, this.aborted), Ec.bold(this.msg), Vg.delimiter(this.done), this.red ? Ec.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, n) => t + `
${n ? " " : PG.pointerSmall} ${Ec.red().italic(r)}`, "")), this.out.write(TG.line + Ra.to(0) + this.outputText + Ra.save + this.outputError +
      Ra.restore + Ra.move(this.cursorOffset, 0)));
    }
  };
  UF.exports = Wg;
});

// ../node_modules/prompts/dist/elements/select.js
var JF = I((Whe, GF) => {
  "use strict";
  var Ln = ot(), BG = Nn(), Na = Ur(), zF = Na.style, HF = Na.clear, wc = Na.figures, OG = Na.wrap, RG = Na.entriesToDisplay, NG = ut(), LG = NG.
  cursor, zg = class extends BG {
    static {
      s(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, n) => (typeof r == "string" && (r = {
        title: r,
        value: n
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? n : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = HF("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(LG.hide) : this.out.write(HF(this.outputText, this.out.columns)), super.render();
      let t = RG(this.cursor, this.choices.length, this.optionsPerPage), r = t.startIndex, n = t.endIndex;
      if (this.outputText = [zF.symbol(this.done, this.aborted), Ln.bold(this.msg), zF.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? Ln.yellow(this.warn) : Ln.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let i = r; i < n; i++) {
          let o, a, u = "", l = this.choices[i];
          i === r && r > 0 ? a = wc.arrowUp : i === n - 1 && n < this.choices.length ? a = wc.arrowDown : a = " ", l.disabled ? (o = this.cursor ===
          i ? Ln.gray().underline(l.title) : Ln.strikethrough().gray(l.title), a = (this.cursor === i ? Ln.bold().gray(wc.pointer) + " " : "\
  ") + a) : (o = this.cursor === i ? Ln.cyan().underline(l.title) : l.title, a = (this.cursor === i ? Ln.cyan(wc.pointer) + " " : "  ") + a,
          l.description && this.cursor === i && (u = ` - ${l.description}`, (a.length + o.length + u.length >= this.out.columns || l.description.
          split(/\r?\n/).length > 1) && (u = `
` + OG(l.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${a} ${o}${Ln.gray(u)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  GF.exports = zg;
});

// ../node_modules/prompts/dist/elements/toggle.js
var e_ = I((Hhe, QF) => {
  "use strict";
  var Sc = ot(), jG = Nn(), KF = Ur(), ZF = KF.style, MG = KF.clear, YF = ut(), XF = YF.cursor, qG = YF.erase, Hg = class extends jG {
    static {
      s(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(XF.hide) : this.out.write(MG(this.outputText, this.out.columns)), super.render(), this.
      outputText = [ZF.symbol(this.done, this.aborted), Sc.bold(this.msg), ZF.delimiter(this.done), this.value ? this.inactive : Sc.cyan().underline(
      this.inactive), Sc.gray("/"), this.value ? Sc.cyan().underline(this.active) : this.active].join(" "), this.out.write(qG.line + XF.to(0) +
      this.outputText));
    }
  };
  QF.exports = Hg;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var ln = I((Jhe, t_) => {
  "use strict";
  var Gg = class e {
    static {
      s(this, "DatePart");
    }
    constructor({
      token: t,
      date: r,
      parts: n,
      locales: i
    }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = n || [this], this.locales = i || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, n) => n > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((n, i) => i > r && n instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  t_.exports = Gg;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var n_ = I((Xhe, r_) => {
  "use strict";
  var $G = ln(), Jg = class extends $G {
    static {
      s(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  r_.exports = Jg;
});

// ../node_modules/prompts/dist/dateparts/day.js
var s_ = I((Yhe, i_) => {
  "use strict";
  var VG = ln(), UG = /* @__PURE__ */ s((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), Zg = class extends VG {
    static {
      s(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + UG(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  i_.exports = Zg;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var a_ = I((efe, o_) => {
  "use strict";
  var WG = ln(), Xg = class extends WG {
    static {
      s(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  o_.exports = Xg;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var l_ = I((rfe, u_) => {
  "use strict";
  var zG = ln(), Kg = class extends zG {
    static {
      s(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  u_.exports = Kg;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var p_ = I((ife, c_) => {
  "use strict";
  var HG = ln(), Yg = class extends HG {
    static {
      s(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  c_.exports = Yg;
});

// ../node_modules/prompts/dist/dateparts/month.js
var f_ = I((ofe, h_) => {
  "use strict";
  var GG = ln(), Qg = class extends GG {
    static {
      s(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  h_.exports = Qg;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var m_ = I((ufe, d_) => {
  "use strict";
  var JG = ln(), e0 = class extends JG {
    static {
      s(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  d_.exports = e0;
});

// ../node_modules/prompts/dist/dateparts/year.js
var y_ = I((cfe, g_) => {
  "use strict";
  var ZG = ln(), t0 = class extends ZG {
    static {
      s(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  g_.exports = t0;
});

// ../node_modules/prompts/dist/dateparts/index.js
var x_ = I((hfe, D_) => {
  "use strict";
  D_.exports = {
    DatePart: ln(),
    Meridiem: n_(),
    Day: s_(),
    Hours: a_(),
    Milliseconds: l_(),
    Minutes: p_(),
    Month: f_(),
    Seconds: m_(),
    Year: y_()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var k_ = I((ffe, __) => {
  "use strict";
  function b_(e, t, r, n, i, o, a) {
    try {
      var u = e[o](a), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  s(b_, "asyncGeneratorStep");
  function v_(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var o = e.apply(t, r);
        function a(l) {
          b_(o, n, i, a, u, "next", l);
        }
        s(a, "_next");
        function u(l) {
          b_(o, n, i, a, u, "throw", l);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(v_, "_asyncToGenerator");
  var r0 = ot(), XG = Nn(), i0 = Ur(), E_ = i0.style, C_ = i0.clear, KG = i0.figures, F_ = ut(), YG = F_.erase, w_ = F_.cursor, jn = x_(), S_ = jn.
  DatePart, QG = jn.Meridiem, eJ = jn.Day, tJ = jn.Hours, rJ = jn.Milliseconds, nJ = jn.Minutes, iJ = jn.Month, sJ = jn.Seconds, oJ = jn.Year,
  aJ = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, A_ = {
    1: ({
      token: e
    }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new eJ(e),
    // Day // TODO
    3: (e) => new iJ(e),
    // Month
    4: (e) => new oJ(e),
    // Year
    5: (e) => new QG(e),
    // AM/PM // TODO (special)
    6: (e) => new tJ(e),
    // Hours
    7: (e) => new nJ(e),
    // Minutes
    8: (e) => new sJ(e),
    // Seconds
    9: (e) => new rJ(e)
    // Fractional seconds
  }, uJ = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, n0 = class extends XG {
    static {
      s(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(uJ, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = C_("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = aJ.exec(t); ) {
        let i = r.shift(), o = r.findIndex((a) => a != null);
        this.parts.push(o in A_ ? A_[o]({
          token: r[o] || i,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[o] || i);
      }
      let n = this.parts.reduce((i, o) => (typeof o == "string" && typeof i[i.length - 1] == "string" ? i[i.length - 1] += o : i.push(o), i),
      []);
      this.parts.splice(0), this.parts.push(...n), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof S_)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return v_(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return v_(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof S_)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(w_.hide) : this.out.write(C_(this.outputText, this.out.columns)), super.render(), this.
      outputText = [E_.symbol(this.done, this.aborted), r0.bold(this.msg), E_.delimiter(!1), this.parts.reduce((t, r, n) => t.concat(n === this.
      cursor && !this.done ? r0.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((t, r, n) => t + `
${n ? " " : KG.pointerSmall} ${r0.red().italic(r)}`, "")), this.out.write(YG.line + w_.to(0) + this.outputText));
    }
  };
  __.exports = n0;
});

// ../node_modules/prompts/dist/elements/number.js
var N_ = I((mfe, R_) => {
  "use strict";
  function T_(e, t, r, n, i, o, a) {
    try {
      var u = e[o](a), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  s(T_, "asyncGeneratorStep");
  function I_(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var o = e.apply(t, r);
        function a(l) {
          T_(o, n, i, a, u, "next", l);
        }
        s(a, "_next");
        function u(l) {
          T_(o, n, i, a, u, "throw", l);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(I_, "_asyncToGenerator");
  var Ac = ot(), lJ = Nn(), O_ = ut(), Fc = O_.cursor, cJ = O_.erase, _c = Ur(), s0 = _c.style, pJ = _c.figures, P_ = _c.clear, hJ = _c.lines,
  fJ = /[0-9]/, o0 = /* @__PURE__ */ s((e) => e !== void 0, "isDef"), B_ = /* @__PURE__ */ s((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), a0 = class extends lJ {
    static {
      s(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = s0.render(t.style), this.msg = t.message, this.initial = o0(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = o0(t.min) ? t.min : -1 / 0, this.max = o0(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Ac.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${B_(t, this.round)}`), this._value = B_(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || fJ.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var t = this;
      return I_(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return I_(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        let r = t.value;
        t.value = r !== "" ? r : t.initial, t.done = !0, t.aborted = !1, t.error = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let n = Date.now();
      if (n - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = n, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Fc.down(hJ(this.outputError, this.out.columns) - 1) + P_(this.
      outputError, this.out.columns)), this.out.write(P_(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [s0.symbol(this.done, this.aborted), Ac.bold(this.msg), s0.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Ac[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, n) => t + `
${n ? " " : pJ.pointerSmall} ${Ac.red().italic(r)}`, "")), this.out.write(cJ.line + Fc.to(0) + this.outputText + Fc.save + this.outputError +
      Fc.restore));
    }
  };
  R_.exports = a0;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var l0 = I((yfe, M_) => {
  "use strict";
  var cn = ot(), dJ = ut(), mJ = dJ.cursor, gJ = Nn(), La = Ur(), L_ = La.clear, ci = La.figures, j_ = La.style, yJ = La.wrap, DJ = La.entriesToDisplay,
  u0 = class extends gJ {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, n) => (typeof r == "string" && (r = {
        title: r,
        value: n
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? n : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = L_("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${ci.arrowUp}/${ci.arrowDown}: Highlight option
    ${ci.arrowLeft}/${ci.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, n, i) {
      let o = (r.selected ? cn.green(ci.radioOn) : ci.radioOff) + " " + i + " ", a, u;
      return r.disabled ? a = t === n ? cn.gray().underline(r.title) : cn.strikethrough().gray(r.title) : (a = t === n ? cn.cyan().underline(
      r.title) : r.title, t === n && r.description && (u = ` - ${r.description}`, (o.length + a.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + yJ(r.description, {
        margin: o.length,
        width: this.out.columns
      })))), o + a + cn.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return cn.red("No matches for this query.");
      let r = DJ(this.cursor, t.length, this.optionsPerPage), n = r.startIndex, i = r.endIndex, o, a = [];
      for (let u = n; u < i; u++)
        u === n && n > 0 ? o = ci.arrowUp : u === i - 1 && i < t.length ? o = ci.arrowDown : o = " ", a.push(this.renderOption(this.cursor, t[u],
        u, o));
      return `
` + a.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [cn.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(cn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(mJ.hide), super.render();
      let t = [j_.symbol(this.done, this.aborted), cn.bold(this.msg), j_.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += cn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = L_(t, this.out.columns);
    }
  };
  M_.exports = u0;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var H_ = I((xfe, z_) => {
  "use strict";
  function q_(e, t, r, n, i, o, a) {
    try {
      var u = e[o](a), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  s(q_, "asyncGeneratorStep");
  function xJ(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var o = e.apply(t, r);
        function a(l) {
          q_(o, n, i, a, u, "next", l);
        }
        s(a, "_next");
        function u(l) {
          q_(o, n, i, a, u, "throw", l);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(xJ, "_asyncToGenerator");
  var ja = ot(), bJ = Nn(), W_ = ut(), vJ = W_.erase, $_ = W_.cursor, Ma = Ur(), c0 = Ma.style, V_ = Ma.clear, p0 = Ma.figures, EJ = Ma.wrap,
  CJ = Ma.entriesToDisplay, U_ = /* @__PURE__ */ s((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), wJ = /* @__PURE__ */ s((e, t) => e[t] &&
  (e[t].title || e[t].value || e[t]), "getTitle"), SJ = /* @__PURE__ */ s((e, t) => {
    let r = e.findIndex((n) => n.value === t || n.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), h0 = class extends bJ {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      SJ(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = {
        noMatches: t.noMatches || "no matches found"
      }, this.fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      t.limit || 10, this.cursor = 0, this.transform = c0.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = V_("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = {
        title: this._fb
      }), t || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = U_(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    complete(t) {
      var r = this;
      return xJ(function* () {
        let n = r.completing = r.suggest(r.input, r.choices), i = yield n;
        if (r.completing !== n) return;
        r.suggestions = i.map((a, u, l) => ({
          title: wJ(l, u),
          value: U_(l, u),
          description: a.description
        })), r.completing = !1;
        let o = Math.max(i.length - 1, 0);
        r.moveSelect(Math.min(o, r.select)), t && t();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let n = this.input.slice(0, this.cursor), i = this.input.slice(this.cursor);
      this.input = `${n}${t}${i}`, this.cursor = n.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, n, i) {
      let o, a = n ? p0.arrowUp : i ? p0.arrowDown : " ", u = r ? ja.cyan().underline(t.title) : t.title;
      return a = (r ? ja.cyan(p0.pointer) + " " : "  ") + a, t.description && (o = ` - ${t.description}`, (a.length + u.length + o.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (o = `
` + EJ(t.description, {
        margin: 3,
        width: this.out.columns
      }))), a + " " + u + ja.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write($_.hide) : this.out.write(V_(this.outputText, this.out.columns)), super.render();
      let t = CJ(this.select, this.choices.length, this.limit), r = t.startIndex, n = t.endIndex;
      if (this.outputText = [c0.symbol(this.done, this.aborted, this.exited), ja.bold(this.msg), c0.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let i = this.suggestions.slice(r, n).map((o, a) => this.renderOption(o, this.select === a + r, a === 0 && r > 0, a + r === n - 1 && n <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (i || ja.gray(this.fallback.title));
      }
      this.out.write(vJ.line + $_.to(0) + this.outputText);
    }
  };
  z_.exports = h0;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var X_ = I((vfe, Z_) => {
  "use strict";
  var Mn = ot(), AJ = ut(), FJ = AJ.cursor, _J = l0(), d0 = Ur(), G_ = d0.clear, J_ = d0.style, oo = d0.figures, f0 = class extends _J {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = G_("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((n) => this.inputValue ? !!(typeof n.title == "string" && n.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof n.value == "string" && n.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((n) => n === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${oo.arrowUp}/${oo.arrowDown}: Highlight option
    ${oo.arrowLeft}/${oo.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : Mn.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, n) {
      let i;
      return r.disabled ? i = t === n ? Mn.gray().underline(r.title) : Mn.strikethrough().gray(r.title) : i = t === n ? Mn.cyan().underline(
      r.title) : r.title, (r.selected ? Mn.green(oo.radioOn) : oo.radioOff) + "  " + i;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [Mn.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(Mn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(FJ.hide), super.render();
      let t = [J_.symbol(this.done, this.aborted), Mn.bold(this.msg), J_.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += Mn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = G_(t, this.out.columns);
    }
  };
  Z_.exports = f0;
});

// ../node_modules/prompts/dist/elements/confirm.js
var n3 = I((Cfe, r3) => {
  "use strict";
  var K_ = ot(), kJ = Nn(), e3 = Ur(), Y_ = e3.style, TJ = e3.clear, t3 = ut(), IJ = t3.erase, Q_ = t3.cursor, m0 = class extends kJ {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Q_.hide) : this.out.write(TJ(this.outputText, this.out.columns)), super.render(), this.
      outputText = [Y_.symbol(this.done, this.aborted), K_.bold(this.msg), Y_.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : K_.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write(IJ.line + Q_.to(0) + this.outputText));
    }
  };
  r3.exports = m0;
});

// ../node_modules/prompts/dist/elements/index.js
var s3 = I((Sfe, i3) => {
  "use strict";
  i3.exports = {
    TextPrompt: WF(),
    SelectPrompt: JF(),
    TogglePrompt: e_(),
    DatePrompt: k_(),
    NumberPrompt: N_(),
    MultiselectPrompt: l0(),
    AutocompletePrompt: H_(),
    AutocompleteMultiselectPrompt: X_(),
    ConfirmPrompt: n3()
  };
});

// ../node_modules/prompts/dist/prompts.js
var a3 = I((o3) => {
  "use strict";
  var zt = o3, PJ = s3(), kc = /* @__PURE__ */ s((e) => e, "noop");
  function pn(e, t, r = {}) {
    return new Promise((n, i) => {
      let o = new PJ[e](t), a = r.onAbort || kc, u = r.onSubmit || kc, l = r.onExit || kc;
      o.on("state", t.onState || kc), o.on("submit", (c) => n(u(c))), o.on("exit", (c) => n(l(c))), o.on("abort", (c) => i(a(c)));
    });
  }
  s(pn, "toPrompt");
  zt.text = (e) => pn("TextPrompt", e);
  zt.password = (e) => (e.style = "password", zt.text(e));
  zt.invisible = (e) => (e.style = "invisible", zt.text(e));
  zt.number = (e) => pn("NumberPrompt", e);
  zt.date = (e) => pn("DatePrompt", e);
  zt.confirm = (e) => pn("ConfirmPrompt", e);
  zt.list = (e) => {
    let t = e.separator || ",";
    return pn("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(t).map((n) => n.trim()), "onSubmit")
    });
  };
  zt.toggle = (e) => pn("TogglePrompt", e);
  zt.select = (e) => pn("SelectPrompt", e);
  zt.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((n) => n.selected).map((n) => n.value), "toSelected");
    return pn("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  zt.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((n) => n.selected).map((n) => n.value), "toSelected");
    return pn("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var BJ = /* @__PURE__ */ s((e, t) => Promise.resolve(t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())), "byTi\
tle");
  zt.autocomplete = (e) => (e.suggest = e.suggest || BJ, e.choices = [].concat(e.choices || []), pn("AutocompletePrompt", e));
});

// ../node_modules/prompts/dist/index.js
var m3 = I((_fe, d3) => {
  "use strict";
  function u3(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t && (n = n.filter(function(i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })), r.push.apply(r, n);
    }
    return r;
  }
  s(u3, "ownKeys");
  function l3(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? u3(Object(r), !0).forEach(function(n) {
        OJ(e, n, r[n]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : u3(Object(r)).forEach(function(n) {
        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
      });
    }
    return e;
  }
  s(l3, "_objectSpread");
  function OJ(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  s(OJ, "_defineProperty");
  function RJ(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = NJ(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var n = 0, i = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: i, n: /* @__PURE__ */ s(function() {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        }, "n"), e: /* @__PURE__ */ s(function(c) {
          throw c;
        }, "e"), f: i };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, a = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var c = r.next();
      return o = c.done, c;
    }, "n"), e: /* @__PURE__ */ s(function(c) {
      a = !0, u = c;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a) throw u;
      }
    }, "f") };
  }
  s(RJ, "_createForOfIteratorHelper");
  function NJ(e, t) {
    if (e) {
      if (typeof e == "string") return c3(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return c3(e, t);
    }
  }
  s(NJ, "_unsupportedIterableToArray");
  function c3(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  s(c3, "_arrayLikeToArray");
  function p3(e, t, r, n, i, o, a) {
    try {
      var u = e[o](a), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  s(p3, "asyncGeneratorStep");
  function h3(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(n, i) {
        var o = e.apply(t, r);
        function a(l) {
          p3(o, n, i, a, u, "next", l);
        }
        s(a, "_next");
        function u(l) {
          p3(o, n, i, a, u, "throw", l);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(h3, "_asyncToGenerator");
  var g0 = a3(), LJ = ["suggest", "format", "onState", "validate", "onRender", "type"], f3 = /* @__PURE__ */ s(() => {
  }, "noop");
  function pi() {
    return y0.apply(this, arguments);
  }
  s(pi, "prompt");
  function y0() {
    return y0 = h3(function* (e = [], {
      onSubmit: t = f3,
      onCancel: r = f3
    } = {}) {
      let n = {}, i = pi._override || {};
      e = [].concat(e);
      let o, a, u, l, c, p, h = /* @__PURE__ */ function() {
        var b = h3(function* (y, E, A = !1) {
          if (!(!A && y.validate && y.validate(E) !== !0))
            return y.format ? yield y.format(E, n) : E;
        });
        return /* @__PURE__ */ s(function(E, A) {
          return b.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var f = RJ(e), d;
      try {
        for (f.s(); !(d = f.n()).done; ) {
          a = d.value;
          var m = a;
          if (l = m.name, c = m.type, typeof c == "function" && (c = yield c(o, l3({}, n), a), a.type = c), !!c) {
            for (let b in a) {
              if (LJ.includes(b)) continue;
              let y = a[b];
              a[b] = typeof y == "function" ? yield y(o, l3({}, n), p) : y;
            }
            if (p = a, typeof a.message != "string")
              throw new Error("prompt message is required");
            var g = a;
            if (l = g.name, c = g.type, g0[c] === void 0)
              throw new Error(`prompt type (${c}) is not defined`);
            if (i[a.name] !== void 0 && (o = yield h(a, i[a.name]), o !== void 0)) {
              n[l] = o;
              continue;
            }
            try {
              o = pi._injected ? jJ(pi._injected, a.initial) : yield g0[c](a), n[l] = o = yield h(a, o, !0), u = yield t(a, o, n);
            } catch {
              u = !(yield r(a, n));
            }
            if (u) return n;
          }
        }
      } catch (b) {
        f.e(b);
      } finally {
        f.f();
      }
      return n;
    }), y0.apply(this, arguments);
  }
  s(y0, "_prompt");
  function jJ(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  s(jJ, "getInjectedAnswer");
  function MJ(e) {
    pi._injected = (pi._injected || []).concat(e);
  }
  s(MJ, "inject");
  function qJ(e) {
    pi._override = Object.assign({}, e);
  }
  s(qJ, "override");
  d3.exports = Object.assign(pi, {
    prompt: pi,
    prompts: g0,
    inject: MJ,
    override: qJ
  });
});

// ../node_modules/prompts/lib/util/action.js
var y3 = I((Tfe, g3) => {
  "use strict";
  g3.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Tc = I((Ife, D3) => {
  "use strict";
  D3.exports = (e) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var v3 = I((Pfe, b3) => {
  "use strict";
  var $J = Tc(), { erase: x3, cursor: VJ } = ut(), UJ = /* @__PURE__ */ s((e) => [...$J(e)].length, "width");
  b3.exports = function(e, t) {
    if (!t) return x3.line + VJ.to(0);
    let r = 0, n = e.split(/\r?\n/);
    for (let i of n)
      r += 1 + Math.floor(Math.max(UJ(i) - 1, 0) / t);
    return x3.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var D0 = I((Ofe, E3) => {
  "use strict";
  var qa = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, WJ = {
    arrowUp: qa.arrowUp,
    arrowDown: qa.arrowDown,
    arrowLeft: qa.arrowLeft,
    arrowRight: qa.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, zJ = process.platform === "win32" ? WJ : qa;
  E3.exports = zJ;
});

// ../node_modules/prompts/lib/util/style.js
var w3 = I((Rfe, C3) => {
  "use strict";
  var ao = ot(), Wi = D0(), x0 = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ s((e) => "*".repeat(e.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ s((e) => "\u{1F603}".repeat(e.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ s((e) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ s((e) => `${e}`, "render") }
  }), HJ = /* @__PURE__ */ s((e) => x0[e] || x0.default, "render"), $a = Object.freeze({
    aborted: ao.red(Wi.cross),
    done: ao.green(Wi.tick),
    exited: ao.yellow(Wi.cross),
    default: ao.cyan("?")
  }), GJ = /* @__PURE__ */ s((e, t, r) => t ? $a.aborted : r ? $a.exited : e ? $a.done : $a.default, "symbol"), JJ = /* @__PURE__ */ s((e) => ao.
  gray(e ? Wi.ellipsis : Wi.pointerSmall), "delimiter"), ZJ = /* @__PURE__ */ s((e, t) => ao.gray(e ? t ? Wi.pointerSmall : "+" : Wi.line), "\
item");
  C3.exports = {
    styles: x0,
    render: HJ,
    symbols: $a,
    symbol: GJ,
    delimiter: JJ,
    item: ZJ
  };
});

// ../node_modules/prompts/lib/util/lines.js
var A3 = I((Lfe, S3) => {
  "use strict";
  var XJ = Tc();
  S3.exports = function(e, t) {
    let r = String(XJ(e) || "").split(/\r?\n/);
    return t ? r.map((n) => Math.ceil(n.length / t)).reduce((n, i) => n + i) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var _3 = I((jfe, F3) => {
  "use strict";
  F3.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", n = t.width;
    return (e || "").split(/\r?\n/g).map((i) => i.split(/\s+/g).reduce((o, a) => (a.length + r.length >= n || o[o.length - 1].length + a.length +
    1 < n ? o[o.length - 1] += ` ${a}` : o.push(`${r}${a}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var T3 = I((Mfe, k3) => {
  "use strict";
  k3.exports = (e, t, r) => {
    r = r || t;
    let n = Math.min(t - r, e - Math.floor(r / 2));
    n < 0 && (n = 0);
    let i = Math.min(n + r, t);
    return { startIndex: n, endIndex: i };
  };
});

// ../node_modules/prompts/lib/util/index.js
var Wr = I((qfe, I3) => {
  "use strict";
  I3.exports = {
    action: y3(),
    clear: v3(),
    style: w3(),
    strip: Tc(),
    figures: D0(),
    lines: A3(),
    wrap: _3(),
    entriesToDisplay: T3()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var qn = I(($fe, B3) => {
  "use strict";
  var P3 = require("readline"), { action: KJ } = Wr(), YJ = require("events"), { beep: QJ, cursor: eZ } = ut(), tZ = ot(), b0 = class extends YJ {
    static {
      s(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = P3.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      P3.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let n = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, i = /* @__PURE__ */ s((o, a) => {
        let u = KJ(a, n);
        u === !1 ? this._ && this._(o, a) : typeof this[u] == "function" ? this[u](a) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(eZ.show), this.in.removeListener("keypress", i), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", i);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(QJ);
    }
    render() {
      this.onRender(tZ), this.firstRender && (this.firstRender = !1);
    }
  };
  B3.exports = b0;
});

// ../node_modules/prompts/lib/elements/text.js
var R3 = I((Ufe, O3) => {
  var Ic = ot(), rZ = qn(), { erase: nZ, cursor: Va } = ut(), { style: v0, clear: E0, lines: iZ, figures: sZ } = Wr(), C0 = class extends rZ {
    static {
      s(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = v0.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = E0("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = Ic.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let n = this.value.slice(0, this.cursor), i = this.value.slice(this.cursor);
      this.value = `${n}${t}${i}`, this.red = !1, this.cursor = this.placeholder ? 0 : n.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Va.down(iZ(this.outputError, this.out.columns) - 1) + E0(this.
      outputError, this.out.columns)), this.out.write(E0(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        v0.symbol(this.done, this.aborted),
        Ic.bold(this.msg),
        v0.delimiter(this.done),
        this.red ? Ic.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, n) => t + `
${n ? " " : sZ.pointerSmall} ${Ic.red().italic(r)}`, "")), this.out.write(nZ.line + Va.to(0) + this.outputText + Va.save + this.outputError +
      Va.restore + Va.move(this.cursorOffset, 0)));
    }
  };
  O3.exports = C0;
});

// ../node_modules/prompts/lib/elements/select.js
var M3 = I((zfe, j3) => {
  "use strict";
  var $n = ot(), oZ = qn(), { style: N3, clear: L3, figures: Pc, wrap: aZ, entriesToDisplay: uZ } = Wr(), { cursor: lZ } = ut(), w0 = class extends oZ {
    static {
      s(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, n) => (typeof r == "string" && (r = { title: r, value: n }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? n : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = L3("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(lZ.hide) : this.out.write(L3(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = uZ(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        N3.symbol(this.done, this.aborted),
        $n.bold(this.msg),
        N3.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? $n.yellow(this.warn) : $n.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let n = t; n < r; n++) {
          let i, o, a = "", u = this.choices[n];
          n === t && t > 0 ? o = Pc.arrowUp : n === r - 1 && r < this.choices.length ? o = Pc.arrowDown : o = " ", u.disabled ? (i = this.cursor ===
          n ? $n.gray().underline(u.title) : $n.strikethrough().gray(u.title), o = (this.cursor === n ? $n.bold().gray(Pc.pointer) + " " : "\
  ") + o) : (i = this.cursor === n ? $n.cyan().underline(u.title) : u.title, o = (this.cursor === n ? $n.cyan(Pc.pointer) + " " : "  ") + o,
          u.description && this.cursor === n && (a = ` - ${u.description}`, (o.length + i.length + a.length >= this.out.columns || u.description.
          split(/\r?\n/).length > 1) && (a = `
` + aZ(u.description, { margin: 3, width: this.out.columns })))), this.outputText += `${o} ${i}${$n.gray(a)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  j3.exports = w0;
});

// ../node_modules/prompts/lib/elements/toggle.js
var U3 = I((Gfe, V3) => {
  var Bc = ot(), cZ = qn(), { style: q3, clear: pZ } = Wr(), { cursor: $3, erase: hZ } = ut(), S0 = class extends cZ {
    static {
      s(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write($3.hide) : this.out.write(pZ(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        q3.symbol(this.done, this.aborted),
        Bc.bold(this.msg),
        q3.delimiter(this.done),
        this.value ? this.inactive : Bc.cyan().underline(this.inactive),
        Bc.gray("/"),
        this.value ? Bc.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(hZ.line + $3.to(0) + this.outputText));
    }
  };
  V3.exports = S0;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var hn = I((Zfe, W3) => {
  "use strict";
  var A0 = class e {
    static {
      s(this, "DatePart");
    }
    constructor({ token: t, date: r, parts: n, locales: i }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = n || [this], this.locales = i || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, n) => n > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((n, i) => i > r && n instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  W3.exports = A0;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var H3 = I((Kfe, z3) => {
  "use strict";
  var fZ = hn(), F0 = class extends fZ {
    static {
      s(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  z3.exports = F0;
});

// ../node_modules/prompts/lib/dateparts/day.js
var J3 = I((Qfe, G3) => {
  "use strict";
  var dZ = hn(), mZ = /* @__PURE__ */ s((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), _0 = class extends dZ {
    static {
      s(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + mZ(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  G3.exports = _0;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var X3 = I((tde, Z3) => {
  "use strict";
  var gZ = hn(), k0 = class extends gZ {
    static {
      s(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Z3.exports = k0;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var Y3 = I((nde, K3) => {
  "use strict";
  var yZ = hn(), T0 = class extends yZ {
    static {
      s(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  K3.exports = T0;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var ek = I((sde, Q3) => {
  "use strict";
  var DZ = hn(), I0 = class extends DZ {
    static {
      s(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Q3.exports = I0;
});

// ../node_modules/prompts/lib/dateparts/month.js
var rk = I((ade, tk) => {
  "use strict";
  var xZ = hn(), P0 = class extends xZ {
    static {
      s(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  tk.exports = P0;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var ik = I((lde, nk) => {
  "use strict";
  var bZ = hn(), B0 = class extends bZ {
    static {
      s(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  nk.exports = B0;
});

// ../node_modules/prompts/lib/dateparts/year.js
var ok = I((pde, sk) => {
  "use strict";
  var vZ = hn(), O0 = class extends vZ {
    static {
      s(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  sk.exports = O0;
});

// ../node_modules/prompts/lib/dateparts/index.js
var uk = I((fde, ak) => {
  "use strict";
  ak.exports = {
    DatePart: hn(),
    Meridiem: H3(),
    Day: J3(),
    Hours: X3(),
    Milliseconds: Y3(),
    Minutes: ek(),
    Month: rk(),
    Seconds: ik(),
    Year: ok()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var mk = I((dde, dk) => {
  "use strict";
  var R0 = ot(), EZ = qn(), { style: lk, clear: ck, figures: CZ } = Wr(), { erase: wZ, cursor: pk } = ut(), { DatePart: hk, Meridiem: SZ, Day: AZ,
  Hours: FZ, Milliseconds: _Z, Minutes: kZ, Month: TZ, Seconds: IZ, Year: PZ } = uk(), BZ = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  fk = {
    1: ({ token: e }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new AZ(e),
    // Day // TODO
    3: (e) => new TZ(e),
    // Month
    4: (e) => new PZ(e),
    // Year
    5: (e) => new SZ(e),
    // AM/PM // TODO (special)
    6: (e) => new FZ(e),
    // Hours
    7: (e) => new kZ(e),
    // Minutes
    8: (e) => new IZ(e),
    // Seconds
    9: (e) => new _Z(e)
    // Fractional seconds
  }, OZ = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, N0 = class extends EZ {
    static {
      s(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(OZ, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = ck("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = BZ.exec(t); ) {
        let i = r.shift(), o = r.findIndex((a) => a != null);
        this.parts.push(o in fk ? fk[o]({ token: r[o] || i, date: this.date, parts: this.parts, locales: this.locales }) : r[o] || i);
      }
      let n = this.parts.reduce((i, o) => (typeof o == "string" && typeof i[i.length - 1] == "string" ? i[i.length - 1] += o : i.push(o), i),
      []);
      this.parts.splice(0), this.parts.push(...n), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof hk)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof hk)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(pk.hide) : this.out.write(ck(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        lk.symbol(this.done, this.aborted),
        R0.bold(this.msg),
        lk.delimiter(!1),
        this.parts.reduce((t, r, n) => t.concat(n === this.cursor && !this.done ? R0.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (t, r, n) => t + `
${n ? " " : CZ.pointerSmall} ${R0.red().italic(r)}`,
        ""
      )), this.out.write(wZ.line + pk.to(0) + this.outputText));
    }
  };
  dk.exports = N0;
});

// ../node_modules/prompts/lib/elements/number.js
var xk = I((gde, Dk) => {
  var Oc = ot(), RZ = qn(), { cursor: Rc, erase: NZ } = ut(), { style: L0, figures: LZ, clear: gk, lines: jZ } = Wr(), MZ = /[0-9]/, j0 = /* @__PURE__ */ s(
  (e) => e !== void 0, "isDef"), yk = /* @__PURE__ */ s((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), M0 = class extends RZ {
    static {
      s(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = L0.render(t.style), this.msg = t.message, this.initial = j0(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = j0(t.min) ? t.min : -1 / 0, this.max = j0(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Oc.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${yk(t, this.round)}`), this._value = yk(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || MZ.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let n = Date.now();
      if (n - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = n, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Rc.down(jZ(this.outputError, this.out.columns) - 1) + gk(this.
      outputError, this.out.columns)), this.out.write(gk(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        L0.symbol(this.done, this.aborted),
        Oc.bold(this.msg),
        L0.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? Oc[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, n) => t + `
${n ? " " : LZ.pointerSmall} ${Oc.red().italic(r)}`, "")), this.out.write(NZ.line + Rc.to(0) + this.outputText + Rc.save + this.outputError +
      Rc.restore));
    }
  };
  Dk.exports = M0;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var $0 = I((Dde, Ek) => {
  "use strict";
  var fn = ot(), { cursor: qZ } = ut(), $Z = qn(), { clear: bk, figures: hi, style: vk, wrap: VZ, entriesToDisplay: UZ } = Wr(), q0 = class extends $Z {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, n) => (typeof r == "string" && (r = { title: r,
      value: n }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? n : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = bk("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${hi.arrowUp}/${hi.arrowDown}: Highlight option
    ${hi.arrowLeft}/${hi.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, n, i) {
      let o = (r.selected ? fn.green(hi.radioOn) : hi.radioOff) + " " + i + " ", a, u;
      return r.disabled ? a = t === n ? fn.gray().underline(r.title) : fn.strikethrough().gray(r.title) : (a = t === n ? fn.cyan().underline(
      r.title) : r.title, t === n && r.description && (u = ` - ${r.description}`, (o.length + a.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + VZ(r.description, { margin: o.length, width: this.out.columns })))), o + a + fn.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return fn.red("No matches for this query.");
      let { startIndex: r, endIndex: n } = UZ(this.cursor, t.length, this.optionsPerPage), i, o = [];
      for (let a = r; a < n; a++)
        a === r && r > 0 ? i = hi.arrowUp : a === n - 1 && n < t.length ? i = hi.arrowDown : i = " ", o.push(this.renderOption(this.cursor, t[a],
        a, i));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [fn.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(fn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(qZ.hide), super.render();
      let t = [
        vk.symbol(this.done, this.aborted),
        fn.bold(this.msg),
        vk.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += fn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = bk(t, this.out.columns);
    }
  };
  Ek.exports = q0;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var Fk = I((bde, Ak) => {
  "use strict";
  var Ua = ot(), WZ = qn(), { erase: zZ, cursor: Ck } = ut(), { style: V0, clear: wk, figures: U0, wrap: HZ, entriesToDisplay: GZ } = Wr(), Sk = /* @__PURE__ */ s(
  (e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), JZ = /* @__PURE__ */ s((e, t) => e[t] && (e[t].title || e[t].value || e[t]),
  "getTitle"), ZZ = /* @__PURE__ */ s((e, t) => {
    let r = e.findIndex((n) => n.value === t || n.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), W0 = class extends WZ {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      ZZ(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = { noMatches: t.noMatches || "no matches found" }, this.
      fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = t.limit ||
      10, this.cursor = 0, this.transform = V0.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = wk("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = { title: this._fb }), t || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = Sk(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    async complete(t) {
      let r = this.completing = this.suggest(this.input, this.choices), n = await r;
      if (this.completing !== r) return;
      this.suggestions = n.map((o, a, u) => ({ title: JZ(u, a), value: Sk(u, a), description: o.description })), this.completing = !1;
      let i = Math.max(n.length - 1, 0);
      this.moveSelect(Math.min(i, this.select)), t && t();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let n = this.input.slice(0, this.cursor), i = this.input.slice(this.cursor);
      this.input = `${n}${t}${i}`, this.cursor = n.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, n, i) {
      let o, a = n ? U0.arrowUp : i ? U0.arrowDown : " ", u = r ? Ua.cyan().underline(t.title) : t.title;
      return a = (r ? Ua.cyan(U0.pointer) + " " : "  ") + a, t.description && (o = ` - ${t.description}`, (a.length + u.length + o.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (o = `
` + HZ(t.description, { margin: 3, width: this.out.columns }))), a + " " + u + Ua.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(Ck.hide) : this.out.write(wk(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = GZ(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        V0.symbol(this.done, this.aborted, this.exited),
        Ua.bold(this.msg),
        V0.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let n = this.suggestions.slice(t, r).map((i, o) => this.renderOption(
          i,
          this.select === o + t,
          o === 0 && t > 0,
          o + t === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (n || Ua.gray(this.fallback.title));
      }
      this.out.write(zZ.line + Ck.to(0) + this.outputText);
    }
  };
  Ak.exports = W0;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var Ik = I((Ede, Tk) => {
  "use strict";
  var Vn = ot(), { cursor: XZ } = ut(), KZ = $0(), { clear: _k, style: kk, figures: uo } = Wr(), z0 = class extends KZ {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = _k("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((n) => this.inputValue ? !!(typeof n.title == "string" && n.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof n.value == "string" && n.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((n) => n === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${uo.arrowUp}/${uo.arrowDown}: Highlight option
    ${uo.arrowLeft}/${uo.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : Vn.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, n) {
      let i;
      return r.disabled ? i = t === n ? Vn.gray().underline(r.title) : Vn.strikethrough().gray(r.title) : i = t === n ? Vn.cyan().underline(
      r.title) : r.title, (r.selected ? Vn.green(uo.radioOn) : uo.radioOff) + "  " + i;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [Vn.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(Vn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(XZ.hide), super.render();
      let t = [
        kk.symbol(this.done, this.aborted),
        Vn.bold(this.msg),
        kk.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += Vn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = _k(t, this.out.columns);
    }
  };
  Tk.exports = z0;
});

// ../node_modules/prompts/lib/elements/confirm.js
var Nk = I((wde, Rk) => {
  var Pk = ot(), YZ = qn(), { style: Bk, clear: QZ } = Wr(), { erase: eX, cursor: Ok } = ut(), H0 = class extends YZ {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Ok.hide) : this.out.write(QZ(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        Bk.symbol(this.done, this.aborted),
        Pk.bold(this.msg),
        Bk.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : Pk.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(eX.line + Ok.to(0) + this.outputText));
    }
  };
  Rk.exports = H0;
});

// ../node_modules/prompts/lib/elements/index.js
var jk = I((Ade, Lk) => {
  "use strict";
  Lk.exports = {
    TextPrompt: R3(),
    SelectPrompt: M3(),
    TogglePrompt: U3(),
    DatePrompt: mk(),
    NumberPrompt: xk(),
    MultiselectPrompt: $0(),
    AutocompletePrompt: Fk(),
    AutocompleteMultiselectPrompt: Ik(),
    ConfirmPrompt: Nk()
  };
});

// ../node_modules/prompts/lib/prompts.js
var qk = I((Mk) => {
  "use strict";
  var Ht = Mk, tX = jk(), Nc = /* @__PURE__ */ s((e) => e, "noop");
  function dn(e, t, r = {}) {
    return new Promise((n, i) => {
      let o = new tX[e](t), a = r.onAbort || Nc, u = r.onSubmit || Nc, l = r.onExit || Nc;
      o.on("state", t.onState || Nc), o.on("submit", (c) => n(u(c))), o.on("exit", (c) => n(l(c))), o.on("abort", (c) => i(a(c)));
    });
  }
  s(dn, "toPrompt");
  Ht.text = (e) => dn("TextPrompt", e);
  Ht.password = (e) => (e.style = "password", Ht.text(e));
  Ht.invisible = (e) => (e.style = "invisible", Ht.text(e));
  Ht.number = (e) => dn("NumberPrompt", e);
  Ht.date = (e) => dn("DatePrompt", e);
  Ht.confirm = (e) => dn("ConfirmPrompt", e);
  Ht.list = (e) => {
    let t = e.separator || ",";
    return dn("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(t).map((n) => n.trim()), "onSubmit")
    });
  };
  Ht.toggle = (e) => dn("TogglePrompt", e);
  Ht.select = (e) => dn("SelectPrompt", e);
  Ht.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((n) => n.selected).map((n) => n.value), "toSelected");
    return dn("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  Ht.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ s((r) => r.filter((n) => n.selected).map((n) => n.value), "toSelected");
    return dn("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var rX = /* @__PURE__ */ s((e, t) => Promise.resolve(
    t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())
  ), "byTitle");
  Ht.autocomplete = (e) => (e.suggest = e.suggest || rX, e.choices = [].concat(e.choices || []), dn("AutocompletePrompt", e));
});

// ../node_modules/prompts/lib/index.js
var Uk = I((kde, Vk) => {
  "use strict";
  var G0 = qk(), nX = ["suggest", "format", "onState", "validate", "onRender", "type"], $k = /* @__PURE__ */ s(() => {
  }, "noop");
  async function fi(e = [], { onSubmit: t = $k, onCancel: r = $k } = {}) {
    let n = {}, i = fi._override || {};
    e = [].concat(e);
    let o, a, u, l, c, p, h = /* @__PURE__ */ s(async (f, d, m = !1) => {
      if (!(!m && f.validate && f.validate(d) !== !0))
        return f.format ? await f.format(d, n) : d;
    }, "getFormattedAnswer");
    for (a of e)
      if ({ name: l, type: c } = a, typeof c == "function" && (c = await c(o, { ...n }, a), a.type = c), !!c) {
        for (let f in a) {
          if (nX.includes(f)) continue;
          let d = a[f];
          a[f] = typeof d == "function" ? await d(o, { ...n }, p) : d;
        }
        if (p = a, typeof a.message != "string")
          throw new Error("prompt message is required");
        if ({ name: l, type: c } = a, G0[c] === void 0)
          throw new Error(`prompt type (${c}) is not defined`);
        if (i[a.name] !== void 0 && (o = await h(a, i[a.name]), o !== void 0)) {
          n[l] = o;
          continue;
        }
        try {
          o = fi._injected ? iX(fi._injected, a.initial) : await G0[c](a), n[l] = o = await h(a, o, !0), u = await t(a, o, n);
        } catch {
          u = !await r(a, n);
        }
        if (u) return n;
      }
    return n;
  }
  s(fi, "prompt");
  function iX(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  s(iX, "getInjectedAnswer");
  function sX(e) {
    fi._injected = (fi._injected || []).concat(e);
  }
  s(sX, "inject");
  function oX(e) {
    fi._override = Object.assign({}, e);
  }
  s(oX, "override");
  Vk.exports = Object.assign(fi, { prompt: fi, prompts: G0, inject: sX, override: oX });
});

// ../node_modules/prompts/index.js
var J0 = I((Ide, Wk) => {
  function aX(e) {
    e = (Array.isArray(e) ? e : e.split(".")).map(Number);
    let t = 0, r = process.versions.node.split(".").map(Number);
    for (; t < e.length; t++) {
      if (r[t] > e[t]) return !1;
      if (e[t] > r[t]) return !0;
    }
    return !1;
  }
  s(aX, "isNodeLT");
  Wk.exports = aX("8.6.0") ? m3() : Uk();
});

// ../node_modules/walk-up-path/dist/cjs/index.js
var Qk = I((qc) => {
  "use strict";
  Object.defineProperty(qc, "__esModule", { value: !0 });
  qc.walkUp = void 0;
  var Yk = require("path"), pX = /* @__PURE__ */ s(function* (e) {
    for (e = (0, Yk.resolve)(e); e; ) {
      yield e;
      let t = (0, Yk.dirname)(e);
      if (t === e)
        break;
      e = t;
    }
  }, "walkUp");
  qc.walkUp = pX;
});

// ../node_modules/zod/lib/helpers/util.js
var za = I((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", { value: !0 });
  Ge.getParsedType = Ge.ZodParsedType = Ge.objectUtil = Ge.util = void 0;
  var iy;
  (function(e) {
    e.assertEqual = (i) => i;
    function t(i) {
    }
    s(t, "assertIs"), e.assertIs = t;
    function r(i) {
      throw new Error();
    }
    s(r, "assertNever"), e.assertNever = r, e.arrayToEnum = (i) => {
      let o = {};
      for (let a of i)
        o[a] = a;
      return o;
    }, e.getValidEnumValues = (i) => {
      let o = e.objectKeys(i).filter((u) => typeof i[i[u]] != "number"), a = {};
      for (let u of o)
        a[u] = i[u];
      return e.objectValues(a);
    }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
      return i[o];
    }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
      let o = [];
      for (let a in i)
        Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
      return o;
    }, e.find = (i, o) => {
      for (let a of i)
        if (o(a))
          return a;
    }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.
    floor(i) === i;
    function n(i, o = " | ") {
      return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(o);
    }
    s(n, "joinValues"), e.joinValues = n, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
  })(iy || (Ge.util = iy = {}));
  var iT;
  (function(e) {
    e.mergeShapes = (t, r) => ({
      ...t,
      ...r
      // second overwrites first
    });
  })(iT || (Ge.objectUtil = iT = {}));
  Ge.ZodParsedType = iy.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var dX = /* @__PURE__ */ s((e) => {
    switch (typeof e) {
      case "undefined":
        return Ge.ZodParsedType.undefined;
      case "string":
        return Ge.ZodParsedType.string;
      case "number":
        return isNaN(e) ? Ge.ZodParsedType.nan : Ge.ZodParsedType.number;
      case "boolean":
        return Ge.ZodParsedType.boolean;
      case "function":
        return Ge.ZodParsedType.function;
      case "bigint":
        return Ge.ZodParsedType.bigint;
      case "symbol":
        return Ge.ZodParsedType.symbol;
      case "object":
        return Array.isArray(e) ? Ge.ZodParsedType.array : e === null ? Ge.ZodParsedType.null : e.then && typeof e.then == "function" && e.catch &&
        typeof e.catch == "function" ? Ge.ZodParsedType.promise : typeof Map < "u" && e instanceof Map ? Ge.ZodParsedType.map : typeof Set <
        "u" && e instanceof Set ? Ge.ZodParsedType.set : typeof Date < "u" && e instanceof Date ? Ge.ZodParsedType.date : Ge.ZodParsedType.object;
      default:
        return Ge.ZodParsedType.unknown;
    }
  }, "getParsedType");
  Ge.getParsedType = dX;
});

// ../node_modules/zod/lib/ZodError.js
var Uc = I((di) => {
  "use strict";
  Object.defineProperty(di, "__esModule", { value: !0 });
  di.ZodError = di.quotelessJson = di.ZodIssueCode = void 0;
  var sT = za();
  di.ZodIssueCode = sT.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var mX = /* @__PURE__ */ s((e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson");
  di.quotelessJson = mX;
  var Ha = class e extends Error {
    static {
      s(this, "ZodError");
    }
    get errors() {
      return this.issues;
    }
    constructor(t) {
      super(), this.issues = [], this.addIssue = (n) => {
        this.issues = [...this.issues, n];
      }, this.addIssues = (n = []) => {
        this.issues = [...this.issues, ...n];
      };
      let r = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    format(t) {
      let r = t || function(o) {
        return o.message;
      }, n = { _errors: [] }, i = /* @__PURE__ */ s((o) => {
        for (let a of o.issues)
          if (a.code === "invalid_union")
            a.unionErrors.map(i);
          else if (a.code === "invalid_return_type")
            i(a.returnTypeError);
          else if (a.code === "invalid_arguments")
            i(a.argumentsError);
          else if (a.path.length === 0)
            n._errors.push(r(a));
          else {
            let u = n, l = 0;
            for (; l < a.path.length; ) {
              let c = a.path[l];
              l === a.path.length - 1 ? (u[c] = u[c] || { _errors: [] }, u[c]._errors.push(r(a))) : u[c] = u[c] || { _errors: [] }, u = u[c],
              l++;
            }
          }
      }, "processError");
      return i(this), n;
    }
    static assert(t) {
      if (!(t instanceof e))
        throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, sT.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(t = (r) => r.message) {
      let r = {}, n = [];
      for (let i of this.issues)
        i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
      return { formErrors: n, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  di.ZodError = Ha;
  Ha.create = (e) => new Ha(e);
});

// ../node_modules/zod/lib/locales/en.js
var oy = I((sy) => {
  "use strict";
  Object.defineProperty(sy, "__esModule", { value: !0 });
  var Hi = za(), _t = Uc(), gX = /* @__PURE__ */ s((e, t) => {
    let r;
    switch (e.code) {
      case _t.ZodIssueCode.invalid_type:
        e.received === Hi.ZodParsedType.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
        break;
      case _t.ZodIssueCode.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(e.expected, Hi.util.jsonStringifyReplacer)}`;
        break;
      case _t.ZodIssueCode.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${Hi.util.joinValues(e.keys, ", ")}`;
        break;
      case _t.ZodIssueCode.invalid_union:
        r = "Invalid input";
        break;
      case _t.ZodIssueCode.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${Hi.util.joinValues(e.options)}`;
        break;
      case _t.ZodIssueCode.invalid_enum_value:
        r = `Invalid enum value. Expected ${Hi.util.joinValues(e.options)}, received '${e.received}'`;
        break;
      case _t.ZodIssueCode.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case _t.ZodIssueCode.invalid_return_type:
        r = "Invalid function return type";
        break;
      case _t.ZodIssueCode.invalid_date:
        r = "Invalid date";
        break;
      case _t.ZodIssueCode.invalid_string:
        typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.
        validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "start\
sWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input\
: must end with "${e.validation.endsWith}"` : Hi.util.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` :
        r = "Invalid";
        break;
      case _t.ZodIssueCode.too_small:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` :
        e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` :
        e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater tha\
n "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "gre\
ater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
        break;
      case _t.ZodIssueCode.too_big:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` :
        e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` :
        e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` :
        e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` :
        e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(
        Number(e.maximum))}` : r = "Invalid input";
        break;
      case _t.ZodIssueCode.custom:
        r = "Invalid input";
        break;
      case _t.ZodIssueCode.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case _t.ZodIssueCode.not_multiple_of:
        r = `Number must be a multiple of ${e.multipleOf}`;
        break;
      case _t.ZodIssueCode.not_finite:
        r = "Number must be finite";
        break;
      default:
        r = t.defaultError, Hi.util.assertNever(e);
    }
    return { message: r };
  }, "errorMap");
  sy.default = gX;
});

// ../node_modules/zod/lib/errors.js
var Wc = I((mn) => {
  "use strict";
  var yX = mn && mn.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(mn, "__esModule", { value: !0 });
  mn.getErrorMap = mn.setErrorMap = mn.defaultErrorMap = void 0;
  var oT = yX(oy());
  mn.defaultErrorMap = oT.default;
  var aT = oT.default;
  function DX(e) {
    aT = e;
  }
  s(DX, "setErrorMap");
  mn.setErrorMap = DX;
  function xX() {
    return aT;
  }
  s(xX, "getErrorMap");
  mn.getErrorMap = xX;
});

// ../node_modules/zod/lib/helpers/parseUtil.js
var uy = I((Le) => {
  "use strict";
  var bX = Le && Le.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(Le, "__esModule", { value: !0 });
  Le.isAsync = Le.isValid = Le.isDirty = Le.isAborted = Le.OK = Le.DIRTY = Le.INVALID = Le.ParseStatus = Le.addIssueToContext = Le.EMPTY_PATH =
  Le.makeIssue = void 0;
  var vX = Wc(), uT = bX(oy()), EX = /* @__PURE__ */ s((e) => {
    let { data: t, path: r, errorMaps: n, issueData: i } = e, o = [...r, ...i.path || []], a = {
      ...i,
      path: o
    };
    if (i.message !== void 0)
      return {
        ...i,
        path: o,
        message: i.message
      };
    let u = "", l = n.filter((c) => !!c).slice().reverse();
    for (let c of l)
      u = c(a, { data: t, defaultError: u }).message;
    return {
      ...i,
      path: o,
      message: u
    };
  }, "makeIssue");
  Le.makeIssue = EX;
  Le.EMPTY_PATH = [];
  function CX(e, t) {
    let r = (0, vX.getErrorMap)(), n = (0, Le.makeIssue)({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        // contextual error map is first priority
        e.schemaErrorMap,
        // then schema-bound map if available
        r,
        // then global override map
        r === uT.default ? void 0 : uT.default
        // then global default map
      ].filter((i) => !!i)
    });
    e.common.issues.push(n);
  }
  s(CX, "addIssueToContext");
  Le.addIssueToContext = CX;
  var ay = class e {
    static {
      s(this, "ParseStatus");
    }
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
      let n = [];
      for (let i of r) {
        if (i.status === "aborted")
          return Le.INVALID;
        i.status === "dirty" && t.dirty(), n.push(i.value);
      }
      return { status: t.value, value: n };
    }
    static async mergeObjectAsync(t, r) {
      let n = [];
      for (let i of r) {
        let o = await i.key, a = await i.value;
        n.push({
          key: o,
          value: a
        });
      }
      return e.mergeObjectSync(t, n);
    }
    static mergeObjectSync(t, r) {
      let n = {};
      for (let i of r) {
        let { key: o, value: a } = i;
        if (o.status === "aborted" || a.status === "aborted")
          return Le.INVALID;
        o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || i.alwaysSet) &&
        (n[o.value] = a.value);
      }
      return { status: t.value, value: n };
    }
  };
  Le.ParseStatus = ay;
  Le.INVALID = Object.freeze({
    status: "aborted"
  });
  var wX = /* @__PURE__ */ s((e) => ({ status: "dirty", value: e }), "DIRTY");
  Le.DIRTY = wX;
  var SX = /* @__PURE__ */ s((e) => ({ status: "valid", value: e }), "OK");
  Le.OK = SX;
  var AX = /* @__PURE__ */ s((e) => e.status === "aborted", "isAborted");
  Le.isAborted = AX;
  var FX = /* @__PURE__ */ s((e) => e.status === "dirty", "isDirty");
  Le.isDirty = FX;
  var _X = /* @__PURE__ */ s((e) => e.status === "valid", "isValid");
  Le.isValid = _X;
  var kX = /* @__PURE__ */ s((e) => typeof Promise < "u" && e instanceof Promise, "isAsync");
  Le.isAsync = kX;
});

// ../node_modules/zod/lib/helpers/typeAliases.js
var cT = I((lT) => {
  "use strict";
  Object.defineProperty(lT, "__esModule", { value: !0 });
});

// ../node_modules/zod/lib/helpers/errorUtil.js
var hT = I((zc) => {
  "use strict";
  Object.defineProperty(zc, "__esModule", { value: !0 });
  zc.errorUtil = void 0;
  var pT;
  (function(e) {
    e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
  })(pT || (zc.errorUtil = pT = {}));
});

// ../node_modules/zod/lib/types.js
var ST = I((q) => {
  "use strict";
  var Gc = q && q.__classPrivateFieldGet || function(e, t, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did n\
ot declare it");
    return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
  }, mT = q && q.__classPrivateFieldSet || function(e, t, r, n, i) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did no\
t declare it");
    return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r), r;
  }, Ga, Ja;
  Object.defineProperty(q, "__esModule", { value: !0 });
  q.boolean = q.bigint = q.array = q.any = q.coerce = q.ZodFirstPartyTypeKind = q.late = q.ZodSchema = q.Schema = q.custom = q.ZodReadonly =
  q.ZodPipeline = q.ZodBranded = q.BRAND = q.ZodNaN = q.ZodCatch = q.ZodDefault = q.ZodNullable = q.ZodOptional = q.ZodTransformer = q.ZodEffects =
  q.ZodPromise = q.ZodNativeEnum = q.ZodEnum = q.ZodLiteral = q.ZodLazy = q.ZodFunction = q.ZodSet = q.ZodMap = q.ZodRecord = q.ZodTuple = q.
  ZodIntersection = q.ZodDiscriminatedUnion = q.ZodUnion = q.ZodObject = q.ZodArray = q.ZodVoid = q.ZodNever = q.ZodUnknown = q.ZodAny = q.ZodNull =
  q.ZodUndefined = q.ZodSymbol = q.ZodDate = q.ZodBoolean = q.ZodBigInt = q.ZodNumber = q.ZodString = q.datetimeRegex = q.ZodType = void 0;
  q.NEVER = q.void = q.unknown = q.union = q.undefined = q.tuple = q.transformer = q.symbol = q.string = q.strictObject = q.set = q.record =
  q.promise = q.preprocess = q.pipeline = q.ostring = q.optional = q.onumber = q.oboolean = q.object = q.number = q.nullable = q.null = q.never =
  q.nativeEnum = q.nan = q.map = q.literal = q.lazy = q.intersection = q.instanceof = q.function = q.enum = q.effect = q.discriminatedUnion =
  q.date = void 0;
  var Hc = Wc(), ue = hT(), V = uy(), ne = za(), te = Uc(), Cr = class {
    static {
      s(this, "ParseInputLazyPath");
    }
    constructor(t, r, n, i) {
      this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.
      push(...this._path, this._key)), this._cachedPath;
    }
  }, fT = /* @__PURE__ */ s((e, t) => {
    if ((0, V.isValid)(t))
      return { success: !0, data: t.value };
    if (!e.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        let r = new te.ZodError(e.common.issues);
        return this._error = r, this._error;
      }
    };
  }, "handleResult");
  function we(e) {
    if (!e)
      return {};
    let { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
    if (t && (r || n))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? { errorMap: t, description: i } : { errorMap: /* @__PURE__ */ s((a, u) => {
      var l, c;
      let { message: p } = e;
      return a.code === "invalid_enum_value" ? { message: p ?? u.defaultError } : typeof u.data > "u" ? { message: (l = p ?? n) !== null && l !==
      void 0 ? l : u.defaultError } : a.code !== "invalid_type" ? { message: u.defaultError } : { message: (c = p ?? r) !== null && c !== void 0 ?
      c : u.defaultError };
    }, "customMap"), description: i };
  }
  s(we, "processCreateParams");
  var Se = class {
    static {
      s(this, "ZodType");
    }
    get description() {
      return this._def.description;
    }
    _getType(t) {
      return (0, ne.getParsedType)(t.data);
    }
    _getOrReturnCtx(t, r) {
      return r || {
        common: t.parent.common,
        data: t.data,
        parsedType: (0, ne.getParsedType)(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      };
    }
    _processInputParams(t) {
      return {
        status: new V.ParseStatus(),
        ctx: {
          common: t.parent.common,
          data: t.data,
          parsedType: (0, ne.getParsedType)(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent
        }
      };
    }
    _parseSync(t) {
      let r = this._parse(t);
      if ((0, V.isAsync)(r))
        throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(t) {
      let r = this._parse(t);
      return Promise.resolve(r);
    }
    parse(t, r) {
      let n = this.safeParse(t, r);
      if (n.success)
        return n.data;
      throw n.error;
    }
    safeParse(t, r) {
      var n;
      let i = {
        common: {
          issues: [],
          async: (n = r?.async) !== null && n !== void 0 ? n : !1,
          contextualErrorMap: r?.errorMap
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ne.getParsedType)(t)
      }, o = this._parseSync({ data: t, path: i.path, parent: i });
      return fT(i, o);
    }
    "~validate"(t) {
      var r, n;
      let i = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ne.getParsedType)(t)
      };
      if (!this["~standard"].async)
        try {
          let o = this._parseSync({ data: t, path: [], parent: i });
          return (0, V.isValid)(o) ? {
            value: o.value
          } : {
            issues: i.common.issues
          };
        } catch (o) {
          !((n = (r = o?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") &&
          (this["~standard"].async = !0), i.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: t, path: [], parent: i }).then((o) => (0, V.isValid)(o) ? {
        value: o.value
      } : {
        issues: i.common.issues
      });
    }
    async parseAsync(t, r) {
      let n = await this.safeParseAsync(t, r);
      if (n.success)
        return n.data;
      throw n.error;
    }
    async safeParseAsync(t, r) {
      let n = {
        common: {
          issues: [],
          contextualErrorMap: r?.errorMap,
          async: !0
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ne.getParsedType)(t)
      }, i = this._parse({ data: t, path: n.path, parent: n }), o = await ((0, V.isAsync)(i) ? i : Promise.resolve(i));
      return fT(n, o);
    }
    refine(t, r) {
      let n = /* @__PURE__ */ s((i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r, "getIssu\
eProperties");
      return this._refinement((i, o) => {
        let a = t(i), u = /* @__PURE__ */ s(() => o.addIssue({
          code: te.ZodIssueCode.custom,
          ...n(i)
        }), "setError");
        return typeof Promise < "u" && a instanceof Promise ? a.then((l) => l ? !0 : (u(), !1)) : a ? !0 : (u(), !1);
      });
    }
    refinement(t, r) {
      return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
    }
    _refinement(t) {
      return new tr({
        schema: this,
        typeName: ye.ZodEffects,
        effect: { type: "refinement", refinement: t }
      });
    }
    superRefine(t) {
      return this._refinement(t);
    }
    constructor(t) {
      this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync =
      this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.
      bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.
      bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.
      promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(
      this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe =
      this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.
      bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: /* @__PURE__ */ s((r) => this["~validate"](r), "validate")
      };
    }
    optional() {
      return Er.create(this, this._def);
    }
    nullable() {
      return yn.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return zn.create(this);
    }
    promise() {
      return yi.create(this, this._def);
    }
    or(t) {
      return Qi.create([this, t], this._def);
    }
    and(t) {
      return es.create(this, t, this._def);
    }
    transform(t) {
      return new tr({
        ...we(this._def),
        schema: this,
        typeName: ye.ZodEffects,
        effect: { type: "transform", transform: t }
      });
    }
    default(t) {
      let r = typeof t == "function" ? t : () => t;
      return new ss({
        ...we(this._def),
        innerType: this,
        defaultValue: r,
        typeName: ye.ZodDefault
      });
    }
    brand() {
      return new Za({
        typeName: ye.ZodBranded,
        type: this,
        ...we(this._def)
      });
    }
    catch(t) {
      let r = typeof t == "function" ? t : () => t;
      return new os({
        ...we(this._def),
        innerType: this,
        catchValue: r,
        typeName: ye.ZodCatch
      });
    }
    describe(t) {
      let r = this.constructor;
      return new r({
        ...this._def,
        description: t
      });
    }
    pipe(t) {
      return Xa.create(this, t);
    }
    readonly() {
      return as.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  q.ZodType = Se;
  q.Schema = Se;
  q.ZodSchema = Se;
  var TX = /^c[^\s-]{8,}$/i, IX = /^[0-9a-z]+$/, PX = /^[0-9A-HJKMNP-TV-Z]{26}$/i, BX = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  OX = /^[a-z0-9_-]{21}$/i, RX = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, NX = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  LX = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, jX = "^(\\p{Extended_Pictographic}|\\p{Emoji_Comp\
onent})+$", ly, MX = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, qX = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  $X = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  VX = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  UX = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, WX = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  gT = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469\
]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", zX = new RegExp(`^${gT}$`);
  function yT(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
  }
  s(yT, "timeRegexSource");
  function HX(e) {
    return new RegExp(`^${yT(e)}$`);
  }
  s(HX, "timeRegex");
  function DT(e) {
    let t = `${gT}T${yT(e)}`, r = [];
    return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
  }
  s(DT, "datetimeRegex");
  q.datetimeRegex = DT;
  function GX(e, t) {
    return !!((t === "v4" || !t) && MX.test(e) || (t === "v6" || !t) && $X.test(e));
  }
  s(GX, "isValidIP");
  function JX(e, t) {
    if (!RX.test(e))
      return !1;
    try {
      let [r] = e.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), i = JSON.parse(atob(
      n));
      return !(typeof i != "object" || i === null || !i.typ || !i.alg || t && i.alg !== t);
    } catch {
      return !1;
    }
  }
  s(JX, "isValidJWT");
  function ZX(e, t) {
    return !!((t === "v4" || !t) && qX.test(e) || (t === "v6" || !t) && VX.test(e));
  }
  s(ZX, "isValidCidr");
  var mi = class e extends Se {
    static {
      s(this, "ZodString");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ne.ZodParsedType.string) {
        let o = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(o, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.string,
          received: o.parsedType
        }), V.INVALID;
      }
      let n = new V.ParseStatus(), i;
      for (let o of this._def.checks)
        if (o.kind === "min")
          t.data.length < o.value && (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            code: te.ZodIssueCode.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
          }), n.dirty());
        else if (o.kind === "max")
          t.data.length > o.value && (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            code: te.ZodIssueCode.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
          }), n.dirty());
        else if (o.kind === "length") {
          let a = t.data.length > o.value, u = t.data.length < o.value;
          (a || u) && (i = this._getOrReturnCtx(t, i), a ? (0, V.addIssueToContext)(i, {
            code: te.ZodIssueCode.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: o.message
          }) : u && (0, V.addIssueToContext)(i, {
            code: te.ZodIssueCode.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: o.message
          }), n.dirty());
        } else if (o.kind === "email")
          LX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "email",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "emoji")
          ly || (ly = new RegExp(jX, "u")), ly.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "emoji",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "uuid")
          BX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "uuid",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "nanoid")
          OX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "nanoid",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "cuid")
          TX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "cuid",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "cuid2")
          IX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "cuid2",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "ulid")
          PX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
            validation: "ulid",
            code: te.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "url")
          try {
            new URL(t.data);
          } catch {
            i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
              validation: "url",
              code: te.ZodIssueCode.invalid_string,
              message: o.message
            }), n.dirty();
          }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(
        i, {
          validation: "regex",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this.
        _getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: { includes: o.value, position: o.position },
          message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() :
        o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: { startsWith: o.value },
          message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: { endsWith: o.value },
          message: o.message
        }), n.dirty()) : o.kind === "datetime" ? DT(o).test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: o.message
        }), n.dirty()) : o.kind === "date" ? zX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: "date",
          message: o.message
        }), n.dirty()) : o.kind === "time" ? HX(o).test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.invalid_string,
          validation: "time",
          message: o.message
        }), n.dirty()) : o.kind === "duration" ? NX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "duration",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "ip" ? GX(t.data, o.version) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "ip",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "jwt" ? JX(t.data, o.alg) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "jwt",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "cidr" ? ZX(t.data, o.version) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "cidr",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "base64" ? UX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "base64",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "base64url" ? WX.test(t.data) || (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          validation: "base64url",
          code: te.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : ne.util.assertNever(o);
      return { status: n.value, value: t.data };
    }
    _regex(t, r, n) {
      return this.refinement((i) => t.test(i), {
        validation: r,
        code: te.ZodIssueCode.invalid_string,
        ...ue.errorUtil.errToObj(n)
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    email(t) {
      return this._addCheck({ kind: "email", ...ue.errorUtil.errToObj(t) });
    }
    url(t) {
      return this._addCheck({ kind: "url", ...ue.errorUtil.errToObj(t) });
    }
    emoji(t) {
      return this._addCheck({ kind: "emoji", ...ue.errorUtil.errToObj(t) });
    }
    uuid(t) {
      return this._addCheck({ kind: "uuid", ...ue.errorUtil.errToObj(t) });
    }
    nanoid(t) {
      return this._addCheck({ kind: "nanoid", ...ue.errorUtil.errToObj(t) });
    }
    cuid(t) {
      return this._addCheck({ kind: "cuid", ...ue.errorUtil.errToObj(t) });
    }
    cuid2(t) {
      return this._addCheck({ kind: "cuid2", ...ue.errorUtil.errToObj(t) });
    }
    ulid(t) {
      return this._addCheck({ kind: "ulid", ...ue.errorUtil.errToObj(t) });
    }
    base64(t) {
      return this._addCheck({ kind: "base64", ...ue.errorUtil.errToObj(t) });
    }
    base64url(t) {
      return this._addCheck({
        kind: "base64url",
        ...ue.errorUtil.errToObj(t)
      });
    }
    jwt(t) {
      return this._addCheck({ kind: "jwt", ...ue.errorUtil.errToObj(t) });
    }
    ip(t) {
      return this._addCheck({ kind: "ip", ...ue.errorUtil.errToObj(t) });
    }
    cidr(t) {
      return this._addCheck({ kind: "cidr", ...ue.errorUtil.errToObj(t) });
    }
    datetime(t) {
      var r, n;
      return typeof t == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: t
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        offset: (r = t?.offset) !== null && r !== void 0 ? r : !1,
        local: (n = t?.local) !== null && n !== void 0 ? n : !1,
        ...ue.errorUtil.errToObj(t?.message)
      });
    }
    date(t) {
      return this._addCheck({ kind: "date", message: t });
    }
    time(t) {
      return typeof t == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: t
      }) : this._addCheck({
        kind: "time",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        ...ue.errorUtil.errToObj(t?.message)
      });
    }
    duration(t) {
      return this._addCheck({ kind: "duration", ...ue.errorUtil.errToObj(t) });
    }
    regex(t, r) {
      return this._addCheck({
        kind: "regex",
        regex: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    includes(t, r) {
      return this._addCheck({
        kind: "includes",
        value: t,
        position: r?.position,
        ...ue.errorUtil.errToObj(r?.message)
      });
    }
    startsWith(t, r) {
      return this._addCheck({
        kind: "startsWith",
        value: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    endsWith(t, r) {
      return this._addCheck({
        kind: "endsWith",
        value: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    length(t, r) {
      return this._addCheck({
        kind: "length",
        value: t,
        ...ue.errorUtil.errToObj(r)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(t) {
      return this.min(1, ue.errorUtil.errToObj(t));
    }
    trim() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((t) => t.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((t) => t.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((t) => t.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((t) => t.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((t) => t.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((t) => t.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((t) => t.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((t) => t.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((t) => t.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((t) => t.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((t) => t.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((t) => t.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((t) => t.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((t) => t.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((t) => t.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((t) => t.kind === "base64url");
    }
    get minLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  q.ZodString = mi;
  mi.create = (e) => {
    var t;
    return new mi({
      checks: [],
      typeName: ye.ZodString,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...we(e)
    });
  };
  function XX(e, t) {
    let r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(
    i).replace(".", "")), a = parseInt(t.toFixed(i).replace(".", ""));
    return o % a / Math.pow(10, i);
  }
  s(XX, "floatSafeRemainder");
  var Gi = class e extends Se {
    static {
      s(this, "ZodNumber");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
      if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ne.ZodParsedType.number) {
        let o = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(o, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.number,
          received: o.parsedType
        }), V.INVALID;
      }
      let n, i = new V.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "int" ? ne.util.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.too_small,
          minimum: o.value,
          type: "number",
          inclusive: o.inclusive,
          exact: !1,
          message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.too_big,
          maximum: o.value,
          type: "number",
          inclusive: o.inclusive,
          exact: !1,
          message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? XX(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(n,
        {
          code: te.ZodIssueCode.not_multiple_of,
          multipleOf: o.value,
          message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.not_finite,
          message: o.message
        }), i.dirty()) : ne.util.assertNever(o);
      return { status: i.value, value: t.data };
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, ue.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, ue.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, ue.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, ue.errorUtil.toString(r));
    }
    setLimit(t, r, n, i) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: n,
            message: ue.errorUtil.toString(i)
          }
        ]
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    int(t) {
      return this._addCheck({
        kind: "int",
        message: ue.errorUtil.toString(t)
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: ue.errorUtil.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: ue.errorUtil.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: ue.errorUtil.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: ue.errorUtil.toString(t)
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: ue.errorUtil.toString(r)
      });
    }
    finite(t) {
      return this._addCheck({
        kind: "finite",
        message: ue.errorUtil.toString(t)
      });
    }
    safe(t) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: ue.errorUtil.toString(t)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: ue.errorUtil.toString(t)
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
    get isInt() {
      return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && ne.util.isInteger(t.value));
    }
    get isFinite() {
      let t = null, r = null;
      for (let n of this._def.checks) {
        if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
          return !0;
        n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
      }
      return Number.isFinite(r) && Number.isFinite(t);
    }
  };
  q.ZodNumber = Gi;
  Gi.create = (e) => new Gi({
    checks: [],
    typeName: ye.ZodNumber,
    coerce: e?.coerce || !1,
    ...we(e)
  });
  var Ji = class e extends Se {
    static {
      s(this, "ZodBigInt");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
      if (this._def.coerce)
        try {
          t.data = BigInt(t.data);
        } catch {
          return this._getInvalidInput(t);
        }
      if (this._getType(t) !== ne.ZodParsedType.bigint)
        return this._getInvalidInput(t);
      let n, i = new V.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.too_small,
          type: "bigint",
          minimum: o.value,
          inclusive: o.inclusive,
          message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.too_big,
          type: "bigint",
          maximum: o.value,
          inclusive: o.inclusive,
          message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), (0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.not_multiple_of,
          multipleOf: o.value,
          message: o.message
        }), i.dirty()) : ne.util.assertNever(o);
      return { status: i.value, value: t.data };
    }
    _getInvalidInput(t) {
      let r = this._getOrReturnCtx(t);
      return (0, V.addIssueToContext)(r, {
        code: te.ZodIssueCode.invalid_type,
        expected: ne.ZodParsedType.bigint,
        received: r.parsedType
      }), V.INVALID;
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, ue.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, ue.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, ue.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, ue.errorUtil.toString(r));
    }
    setLimit(t, r, n, i) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: n,
            message: ue.errorUtil.toString(i)
          }
        ]
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: ue.errorUtil.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: ue.errorUtil.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: ue.errorUtil.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: ue.errorUtil.toString(t)
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: ue.errorUtil.toString(r)
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  q.ZodBigInt = Ji;
  Ji.create = (e) => {
    var t;
    return new Ji({
      checks: [],
      typeName: ye.ZodBigInt,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...we(e)
    });
  };
  var Zi = class extends Se {
    static {
      s(this, "ZodBoolean");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ne.ZodParsedType.boolean) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.boolean,
          received: n.parsedType
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
  };
  q.ZodBoolean = Zi;
  Zi.create = (e) => new Zi({
    typeName: ye.ZodBoolean,
    coerce: e?.coerce || !1,
    ...we(e)
  });
  var Xi = class e extends Se {
    static {
      s(this, "ZodDate");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ne.ZodParsedType.date) {
        let o = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(o, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.date,
          received: o.parsedType
        }), V.INVALID;
      }
      if (isNaN(t.data.getTime())) {
        let o = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(o, {
          code: te.ZodIssueCode.invalid_date
        }), V.INVALID;
      }
      let n = new V.ParseStatus(), i;
      for (let o of this._def.checks)
        o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.too_small,
          message: o.message,
          inclusive: !0,
          exact: !1,
          minimum: o.value,
          type: "date"
        }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), (0, V.addIssueToContext)(i, {
          code: te.ZodIssueCode.too_big,
          message: o.message,
          inclusive: !0,
          exact: !1,
          maximum: o.value,
          type: "date"
        }), n.dirty()) : ne.util.assertNever(o);
      return {
        status: n.value,
        value: new Date(t.data.getTime())
      };
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t.getTime(),
        message: ue.errorUtil.toString(r)
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t.getTime(),
        message: ue.errorUtil.toString(r)
      });
    }
    get minDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
    get maxDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
  };
  q.ZodDate = Xi;
  Xi.create = (e) => new Xi({
    checks: [],
    coerce: e?.coerce || !1,
    typeName: ye.ZodDate,
    ...we(e)
  });
  var po = class extends Se {
    static {
      s(this, "ZodSymbol");
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.symbol) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.symbol,
          received: n.parsedType
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
  };
  q.ZodSymbol = po;
  po.create = (e) => new po({
    typeName: ye.ZodSymbol,
    ...we(e)
  });
  var Ki = class extends Se {
    static {
      s(this, "ZodUndefined");
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.undefined,
          received: n.parsedType
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
  };
  q.ZodUndefined = Ki;
  Ki.create = (e) => new Ki({
    typeName: ye.ZodUndefined,
    ...we(e)
  });
  var Yi = class extends Se {
    static {
      s(this, "ZodNull");
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.null) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.null,
          received: n.parsedType
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
  };
  q.ZodNull = Yi;
  Yi.create = (e) => new Yi({
    typeName: ye.ZodNull,
    ...we(e)
  });
  var gi = class extends Se {
    static {
      s(this, "ZodAny");
    }
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(t) {
      return (0, V.OK)(t.data);
    }
  };
  q.ZodAny = gi;
  gi.create = (e) => new gi({
    typeName: ye.ZodAny,
    ...we(e)
  });
  var Wn = class extends Se {
    static {
      s(this, "ZodUnknown");
    }
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(t) {
      return (0, V.OK)(t.data);
    }
  };
  q.ZodUnknown = Wn;
  Wn.create = (e) => new Wn({
    typeName: ye.ZodUnknown,
    ...we(e)
  });
  var zr = class extends Se {
    static {
      s(this, "ZodNever");
    }
    _parse(t) {
      let r = this._getOrReturnCtx(t);
      return (0, V.addIssueToContext)(r, {
        code: te.ZodIssueCode.invalid_type,
        expected: ne.ZodParsedType.never,
        received: r.parsedType
      }), V.INVALID;
    }
  };
  q.ZodNever = zr;
  zr.create = (e) => new zr({
    typeName: ye.ZodNever,
    ...we(e)
  });
  var ho = class extends Se {
    static {
      s(this, "ZodVoid");
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.void,
          received: n.parsedType
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
  };
  q.ZodVoid = ho;
  ho.create = (e) => new ho({
    typeName: ye.ZodVoid,
    ...we(e)
  });
  var zn = class e extends Se {
    static {
      s(this, "ZodArray");
    }
    _parse(t) {
      let { ctx: r, status: n } = this._processInputParams(t), i = this._def;
      if (r.parsedType !== ne.ZodParsedType.array)
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.array,
          received: r.parsedType
        }), V.INVALID;
      if (i.exactLength !== null) {
        let a = r.data.length > i.exactLength.value, u = r.data.length < i.exactLength.value;
        (a || u) && ((0, V.addIssueToContext)(r, {
          code: a ? te.ZodIssueCode.too_big : te.ZodIssueCode.too_small,
          minimum: u ? i.exactLength.value : void 0,
          maximum: a ? i.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: i.exactLength.message
        }), n.dirty());
      }
      if (i.minLength !== null && r.data.length < i.minLength.value && ((0, V.addIssueToContext)(r, {
        code: te.ZodIssueCode.too_small,
        minimum: i.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: i.minLength.message
      }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && ((0, V.addIssueToContext)(r, {
        code: te.ZodIssueCode.too_big,
        maximum: i.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: i.maxLength.message
      }), n.dirty()), r.common.async)
        return Promise.all([...r.data].map((a, u) => i.type._parseAsync(new Cr(r, a, r.path, u)))).then((a) => V.ParseStatus.mergeArray(n, a));
      let o = [...r.data].map((a, u) => i.type._parseSync(new Cr(r, a, r.path, u)));
      return V.ParseStatus.mergeArray(n, o);
    }
    get element() {
      return this._def.type;
    }
    min(t, r) {
      return new e({
        ...this._def,
        minLength: { value: t, message: ue.errorUtil.toString(r) }
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxLength: { value: t, message: ue.errorUtil.toString(r) }
      });
    }
    length(t, r) {
      return new e({
        ...this._def,
        exactLength: { value: t, message: ue.errorUtil.toString(r) }
      });
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  q.ZodArray = zn;
  zn.create = (e, t) => new zn({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ye.ZodArray,
    ...we(t)
  });
  function co(e) {
    if (e instanceof Gt) {
      let t = {};
      for (let r in e.shape) {
        let n = e.shape[r];
        t[r] = Er.create(co(n));
      }
      return new Gt({
        ...e._def,
        shape: /* @__PURE__ */ s(() => t, "shape")
      });
    } else return e instanceof zn ? new zn({
      ...e._def,
      type: co(e.element)
    }) : e instanceof Er ? Er.create(co(e.unwrap())) : e instanceof yn ? yn.create(co(e.unwrap())) : e instanceof gn ? gn.create(e.items.map(
    (t) => co(t))) : e;
  }
  s(co, "deepPartialify");
  var Gt = class e extends Se {
    static {
      s(this, "ZodObject");
    }
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      let t = this._def.shape(), r = ne.util.objectKeys(t);
      return this._cached = { shape: t, keys: r };
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.object) {
        let c = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(c, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.object,
          received: c.parsedType
        }), V.INVALID;
      }
      let { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: a } = this._getCached(), u = [];
      if (!(this._def.catchall instanceof zr && this._def.unknownKeys === "strip"))
        for (let c in i.data)
          a.includes(c) || u.push(c);
      let l = [];
      for (let c of a) {
        let p = o[c], h = i.data[c];
        l.push({
          key: { status: "valid", value: c },
          value: p._parse(new Cr(i, h, i.path, c)),
          alwaysSet: c in i.data
        });
      }
      if (this._def.catchall instanceof zr) {
        let c = this._def.unknownKeys;
        if (c === "passthrough")
          for (let p of u)
            l.push({
              key: { status: "valid", value: p },
              value: { status: "valid", value: i.data[p] }
            });
        else if (c === "strict")
          u.length > 0 && ((0, V.addIssueToContext)(i, {
            code: te.ZodIssueCode.unrecognized_keys,
            keys: u
          }), n.dirty());
        else if (c !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        let c = this._def.catchall;
        for (let p of u) {
          let h = i.data[p];
          l.push({
            key: { status: "valid", value: p },
            value: c._parse(
              new Cr(i, h, i.path, p)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: p in i.data
          });
        }
      }
      return i.common.async ? Promise.resolve().then(async () => {
        let c = [];
        for (let p of l) {
          let h = await p.key, f = await p.value;
          c.push({
            key: h,
            value: f,
            alwaysSet: p.alwaysSet
          });
        }
        return c;
      }).then((c) => V.ParseStatus.mergeObjectSync(n, c)) : V.ParseStatus.mergeObjectSync(n, l);
    }
    get shape() {
      return this._def.shape();
    }
    strict(t) {
      return ue.errorUtil.errToObj, new e({
        ...this._def,
        unknownKeys: "strict",
        ...t !== void 0 ? {
          errorMap: /* @__PURE__ */ s((r, n) => {
            var i, o, a, u;
            let l = (a = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && a !== void 0 ?
            a : n.defaultError;
            return r.code === "unrecognized_keys" ? {
              message: (u = ue.errorUtil.errToObj(t).message) !== null && u !== void 0 ? u : l
            } : {
              message: l
            };
          }, "errorMap")
        } : {}
      });
    }
    strip() {
      return new e({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new e({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
      return new e({
        ...this._def,
        shape: /* @__PURE__ */ s(() => ({
          ...this._def.shape(),
          ...t
        }), "shape")
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(t) {
      return new e({
        unknownKeys: t._def.unknownKeys,
        catchall: t._def.catchall,
        shape: /* @__PURE__ */ s(() => ({
          ...this._def.shape(),
          ...t._def.shape()
        }), "shape"),
        typeName: ye.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
      return this.augment({ [t]: r });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
      return new e({
        ...this._def,
        catchall: t
      });
    }
    pick(t) {
      let r = {};
      return ne.util.objectKeys(t).forEach((n) => {
        t[n] && this.shape[n] && (r[n] = this.shape[n]);
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ s(() => r, "shape")
      });
    }
    omit(t) {
      let r = {};
      return ne.util.objectKeys(this.shape).forEach((n) => {
        t[n] || (r[n] = this.shape[n]);
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ s(() => r, "shape")
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return co(this);
    }
    partial(t) {
      let r = {};
      return ne.util.objectKeys(this.shape).forEach((n) => {
        let i = this.shape[n];
        t && !t[n] ? r[n] = i : r[n] = i.optional();
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ s(() => r, "shape")
      });
    }
    required(t) {
      let r = {};
      return ne.util.objectKeys(this.shape).forEach((n) => {
        if (t && !t[n])
          r[n] = this.shape[n];
        else {
          let o = this.shape[n];
          for (; o instanceof Er; )
            o = o._def.innerType;
          r[n] = o;
        }
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ s(() => r, "shape")
      });
    }
    keyof() {
      return xT(ne.util.objectKeys(this.shape));
    }
  };
  q.ZodObject = Gt;
  Gt.create = (e, t) => new Gt({
    shape: /* @__PURE__ */ s(() => e, "shape"),
    unknownKeys: "strip",
    catchall: zr.create(),
    typeName: ye.ZodObject,
    ...we(t)
  });
  Gt.strictCreate = (e, t) => new Gt({
    shape: /* @__PURE__ */ s(() => e, "shape"),
    unknownKeys: "strict",
    catchall: zr.create(),
    typeName: ye.ZodObject,
    ...we(t)
  });
  Gt.lazycreate = (e, t) => new Gt({
    shape: e,
    unknownKeys: "strip",
    catchall: zr.create(),
    typeName: ye.ZodObject,
    ...we(t)
  });
  var Qi = class extends Se {
    static {
      s(this, "ZodUnion");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), n = this._def.options;
      function i(o) {
        for (let u of o)
          if (u.result.status === "valid")
            return u.result;
        for (let u of o)
          if (u.result.status === "dirty")
            return r.common.issues.push(...u.ctx.common.issues), u.result;
        let a = o.map((u) => new te.ZodError(u.ctx.common.issues));
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_union,
          unionErrors: a
        }), V.INVALID;
      }
      if (s(i, "handleResults"), r.common.async)
        return Promise.all(n.map(async (o) => {
          let a = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await o._parseAsync({
              data: r.data,
              path: r.path,
              parent: a
            }),
            ctx: a
          };
        })).then(i);
      {
        let o, a = [];
        for (let l of n) {
          let c = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          }, p = l._parseSync({
            data: r.data,
            path: r.path,
            parent: c
          });
          if (p.status === "valid")
            return p;
          p.status === "dirty" && !o && (o = { result: p, ctx: c }), c.common.issues.length && a.push(c.common.issues);
        }
        if (o)
          return r.common.issues.push(...o.ctx.common.issues), o.result;
        let u = a.map((l) => new te.ZodError(l));
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_union,
          unionErrors: u
        }), V.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  q.ZodUnion = Qi;
  Qi.create = (e, t) => new Qi({
    options: e,
    typeName: ye.ZodUnion,
    ...we(t)
  });
  var Un = /* @__PURE__ */ s((e) => e instanceof ts ? Un(e.schema) : e instanceof tr ? Un(e.innerType()) : e instanceof rs ? [e.value] : e instanceof
  ns ? e.options : e instanceof is ? ne.util.objectValues(e.enum) : e instanceof ss ? Un(e._def.innerType) : e instanceof Ki ? [void 0] : e instanceof
  Yi ? [null] : e instanceof Er ? [void 0, ...Un(e.unwrap())] : e instanceof yn ? [null, ...Un(e.unwrap())] : e instanceof Za || e instanceof
  as ? Un(e.unwrap()) : e instanceof os ? Un(e._def.innerType) : [], "getDiscriminator"), Jc = class e extends Se {
    static {
      s(this, "ZodDiscriminatedUnion");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ne.ZodParsedType.object)
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.object,
          received: r.parsedType
        }), V.INVALID;
      let n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
      return o ? r.common.async ? o._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }) : o._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }) : ((0, V.addIssueToContext)(r, {
        code: te.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [n]
      }), V.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(t, r, n) {
      let i = /* @__PURE__ */ new Map();
      for (let o of r) {
        let a = Un(o.shape[t]);
        if (!a.length)
          throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
        for (let u of a) {
          if (i.has(u))
            throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);
          i.set(u, o);
        }
      }
      return new e({
        typeName: ye.ZodDiscriminatedUnion,
        discriminator: t,
        options: r,
        optionsMap: i,
        ...we(n)
      });
    }
  };
  q.ZodDiscriminatedUnion = Jc;
  function cy(e, t) {
    let r = (0, ne.getParsedType)(e), n = (0, ne.getParsedType)(t);
    if (e === t)
      return { valid: !0, data: e };
    if (r === ne.ZodParsedType.object && n === ne.ZodParsedType.object) {
      let i = ne.util.objectKeys(t), o = ne.util.objectKeys(e).filter((u) => i.indexOf(u) !== -1), a = { ...e, ...t };
      for (let u of o) {
        let l = cy(e[u], t[u]);
        if (!l.valid)
          return { valid: !1 };
        a[u] = l.data;
      }
      return { valid: !0, data: a };
    } else if (r === ne.ZodParsedType.array && n === ne.ZodParsedType.array) {
      if (e.length !== t.length)
        return { valid: !1 };
      let i = [];
      for (let o = 0; o < e.length; o++) {
        let a = e[o], u = t[o], l = cy(a, u);
        if (!l.valid)
          return { valid: !1 };
        i.push(l.data);
      }
      return { valid: !0, data: i };
    } else return r === ne.ZodParsedType.date && n === ne.ZodParsedType.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
  }
  s(cy, "mergeValues");
  var es = class extends Se {
    static {
      s(this, "ZodIntersection");
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t), i = /* @__PURE__ */ s((o, a) => {
        if ((0, V.isAborted)(o) || (0, V.isAborted)(a))
          return V.INVALID;
        let u = cy(o.value, a.value);
        return u.valid ? (((0, V.isDirty)(o) || (0, V.isDirty)(a)) && r.dirty(), { status: r.value, value: u.data }) : ((0, V.addIssueToContext)(
        n, {
          code: te.ZodIssueCode.invalid_intersection_types
        }), V.INVALID);
      }, "handleParsed");
      return n.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        }),
        this._def.right._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        })
      ]).then(([o, a]) => i(o, a)) : i(this._def.left._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      }), this._def.right._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      }));
    }
  };
  q.ZodIntersection = es;
  es.create = (e, t, r) => new es({
    left: e,
    right: t,
    typeName: ye.ZodIntersection,
    ...we(r)
  });
  var gn = class e extends Se {
    static {
      s(this, "ZodTuple");
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ne.ZodParsedType.array)
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.array,
          received: n.parsedType
        }), V.INVALID;
      if (n.data.length < this._def.items.length)
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), V.INVALID;
      !this._def.rest && n.data.length > this._def.items.length && ((0, V.addIssueToContext)(n, {
        code: te.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), r.dirty());
      let o = [...n.data].map((a, u) => {
        let l = this._def.items[u] || this._def.rest;
        return l ? l._parse(new Cr(n, a, n.path, u)) : null;
      }).filter((a) => !!a);
      return n.common.async ? Promise.all(o).then((a) => V.ParseStatus.mergeArray(r, a)) : V.ParseStatus.mergeArray(r, o);
    }
    get items() {
      return this._def.items;
    }
    rest(t) {
      return new e({
        ...this._def,
        rest: t
      });
    }
  };
  q.ZodTuple = gn;
  gn.create = (e, t) => {
    if (!Array.isArray(e))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new gn({
      items: e,
      typeName: ye.ZodTuple,
      rest: null,
      ...we(t)
    });
  };
  var Zc = class e extends Se {
    static {
      s(this, "ZodRecord");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ne.ZodParsedType.object)
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.object,
          received: n.parsedType
        }), V.INVALID;
      let i = [], o = this._def.keyType, a = this._def.valueType;
      for (let u in n.data)
        i.push({
          key: o._parse(new Cr(n, u, n.path, u)),
          value: a._parse(new Cr(n, n.data[u], n.path, u)),
          alwaysSet: u in n.data
        });
      return n.common.async ? V.ParseStatus.mergeObjectAsync(r, i) : V.ParseStatus.mergeObjectSync(r, i);
    }
    get element() {
      return this._def.valueType;
    }
    static create(t, r, n) {
      return r instanceof Se ? new e({
        keyType: t,
        valueType: r,
        typeName: ye.ZodRecord,
        ...we(n)
      }) : new e({
        keyType: mi.create(),
        valueType: t,
        typeName: ye.ZodRecord,
        ...we(r)
      });
    }
  };
  q.ZodRecord = Zc;
  var fo = class extends Se {
    static {
      s(this, "ZodMap");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ne.ZodParsedType.map)
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.map,
          received: n.parsedType
        }), V.INVALID;
      let i = this._def.keyType, o = this._def.valueType, a = [...n.data.entries()].map(([u, l], c) => ({
        key: i._parse(new Cr(n, u, n.path, [c, "key"])),
        value: o._parse(new Cr(n, l, n.path, [c, "value"]))
      }));
      if (n.common.async) {
        let u = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (let l of a) {
            let c = await l.key, p = await l.value;
            if (c.status === "aborted" || p.status === "aborted")
              return V.INVALID;
            (c.status === "dirty" || p.status === "dirty") && r.dirty(), u.set(c.value, p.value);
          }
          return { status: r.value, value: u };
        });
      } else {
        let u = /* @__PURE__ */ new Map();
        for (let l of a) {
          let c = l.key, p = l.value;
          if (c.status === "aborted" || p.status === "aborted")
            return V.INVALID;
          (c.status === "dirty" || p.status === "dirty") && r.dirty(), u.set(c.value, p.value);
        }
        return { status: r.value, value: u };
      }
    }
  };
  q.ZodMap = fo;
  fo.create = (e, t, r) => new fo({
    valueType: t,
    keyType: e,
    typeName: ye.ZodMap,
    ...we(r)
  });
  var mo = class e extends Se {
    static {
      s(this, "ZodSet");
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.parsedType !== ne.ZodParsedType.set)
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.set,
          received: n.parsedType
        }), V.INVALID;
      let i = this._def;
      i.minSize !== null && n.data.size < i.minSize.value && ((0, V.addIssueToContext)(n, {
        code: te.ZodIssueCode.too_small,
        minimum: i.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: i.minSize.message
      }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && ((0, V.addIssueToContext)(n, {
        code: te.ZodIssueCode.too_big,
        maximum: i.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: i.maxSize.message
      }), r.dirty());
      let o = this._def.valueType;
      function a(l) {
        let c = /* @__PURE__ */ new Set();
        for (let p of l) {
          if (p.status === "aborted")
            return V.INVALID;
          p.status === "dirty" && r.dirty(), c.add(p.value);
        }
        return { status: r.value, value: c };
      }
      s(a, "finalizeSet");
      let u = [...n.data.values()].map((l, c) => o._parse(new Cr(n, l, n.path, c)));
      return n.common.async ? Promise.all(u).then((l) => a(l)) : a(u);
    }
    min(t, r) {
      return new e({
        ...this._def,
        minSize: { value: t, message: ue.errorUtil.toString(r) }
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxSize: { value: t, message: ue.errorUtil.toString(r) }
      });
    }
    size(t, r) {
      return this.min(t, r).max(t, r);
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  q.ZodSet = mo;
  mo.create = (e, t) => new mo({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: ye.ZodSet,
    ...we(t)
  });
  var Xc = class e extends Se {
    static {
      s(this, "ZodFunction");
    }
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ne.ZodParsedType.function)
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.function,
          received: r.parsedType
        }), V.INVALID;
      function n(u, l) {
        return (0, V.makeIssue)({
          data: u,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, Hc.getErrorMap)(),
            Hc.defaultErrorMap
          ].filter((c) => !!c),
          issueData: {
            code: te.ZodIssueCode.invalid_arguments,
            argumentsError: l
          }
        });
      }
      s(n, "makeArgsIssue");
      function i(u, l) {
        return (0, V.makeIssue)({
          data: u,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, Hc.getErrorMap)(),
            Hc.defaultErrorMap
          ].filter((c) => !!c),
          issueData: {
            code: te.ZodIssueCode.invalid_return_type,
            returnTypeError: l
          }
        });
      }
      s(i, "makeReturnsIssue");
      let o = { errorMap: r.common.contextualErrorMap }, a = r.data;
      if (this._def.returns instanceof yi) {
        let u = this;
        return (0, V.OK)(async function(...l) {
          let c = new te.ZodError([]), p = await u._def.args.parseAsync(l, o).catch((d) => {
            throw c.addIssue(n(l, d)), c;
          }), h = await Reflect.apply(a, this, p);
          return await u._def.returns._def.type.parseAsync(h, o).catch((d) => {
            throw c.addIssue(i(h, d)), c;
          });
        });
      } else {
        let u = this;
        return (0, V.OK)(function(...l) {
          let c = u._def.args.safeParse(l, o);
          if (!c.success)
            throw new te.ZodError([n(l, c.error)]);
          let p = Reflect.apply(a, this, c.data), h = u._def.returns.safeParse(p, o);
          if (!h.success)
            throw new te.ZodError([i(p, h.error)]);
          return h.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...t) {
      return new e({
        ...this._def,
        args: gn.create(t).rest(Wn.create())
      });
    }
    returns(t) {
      return new e({
        ...this._def,
        returns: t
      });
    }
    implement(t) {
      return this.parse(t);
    }
    strictImplement(t) {
      return this.parse(t);
    }
    static create(t, r, n) {
      return new e({
        args: t || gn.create([]).rest(Wn.create()),
        returns: r || Wn.create(),
        typeName: ye.ZodFunction,
        ...we(n)
      });
    }
  };
  q.ZodFunction = Xc;
  var ts = class extends Se {
    static {
      s(this, "ZodLazy");
    }
    get schema() {
      return this._def.getter();
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
    }
  };
  q.ZodLazy = ts;
  ts.create = (e, t) => new ts({
    getter: e,
    typeName: ye.ZodLazy,
    ...we(t)
  });
  var rs = class extends Se {
    static {
      s(this, "ZodLiteral");
    }
    _parse(t) {
      if (t.data !== this._def.value) {
        let r = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(r, {
          received: r.data,
          code: te.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), V.INVALID;
      }
      return { status: "valid", value: t.data };
    }
    get value() {
      return this._def.value;
    }
  };
  q.ZodLiteral = rs;
  rs.create = (e, t) => new rs({
    value: e,
    typeName: ye.ZodLiteral,
    ...we(t)
  });
  function xT(e, t) {
    return new ns({
      values: e,
      typeName: ye.ZodEnum,
      ...we(t)
    });
  }
  s(xT, "createZodEnum");
  var ns = class e extends Se {
    static {
      s(this, "ZodEnum");
    }
    constructor() {
      super(...arguments), Ga.set(this, void 0);
    }
    _parse(t) {
      if (typeof t.data != "string") {
        let r = this._getOrReturnCtx(t), n = this._def.values;
        return (0, V.addIssueToContext)(r, {
          expected: ne.util.joinValues(n),
          received: r.parsedType,
          code: te.ZodIssueCode.invalid_type
        }), V.INVALID;
      }
      if (Gc(this, Ga, "f") || mT(this, Ga, new Set(this._def.values), "f"), !Gc(this, Ga, "f").has(t.data)) {
        let r = this._getOrReturnCtx(t), n = this._def.values;
        return (0, V.addIssueToContext)(r, {
          received: r.data,
          code: te.ZodIssueCode.invalid_enum_value,
          options: n
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    get Values() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    get Enum() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    extract(t, r = this._def) {
      return e.create(t, {
        ...this._def,
        ...r
      });
    }
    exclude(t, r = this._def) {
      return e.create(this.options.filter((n) => !t.includes(n)), {
        ...this._def,
        ...r
      });
    }
  };
  q.ZodEnum = ns;
  Ga = /* @__PURE__ */ new WeakMap();
  ns.create = xT;
  var is = class extends Se {
    static {
      s(this, "ZodNativeEnum");
    }
    constructor() {
      super(...arguments), Ja.set(this, void 0);
    }
    _parse(t) {
      let r = ne.util.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
      if (n.parsedType !== ne.ZodParsedType.string && n.parsedType !== ne.ZodParsedType.number) {
        let i = ne.util.objectValues(r);
        return (0, V.addIssueToContext)(n, {
          expected: ne.util.joinValues(i),
          received: n.parsedType,
          code: te.ZodIssueCode.invalid_type
        }), V.INVALID;
      }
      if (Gc(this, Ja, "f") || mT(this, Ja, new Set(ne.util.getValidEnumValues(this._def.values)), "f"), !Gc(this, Ja, "f").has(t.data)) {
        let i = ne.util.objectValues(r);
        return (0, V.addIssueToContext)(n, {
          received: n.data,
          code: te.ZodIssueCode.invalid_enum_value,
          options: i
        }), V.INVALID;
      }
      return (0, V.OK)(t.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  q.ZodNativeEnum = is;
  Ja = /* @__PURE__ */ new WeakMap();
  is.create = (e, t) => new is({
    values: e,
    typeName: ye.ZodNativeEnum,
    ...we(t)
  });
  var yi = class extends Se {
    static {
      s(this, "ZodPromise");
    }
    unwrap() {
      return this._def.type;
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ne.ZodParsedType.promise && r.common.async === !1)
        return (0, V.addIssueToContext)(r, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.promise,
          received: r.parsedType
        }), V.INVALID;
      let n = r.parsedType === ne.ZodParsedType.promise ? r.data : Promise.resolve(r.data);
      return (0, V.OK)(n.then((i) => this._def.type.parseAsync(i, {
        path: r.path,
        errorMap: r.common.contextualErrorMap
      })));
    }
  };
  q.ZodPromise = yi;
  yi.create = (e, t) => new yi({
    type: e,
    typeName: ye.ZodPromise,
    ...we(t)
  });
  var tr = class extends Se {
    static {
      s(this, "ZodEffects");
    }
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ye.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null, o = {
        addIssue: /* @__PURE__ */ s((a) => {
          (0, V.addIssueToContext)(n, a), a.fatal ? r.abort() : r.dirty();
        }, "addIssue"),
        get path() {
          return n.path;
        }
      };
      if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
        let a = i.transform(n.data, o);
        if (n.common.async)
          return Promise.resolve(a).then(async (u) => {
            if (r.value === "aborted")
              return V.INVALID;
            let l = await this._def.schema._parseAsync({
              data: u,
              path: n.path,
              parent: n
            });
            return l.status === "aborted" ? V.INVALID : l.status === "dirty" || r.value === "dirty" ? (0, V.DIRTY)(l.value) : l;
          });
        {
          if (r.value === "aborted")
            return V.INVALID;
          let u = this._def.schema._parseSync({
            data: a,
            path: n.path,
            parent: n
          });
          return u.status === "aborted" ? V.INVALID : u.status === "dirty" || r.value === "dirty" ? (0, V.DIRTY)(u.value) : u;
        }
      }
      if (i.type === "refinement") {
        let a = /* @__PURE__ */ s((u) => {
          let l = i.refinement(u, o);
          if (n.common.async)
            return Promise.resolve(l);
          if (l instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return u;
        }, "executeRefinement");
        if (n.common.async === !1) {
          let u = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n
          });
          return u.status === "aborted" ? V.INVALID : (u.status === "dirty" && r.dirty(), a(u.value), { status: r.value, value: u.value });
        } else
          return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((u) => u.status === "aborted" ? V.INVALID : (u.
          status === "dirty" && r.dirty(), a(u.value).then(() => ({ status: r.value, value: u.value }))));
      }
      if (i.type === "transform")
        if (n.common.async === !1) {
          let a = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n
          });
          if (!(0, V.isValid)(a))
            return a;
          let u = i.transform(a.value, o);
          if (u instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: r.value, value: u };
        } else
          return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => (0, V.isValid)(a) ? Promise.resolve(i.transform(
          a.value, o)).then((u) => ({ status: r.value, value: u })) : a);
      ne.util.assertNever(i);
    }
  };
  q.ZodEffects = tr;
  q.ZodTransformer = tr;
  tr.create = (e, t, r) => new tr({
    schema: e,
    typeName: ye.ZodEffects,
    effect: t,
    ...we(r)
  });
  tr.createWithPreprocess = (e, t, r) => new tr({
    schema: t,
    effect: { type: "preprocess", transform: e },
    typeName: ye.ZodEffects,
    ...we(r)
  });
  var Er = class extends Se {
    static {
      s(this, "ZodOptional");
    }
    _parse(t) {
      return this._getType(t) === ne.ZodParsedType.undefined ? (0, V.OK)(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  q.ZodOptional = Er;
  Er.create = (e, t) => new Er({
    innerType: e,
    typeName: ye.ZodOptional,
    ...we(t)
  });
  var yn = class extends Se {
    static {
      s(this, "ZodNullable");
    }
    _parse(t) {
      return this._getType(t) === ne.ZodParsedType.null ? (0, V.OK)(null) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  q.ZodNullable = yn;
  yn.create = (e, t) => new yn({
    innerType: e,
    typeName: ye.ZodNullable,
    ...we(t)
  });
  var ss = class extends Se {
    static {
      s(this, "ZodDefault");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), n = r.data;
      return r.parsedType === ne.ZodParsedType.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
        data: n,
        path: r.path,
        parent: r
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  q.ZodDefault = ss;
  ss.create = (e, t) => new ss({
    innerType: e,
    typeName: ye.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...we(t)
  });
  var os = class extends Se {
    static {
      s(this, "ZodCatch");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), n = {
        ...r,
        common: {
          ...r.common,
          issues: []
        }
      }, i = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: {
          ...n
        }
      });
      return (0, V.isAsync)(i) ? i.then((o) => ({
        status: "valid",
        value: o.status === "valid" ? o.value : this._def.catchValue({
          get error() {
            return new te.ZodError(n.common.issues);
          },
          input: n.data
        })
      })) : {
        status: "valid",
        value: i.status === "valid" ? i.value : this._def.catchValue({
          get error() {
            return new te.ZodError(n.common.issues);
          },
          input: n.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  q.ZodCatch = os;
  os.create = (e, t) => new os({
    innerType: e,
    typeName: ye.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...we(t)
  });
  var go = class extends Se {
    static {
      s(this, "ZodNaN");
    }
    _parse(t) {
      if (this._getType(t) !== ne.ZodParsedType.nan) {
        let n = this._getOrReturnCtx(t);
        return (0, V.addIssueToContext)(n, {
          code: te.ZodIssueCode.invalid_type,
          expected: ne.ZodParsedType.nan,
          received: n.parsedType
        }), V.INVALID;
      }
      return { status: "valid", value: t.data };
    }
  };
  q.ZodNaN = go;
  go.create = (e) => new go({
    typeName: ye.ZodNaN,
    ...we(e)
  });
  q.BRAND = Symbol("zod_brand");
  var Za = class extends Se {
    static {
      s(this, "ZodBranded");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), n = r.data;
      return this._def.type._parse({
        data: n,
        path: r.path,
        parent: r
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  q.ZodBranded = Za;
  var Xa = class e extends Se {
    static {
      s(this, "ZodPipeline");
    }
    _parse(t) {
      let { status: r, ctx: n } = this._processInputParams(t);
      if (n.common.async)
        return (/* @__PURE__ */ s(async () => {
          let o = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
          });
          return o.status === "aborted" ? V.INVALID : o.status === "dirty" ? (r.dirty(), (0, V.DIRTY)(o.value)) : this._def.out._parseAsync(
          {
            data: o.value,
            path: n.path,
            parent: n
          });
        }, "handleAsync"))();
      {
        let i = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? V.INVALID : i.status === "dirty" ? (r.dirty(), {
          status: "dirty",
          value: i.value
        }) : this._def.out._parseSync({
          data: i.value,
          path: n.path,
          parent: n
        });
      }
    }
    static create(t, r) {
      return new e({
        in: t,
        out: r,
        typeName: ye.ZodPipeline
      });
    }
  };
  q.ZodPipeline = Xa;
  var as = class extends Se {
    static {
      s(this, "ZodReadonly");
    }
    _parse(t) {
      let r = this._def.innerType._parse(t), n = /* @__PURE__ */ s((i) => ((0, V.isValid)(i) && (i.value = Object.freeze(i.value)), i), "fre\
eze");
      return (0, V.isAsync)(r) ? r.then((i) => n(i)) : n(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  q.ZodReadonly = as;
  as.create = (e, t) => new as({
    innerType: e,
    typeName: ye.ZodReadonly,
    ...we(t)
  });
  function dT(e, t) {
    let r = typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e;
    return typeof r == "string" ? { message: r } : r;
  }
  s(dT, "cleanParams");
  function bT(e, t = {}, r) {
    return e ? gi.create().superRefine((n, i) => {
      var o, a;
      let u = e(n);
      if (u instanceof Promise)
        return u.then((l) => {
          var c, p;
          if (!l) {
            let h = dT(t, n), f = (p = (c = h.fatal) !== null && c !== void 0 ? c : r) !== null && p !== void 0 ? p : !0;
            i.addIssue({ code: "custom", ...h, fatal: f });
          }
        });
      if (!u) {
        let l = dT(t, n), c = (a = (o = l.fatal) !== null && o !== void 0 ? o : r) !== null && a !== void 0 ? a : !0;
        i.addIssue({ code: "custom", ...l, fatal: c });
      }
    }) : gi.create();
  }
  s(bT, "custom");
  q.custom = bT;
  q.late = {
    object: Gt.lazycreate
  };
  var ye;
  (function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate =
    "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUn\
known", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion =
    "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap",
    e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects =
    "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefaul\
t", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodRe\
adonly";
  })(ye || (q.ZodFirstPartyTypeKind = ye = {}));
  var KX = /* @__PURE__ */ s((e, t = {
    message: `Input not instance of ${e.name}`
  }) => bT((r) => r instanceof e, t), "instanceOfType");
  q.instanceof = KX;
  var vT = mi.create;
  q.string = vT;
  var ET = Gi.create;
  q.number = ET;
  var YX = go.create;
  q.nan = YX;
  var QX = Ji.create;
  q.bigint = QX;
  var CT = Zi.create;
  q.boolean = CT;
  var eK = Xi.create;
  q.date = eK;
  var tK = po.create;
  q.symbol = tK;
  var rK = Ki.create;
  q.undefined = rK;
  var nK = Yi.create;
  q.null = nK;
  var iK = gi.create;
  q.any = iK;
  var sK = Wn.create;
  q.unknown = sK;
  var oK = zr.create;
  q.never = oK;
  var aK = ho.create;
  q.void = aK;
  var uK = zn.create;
  q.array = uK;
  var lK = Gt.create;
  q.object = lK;
  var cK = Gt.strictCreate;
  q.strictObject = cK;
  var pK = Qi.create;
  q.union = pK;
  var hK = Jc.create;
  q.discriminatedUnion = hK;
  var fK = es.create;
  q.intersection = fK;
  var dK = gn.create;
  q.tuple = dK;
  var mK = Zc.create;
  q.record = mK;
  var gK = fo.create;
  q.map = gK;
  var yK = mo.create;
  q.set = yK;
  var DK = Xc.create;
  q.function = DK;
  var xK = ts.create;
  q.lazy = xK;
  var bK = rs.create;
  q.literal = bK;
  var vK = ns.create;
  q.enum = vK;
  var EK = is.create;
  q.nativeEnum = EK;
  var CK = yi.create;
  q.promise = CK;
  var wT = tr.create;
  q.effect = wT;
  q.transformer = wT;
  var wK = Er.create;
  q.optional = wK;
  var SK = yn.create;
  q.nullable = SK;
  var AK = tr.createWithPreprocess;
  q.preprocess = AK;
  var FK = Xa.create;
  q.pipeline = FK;
  var _K = /* @__PURE__ */ s(() => vT().optional(), "ostring");
  q.ostring = _K;
  var kK = /* @__PURE__ */ s(() => ET().optional(), "onumber");
  q.onumber = kK;
  var TK = /* @__PURE__ */ s(() => CT().optional(), "oboolean");
  q.oboolean = TK;
  q.coerce = {
    string: /* @__PURE__ */ s((e) => mi.create({ ...e, coerce: !0 }), "string"),
    number: /* @__PURE__ */ s((e) => Gi.create({ ...e, coerce: !0 }), "number"),
    boolean: /* @__PURE__ */ s((e) => Zi.create({
      ...e,
      coerce: !0
    }), "boolean"),
    bigint: /* @__PURE__ */ s((e) => Ji.create({ ...e, coerce: !0 }), "bigint"),
    date: /* @__PURE__ */ s((e) => Xi.create({ ...e, coerce: !0 }), "date")
  };
  q.NEVER = V.INVALID;
});

// ../node_modules/zod/lib/external.js
var py = I((wr) => {
  "use strict";
  var IK = wr && wr.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, n, i);
  } : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
  }), yo = wr && wr.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && IK(t, e, r);
  };
  Object.defineProperty(wr, "__esModule", { value: !0 });
  yo(Wc(), wr);
  yo(uy(), wr);
  yo(cT(), wr);
  yo(za(), wr);
  yo(ST(), wr);
  yo(Uc(), wr);
});

// ../node_modules/zod/lib/index.js
var _T = I((Jt) => {
  "use strict";
  var AT = Jt && Jt.__createBinding || (Object.create ? function(e, t, r, n) {
    n === void 0 && (n = r);
    var i = Object.getOwnPropertyDescriptor(t, r);
    (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: /* @__PURE__ */ s(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, n, i);
  } : function(e, t, r, n) {
    n === void 0 && (n = r), e[n] = t[r];
  }), PK = Jt && Jt.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), BK = Jt && Jt.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && AT(t, e, r);
    return PK(t, e), t;
  }, OK = Jt && Jt.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && AT(t, e, r);
  };
  Object.defineProperty(Jt, "__esModule", { value: !0 });
  Jt.z = void 0;
  var FT = BK(py());
  Jt.z = FT;
  OK(py(), Jt);
  Jt.default = FT;
});

// ../node_modules/isexe/windows.js
var NT = I((xme, RT) => {
  RT.exports = OT;
  OT.sync = MK;
  var PT = require("fs");
  function jK(e, t) {
    var r = t.pathExt !== void 0 ? t.pathExt : process.env.PATHEXT;
    if (!r || (r = r.split(";"), r.indexOf("") !== -1))
      return !0;
    for (var n = 0; n < r.length; n++) {
      var i = r[n].toLowerCase();
      if (i && e.substr(-i.length).toLowerCase() === i)
        return !0;
    }
    return !1;
  }
  s(jK, "checkPathExt");
  function BT(e, t, r) {
    return !e.isSymbolicLink() && !e.isFile() ? !1 : jK(t, r);
  }
  s(BT, "checkStat");
  function OT(e, t, r) {
    PT.stat(e, function(n, i) {
      r(n, n ? !1 : BT(i, e, t));
    });
  }
  s(OT, "isexe");
  function MK(e, t) {
    return BT(PT.statSync(e), e, t);
  }
  s(MK, "sync");
});

// ../node_modules/isexe/mode.js
var $T = I((vme, qT) => {
  qT.exports = jT;
  jT.sync = qK;
  var LT = require("fs");
  function jT(e, t, r) {
    LT.stat(e, function(n, i) {
      r(n, n ? !1 : MT(i, t));
    });
  }
  s(jT, "isexe");
  function qK(e, t) {
    return MT(LT.statSync(e), t);
  }
  s(qK, "sync");
  function MT(e, t) {
    return e.isFile() && $K(e, t);
  }
  s(MT, "checkStat");
  function $K(e, t) {
    var r = e.mode, n = e.uid, i = e.gid, o = t.uid !== void 0 ? t.uid : process.getuid && process.getuid(), a = t.gid !== void 0 ? t.gid : process.
    getgid && process.getgid(), u = parseInt("100", 8), l = parseInt("010", 8), c = parseInt("001", 8), p = u | l, h = r & c || r & l && i ===
    a || r & u && n === o || r & p && o === 0;
    return h;
  }
  s($K, "checkMode");
});

// ../node_modules/isexe/index.js
var UT = I((wme, VT) => {
  var Cme = require("fs"), ep;
  process.platform === "win32" || global.TESTING_WINDOWS ? ep = NT() : ep = $T();
  VT.exports = hy;
  hy.sync = VK;
  function hy(e, t, r) {
    if (typeof t == "function" && (r = t, t = {}), !r) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(n, i) {
        hy(e, t || {}, function(o, a) {
          o ? i(o) : n(a);
        });
      });
    }
    ep(e, t || {}, function(n, i) {
      n && (n.code === "EACCES" || t && t.ignoreErrors) && (n = null, i = !1), r(n, i);
    });
  }
  s(hy, "isexe");
  function VK(e, t) {
    try {
      return ep.sync(e, t || {});
    } catch (r) {
      if (t && t.ignoreErrors || r.code === "EACCES")
        return !1;
      throw r;
    }
  }
  s(VK, "sync");
});

// ../node_modules/which/which.js
var XT = I((Ame, ZT) => {
  var bo = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", WT = require("path"), UK = bo ?
  ";" : ":", zT = UT(), HT = /* @__PURE__ */ s((e) => Object.assign(new Error(`not found: ${e}`), { code: "ENOENT" }), "getNotFoundError"), GT = /* @__PURE__ */ s(
  (e, t) => {
    let r = t.colon || UK, n = e.match(/\//) || bo && e.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...bo ? [process.cwd()] : [],
      ...(t.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(r)
    ], i = bo ? t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = bo ? i.split(r) : [""];
    return bo && e.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
      pathEnv: n,
      pathExt: o,
      pathExtExe: i
    };
  }, "getPathInfo"), JT = /* @__PURE__ */ s((e, t, r) => {
    typeof t == "function" && (r = t, t = {}), t || (t = {});
    let { pathEnv: n, pathExt: i, pathExtExe: o } = GT(e, t), a = [], u = /* @__PURE__ */ s((c) => new Promise((p, h) => {
      if (c === n.length)
        return t.all && a.length ? p(a) : h(HT(e));
      let f = n[c], d = /^".*"$/.test(f) ? f.slice(1, -1) : f, m = WT.join(d, e), g = !d && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + m : m;
      p(l(g, c, 0));
    }), "step"), l = /* @__PURE__ */ s((c, p, h) => new Promise((f, d) => {
      if (h === i.length)
        return f(u(p + 1));
      let m = i[h];
      zT(c + m, { pathExt: o }, (g, b) => {
        if (!g && b)
          if (t.all)
            a.push(c + m);
          else
            return f(c + m);
        return f(l(c, p, h + 1));
      });
    }), "subStep");
    return r ? u(0).then((c) => r(null, c), r) : u(0);
  }, "which"), WK = /* @__PURE__ */ s((e, t) => {
    t = t || {};
    let { pathEnv: r, pathExt: n, pathExtExe: i } = GT(e, t), o = [];
    for (let a = 0; a < r.length; a++) {
      let u = r[a], l = /^".*"$/.test(u) ? u.slice(1, -1) : u, c = WT.join(l, e), p = !l && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + c : c;
      for (let h = 0; h < n.length; h++) {
        let f = p + n[h];
        try {
          if (zT.sync(f, { pathExt: i }))
            if (t.all)
              o.push(f);
            else
              return f;
        } catch {
        }
      }
    }
    if (t.all && o.length)
      return o;
    if (t.nothrow)
      return null;
    throw HT(e);
  }, "whichSync");
  ZT.exports = JT;
  JT.sync = WK;
});

// ../node_modules/path-key/index.js
var YT = I((_me, fy) => {
  "use strict";
  var KT = /* @__PURE__ */ s((e = {}) => {
    let t = e.env || process.env;
    return (e.platform || process.platform) !== "win32" ? "PATH" : Object.keys(t).reverse().find((n) => n.toUpperCase() === "PATH") || "Path";
  }, "pathKey");
  fy.exports = KT;
  fy.exports.default = KT;
});

// ../node_modules/cross-spawn/lib/util/resolveCommand.js
var rI = I((Tme, tI) => {
  "use strict";
  var QT = require("path"), zK = XT(), HK = YT();
  function eI(e, t) {
    let r = e.options.env || process.env, n = process.cwd(), i = e.options.cwd != null, o = i && process.chdir !== void 0 && !process.chdir.
    disabled;
    if (o)
      try {
        process.chdir(e.options.cwd);
      } catch {
      }
    let a;
    try {
      a = zK.sync(e.command, {
        path: r[HK({ env: r })],
        pathExt: t ? QT.delimiter : void 0
      });
    } catch {
    } finally {
      o && process.chdir(n);
    }
    return a && (a = QT.resolve(i ? e.options.cwd : "", a)), a;
  }
  s(eI, "resolveCommandAttempt");
  function GK(e) {
    return eI(e) || eI(e, !0);
  }
  s(GK, "resolveCommand");
  tI.exports = GK;
});

// ../node_modules/cross-spawn/lib/util/escape.js
var nI = I((Pme, my) => {
  "use strict";
  var dy = /([()\][%!^"`<>&|;, *?])/g;
  function JK(e) {
    return e = e.replace(dy, "^$1"), e;
  }
  s(JK, "escapeCommand");
  function ZK(e, t) {
    return e = `${e}`, e = e.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), e = e.replace(/(?=(\\+?)?)\1$/, "$1$1"), e = `"${e}"`, e = e.replace(dy,
    "^$1"), t && (e = e.replace(dy, "^$1")), e;
  }
  s(ZK, "escapeArgument");
  my.exports.command = JK;
  my.exports.argument = ZK;
});

// ../node_modules/shebang-regex/index.js
var sI = I((Ome, iI) => {
  "use strict";
  iI.exports = /^#!(.*)/;
});

// ../node_modules/shebang-command/index.js
var aI = I((Rme, oI) => {
  "use strict";
  var XK = sI();
  oI.exports = (e = "") => {
    let t = e.match(XK);
    if (!t)
      return null;
    let [r, n] = t[0].replace(/#! ?/, "").split(" "), i = r.split("/").pop();
    return i === "env" ? n : n ? `${i} ${n}` : i;
  };
});

// ../node_modules/cross-spawn/lib/util/readShebang.js
var lI = I((Nme, uI) => {
  "use strict";
  var gy = require("fs"), KK = aI();
  function YK(e) {
    let r = Buffer.alloc(150), n;
    try {
      n = gy.openSync(e, "r"), gy.readSync(n, r, 0, 150, 0), gy.closeSync(n);
    } catch {
    }
    return KK(r.toString());
  }
  s(YK, "readShebang");
  uI.exports = YK;
});

// ../node_modules/cross-spawn/lib/parse.js
var fI = I((jme, hI) => {
  "use strict";
  var QK = require("path"), cI = rI(), pI = nI(), eY = lI(), tY = process.platform === "win32", rY = /\.(?:com|exe)$/i, nY = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function iY(e) {
    e.file = cI(e);
    let t = e.file && eY(e.file);
    return t ? (e.args.unshift(e.file), e.command = t, cI(e)) : e.file;
  }
  s(iY, "detectShebang");
  function sY(e) {
    if (!tY)
      return e;
    let t = iY(e), r = !rY.test(t);
    if (e.options.forceShell || r) {
      let n = nY.test(t);
      e.command = QK.normalize(e.command), e.command = pI.command(e.command), e.args = e.args.map((o) => pI.argument(o, n));
      let i = [e.command].concat(e.args).join(" ");
      e.args = ["/d", "/s", "/c", `"${i}"`], e.command = process.env.comspec || "cmd.exe", e.options.windowsVerbatimArguments = !0;
    }
    return e;
  }
  s(sY, "parseNonShell");
  function oY(e, t, r) {
    t && !Array.isArray(t) && (r = t, t = null), t = t ? t.slice(0) : [], r = Object.assign({}, r);
    let n = {
      command: e,
      args: t,
      options: r,
      file: void 0,
      original: {
        command: e,
        args: t
      }
    };
    return r.shell ? n : sY(n);
  }
  s(oY, "parse");
  hI.exports = oY;
});

// ../node_modules/cross-spawn/lib/enoent.js
var gI = I((qme, mI) => {
  "use strict";
  var yy = process.platform === "win32";
  function Dy(e, t) {
    return Object.assign(new Error(`${t} ${e.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${t} ${e.command}`,
      path: e.command,
      spawnargs: e.args
    });
  }
  s(Dy, "notFoundError");
  function aY(e, t) {
    if (!yy)
      return;
    let r = e.emit;
    e.emit = function(n, i) {
      if (n === "exit") {
        let o = dI(i, t);
        if (o)
          return r.call(e, "error", o);
      }
      return r.apply(e, arguments);
    };
  }
  s(aY, "hookChildProcess");
  function dI(e, t) {
    return yy && e === 1 && !t.file ? Dy(t.original, "spawn") : null;
  }
  s(dI, "verifyENOENT");
  function uY(e, t) {
    return yy && e === 1 && !t.file ? Dy(t.original, "spawnSync") : null;
  }
  s(uY, "verifyENOENTSync");
  mI.exports = {
    hookChildProcess: aY,
    verifyENOENT: dI,
    verifyENOENTSync: uY,
    notFoundError: Dy
  };
});

// ../node_modules/cross-spawn/index.js
var xI = I((Vme, vo) => {
  "use strict";
  var yI = require("child_process"), xy = fI(), by = gI();
  function DI(e, t, r) {
    let n = xy(e, t, r), i = yI.spawn(n.command, n.args, n.options);
    return by.hookChildProcess(i, n), i;
  }
  s(DI, "spawn");
  function lY(e, t, r) {
    let n = xy(e, t, r), i = yI.spawnSync(n.command, n.args, n.options);
    return i.error = i.error || by.verifyENOENTSync(i.status, n), i;
  }
  s(lY, "spawnSync");
  vo.exports = DI;
  vo.exports.spawn = DI;
  vo.exports.sync = lY;
  vo.exports._parse = xy;
  vo.exports._enoent = by;
});

// ../node_modules/merge-stream/index.js
var KI = I((s0e, XI) => {
  "use strict";
  var { PassThrough: tQ } = require("stream");
  XI.exports = function() {
    var e = [], t = new tQ({ objectMode: !0 });
    return t.setMaxListeners(0), t.add = r, t.isEmpty = n, t.on("unpipe", i), Array.prototype.slice.call(arguments).forEach(r), t;
    function r(o) {
      return Array.isArray(o) ? (o.forEach(r), this) : (e.push(o), o.once("end", i.bind(null, o)), o.once("error", t.emit.bind(t, "error")),
      o.pipe(t, { end: !1 }), this);
    }
    s(r, "add");
    function n() {
      return e.length == 0;
    }
    s(n, "isEmpty");
    function i(o) {
      e = e.filter(function(a) {
        return a !== o;
      }), !e.length && t.readable && t.end();
    }
    s(i, "remove");
  };
});

// ../node_modules/common-path-prefix/index.js
var AP = I((L0e, SP) => {
  "use strict";
  var { sep: mQ } = require("path"), gQ = /* @__PURE__ */ s((e) => {
    for (let t of e) {
      let r = /(\/|\\)/.exec(t);
      if (r !== null) return r[0];
    }
    return mQ;
  }, "determineSeparator");
  SP.exports = /* @__PURE__ */ s(function(t, r = gQ(t)) {
    let [n = "", ...i] = t;
    if (n === "" || i.length === 0) return "";
    let o = n.split(r), a = o.length;
    for (let l of i) {
      let c = l.split(r);
      for (let p = 0; p < a; p++)
        c[p] !== o[p] && (a = p);
      if (a === 0) return "";
    }
    let u = o.slice(0, a).join(r);
    return u.endsWith(r) ? u : u + r;
  }, "commonPathPrefix");
});

// ../node_modules/fetch-retry/index.js
var uB = I((exe, aB) => {
  "use strict";
  aB.exports = function(e, t) {
    if (t = t || {}, typeof e != "function")
      throw new xi("fetch must be a function");
    if (typeof t != "object")
      throw new xi("defaults must be an object");
    if (t.retries !== void 0 && !wp(t.retries))
      throw new xi("retries must be a positive integer");
    if (t.retryDelay !== void 0 && !wp(t.retryDelay) && typeof t.retryDelay != "function")
      throw new xi("retryDelay must be a positive integer or a function returning a positive integer");
    if (t.retryOn !== void 0 && !Array.isArray(t.retryOn) && typeof t.retryOn != "function")
      throw new xi("retryOn property expects an array or function");
    var r = {
      retries: 3,
      retryDelay: 1e3,
      retryOn: []
    };
    return t = Object.assign(r, t), /* @__PURE__ */ s(function(i, o) {
      var a = t.retries, u = t.retryDelay, l = t.retryOn;
      if (o && o.retries !== void 0)
        if (wp(o.retries))
          a = o.retries;
        else
          throw new xi("retries must be a positive integer");
      if (o && o.retryDelay !== void 0)
        if (wp(o.retryDelay) || typeof o.retryDelay == "function")
          u = o.retryDelay;
        else
          throw new xi("retryDelay must be a positive integer or a function returning a positive integer");
      if (o && o.retryOn)
        if (Array.isArray(o.retryOn) || typeof o.retryOn == "function")
          l = o.retryOn;
        else
          throw new xi("retryOn property expects an array or function");
      return new Promise(function(c, p) {
        var h = /* @__PURE__ */ s(function(d) {
          var m = typeof Request < "u" && i instanceof Request ? i.clone() : i;
          e(m, o).then(function(g) {
            if (Array.isArray(l) && l.indexOf(g.status) === -1)
              c(g);
            else if (typeof l == "function")
              try {
                return Promise.resolve(l(d, null, g)).then(function(b) {
                  b ? f(d, null, g) : c(g);
                }).catch(p);
              } catch (b) {
                p(b);
              }
            else
              d < a ? f(d, null, g) : c(g);
          }).catch(function(g) {
            if (typeof l == "function")
              try {
                Promise.resolve(l(d, g, null)).then(function(b) {
                  b ? f(d, g, null) : p(g);
                }).catch(function(b) {
                  p(b);
                });
              } catch (b) {
                p(b);
              }
            else d < a ? f(d, g, null) : p(g);
          });
        }, "wrappedFetch");
        function f(d, m, g) {
          var b = typeof u == "function" ? u(d, m, g) : u;
          setTimeout(function() {
            h(++d);
          }, b);
        }
        s(f, "retry"), h(0);
      });
    }, "fetchRetry");
  };
  function wp(e) {
    return Number.isInteger(e) && e >= 0;
  }
  s(wp, "isPositiveInteger");
  function xi(e) {
    this.name = "ArgumentError", this.message = e;
  }
  s(xi, "ArgumentError");
});

// ../node_modules/telejson/dist/index.js
var sO = I((Jxe, iO) => {
  "use strict";
  var QQ = Object.create, kp = Object.defineProperty, eee = Object.getOwnPropertyDescriptor, RB = Object.getOwnPropertyNames, tee = Object.getPrototypeOf,
  ree = Object.prototype.hasOwnProperty, _e = /* @__PURE__ */ s((e, t) => /* @__PURE__ */ s(function() {
    return t || (0, e[RB(e)[0]])((t = { exports: {} }).exports, t), t.exports;
  }, "__require"), "__commonJS"), nee = /* @__PURE__ */ s((e, t) => {
    for (var r in t)
      kp(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), NB = /* @__PURE__ */ s((e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of RB(t))
        !ree.call(e, i) && i !== r && kp(e, i, { get: /* @__PURE__ */ s(() => t[i], "get"), enumerable: !(n = eee(t, i)) || n.enumerable });
    return e;
  }, "__copyProps"), cD = /* @__PURE__ */ s((e, t, r) => (r = e != null ? QQ(tee(e)) : {}, NB(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    t || !e || !e.__esModule ? kp(r, "default", { value: e, enumerable: !0 }) : r,
    e
  )), "__toESM"), iee = /* @__PURE__ */ s((e) => NB(kp({}, "__esModule", { value: !0 }), e), "__toCommonJS"), LB = _e({
    "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(e, t) {
      "use strict";
      t.exports = Object;
    }
  }), see = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(e, t) {
      "use strict";
      t.exports = Error;
    }
  }), oee = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(e, t) {
      "use strict";
      t.exports = EvalError;
    }
  }), aee = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(e, t) {
      "use strict";
      t.exports = RangeError;
    }
  }), uee = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(e, t) {
      "use strict";
      t.exports = ReferenceError;
    }
  }), lee = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(e, t) {
      "use strict";
      t.exports = SyntaxError;
    }
  }), pD = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(e, t) {
      "use strict";
      t.exports = TypeError;
    }
  }), cee = _e({
    "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(e, t) {
      "use strict";
      t.exports = URIError;
    }
  }), pee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(e, t) {
      "use strict";
      t.exports = Math.abs;
    }
  }), hee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(e, t) {
      "use strict";
      t.exports = Math.floor;
    }
  }), fee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(e, t) {
      "use strict";
      t.exports = Math.max;
    }
  }), dee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(e, t) {
      "use strict";
      t.exports = Math.min;
    }
  }), mee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(e, t) {
      "use strict";
      t.exports = Math.pow;
    }
  }), gee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(e, t) {
      "use strict";
      t.exports = Math.round;
    }
  }), yee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(e, t) {
      "use strict";
      t.exports = Number.isNaN || /* @__PURE__ */ s(function(n) {
        return n !== n;
      }, "isNaN2");
    }
  }), Dee = _e({
    "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(e, t) {
      "use strict";
      var r = yee();
      t.exports = /* @__PURE__ */ s(function(i) {
        return r(i) || i === 0 ? i : i < 0 ? -1 : 1;
      }, "sign");
    }
  }), xee = _e({
    "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(e, t) {
      "use strict";
      t.exports = Object.getOwnPropertyDescriptor;
    }
  }), hD = _e({
    "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(e, t) {
      "use strict";
      var r = xee();
      if (r)
        try {
          r([], "length");
        } catch {
          r = null;
        }
      t.exports = r;
    }
  }), bee = _e({
    "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(e, t) {
      "use strict";
      var r = Object.defineProperty || !1;
      if (r)
        try {
          r({}, "a", { value: 1 });
        } catch {
          r = !1;
        }
      t.exports = r;
    }
  }), jB = _e({
    "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(e, t) {
      "use strict";
      t.exports = /* @__PURE__ */ s(function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
          return !1;
        if (typeof Symbol.iterator == "symbol")
          return !0;
        var n = {}, i = Symbol("test"), o = Object(i);
        if (typeof i == "string" || Object.prototype.toString.call(i) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[objec\
t Symbol]")
          return !1;
        var a = 42;
        n[i] = a;
        for (var u in n)
          return !1;
        if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(
        n).length !== 0)
          return !1;
        var l = Object.getOwnPropertySymbols(n);
        if (l.length !== 1 || l[0] !== i || !Object.prototype.propertyIsEnumerable.call(n, i))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var c = (
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(n, i)
          );
          if (c.value !== a || c.enumerable !== !0)
            return !1;
        }
        return !0;
      }, "hasSymbols");
    }
  }), MB = _e({
    "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(e, t) {
      "use strict";
      var r = typeof Symbol < "u" && Symbol, n = jB();
      t.exports = /* @__PURE__ */ s(function() {
        return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 :
        n();
      }, "hasNativeSymbols");
    }
  }), qB = _e({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(e, t) {
      "use strict";
      t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
    }
  }), $B = _e({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(e, t) {
      "use strict";
      var r = LB();
      t.exports = r.getPrototypeOf || null;
    }
  }), vee = _e({
    "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(e, t) {
      "use strict";
      var r = "Function.prototype.bind called on incompatible ", n = Object.prototype.toString, i = Math.max, o = "[object Function]", a = /* @__PURE__ */ s(
      function(p, h) {
        for (var f = [], d = 0; d < p.length; d += 1)
          f[d] = p[d];
        for (var m = 0; m < h.length; m += 1)
          f[m + p.length] = h[m];
        return f;
      }, "concatty2"), u = /* @__PURE__ */ s(function(p, h) {
        for (var f = [], d = h || 0, m = 0; d < p.length; d += 1, m += 1)
          f[m] = p[d];
        return f;
      }, "slicy2"), l = /* @__PURE__ */ s(function(c, p) {
        for (var h = "", f = 0; f < c.length; f += 1)
          h += c[f], f + 1 < c.length && (h += p);
        return h;
      }, "joiny");
      t.exports = /* @__PURE__ */ s(function(p) {
        var h = this;
        if (typeof h != "function" || n.apply(h) !== o)
          throw new TypeError(r + h);
        for (var f = u(arguments, 1), d, m = /* @__PURE__ */ s(function() {
          if (this instanceof d) {
            var A = h.apply(
              this,
              a(f, arguments)
            );
            return Object(A) === A ? A : this;
          }
          return h.apply(
            p,
            a(f, arguments)
          );
        }, "binder"), g = i(0, h.length - f.length), b = [], y = 0; y < g; y++)
          b[y] = "$" + y;
        if (d = Function("binder", "return function (" + l(b, ",") + "){ return binder.apply(this,arguments); }")(m), h.prototype) {
          var E = /* @__PURE__ */ s(function() {
          }, "Empty2");
          E.prototype = h.prototype, d.prototype = new E(), E.prototype = null;
        }
        return d;
      }, "bind");
    }
  }), Tp = _e({
    "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(e, t) {
      "use strict";
      var r = vee();
      t.exports = Function.prototype.bind || r;
    }
  }), fD = _e({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(e, t) {
      "use strict";
      t.exports = Function.prototype.call;
    }
  }), VB = _e({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(e, t) {
      "use strict";
      t.exports = Function.prototype.apply;
    }
  }), Eee = _e({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(e, t) {
      "use strict";
      t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
    }
  }), Cee = _e({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(e, t) {
      "use strict";
      var r = Tp(), n = VB(), i = fD(), o = Eee();
      t.exports = o || r.call(i, n);
    }
  }), UB = _e({
    "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(e, t) {
      "use strict";
      var r = Tp(), n = pD(), i = fD(), o = Cee();
      t.exports = /* @__PURE__ */ s(function(u) {
        if (u.length < 1 || typeof u[0] != "function")
          throw new n("a function is required");
        return o(r, i, u);
      }, "callBindBasic");
    }
  }), wee = _e({
    "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(e, t) {
      "use strict";
      var r = UB(), n = hD(), i;
      try {
        i = /** @type {{ __proto__?: typeof Array.prototype }} */
        [].__proto__ === Array.prototype;
      } catch (l) {
        if (!l || typeof l != "object" || !("code" in l) || l.code !== "ERR_PROTO_ACCESS")
          throw l;
      }
      var o = !!i && n && n(
        Object.prototype,
        /** @type {keyof typeof Object.prototype} */
        "__proto__"
      ), a = Object, u = a.getPrototypeOf;
      t.exports = o && typeof o.get == "function" ? r([o.get]) : typeof u == "function" ? (
        /** @type {import('./get')} */
        /* @__PURE__ */ s(function(c) {
          return u(c == null ? c : a(c));
        }, "getDunder")
      ) : !1;
    }
  }), See = _e({
    "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(e, t) {
      "use strict";
      var r = qB(), n = $B(), i = wee();
      t.exports = r ? /* @__PURE__ */ s(function(a) {
        return r(a);
      }, "getProto") : n ? /* @__PURE__ */ s(function(a) {
        if (!a || typeof a != "object" && typeof a != "function")
          throw new TypeError("getProto: not an object");
        return n(a);
      }, "getProto") : i ? /* @__PURE__ */ s(function(a) {
        return i(a);
      }, "getProto") : null;
    }
  }), WB = _e({
    "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(e, t) {
      "use strict";
      var r = Function.prototype.call, n = Object.prototype.hasOwnProperty, i = Tp();
      t.exports = i.call(r, n);
    }
  }), Aee = _e({
    "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(e, t) {
      "use strict";
      var r, n = LB(), i = see(), o = oee(), a = aee(), u = uee(), l = lee(), c = pD(), p = cee(), h = pee(), f = hee(), d = fee(), m = dee(),
      g = mee(), b = gee(), y = Dee(), E = Function, A = /* @__PURE__ */ s(function(K) {
        try {
          return E('"use strict"; return (' + K + ").constructor;")();
        } catch {
        }
      }, "getEvalledConstructor"), k = hD(), O = bee(), w = /* @__PURE__ */ s(function() {
        throw new c();
      }, "throwTypeError"), C = k ? function() {
        try {
          return arguments.callee, w;
        } catch {
          try {
            return k(arguments, "callee").get;
          } catch {
            return w;
          }
        }
      }() : w, T = MB()(), F = See(), $ = $B(), R = qB(), U = VB(), W = fD(), Y = {}, j = typeof Uint8Array > "u" || !F ? r : F(Uint8Array),
      N = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
        "%ArrayIteratorPrototype%": T && F ? F([][Symbol.iterator]()) : r,
        "%AsyncFromSyncIteratorPrototype%": r,
        "%AsyncFunction%": Y,
        "%AsyncGenerator%": Y,
        "%AsyncGeneratorFunction%": Y,
        "%AsyncIteratorPrototype%": Y,
        "%Atomics%": typeof Atomics > "u" ? r : Atomics,
        "%BigInt%": typeof BigInt > "u" ? r : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? r : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": i,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": o,
        "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
        "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
        "%Function%": E,
        "%GeneratorFunction%": Y,
        "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": T && F ? F(F([][Symbol.iterator]())) : r,
        "%JSON%": typeof JSON == "object" ? JSON : r,
        "%Map%": typeof Map > "u" ? r : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !T || !F ? r : F((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": n,
        "%Object.getOwnPropertyDescriptor%": k,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? r : Promise,
        "%Proxy%": typeof Proxy > "u" ? r : Proxy,
        "%RangeError%": a,
        "%ReferenceError%": u,
        "%Reflect%": typeof Reflect > "u" ? r : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? r : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !T || !F ? r : F((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": T && F ? F(""[Symbol.iterator]()) : r,
        "%Symbol%": T ? Symbol : r,
        "%SyntaxError%": l,
        "%ThrowTypeError%": C,
        "%TypedArray%": j,
        "%TypeError%": c,
        "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
        "%URIError%": p,
        "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
        "%Function.prototype.call%": W,
        "%Function.prototype.apply%": U,
        "%Object.defineProperty%": O,
        "%Object.getPrototypeOf%": $,
        "%Math.abs%": h,
        "%Math.floor%": f,
        "%Math.max%": d,
        "%Math.min%": m,
        "%Math.pow%": g,
        "%Math.round%": b,
        "%Math.sign%": y,
        "%Reflect.getPrototypeOf%": R
      };
      if (F)
        try {
          null.error;
        } catch (K) {
          z = F(F(K)), N["%Error.prototype%"] = z;
        }
      var z, Q = /* @__PURE__ */ s(function K(se) {
        var ge;
        if (se === "%AsyncFunction%")
          ge = A("async function () {}");
        else if (se === "%GeneratorFunction%")
          ge = A("function* () {}");
        else if (se === "%AsyncGeneratorFunction%")
          ge = A("async function* () {}");
        else if (se === "%AsyncGenerator%") {
          var be = K("%AsyncGeneratorFunction%");
          be && (ge = be.prototype);
        } else if (se === "%AsyncIteratorPrototype%") {
          var Ee = K("%AsyncGenerator%");
          Ee && F && (ge = F(Ee.prototype));
        }
        return N[se] = ge, ge;
      }, "doEval2"), ie = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      }, B = Tp(), ce = WB(), Je = B.call(W, Array.prototype.concat), L = B.call(U, Array.prototype.splice), Ue = B.call(W, String.prototype.
      replace), $e = B.call(W, String.prototype.slice), me = B.call(W, RegExp.prototype.exec), It = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
      Me = /\\(\\)?/g, re = /* @__PURE__ */ s(function(se) {
        var ge = $e(se, 0, 1), be = $e(se, -1);
        if (ge === "%" && be !== "%")
          throw new l("invalid intrinsic syntax, expected closing `%`");
        if (be === "%" && ge !== "%")
          throw new l("invalid intrinsic syntax, expected opening `%`");
        var Ee = [];
        return Ue(se, It, function(rt, Ct, We, sr) {
          Ee[Ee.length] = We ? Ue(sr, Me, "$1") : Ct || rt;
        }), Ee;
      }, "stringToPath3"), xe = /* @__PURE__ */ s(function(se, ge) {
        var be = se, Ee;
        if (ce(ie, be) && (Ee = ie[be], be = "%" + Ee[0] + "%"), ce(N, be)) {
          var rt = N[be];
          if (rt === Y && (rt = Q(be)), typeof rt > "u" && !ge)
            throw new c("intrinsic " + se + " exists, but is not available. Please file an issue!");
          return {
            alias: Ee,
            name: be,
            value: rt
          };
        }
        throw new l("intrinsic " + se + " does not exist!");
      }, "getBaseIntrinsic2");
      t.exports = /* @__PURE__ */ s(function(se, ge) {
        if (typeof se != "string" || se.length === 0)
          throw new c("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof ge != "boolean")
          throw new c('"allowMissing" argument must be a boolean');
        if (me(/^%?[^%]*%?$/, se) === null)
          throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var be = re(se), Ee = be.length > 0 ? be[0] : "", rt = xe("%" + Ee + "%", ge), Ct = rt.name, We = rt.value, sr = !1, or = rt.alias;
        or && (Ee = or[0], L(be, Je([0, 1], or)));
        for (var kr = 1, pe = !0; kr < be.length; kr += 1) {
          var Ye = be[kr], x = $e(Ye, 0, 1), D = $e(Ye, -1);
          if ((x === '"' || x === "'" || x === "`" || D === '"' || D === "'" || D === "`") && x !== D)
            throw new l("property names with quotes must have matching quotes");
          if ((Ye === "constructor" || !pe) && (sr = !0), Ee += "." + Ye, Ct = "%" + Ee + "%", ce(N, Ct))
            We = N[Ct];
          else if (We != null) {
            if (!(Ye in We)) {
              if (!ge)
                throw new c("base intrinsic for " + se + " exists, but the property is not available.");
              return;
            }
            if (k && kr + 1 >= be.length) {
              var _ = k(We, Ye);
              pe = !!_, pe && "get" in _ && !("originalValue" in _.get) ? We = _.get : We = We[Ye];
            } else
              pe = ce(We, Ye), We = We[Ye];
            pe && !sr && (N[Ct] = We);
          }
        }
        return We;
      }, "GetIntrinsic");
    }
  }), dD = _e({
    "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(e, t) {
      "use strict";
      var r = Aee(), n = UB(), i = n([r("%String.prototype.indexOf%")]);
      t.exports = /* @__PURE__ */ s(function(a, u) {
        var l = (
          /** @type {(this: unknown, ...args: unknown[]) => unknown} */
          r(a, !!u)
        );
        return typeof l == "function" && i(a, ".prototype.") > -1 ? n(
          /** @type {const} */
          [l]
        ) : l;
      }, "callBoundIntrinsic");
    }
  }), Fee = _e({
    "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(e, t) {
      "use strict";
      var r = jB();
      t.exports = /* @__PURE__ */ s(function() {
        return r() && !!Symbol.toStringTag;
      }, "hasToStringTagShams");
    }
  }), zB = _e({
    "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(e, t) {
      "use strict";
      var r = dD(), n = Fee()(), i = WB(), o = hD(), a;
      n ? (u = r("RegExp.prototype.exec"), l = {}, c = /* @__PURE__ */ s(function() {
        throw l;
      }, "throwRegexMarker"), p = {
        toString: c,
        valueOf: c
      }, typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = c), a = /* @__PURE__ */ s(function(m) {
        if (!m || typeof m != "object")
          return !1;
        var g = (
          /** @type {NonNullable<typeof gOPD>} */
          o(
            /** @type {{ lastIndex?: unknown }} */
            m,
            "lastIndex"
          )
        ), b = g && i(g, "value");
        if (!b)
          return !1;
        try {
          u(
            m,
            /** @type {string} */
            /** @type {unknown} */
            p
          );
        } catch (y) {
          return y === l;
        }
      }, "isRegex")) : (h = r("Object.prototype.toString"), f = "[object RegExp]", a = /* @__PURE__ */ s(function(m) {
        return !m || typeof m != "object" && typeof m != "function" ? !1 : h(m) === f;
      }, "isRegex"));
      var u, l, c, p, h, f;
      t.exports = a;
    }
  }), _ee = _e({
    "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(e, t) {
      t.exports = n;
      var r = Object.prototype.toString;
      function n(i) {
        if (!i)
          return !1;
        var o = r.call(i);
        return o === "[object Function]" || typeof i == "function" && o !== "[object RegExp]" || typeof window < "u" && // IE8 and below
        (i === window.setTimeout || i === window.alert || i === window.confirm || i === window.prompt);
      }
      s(n, "isFunction3");
    }
  }), kee = _e({
    "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(e, t) {
      "use strict";
      var r = dD(), n = zB(), i = r("RegExp.prototype.exec"), o = pD();
      t.exports = /* @__PURE__ */ s(function(u) {
        if (!n(u))
          throw new o("`regex` must be a RegExp");
        return /* @__PURE__ */ s(function(c) {
          return i(u, c) !== null;
        }, "test");
      }, "regexTester");
    }
  }), Tee = _e({
    "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(e, t) {
      "use strict";
      var r = dD(), n = r("Object.prototype.toString"), i = MB()(), o = kee();
      i ? (a = r("Symbol.prototype.toString"), u = o(/^Symbol\(.*\)$/), l = /* @__PURE__ */ s(function(p) {
        return typeof p.valueOf() != "symbol" ? !1 : u(a(p));
      }, "isRealSymbolObject"), t.exports = /* @__PURE__ */ s(function(p) {
        if (typeof p == "symbol")
          return !0;
        if (!p || typeof p != "object" || n(p) !== "[object Symbol]")
          return !1;
        try {
          return l(p);
        } catch {
          return !1;
        }
      }, "isSymbol3")) : t.exports = /* @__PURE__ */ s(function(p) {
        return !1;
      }, "isSymbol3");
      var a, u, l;
    }
  }), HB = {};
  nee(HB, {
    isJSON: /* @__PURE__ */ s(() => QB, "isJSON"),
    parse: /* @__PURE__ */ s(() => rne, "parse"),
    replacer: /* @__PURE__ */ s(() => tO, "replacer"),
    reviver: /* @__PURE__ */ s(() => rO, "reviver"),
    stringify: /* @__PURE__ */ s(() => ene, "stringify")
  });
  iO.exports = iee(HB);
  var Iee = cD(zB()), Pee = cD(_ee()), Bee = cD(Tee());
  function Oee(e) {
    return e != null && typeof e == "object" && Array.isArray(e) === !1;
  }
  s(Oee, "isObject");
  var Ree = typeof global == "object" && global && global.Object === Object && global, Nee = Ree, Lee = typeof self == "object" && self && self.
  Object === Object && self, jee = Nee || Lee || Function("return this")(), mD = jee, Mee = mD.Symbol, Ao = Mee, GB = Object.prototype, qee = GB.
  hasOwnProperty, $ee = GB.toString, lu = Ao ? Ao.toStringTag : void 0;
  function Vee(e) {
    var t = qee.call(e, lu), r = e[lu];
    try {
      e[lu] = void 0;
      var n = !0;
    } catch {
    }
    var i = $ee.call(e);
    return n && (t ? e[lu] = r : delete e[lu]), i;
  }
  s(Vee, "getRawTag");
  var Uee = Vee, Wee = Object.prototype, zee = Wee.toString;
  function Hee(e) {
    return zee.call(e);
  }
  s(Hee, "objectToString");
  var Gee = Hee, Jee = "[object Null]", Zee = "[object Undefined]", TB = Ao ? Ao.toStringTag : void 0;
  function Xee(e) {
    return e == null ? e === void 0 ? Zee : Jee : TB && TB in Object(e) ? Uee(e) : Gee(e);
  }
  s(Xee, "baseGetTag");
  var JB = Xee;
  function Kee(e) {
    return e != null && typeof e == "object";
  }
  s(Kee, "isObjectLike");
  var Yee = Kee, Qee = "[object Symbol]";
  function ete(e) {
    return typeof e == "symbol" || Yee(e) && JB(e) == Qee;
  }
  s(ete, "isSymbol");
  var gD = ete;
  function tte(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
      i[r] = t(e[r], r, e);
    return i;
  }
  s(tte, "arrayMap");
  var rte = tte, nte = Array.isArray, yD = nte, ite = 1 / 0, IB = Ao ? Ao.prototype : void 0, PB = IB ? IB.toString : void 0;
  function ZB(e) {
    if (typeof e == "string")
      return e;
    if (yD(e))
      return rte(e, ZB) + "";
    if (gD(e))
      return PB ? PB.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -ite ? "-0" : t;
  }
  s(ZB, "baseToString");
  var ste = ZB;
  function ote(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  s(ote, "isObject2");
  var XB = ote, ate = "[object AsyncFunction]", ute = "[object Function]", lte = "[object GeneratorFunction]", cte = "[object Proxy]";
  function pte(e) {
    if (!XB(e))
      return !1;
    var t = JB(e);
    return t == ute || t == lte || t == ate || t == cte;
  }
  s(pte, "isFunction");
  var hte = pte, fte = mD["__core-js_shared__"], lD = fte, BB = function() {
    var e = /[^.]+$/.exec(lD && lD.keys && lD.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function dte(e) {
    return !!BB && BB in e;
  }
  s(dte, "isMasked");
  var mte = dte, gte = Function.prototype, yte = gte.toString;
  function Dte(e) {
    if (e != null) {
      try {
        return yte.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  s(Dte, "toSource");
  var xte = Dte, bte = /[\\^$.*+?()[\]{}|]/g, vte = /^\[object .+?Constructor\]$/, Ete = Function.prototype, Cte = Object.prototype, wte = Ete.
  toString, Ste = Cte.hasOwnProperty, Ate = RegExp(
    "^" + wte.call(Ste).replace(bte, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function Fte(e) {
    if (!XB(e) || mte(e))
      return !1;
    var t = hte(e) ? Ate : vte;
    return t.test(xte(e));
  }
  s(Fte, "baseIsNative");
  var _te = Fte;
  function kte(e, t) {
    return e?.[t];
  }
  s(kte, "getValue");
  var Tte = kte;
  function Ite(e, t) {
    var r = Tte(e, t);
    return _te(r) ? r : void 0;
  }
  s(Ite, "getNative");
  var KB = Ite;
  function Pte(e, t) {
    return e === t || e !== e && t !== t;
  }
  s(Pte, "eq");
  var Bte = Pte, Ote = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Rte = /^\w*$/;
  function Nte(e, t) {
    if (yD(e))
      return !1;
    var r = typeof e;
    return r == "number" || r == "symbol" || r == "boolean" || e == null || gD(e) ? !0 : Rte.test(e) || !Ote.test(e) || t != null && e in Object(
    t);
  }
  s(Nte, "isKey");
  var Lte = Nte, jte = KB(Object, "create"), cu = jte;
  function Mte() {
    this.__data__ = cu ? cu(null) : {}, this.size = 0;
  }
  s(Mte, "hashClear");
  var qte = Mte;
  function $te(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  s($te, "hashDelete");
  var Vte = $te, Ute = "__lodash_hash_undefined__", Wte = Object.prototype, zte = Wte.hasOwnProperty;
  function Hte(e) {
    var t = this.__data__;
    if (cu) {
      var r = t[e];
      return r === Ute ? void 0 : r;
    }
    return zte.call(t, e) ? t[e] : void 0;
  }
  s(Hte, "hashGet");
  var Gte = Hte, Jte = Object.prototype, Zte = Jte.hasOwnProperty;
  function Xte(e) {
    var t = this.__data__;
    return cu ? t[e] !== void 0 : Zte.call(t, e);
  }
  s(Xte, "hashHas");
  var Kte = Xte, Yte = "__lodash_hash_undefined__";
  function Qte(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1, r[e] = cu && t === void 0 ? Yte : t, this;
  }
  s(Qte, "hashSet");
  var ere = Qte;
  function Fo(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  s(Fo, "Hash");
  Fo.prototype.clear = qte;
  Fo.prototype.delete = Vte;
  Fo.prototype.get = Gte;
  Fo.prototype.has = Kte;
  Fo.prototype.set = ere;
  var OB = Fo;
  function tre() {
    this.__data__ = [], this.size = 0;
  }
  s(tre, "listCacheClear");
  var rre = tre;
  function nre(e, t) {
    for (var r = e.length; r--; )
      if (Bte(e[r][0], t))
        return r;
    return -1;
  }
  s(nre, "assocIndexOf");
  var Ip = nre, ire = Array.prototype, sre = ire.splice;
  function ore(e) {
    var t = this.__data__, r = Ip(t, e);
    if (r < 0)
      return !1;
    var n = t.length - 1;
    return r == n ? t.pop() : sre.call(t, r, 1), --this.size, !0;
  }
  s(ore, "listCacheDelete");
  var are = ore;
  function ure(e) {
    var t = this.__data__, r = Ip(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  s(ure, "listCacheGet");
  var lre = ure;
  function cre(e) {
    return Ip(this.__data__, e) > -1;
  }
  s(cre, "listCacheHas");
  var pre = cre;
  function hre(e, t) {
    var r = this.__data__, n = Ip(r, e);
    return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
  }
  s(hre, "listCacheSet");
  var fre = hre;
  function _o(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  s(_o, "ListCache");
  _o.prototype.clear = rre;
  _o.prototype.delete = are;
  _o.prototype.get = lre;
  _o.prototype.has = pre;
  _o.prototype.set = fre;
  var dre = _o, mre = KB(mD, "Map"), gre = mre;
  function yre() {
    this.size = 0, this.__data__ = {
      hash: new OB(),
      map: new (gre || dre)(),
      string: new OB()
    };
  }
  s(yre, "mapCacheClear");
  var Dre = yre;
  function xre(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  s(xre, "isKeyable");
  var bre = xre;
  function vre(e, t) {
    var r = e.__data__;
    return bre(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  s(vre, "getMapData");
  var Pp = vre;
  function Ere(e) {
    var t = Pp(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  s(Ere, "mapCacheDelete");
  var Cre = Ere;
  function wre(e) {
    return Pp(this, e).get(e);
  }
  s(wre, "mapCacheGet");
  var Sre = wre;
  function Are(e) {
    return Pp(this, e).has(e);
  }
  s(Are, "mapCacheHas");
  var Fre = Are;
  function _re(e, t) {
    var r = Pp(this, e), n = r.size;
    return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
  }
  s(_re, "mapCacheSet");
  var kre = _re;
  function ko(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  s(ko, "MapCache");
  ko.prototype.clear = Dre;
  ko.prototype.delete = Cre;
  ko.prototype.get = Sre;
  ko.prototype.has = Fre;
  ko.prototype.set = kre;
  var YB = ko, Tre = "Expected a function";
  function DD(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(Tre);
    var r = /* @__PURE__ */ s(function() {
      var n = arguments, i = t ? t.apply(this, n) : n[0], o = r.cache;
      if (o.has(i))
        return o.get(i);
      var a = e.apply(this, n);
      return r.cache = o.set(i, a) || o, a;
    }, "memoized");
    return r.cache = new (DD.Cache || YB)(), r;
  }
  s(DD, "memoize");
  DD.Cache = YB;
  var Ire = DD, Pre = 500;
  function Bre(e) {
    var t = Ire(e, function(n) {
      return r.size === Pre && r.clear(), n;
    }), r = t.cache;
    return t;
  }
  s(Bre, "memoizeCapped");
  var Ore = Bre, Rre = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Nre = /\\(\\)?/g,
  Lre = Ore(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(Rre, function(r, n, i, o) {
      t.push(i ? o.replace(Nre, "$1") : n || r);
    }), t;
  }), jre = Lre;
  function Mre(e) {
    return e == null ? "" : ste(e);
  }
  s(Mre, "toString");
  var qre = Mre;
  function $re(e, t) {
    return yD(e) ? e : Lte(e, t) ? [e] : jre(qre(e));
  }
  s($re, "castPath");
  var Vre = $re, Ure = 1 / 0;
  function Wre(e) {
    if (typeof e == "string" || gD(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -Ure ? "-0" : t;
  }
  s(Wre, "toKey");
  var zre = Wre;
  function Hre(e, t) {
    t = Vre(t, e);
    for (var r = 0, n = t.length; e != null && r < n; )
      e = e[zre(t[r++])];
    return r && r == n ? e : void 0;
  }
  s(Hre, "baseGet");
  var Gre = Hre;
  function Jre(e, t, r) {
    var n = e == null ? void 0 : Gre(e, t);
    return n === void 0 ? r : n;
  }
  s(Jre, "get");
  var Zre = Jre, Xre = [
    "bubbles",
    "cancelBubble",
    "cancelable",
    "composed",
    "currentTarget",
    "defaultPrevented",
    "eventPhase",
    "isTrusted",
    "returnValue",
    "srcElement",
    "target",
    "timeStamp",
    "type"
  ], Kre = ["detail"];
  function Yre(e) {
    let t = Xre.filter((r) => e[r] !== void 0).reduce((r, n) => (r[n] = e[n], r), {});
    if (e instanceof CustomEvent)
      for (let r of Kre.filter(
        (n) => e[n] !== void 0
      ))
        t[r] = e[r];
    return t;
  }
  s(Yre, "extractEventHiddenProperties");
  var xD = Oee, Qre = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, QB = /* @__PURE__ */ s((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), "\
isJSON");
  function eO(e) {
    if (!xD(e))
      return e;
    let t = e, r = !1;
    return typeof Event < "u" && e instanceof Event && (t = Yre(t), r = !0), t = Object.keys(t).reduce((n, i) => {
      try {
        t[i] && t[i].toJSON, n[i] = t[i];
      } catch {
        r = !0;
      }
      return n;
    }, {}), r ? t : e;
  }
  s(eO, "convertUnconventionalData");
  var tO = /* @__PURE__ */ s(function(t) {
    let r, n, i, o;
    return /* @__PURE__ */ s(function(u, l) {
      try {
        if (u === "")
          return o = [], r = /* @__PURE__ */ new Map([[l, "[]"]]), n = /* @__PURE__ */ new Map(), i = [], l;
        let c = n.get(this) || this;
        for (; i.length && c !== i[0]; )
          i.shift(), o.pop();
        if (typeof l == "boolean")
          return l;
        if (l === void 0)
          return t.allowUndefined ? "_undefined_" : void 0;
        if (l === null)
          return null;
        if (typeof l == "number")
          return l === Number.NEGATIVE_INFINITY ? "_-Infinity_" : l === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(l) ? "_NaN_" :
          l;
        if (typeof l == "bigint")
          return `_bigint_${l.toString()}`;
        if (typeof l == "string")
          return Qre.test(l) ? t.allowDate ? `_date_${l}` : void 0 : l;
        if ((0, Iee.default)(l))
          return t.allowRegExp ? `_regexp_${l.flags}|${l.source}` : void 0;
        if ((0, Pee.default)(l))
          return;
        if ((0, Bee.default)(l)) {
          if (!t.allowSymbol)
            return;
          let h = Symbol.keyFor(l);
          return h !== void 0 ? `_gsymbol_${h}` : `_symbol_${l.toString().slice(7, -1)}`;
        }
        if (i.length >= t.maxDepth)
          return Array.isArray(l) ? `[Array(${l.length})]` : "[Object]";
        if (l === this)
          return `_duplicate_${JSON.stringify(o)}`;
        if (l instanceof Error && t.allowError)
          return {
            __isConvertedError__: !0,
            errorProperties: {
              // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
              ...l.cause ? { cause: l.cause } : {},
              ...l,
              name: l.name,
              message: l.message,
              stack: l.stack,
              "_constructor-name_": l.constructor.name
            }
          };
        if (l?.constructor?.name && l.constructor.name !== "Object" && !Array.isArray(l)) {
          let h = r.get(l);
          if (!h) {
            let f = {
              __isClassInstance__: !0,
              __className__: l.constructor.name,
              ...Object.getOwnPropertyNames(l).reduce(
                (d, m) => {
                  try {
                    d[m] = l[m];
                  } catch {
                  }
                  return d;
                },
                {}
              )
            };
            return o.push(u), i.unshift(f), r.set(l, JSON.stringify(o)), l !== f && n.set(l, f), f;
          }
          return `_duplicate_${h}`;
        }
        let p = r.get(l);
        if (!p) {
          let h = Array.isArray(l) ? l : eO(l);
          return o.push(u), i.unshift(h), r.set(l, JSON.stringify(o)), l !== h && n.set(l, h), h;
        }
        return `_duplicate_${p}`;
      } catch {
        return;
      }
    }, "replace");
  }, "replacer2"), rO = /* @__PURE__ */ s(function(t) {
    let r = [], n;
    return /* @__PURE__ */ s(function(o, a) {
      if (o === "" && (n = a, r.forEach(({ target: u, container: l, replacement: c }) => {
        let p = QB(c) ? JSON.parse(c) : c.split(".");
        p.length === 0 ? l[u] = n : l[u] = Zre(n, p);
      })), o === "_constructor-name_")
        return a;
      if (xD(a) && a.__isConvertedError__) {
        let { message: u, ...l } = a.errorProperties, c = new Error(u);
        return Object.assign(c, l), c;
      }
      if (typeof a == "string" && a.startsWith("_regexp_") && t.allowRegExp) {
        let [, u, l] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
        return new RegExp(l, u);
      }
      return typeof a == "string" && a.startsWith("_date_") && t.allowDate ? new Date(a.replace("_date_", "")) : typeof a == "string" && a.startsWith(
      "_duplicate_") ? (r.push({ target: o, container: this, replacement: a.replace(/^_duplicate_/, "") }), null) : typeof a == "string" && a.
      startsWith("_symbol_") && t.allowSymbol ? Symbol(a.replace("_symbol_", "")) : typeof a == "string" && a.startsWith("_gsymbol_") && t.allowSymbol ?
      Symbol.for(a.replace("_gsymbol_", "")) : typeof a == "string" && a === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof a == "string" &&
      a === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof a == "string" && a === "_NaN_" ? Number.NaN : typeof a == "string" && a.startsWith(
      "_bigint_") && typeof BigInt == "function" ? BigInt(a.replace("_bigint_", "")) : a;
    }, "revive");
  }, "reviver2"), nO = {
    maxDepth: 10,
    space: void 0,
    allowRegExp: !0,
    allowDate: !0,
    allowError: !0,
    allowUndefined: !0,
    allowSymbol: !0
  }, ene = /* @__PURE__ */ s((e, t = {}) => {
    let r = { ...nO, ...t };
    return JSON.stringify(eO(e), tO(r), t.space);
  }, "stringify"), tne = /* @__PURE__ */ s(() => {
    let e = /* @__PURE__ */ new Map();
    return /* @__PURE__ */ s(function t(r) {
      xD(r) && Object.entries(r).forEach(([n, i]) => {
        i === "_undefined_" ? r[n] = void 0 : e.get(i) || (e.set(i, !0), t(i));
      }), Array.isArray(r) && r.forEach((n, i) => {
        n === "_undefined_" ? (e.set(n, !0), r[i] = void 0) : e.get(n) || (e.set(n, !0), t(n));
      });
    }, "mutateUndefined");
  }, "mutator"), rne = /* @__PURE__ */ s((e, t = {}) => {
    let r = { ...nO, ...t }, n = JSON.parse(e, rO(r));
    return tne()(n), n;
  }, "parse");
});

// ../node_modules/@aw-web-design/x-default-browser/src/common-name.js
var hu = I((pbe, fO) => {
  fO.exports = function(e) {
    return e.isEdge ? "edge" : e.isIE ? "ie" : e.isFirefox ? "firefox" : e.isChrome ? "chrome" : e.isChromium ? "chromium" : e.isOpera ? "op\
era" : e.isSafari ? "safari" : "unknown";
  };
});

// ../node_modules/@aw-web-design/x-default-browser/src/detect-windows10.js
var mO = I((hbe, dO) => {
  var sne = require("child_process").exec;
  dO.exports = function(e) {
    var t = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\Shell\\Associations\\URLAssociations\\http\\UserChoice", r = "reg query " + t +
    ' | findstr "ProgId"';
    sne(r, function(n, i, o) {
      var a;
      if (n) {
        if (o.length > 0)
          return e("Unable to execute the query: " + n);
        a = "iexplore.exe";
      }
      if (!a) {
        i = i.trim().replace(/\s\s+/g, " ");
        var u = i.split(" ");
        a = u[2].toLowerCase();
      }
      var l = {
        isEdge: a.indexOf("app") > -1,
        // AppXq0fevzme2pys62n3e0fbqa7peapykr8v
        isIE: a.indexOf("ie.http") > -1,
        // IE.HTTP
        isSafari: a.indexOf("safari") > -1,
        // SafariURL
        isFirefox: a.indexOf("firefox") > -1,
        // FirefoxURL
        isChrome: a.indexOf("chrome") > -1,
        // ChromeHTML
        isChromium: a.indexOf("chromium") > -1,
        isOpera: a.indexOf("opera") > -1,
        // OperaHTML
        identity: a
      };
      l.isBlink = l.isChrome || l.isChromium || l.isOpera, l.isWebkit = l.isSafari || l.isBlink, l.commonName = hu()(l), e(null, l);
    });
  };
});

// ../node_modules/@aw-web-design/x-default-browser/src/detect-windows.js
var yO = I((fbe, gO) => {
  var one = require("child_process").exec;
  gO.exports = function(e) {
    var t = "HKCU\\Software\\Clients\\StartMenuInternet", r = "reg query " + t + ' | findstr "REG_SZ"';
    one(r, function(n, i, o) {
      var a;
      if (n) {
        if (o.length > 0)
          return e("Unable to execute the query: " + n);
        a = "iexplore.exe";
      }
      if (!a) {
        i = i.replace("NO NAME", "NONAME");
        var u = i.trim().split(/(\t| +)/);
        a = (u[4] + (u[5] || "") + (u[6] || "")).toLowerCase();
      }
      var l = {
        isIE: a.indexOf("iexplore") > -1,
        // IEXPLORE.EXE             / -
        isSafari: a.indexOf("safari") > -1,
        // Safari.exe
        // works also for nightly
        isFirefox: a.indexOf("firefox") > -1,
        // FIREFOX.EXE              / "C:\Program Files (x86)\Mozilla Firefox\firefox.exe" -osint -url "%1"
        // note that both chrome and chromium are chrome.exe! we can't look for 'chrome' hence
        isChrome: a.indexOf("google") > -1,
        // Google Chrome            / "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" -- "%1"
        isChromium: a.indexOf("chromium") > -1,
        // Chromium.<randomstring>  / "C:\Users\<username>\AppData\Local\Chromium\Application\chrome.exe" -- "%1"
        isOpera: a.indexOf("opera") > -1,
        // OperaStable              / "C:\Program Files (x86)\Opera\launcher.exe" -noautoupdate -- "%1"
        identity: a
      };
      l.isBlink = l.isChrome || l.isChromium || l.isOpera, l.isWebkit = l.isSafari || l.isBlink, l.commonName = hu()(l), e(null, l);
    });
  };
});

// ../node_modules/big-integer/BigInteger.js
var DO = I((dbe, Op) => {
  var yt = function(e) {
    "use strict";
    var t = 1e7, r = 7, n = 9007199254740992, i = f(n), o = "0123456789abcdefghijklmnopqrstuvwxyz", a = typeof BigInt == "function";
    function u(x, D, _, P) {
      return typeof x > "u" ? u[0] : typeof D < "u" ? +D == 10 && !_ ? pe(x) : Ee(x, D, _, P) : pe(x);
    }
    s(u, "Integer");
    function l(x, D) {
      this.value = x, this.sign = D, this.isSmall = !1;
    }
    s(l, "BigInteger"), l.prototype = Object.create(u.prototype);
    function c(x) {
      this.value = x, this.sign = x < 0, this.isSmall = !0;
    }
    s(c, "SmallInteger"), c.prototype = Object.create(u.prototype);
    function p(x) {
      this.value = x;
    }
    s(p, "NativeBigInt"), p.prototype = Object.create(u.prototype);
    function h(x) {
      return -n < x && x < n;
    }
    s(h, "isPrecise");
    function f(x) {
      return x < 1e7 ? [x] : x < 1e14 ? [x % 1e7, Math.floor(x / 1e7)] : [x % 1e7, Math.floor(x / 1e7) % 1e7, Math.floor(x / 1e14)];
    }
    s(f, "smallToArray");
    function d(x) {
      m(x);
      var D = x.length;
      if (D < 4 && Q(x, i) < 0)
        switch (D) {
          case 0:
            return 0;
          case 1:
            return x[0];
          case 2:
            return x[0] + x[1] * t;
          default:
            return x[0] + (x[1] + x[2] * t) * t;
        }
      return x;
    }
    s(d, "arrayToSmall");
    function m(x) {
      for (var D = x.length; x[--D] === 0; ) ;
      x.length = D + 1;
    }
    s(m, "trim");
    function g(x) {
      for (var D = new Array(x), _ = -1; ++_ < x; )
        D[_] = 0;
      return D;
    }
    s(g, "createArray");
    function b(x) {
      return x > 0 ? Math.floor(x) : Math.ceil(x);
    }
    s(b, "truncate");
    function y(x, D) {
      var _ = x.length, P = D.length, v = new Array(_), M = 0, H = t, G, Z;
      for (Z = 0; Z < P; Z++)
        G = x[Z] + D[Z] + M, M = G >= H ? 1 : 0, v[Z] = G - M * H;
      for (; Z < _; )
        G = x[Z] + M, M = G === H ? 1 : 0, v[Z++] = G - M * H;
      return M > 0 && v.push(M), v;
    }
    s(y, "add");
    function E(x, D) {
      return x.length >= D.length ? y(x, D) : y(D, x);
    }
    s(E, "addAny");
    function A(x, D) {
      var _ = x.length, P = new Array(_), v = t, M, H;
      for (H = 0; H < _; H++)
        M = x[H] - v + D, D = Math.floor(M / v), P[H] = M - D * v, D += 1;
      for (; D > 0; )
        P[H++] = D % v, D = Math.floor(D / v);
      return P;
    }
    s(A, "addSmall"), l.prototype.add = function(x) {
      var D = pe(x);
      if (this.sign !== D.sign)
        return this.subtract(D.negate());
      var _ = this.value, P = D.value;
      return D.isSmall ? new l(A(_, Math.abs(P)), this.sign) : new l(E(_, P), this.sign);
    }, l.prototype.plus = l.prototype.add, c.prototype.add = function(x) {
      var D = pe(x), _ = this.value;
      if (_ < 0 !== D.sign)
        return this.subtract(D.negate());
      var P = D.value;
      if (D.isSmall) {
        if (h(_ + P)) return new c(_ + P);
        P = f(Math.abs(P));
      }
      return new l(A(P, Math.abs(_)), _ < 0);
    }, c.prototype.plus = c.prototype.add, p.prototype.add = function(x) {
      return new p(this.value + pe(x).value);
    }, p.prototype.plus = p.prototype.add;
    function k(x, D) {
      var _ = x.length, P = D.length, v = new Array(_), M = 0, H = t, G, Z;
      for (G = 0; G < P; G++)
        Z = x[G] - M - D[G], Z < 0 ? (Z += H, M = 1) : M = 0, v[G] = Z;
      for (G = P; G < _; G++) {
        if (Z = x[G] - M, Z < 0) Z += H;
        else {
          v[G++] = Z;
          break;
        }
        v[G] = Z;
      }
      for (; G < _; G++)
        v[G] = x[G];
      return m(v), v;
    }
    s(k, "subtract");
    function O(x, D, _) {
      var P;
      return Q(x, D) >= 0 ? P = k(x, D) : (P = k(D, x), _ = !_), P = d(P), typeof P == "number" ? (_ && (P = -P), new c(P)) : new l(P, _);
    }
    s(O, "subtractAny");
    function w(x, D, _) {
      var P = x.length, v = new Array(P), M = -D, H = t, G, Z;
      for (G = 0; G < P; G++)
        Z = x[G] + M, M = Math.floor(Z / H), Z %= H, v[G] = Z < 0 ? Z + H : Z;
      return v = d(v), typeof v == "number" ? (_ && (v = -v), new c(v)) : new l(v, _);
    }
    s(w, "subtractSmall"), l.prototype.subtract = function(x) {
      var D = pe(x);
      if (this.sign !== D.sign)
        return this.add(D.negate());
      var _ = this.value, P = D.value;
      return D.isSmall ? w(_, Math.abs(P), this.sign) : O(_, P, this.sign);
    }, l.prototype.minus = l.prototype.subtract, c.prototype.subtract = function(x) {
      var D = pe(x), _ = this.value;
      if (_ < 0 !== D.sign)
        return this.add(D.negate());
      var P = D.value;
      return D.isSmall ? new c(_ - P) : w(P, Math.abs(_), _ >= 0);
    }, c.prototype.minus = c.prototype.subtract, p.prototype.subtract = function(x) {
      return new p(this.value - pe(x).value);
    }, p.prototype.minus = p.prototype.subtract, l.prototype.negate = function() {
      return new l(this.value, !this.sign);
    }, c.prototype.negate = function() {
      var x = this.sign, D = new c(-this.value);
      return D.sign = !x, D;
    }, p.prototype.negate = function() {
      return new p(-this.value);
    }, l.prototype.abs = function() {
      return new l(this.value, !1);
    }, c.prototype.abs = function() {
      return new c(Math.abs(this.value));
    }, p.prototype.abs = function() {
      return new p(this.value >= 0 ? this.value : -this.value);
    };
    function C(x, D) {
      var _ = x.length, P = D.length, v = _ + P, M = g(v), H = t, G, Z, fe, Ae, he;
      for (fe = 0; fe < _; ++fe) {
        Ae = x[fe];
        for (var ke = 0; ke < P; ++ke)
          he = D[ke], G = Ae * he + M[fe + ke], Z = Math.floor(G / H), M[fe + ke] = G - Z * H, M[fe + ke + 1] += Z;
      }
      return m(M), M;
    }
    s(C, "multiplyLong");
    function T(x, D) {
      var _ = x.length, P = new Array(_), v = t, M = 0, H, G;
      for (G = 0; G < _; G++)
        H = x[G] * D + M, M = Math.floor(H / v), P[G] = H - M * v;
      for (; M > 0; )
        P[G++] = M % v, M = Math.floor(M / v);
      return P;
    }
    s(T, "multiplySmall");
    function F(x, D) {
      for (var _ = []; D-- > 0; ) _.push(0);
      return _.concat(x);
    }
    s(F, "shiftLeft");
    function $(x, D) {
      var _ = Math.max(x.length, D.length);
      if (_ <= 30) return C(x, D);
      _ = Math.ceil(_ / 2);
      var P = x.slice(_), v = x.slice(0, _), M = D.slice(_), H = D.slice(0, _), G = $(v, H), Z = $(P, M), fe = $(E(v, P), E(H, M)), Ae = E(E(
      G, F(k(k(fe, G), Z), _)), F(Z, 2 * _));
      return m(Ae), Ae;
    }
    s($, "multiplyKaratsuba");
    function R(x, D) {
      return -0.012 * x - 0.012 * D + 15e-6 * x * D > 0;
    }
    s(R, "useKaratsuba"), l.prototype.multiply = function(x) {
      var D = pe(x), _ = this.value, P = D.value, v = this.sign !== D.sign, M;
      if (D.isSmall) {
        if (P === 0) return u[0];
        if (P === 1) return this;
        if (P === -1) return this.negate();
        if (M = Math.abs(P), M < t)
          return new l(T(_, M), v);
        P = f(M);
      }
      return R(_.length, P.length) ? new l($(_, P), v) : new l(C(_, P), v);
    }, l.prototype.times = l.prototype.multiply;
    function U(x, D, _) {
      return x < t ? new l(T(D, x), _) : new l(C(D, f(x)), _);
    }
    s(U, "multiplySmallAndArray"), c.prototype._multiplyBySmall = function(x) {
      return h(x.value * this.value) ? new c(x.value * this.value) : U(Math.abs(x.value), f(Math.abs(this.value)), this.sign !== x.sign);
    }, l.prototype._multiplyBySmall = function(x) {
      return x.value === 0 ? u[0] : x.value === 1 ? this : x.value === -1 ? this.negate() : U(Math.abs(x.value), this.value, this.sign !== x.
      sign);
    }, c.prototype.multiply = function(x) {
      return pe(x)._multiplyBySmall(this);
    }, c.prototype.times = c.prototype.multiply, p.prototype.multiply = function(x) {
      return new p(this.value * pe(x).value);
    }, p.prototype.times = p.prototype.multiply;
    function W(x) {
      var D = x.length, _ = g(D + D), P = t, v, M, H, G, Z;
      for (H = 0; H < D; H++) {
        G = x[H], M = 0 - G * G;
        for (var fe = H; fe < D; fe++)
          Z = x[fe], v = 2 * (G * Z) + _[H + fe] + M, M = Math.floor(v / P), _[H + fe] = v - M * P;
        _[H + D] = M;
      }
      return m(_), _;
    }
    s(W, "square"), l.prototype.square = function() {
      return new l(W(this.value), !1);
    }, c.prototype.square = function() {
      var x = this.value * this.value;
      return h(x) ? new c(x) : new l(W(f(Math.abs(this.value))), !1);
    }, p.prototype.square = function(x) {
      return new p(this.value * this.value);
    };
    function Y(x, D) {
      var _ = x.length, P = D.length, v = t, M = g(D.length), H = D[P - 1], G = Math.ceil(v / (2 * H)), Z = T(x, G), fe = T(D, G), Ae, he, ke,
      nt, qt, lh, ch;
      for (Z.length <= _ && Z.push(0), fe.push(0), H = fe[P - 1], he = _ - P; he >= 0; he--) {
        for (Ae = v - 1, Z[he + P] !== H && (Ae = Math.floor((Z[he + P] * v + Z[he + P - 1]) / H)), ke = 0, nt = 0, lh = fe.length, qt = 0; qt <
        lh; qt++)
          ke += Ae * fe[qt], ch = Math.floor(ke / v), nt += Z[he + qt] - (ke - ch * v), ke = ch, nt < 0 ? (Z[he + qt] = nt + v, nt = -1) : (Z[he +
          qt] = nt, nt = 0);
        for (; nt !== 0; ) {
          for (Ae -= 1, ke = 0, qt = 0; qt < lh; qt++)
            ke += Z[he + qt] - v + fe[qt], ke < 0 ? (Z[he + qt] = ke + v, ke = 0) : (Z[he + qt] = ke, ke = 1);
          nt += ke;
        }
        M[he] = Ae;
      }
      return Z = N(Z, G)[0], [d(M), d(Z)];
    }
    s(Y, "divMod1");
    function j(x, D) {
      for (var _ = x.length, P = D.length, v = [], M = [], H = t, G, Z, fe, Ae, he; _; ) {
        if (M.unshift(x[--_]), m(M), Q(M, D) < 0) {
          v.push(0);
          continue;
        }
        Z = M.length, fe = M[Z - 1] * H + M[Z - 2], Ae = D[P - 1] * H + D[P - 2], Z > P && (fe = (fe + 1) * H), G = Math.ceil(fe / Ae);
        do {
          if (he = T(D, G), Q(he, M) <= 0) break;
          G--;
        } while (G);
        v.push(G), M = k(M, he);
      }
      return v.reverse(), [d(v), d(M)];
    }
    s(j, "divMod2");
    function N(x, D) {
      var _ = x.length, P = g(_), v = t, M, H, G, Z;
      for (G = 0, M = _ - 1; M >= 0; --M)
        Z = G * v + x[M], H = b(Z / D), G = Z - H * D, P[M] = H | 0;
      return [P, G | 0];
    }
    s(N, "divModSmall");
    function z(x, D) {
      var _, P = pe(D);
      if (a)
        return [new p(x.value / P.value), new p(x.value % P.value)];
      var v = x.value, M = P.value, H;
      if (M === 0) throw new Error("Cannot divide by zero");
      if (x.isSmall)
        return P.isSmall ? [new c(b(v / M)), new c(v % M)] : [u[0], x];
      if (P.isSmall) {
        if (M === 1) return [x, u[0]];
        if (M == -1) return [x.negate(), u[0]];
        var G = Math.abs(M);
        if (G < t) {
          _ = N(v, G), H = d(_[0]);
          var Z = _[1];
          return x.sign && (Z = -Z), typeof H == "number" ? (x.sign !== P.sign && (H = -H), [new c(H), new c(Z)]) : [new l(H, x.sign !== P.sign),
          new c(Z)];
        }
        M = f(G);
      }
      var fe = Q(v, M);
      if (fe === -1) return [u[0], x];
      if (fe === 0) return [u[x.sign === P.sign ? 1 : -1], u[0]];
      v.length + M.length <= 200 ? _ = Y(v, M) : _ = j(v, M), H = _[0];
      var Ae = x.sign !== P.sign, he = _[1], ke = x.sign;
      return typeof H == "number" ? (Ae && (H = -H), H = new c(H)) : H = new l(H, Ae), typeof he == "number" ? (ke && (he = -he), he = new c(
      he)) : he = new l(he, ke), [H, he];
    }
    s(z, "divModAny"), l.prototype.divmod = function(x) {
      var D = z(this, x);
      return {
        quotient: D[0],
        remainder: D[1]
      };
    }, p.prototype.divmod = c.prototype.divmod = l.prototype.divmod, l.prototype.divide = function(x) {
      return z(this, x)[0];
    }, p.prototype.over = p.prototype.divide = function(x) {
      return new p(this.value / pe(x).value);
    }, c.prototype.over = c.prototype.divide = l.prototype.over = l.prototype.divide, l.prototype.mod = function(x) {
      return z(this, x)[1];
    }, p.prototype.mod = p.prototype.remainder = function(x) {
      return new p(this.value % pe(x).value);
    }, c.prototype.remainder = c.prototype.mod = l.prototype.remainder = l.prototype.mod, l.prototype.pow = function(x) {
      var D = pe(x), _ = this.value, P = D.value, v, M, H;
      if (P === 0) return u[1];
      if (_ === 0) return u[0];
      if (_ === 1) return u[1];
      if (_ === -1) return D.isEven() ? u[1] : u[-1];
      if (D.sign)
        return u[0];
      if (!D.isSmall) throw new Error("The exponent " + D.toString() + " is too large.");
      if (this.isSmall && h(v = Math.pow(_, P)))
        return new c(b(v));
      for (M = this, H = u[1]; P & !0 && (H = H.times(M), --P), P !== 0; )
        P /= 2, M = M.square();
      return H;
    }, c.prototype.pow = l.prototype.pow, p.prototype.pow = function(x) {
      var D = pe(x), _ = this.value, P = D.value, v = BigInt(0), M = BigInt(1), H = BigInt(2);
      if (P === v) return u[1];
      if (_ === v) return u[0];
      if (_ === M) return u[1];
      if (_ === BigInt(-1)) return D.isEven() ? u[1] : u[-1];
      if (D.isNegative()) return new p(v);
      for (var G = this, Z = u[1]; (P & M) === M && (Z = Z.times(G), --P), P !== v; )
        P /= H, G = G.square();
      return Z;
    }, l.prototype.modPow = function(x, D) {
      if (x = pe(x), D = pe(D), D.isZero()) throw new Error("Cannot take modPow with modulus 0");
      var _ = u[1], P = this.mod(D);
      for (x.isNegative() && (x = x.multiply(u[-1]), P = P.modInv(D)); x.isPositive(); ) {
        if (P.isZero()) return u[0];
        x.isOdd() && (_ = _.multiply(P).mod(D)), x = x.divide(2), P = P.square().mod(D);
      }
      return _;
    }, p.prototype.modPow = c.prototype.modPow = l.prototype.modPow;
    function Q(x, D) {
      if (x.length !== D.length)
        return x.length > D.length ? 1 : -1;
      for (var _ = x.length - 1; _ >= 0; _--)
        if (x[_] !== D[_]) return x[_] > D[_] ? 1 : -1;
      return 0;
    }
    s(Q, "compareAbs"), l.prototype.compareAbs = function(x) {
      var D = pe(x), _ = this.value, P = D.value;
      return D.isSmall ? 1 : Q(_, P);
    }, c.prototype.compareAbs = function(x) {
      var D = pe(x), _ = Math.abs(this.value), P = D.value;
      return D.isSmall ? (P = Math.abs(P), _ === P ? 0 : _ > P ? 1 : -1) : -1;
    }, p.prototype.compareAbs = function(x) {
      var D = this.value, _ = pe(x).value;
      return D = D >= 0 ? D : -D, _ = _ >= 0 ? _ : -_, D === _ ? 0 : D > _ ? 1 : -1;
    }, l.prototype.compare = function(x) {
      if (x === 1 / 0)
        return -1;
      if (x === -1 / 0)
        return 1;
      var D = pe(x), _ = this.value, P = D.value;
      return this.sign !== D.sign ? D.sign ? 1 : -1 : D.isSmall ? this.sign ? -1 : 1 : Q(_, P) * (this.sign ? -1 : 1);
    }, l.prototype.compareTo = l.prototype.compare, c.prototype.compare = function(x) {
      if (x === 1 / 0)
        return -1;
      if (x === -1 / 0)
        return 1;
      var D = pe(x), _ = this.value, P = D.value;
      return D.isSmall ? _ == P ? 0 : _ > P ? 1 : -1 : _ < 0 !== D.sign ? _ < 0 ? -1 : 1 : _ < 0 ? 1 : -1;
    }, c.prototype.compareTo = c.prototype.compare, p.prototype.compare = function(x) {
      if (x === 1 / 0)
        return -1;
      if (x === -1 / 0)
        return 1;
      var D = this.value, _ = pe(x).value;
      return D === _ ? 0 : D > _ ? 1 : -1;
    }, p.prototype.compareTo = p.prototype.compare, l.prototype.equals = function(x) {
      return this.compare(x) === 0;
    }, p.prototype.eq = p.prototype.equals = c.prototype.eq = c.prototype.equals = l.prototype.eq = l.prototype.equals, l.prototype.notEquals =
    function(x) {
      return this.compare(x) !== 0;
    }, p.prototype.neq = p.prototype.notEquals = c.prototype.neq = c.prototype.notEquals = l.prototype.neq = l.prototype.notEquals, l.prototype.
    greater = function(x) {
      return this.compare(x) > 0;
    }, p.prototype.gt = p.prototype.greater = c.prototype.gt = c.prototype.greater = l.prototype.gt = l.prototype.greater, l.prototype.lesser =
    function(x) {
      return this.compare(x) < 0;
    }, p.prototype.lt = p.prototype.lesser = c.prototype.lt = c.prototype.lesser = l.prototype.lt = l.prototype.lesser, l.prototype.greaterOrEquals =
    function(x) {
      return this.compare(x) >= 0;
    }, p.prototype.geq = p.prototype.greaterOrEquals = c.prototype.geq = c.prototype.greaterOrEquals = l.prototype.geq = l.prototype.greaterOrEquals,
    l.prototype.lesserOrEquals = function(x) {
      return this.compare(x) <= 0;
    }, p.prototype.leq = p.prototype.lesserOrEquals = c.prototype.leq = c.prototype.lesserOrEquals = l.prototype.leq = l.prototype.lesserOrEquals,
    l.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    }, c.prototype.isEven = function() {
      return (this.value & 1) === 0;
    }, p.prototype.isEven = function() {
      return (this.value & BigInt(1)) === BigInt(0);
    }, l.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    }, c.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    }, p.prototype.isOdd = function() {
      return (this.value & BigInt(1)) === BigInt(1);
    }, l.prototype.isPositive = function() {
      return !this.sign;
    }, c.prototype.isPositive = function() {
      return this.value > 0;
    }, p.prototype.isPositive = c.prototype.isPositive, l.prototype.isNegative = function() {
      return this.sign;
    }, c.prototype.isNegative = function() {
      return this.value < 0;
    }, p.prototype.isNegative = c.prototype.isNegative, l.prototype.isUnit = function() {
      return !1;
    }, c.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    }, p.prototype.isUnit = function() {
      return this.abs().value === BigInt(1);
    }, l.prototype.isZero = function() {
      return !1;
    }, c.prototype.isZero = function() {
      return this.value === 0;
    }, p.prototype.isZero = function() {
      return this.value === BigInt(0);
    }, l.prototype.isDivisibleBy = function(x) {
      var D = pe(x);
      return D.isZero() ? !1 : D.isUnit() ? !0 : D.compareAbs(2) === 0 ? this.isEven() : this.mod(D).isZero();
    }, p.prototype.isDivisibleBy = c.prototype.isDivisibleBy = l.prototype.isDivisibleBy;
    function ie(x) {
      var D = x.abs();
      if (D.isUnit()) return !1;
      if (D.equals(2) || D.equals(3) || D.equals(5)) return !0;
      if (D.isEven() || D.isDivisibleBy(3) || D.isDivisibleBy(5)) return !1;
      if (D.lesser(49)) return !0;
    }
    s(ie, "isBasicPrime");
    function B(x, D) {
      for (var _ = x.prev(), P = _, v = 0, M, H, G, Z; P.isEven(); ) P = P.divide(2), v++;
      e: for (G = 0; G < D.length; G++)
        if (!x.lesser(D[G]) && (Z = yt(D[G]).modPow(P, x), !(Z.isUnit() || Z.equals(_)))) {
          for (M = v - 1; M != 0; M--) {
            if (Z = Z.square().mod(x), Z.isUnit()) return !1;
            if (Z.equals(_)) continue e;
          }
          return !1;
        }
      return !0;
    }
    s(B, "millerRabinTest"), l.prototype.isPrime = function(x) {
      var D = ie(this);
      if (D !== e) return D;
      var _ = this.abs(), P = _.bitLength();
      if (P <= 64)
        return B(_, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      for (var v = Math.log(2) * P.toJSNumber(), M = Math.ceil(x === !0 ? 2 * Math.pow(v, 2) : v), H = [], G = 0; G < M; G++)
        H.push(yt(G + 2));
      return B(_, H);
    }, p.prototype.isPrime = c.prototype.isPrime = l.prototype.isPrime, l.prototype.isProbablePrime = function(x, D) {
      var _ = ie(this);
      if (_ !== e) return _;
      for (var P = this.abs(), v = x === e ? 5 : x, M = [], H = 0; H < v; H++)
        M.push(yt.randBetween(2, P.minus(2), D));
      return B(P, M);
    }, p.prototype.isProbablePrime = c.prototype.isProbablePrime = l.prototype.isProbablePrime, l.prototype.modInv = function(x) {
      for (var D = yt.zero, _ = yt.one, P = pe(x), v = this.abs(), M, H, G; !v.isZero(); )
        M = P.divide(v), H = D, G = P, D = _, P = v, _ = H.subtract(M.multiply(_)), v = G.subtract(M.multiply(v));
      if (!P.isUnit()) throw new Error(this.toString() + " and " + x.toString() + " are not co-prime");
      return D.compare(0) === -1 && (D = D.add(x)), this.isNegative() ? D.negate() : D;
    }, p.prototype.modInv = c.prototype.modInv = l.prototype.modInv, l.prototype.next = function() {
      var x = this.value;
      return this.sign ? w(x, 1, this.sign) : new l(A(x, 1), this.sign);
    }, c.prototype.next = function() {
      var x = this.value;
      return x + 1 < n ? new c(x + 1) : new l(i, !1);
    }, p.prototype.next = function() {
      return new p(this.value + BigInt(1));
    }, l.prototype.prev = function() {
      var x = this.value;
      return this.sign ? new l(A(x, 1), !0) : w(x, 1, this.sign);
    }, c.prototype.prev = function() {
      var x = this.value;
      return x - 1 > -n ? new c(x - 1) : new l(i, !0);
    }, p.prototype.prev = function() {
      return new p(this.value - BigInt(1));
    };
    for (var ce = [1]; 2 * ce[ce.length - 1] <= t; ) ce.push(2 * ce[ce.length - 1]);
    var Je = ce.length, L = ce[Je - 1];
    function Ue(x) {
      return Math.abs(x) <= t;
    }
    s(Ue, "shift_isSmall"), l.prototype.shiftLeft = function(x) {
      var D = pe(x).toJSNumber();
      if (!Ue(D))
        throw new Error(String(D) + " is too large for shifting.");
      if (D < 0) return this.shiftRight(-D);
      var _ = this;
      if (_.isZero()) return _;
      for (; D >= Je; )
        _ = _.multiply(L), D -= Je - 1;
      return _.multiply(ce[D]);
    }, p.prototype.shiftLeft = c.prototype.shiftLeft = l.prototype.shiftLeft, l.prototype.shiftRight = function(x) {
      var D, _ = pe(x).toJSNumber();
      if (!Ue(_))
        throw new Error(String(_) + " is too large for shifting.");
      if (_ < 0) return this.shiftLeft(-_);
      for (var P = this; _ >= Je; ) {
        if (P.isZero() || P.isNegative() && P.isUnit()) return P;
        D = z(P, L), P = D[1].isNegative() ? D[0].prev() : D[0], _ -= Je - 1;
      }
      return D = z(P, ce[_]), D[1].isNegative() ? D[0].prev() : D[0];
    }, p.prototype.shiftRight = c.prototype.shiftRight = l.prototype.shiftRight;
    function $e(x, D, _) {
      D = pe(D);
      for (var P = x.isNegative(), v = D.isNegative(), M = P ? x.not() : x, H = v ? D.not() : D, G = 0, Z = 0, fe = null, Ae = null, he = []; !M.
      isZero() || !H.isZero(); )
        fe = z(M, L), G = fe[1].toJSNumber(), P && (G = L - 1 - G), Ae = z(H, L), Z = Ae[1].toJSNumber(), v && (Z = L - 1 - Z), M = fe[0], H =
        Ae[0], he.push(_(G, Z));
      for (var ke = _(P ? 1 : 0, v ? 1 : 0) !== 0 ? yt(-1) : yt(0), nt = he.length - 1; nt >= 0; nt -= 1)
        ke = ke.multiply(L).add(yt(he[nt]));
      return ke;
    }
    s($e, "bitwise"), l.prototype.not = function() {
      return this.negate().prev();
    }, p.prototype.not = c.prototype.not = l.prototype.not, l.prototype.and = function(x) {
      return $e(this, x, function(D, _) {
        return D & _;
      });
    }, p.prototype.and = c.prototype.and = l.prototype.and, l.prototype.or = function(x) {
      return $e(this, x, function(D, _) {
        return D | _;
      });
    }, p.prototype.or = c.prototype.or = l.prototype.or, l.prototype.xor = function(x) {
      return $e(this, x, function(D, _) {
        return D ^ _;
      });
    }, p.prototype.xor = c.prototype.xor = l.prototype.xor;
    var me = 1 << 30, It = (t & -t) * (t & -t) | me;
    function Me(x) {
      var D = x.value, _ = typeof D == "number" ? D | me : typeof D == "bigint" ? D | BigInt(me) : D[0] + D[1] * t | It;
      return _ & -_;
    }
    s(Me, "roughLOB");
    function re(x, D) {
      if (D.compareTo(x) <= 0) {
        var _ = re(x, D.square(D)), P = _.p, v = _.e, M = P.multiply(D);
        return M.compareTo(x) <= 0 ? { p: M, e: v * 2 + 1 } : { p: P, e: v * 2 };
      }
      return { p: yt(1), e: 0 };
    }
    s(re, "integerLogarithm"), l.prototype.bitLength = function() {
      var x = this;
      return x.compareTo(yt(0)) < 0 && (x = x.negate().subtract(yt(1))), x.compareTo(yt(0)) === 0 ? yt(0) : yt(re(x, yt(2)).e).add(yt(1));
    }, p.prototype.bitLength = c.prototype.bitLength = l.prototype.bitLength;
    function xe(x, D) {
      return x = pe(x), D = pe(D), x.greater(D) ? x : D;
    }
    s(xe, "max");
    function K(x, D) {
      return x = pe(x), D = pe(D), x.lesser(D) ? x : D;
    }
    s(K, "min");
    function se(x, D) {
      if (x = pe(x).abs(), D = pe(D).abs(), x.equals(D)) return x;
      if (x.isZero()) return D;
      if (D.isZero()) return x;
      for (var _ = u[1], P, v; x.isEven() && D.isEven(); )
        P = K(Me(x), Me(D)), x = x.divide(P), D = D.divide(P), _ = _.multiply(P);
      for (; x.isEven(); )
        x = x.divide(Me(x));
      do {
        for (; D.isEven(); )
          D = D.divide(Me(D));
        x.greater(D) && (v = D, D = x, x = v), D = D.subtract(x);
      } while (!D.isZero());
      return _.isUnit() ? x : x.multiply(_);
    }
    s(se, "gcd");
    function ge(x, D) {
      return x = pe(x).abs(), D = pe(D).abs(), x.divide(se(x, D)).multiply(D);
    }
    s(ge, "lcm");
    function be(x, D, _) {
      x = pe(x), D = pe(D);
      var P = _ || Math.random, v = K(x, D), M = xe(x, D), H = M.subtract(v).add(1);
      if (H.isSmall) return v.add(Math.floor(P() * H));
      for (var G = We(H, t).value, Z = [], fe = !0, Ae = 0; Ae < G.length; Ae++) {
        var he = fe ? G[Ae] + (Ae + 1 < G.length ? G[Ae + 1] / t : 0) : t, ke = b(P() * he);
        Z.push(ke), ke < G[Ae] && (fe = !1);
      }
      return v.add(u.fromArray(Z, t, !1));
    }
    s(be, "randBetween");
    var Ee = /* @__PURE__ */ s(function(x, D, _, P) {
      _ = _ || o, x = String(x), P || (x = x.toLowerCase(), _ = _.toLowerCase());
      var v = x.length, M, H = Math.abs(D), G = {};
      for (M = 0; M < _.length; M++)
        G[_[M]] = M;
      for (M = 0; M < v; M++) {
        var Z = x[M];
        if (Z !== "-" && Z in G && G[Z] >= H) {
          if (Z === "1" && H === 1) continue;
          throw new Error(Z + " is not a valid digit in base " + D + ".");
        }
      }
      D = pe(D);
      var fe = [], Ae = x[0] === "-";
      for (M = Ae ? 1 : 0; M < x.length; M++) {
        var Z = x[M];
        if (Z in G) fe.push(pe(G[Z]));
        else if (Z === "<") {
          var he = M;
          do
            M++;
          while (x[M] !== ">" && M < x.length);
          fe.push(pe(x.slice(he + 1, M)));
        } else throw new Error(Z + " is not a valid character");
      }
      return rt(fe, D, Ae);
    }, "parseBase");
    function rt(x, D, _) {
      var P = u[0], v = u[1], M;
      for (M = x.length - 1; M >= 0; M--)
        P = P.add(x[M].times(v)), v = v.times(D);
      return _ ? P.negate() : P;
    }
    s(rt, "parseBaseFromArray");
    function Ct(x, D) {
      return D = D || o, x < D.length ? D[x] : "<" + x + ">";
    }
    s(Ct, "stringify");
    function We(x, D) {
      if (D = yt(D), D.isZero()) {
        if (x.isZero()) return { value: [0], isNegative: !1 };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (D.equals(-1)) {
        if (x.isZero()) return { value: [0], isNegative: !1 };
        if (x.isNegative())
          return {
            value: [].concat.apply(
              [],
              Array.apply(null, Array(-x.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
            ),
            isNegative: !1
          };
        var _ = Array.apply(null, Array(x.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        return _.unshift([1]), {
          value: [].concat.apply([], _),
          isNegative: !1
        };
      }
      var P = !1;
      if (x.isNegative() && D.isPositive() && (P = !0, x = x.abs()), D.isUnit())
        return x.isZero() ? { value: [0], isNegative: !1 } : {
          value: Array.apply(null, Array(x.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: P
        };
      for (var v = [], M = x, H; M.isNegative() || M.compareAbs(D) >= 0; ) {
        H = M.divmod(D), M = H.quotient;
        var G = H.remainder;
        G.isNegative() && (G = D.minus(G).abs(), M = M.next()), v.push(G.toJSNumber());
      }
      return v.push(M.toJSNumber()), { value: v.reverse(), isNegative: P };
    }
    s(We, "toBase");
    function sr(x, D, _) {
      var P = We(x, D);
      return (P.isNegative ? "-" : "") + P.value.map(function(v) {
        return Ct(v, _);
      }).join("");
    }
    s(sr, "toBaseString"), l.prototype.toArray = function(x) {
      return We(this, x);
    }, c.prototype.toArray = function(x) {
      return We(this, x);
    }, p.prototype.toArray = function(x) {
      return We(this, x);
    }, l.prototype.toString = function(x, D) {
      if (x === e && (x = 10), x !== 10 || D) return sr(this, x, D);
      for (var _ = this.value, P = _.length, v = String(_[--P]), M = "0000000", H; --P >= 0; )
        H = String(_[P]), v += M.slice(H.length) + H;
      var G = this.sign ? "-" : "";
      return G + v;
    }, c.prototype.toString = function(x, D) {
      return x === e && (x = 10), x != 10 || D ? sr(this, x, D) : String(this.value);
    }, p.prototype.toString = c.prototype.toString, p.prototype.toJSON = l.prototype.toJSON = c.prototype.toJSON = function() {
      return this.toString();
    }, l.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    }, l.prototype.toJSNumber = l.prototype.valueOf, c.prototype.valueOf = function() {
      return this.value;
    }, c.prototype.toJSNumber = c.prototype.valueOf, p.prototype.valueOf = p.prototype.toJSNumber = function() {
      return parseInt(this.toString(), 10);
    };
    function or(x) {
      if (h(+x)) {
        var D = +x;
        if (D === b(D))
          return a ? new p(BigInt(D)) : new c(D);
        throw new Error("Invalid integer: " + x);
      }
      var _ = x[0] === "-";
      _ && (x = x.slice(1));
      var P = x.split(/e/i);
      if (P.length > 2) throw new Error("Invalid integer: " + P.join("e"));
      if (P.length === 2) {
        var v = P[1];
        if (v[0] === "+" && (v = v.slice(1)), v = +v, v !== b(v) || !h(v)) throw new Error("Invalid integer: " + v + " is not a valid expone\
nt.");
        var M = P[0], H = M.indexOf(".");
        if (H >= 0 && (v -= M.length - H - 1, M = M.slice(0, H) + M.slice(H + 1)), v < 0) throw new Error("Cannot include negative exponent \
part for integers");
        M += new Array(v + 1).join("0"), x = M;
      }
      var G = /^([0-9][0-9]*)$/.test(x);
      if (!G) throw new Error("Invalid integer: " + x);
      if (a)
        return new p(BigInt(_ ? "-" + x : x));
      for (var Z = [], fe = x.length, Ae = r, he = fe - Ae; fe > 0; )
        Z.push(+x.slice(he, fe)), he -= Ae, he < 0 && (he = 0), fe -= Ae;
      return m(Z), new l(Z, _);
    }
    s(or, "parseStringValue");
    function kr(x) {
      if (a)
        return new p(BigInt(x));
      if (h(x)) {
        if (x !== b(x)) throw new Error(x + " is not an integer.");
        return new c(x);
      }
      return or(x.toString());
    }
    s(kr, "parseNumberValue");
    function pe(x) {
      return typeof x == "number" ? kr(x) : typeof x == "string" ? or(x) : typeof x == "bigint" ? new p(x) : x;
    }
    s(pe, "parseValue");
    for (var Ye = 0; Ye < 1e3; Ye++)
      u[Ye] = pe(Ye), Ye > 0 && (u[-Ye] = pe(-Ye));
    return u.one = u[1], u.zero = u[0], u.minusOne = u[-1], u.max = xe, u.min = K, u.gcd = se, u.lcm = ge, u.isInstance = function(x) {
      return x instanceof l || x instanceof c || x instanceof p;
    }, u.randBetween = be, u.fromArray = function(x, D, _) {
      return rt(x.map(pe), pe(D || 10), _);
    }, u;
  }();
  typeof Op < "u" && Op.hasOwnProperty("exports") && (Op.exports = yt);
  typeof define == "function" && define.amd && define(function() {
    return yt;
  });
});

// ../node_modules/bplist-parser/bplistParser.js
var xO = I((Dt) => {
  "use strict";
  var ane = require("fs"), une = DO(), vi = !1;
  Dt.maxObjectSize = 100 * 1e3 * 1e3;
  Dt.maxObjectCount = 32768;
  var lne = 9783072e5, cne = Dt.UID = function(e) {
    this.UID = e;
  }, gbe = Dt.parseFile = function(e, t) {
    return new Promise(function(r, n) {
      function i(o) {
        let a = null, u;
        try {
          u = pne(o), r(u);
        } catch (l) {
          a = l, n(a);
        } finally {
          t && t(a, u);
        }
      }
      if (s(i, "tryParseBuffer"), Buffer.isBuffer(e))
        return i(e);
      ane.readFile(e, function(o, a) {
        if (o)
          return n(o), t(o);
        i(a);
      });
    });
  }, pne = Dt.parseBuffer = function(e) {
    if (e.slice(0, 6).toString("utf8") !== "bplist")
      throw new Error("Invalid binary plist. Expected 'bplist' at offset 0.");
    let r = e.slice(e.length - 32, e.length), n = r.readUInt8(6);
    vi && console.log("offsetSize: " + n);
    let i = r.readUInt8(7);
    vi && console.log("objectRefSize: " + i);
    let o = ED(r, 8);
    vi && console.log("numObjects: " + o);
    let a = ED(r, 16);
    vi && console.log("topObject: " + a);
    let u = ED(r, 24);
    if (vi && console.log("offsetTableOffset: " + u), o > Dt.maxObjectCount)
      throw new Error("maxObjectCount exceeded");
    let l = [];
    for (let p = 0; p < o; p++) {
      let h = e.slice(u + p * n, u + (p + 1) * n);
      l[p] = Zt(h, 0), vi && console.log("Offset for Object #" + p + " is " + l[p] + " [" + l[p].toString(16) + "]");
    }
    function c(p) {
      let h = l[p], f = e[h], d = (f & 240) >> 4, m = f & 15;
      switch (d) {
        case 0:
          return g();
        case 1:
          return y();
        case 8:
          return E();
        case 2:
          return A();
        case 3:
          return k();
        case 4:
          return O();
        case 5:
          return w();
        case 6:
          return w(!0);
        case 10:
          return C();
        case 13:
          return T();
        default:
          throw new Error("Unhandled type 0x" + d.toString(16));
      }
      function g() {
        switch (m) {
          case 0:
            return null;
          case 8:
            return !1;
          case 9:
            return !0;
          case 15:
            return null;
          default:
            throw new Error("Unhandled simple type 0x" + d.toString(16));
        }
      }
      s(g, "parseSimple");
      function b(F) {
        let $ = "", R;
        for (R = 0; R < F.length && F[R] == 0; R++)
          ;
        for (; R < F.length; R++) {
          let U = "00" + F[R].toString(16);
          $ += U.substr(U.length - 2);
        }
        return $;
      }
      s(b, "bufferToHexString");
      function y() {
        let F = Math.pow(2, m);
        if (m == 4) {
          let $ = e.slice(h + 1, h + 1 + F), R = b($);
          return une(R, 16);
        }
        if (m == 3)
          return e.readInt32BE(h + 1);
        if (F < Dt.maxObjectSize)
          return Zt(e.slice(h + 1, h + 1 + F));
        throw new Error("To little heap space available! Wanted to read " + F + " bytes, but only " + Dt.maxObjectSize + " are available.");
      }
      s(y, "parseInteger");
      function E() {
        let F = m + 1;
        if (F < Dt.maxObjectSize)
          return new cne(Zt(e.slice(h + 1, h + 1 + F)));
        throw new Error("To little heap space available! Wanted to read " + F + " bytes, but only " + Dt.maxObjectSize + " are available.");
      }
      s(E, "parseUID");
      function A() {
        let F = Math.pow(2, m);
        if (F < Dt.maxObjectSize) {
          let $ = e.slice(h + 1, h + 1 + F);
          if (F === 4)
            return $.readFloatBE(0);
          if (F === 8)
            return $.readDoubleBE(0);
        } else
          throw new Error("To little heap space available! Wanted to read " + F + " bytes, but only " + Dt.maxObjectSize + " are available.");
      }
      s(A, "parseReal");
      function k() {
        m != 3 && console.error("Unknown date type :" + m + ". Parsing anyway...");
        let F = e.slice(h + 1, h + 9);
        return new Date(lne + 1e3 * F.readDoubleBE(0));
      }
      s(k, "parseDate");
      function O() {
        let F = 1, $ = m;
        if (m == 15) {
          let R = e[h + 1], U = (R & 240) / 16;
          U != 1 && console.error("0x4: UNEXPECTED LENGTH-INT TYPE! " + U);
          let W = R & 15, Y = Math.pow(2, W);
          F = 2 + Y, Y < 3, $ = Zt(e.slice(h + 2, h + 2 + Y));
        }
        if ($ < Dt.maxObjectSize)
          return e.slice(h + F, h + F + $);
        throw new Error("To little heap space available! Wanted to read " + $ + " bytes, but only " + Dt.maxObjectSize + " are available.");
      }
      s(O, "parseData");
      function w(F) {
        F = F || 0;
        let $ = "utf8", R = m, U = 1;
        if (m == 15) {
          let W = e[h + 1], Y = (W & 240) / 16;
          Y != 1 && console.err("UNEXPECTED LENGTH-INT TYPE! " + Y);
          let j = W & 15, N = Math.pow(2, j);
          U = 2 + N, N < 3, R = Zt(e.slice(h + 2, h + 2 + N));
        }
        if (R *= F + 1, R < Dt.maxObjectSize) {
          let W = Buffer.from(e.slice(h + U, h + U + R));
          return F && (W = hne(W), $ = "ucs2"), W.toString($);
        }
        throw new Error("To little heap space available! Wanted to read " + R + " bytes, but only " + Dt.maxObjectSize + " are available.");
      }
      s(w, "parsePlistString");
      function C() {
        let F = m, $ = 1;
        if (m == 15) {
          let U = e[h + 1], W = (U & 240) / 16;
          W != 1 && console.error("0xa: UNEXPECTED LENGTH-INT TYPE! " + W);
          let Y = U & 15, j = Math.pow(2, Y);
          $ = 2 + j, j < 3, F = Zt(e.slice(h + 2, h + 2 + j));
        }
        if (F * i > Dt.maxObjectSize)
          throw new Error("To little heap space available!");
        let R = [];
        for (let U = 0; U < F; U++) {
          let W = Zt(e.slice(h + $ + U * i, h + $ + (U + 1) * i));
          R[U] = c(W);
        }
        return R;
      }
      s(C, "parseArray");
      function T() {
        let F = m, $ = 1;
        if (m == 15) {
          let U = e[h + 1], W = (U & 240) / 16;
          W != 1 && console.error("0xD: UNEXPECTED LENGTH-INT TYPE! " + W);
          let Y = U & 15, j = Math.pow(2, Y);
          $ = 2 + j, j < 3, F = Zt(e.slice(h + 2, h + 2 + j));
        }
        if (F * 2 * i > Dt.maxObjectSize)
          throw new Error("To little heap space available!");
        vi && console.log("Parsing dictionary #" + p);
        let R = {};
        for (let U = 0; U < F; U++) {
          let W = Zt(e.slice(h + $ + U * i, h + $ + (U + 1) * i)), Y = Zt(e.slice(h + $ + F * i + U * i, h + $ + F * i + (U + 1) * i)), j = c(
          W), N = c(Y);
          vi && console.log("  DICT #" + p + ": Mapped " + j + " to " + N), R[j] = N;
        }
        return R;
      }
      s(T, "parseDictionary");
    }
    return s(c, "parseObject"), [c(a)];
  };
  function Zt(e, t) {
    t = t || 0;
    let r = 0;
    for (let n = t; n < e.length; n++)
      r <<= 8, r |= e[n] & 255;
    return r;
  }
  s(Zt, "readUInt");
  function ED(e, t) {
    return e.slice(t, t + 8).readUInt32BE(4, 8);
  }
  s(ED, "readUInt64BE");
  function hne(e) {
    let t = e.length;
    for (let r = 0; r < t; r += 2) {
      let n = e[r];
      e[r] = e[r + 1], e[r + 1] = n;
    }
    return e;
  }
  s(hne, "swapBytes");
});

// ../node_modules/untildify/index.js
var EO = I((xbe, vO) => {
  "use strict";
  var fne = require("os"), bO = fne.homedir();
  vO.exports = (e) => {
    if (typeof e != "string")
      throw new TypeError(`Expected a string, got ${typeof e}`);
    return bO ? e.replace(/^~(?=$|\/|\\)/, bO) : e;
  };
});

// ../node_modules/@aw-web-design/x-default-browser/node_modules/default-browser-id/index.js
var _O = {};
Gn(_O, {
  default: () => FO
});
async function FO() {
  if (process.platform !== "darwin")
    throw new Error("macOS only");
  let e = "com.apple.Safari", t;
  try {
    t = await wO.promises.readFile(mne);
  } catch (i) {
    if (i.code === "ENOENT")
      return e;
    throw i;
  }
  let r = SO.default.parseBuffer(t), n = r && r[0].LSHandlers;
  if (!n || n.length === 0)
    return e;
  for (let i of n)
    if (i.LSHandlerURLScheme === "http" && i.LSHandlerRoleAll) {
      e = i.LSHandlerRoleAll;
      break;
    }
  return e;
}
var CO, wO, SO, AO, dne, mne, kO = wt(() => {
  CO = J(require("os"), 1), wO = require("fs"), SO = J(xO(), 1), AO = J(EO(), 1), dne = Number(CO.default.release().split(".")[0]), mne = (0, AO.default)(
  dne >= 14 ? "~/Library/Preferences/com.apple.LaunchServices/com.apple.launchservices.secure.plist" : "~/Library/Preferences/com.apple.Laun\
chServices.plist");
  s(FO, "defaultBrowserId");
});

// ../node_modules/@aw-web-design/x-default-browser/src/detect-mac.js
var IO = I((vbe, TO) => {
  var gne = Promise.resolve().then(() => (kO(), _O));
  TO.exports = async function(e) {
    let t = await gne.then((r) => r.default());
    if (t) {
      let r = t.toLowerCase(), n = {
        isIE: !1,
        isSafari: r.indexOf("safari") > -1,
        isFirefox: r.indexOf("firefox") > -1,
        isChrome: r.indexOf("google") > -1,
        isChromium: r.indexOf("chromium") > -1,
        // untested
        isOpera: r.indexOf("opera") > -1,
        identity: t
      };
      n.isBlink = n.isChrome || n.isChromium || n.isOpera, n.isWebkit = n.isSafari || n.isBlink, n.commonName = hu()(n), e(null, n);
    } else
      e("Unable to retrieve default browser");
  };
});

// ../node_modules/@aw-web-design/x-default-browser/src/detect-linux.js
var BO = I((Ebe, PO) => {
  var yne = require("child_process").exec;
  PO.exports = function(e) {
    var t = "xdg-mime query default x-scheme-handler/http";
    yne(t, function(r, n, i) {
      if (r) {
        e("Unable to execute the query: " + r + `
` + i);
        return;
      }
      var o = n, a = {
        isIE: !1,
        isSafari: !1,
        isFirefox: o.indexOf("firefox") > -1,
        isChrome: o.indexOf("google") > -1,
        isChromium: o.indexOf("chromium") > -1,
        isOpera: o.indexOf("opera") > -1,
        identity: o
      };
      a.isWebkit = a.isBlink = a.isChrome || a.isChromium || a.isOpera, a.commonName = hu()(a), e(null, a);
    });
  };
});

// ../node_modules/@aw-web-design/x-default-browser/src/detect-stub.js
var RO = I((Cbe, OO) => {
  OO.exports = function(e) {
    e("Your platform is not supported, sorry. Patches welcome.");
  };
});

// ../node_modules/@aw-web-design/x-default-browser/index.js
var LO = I((wbe, NO) => {
  var Io, fu = require("os");
  fu.platform() == "win32" ? fu.release().indexOf("10.") == 0 ? Io = mO() : Io = yO() : fu.platform() == "darwin" ? Io = IO() : fu.platform() ==
  "linux" || fu.platform() == "freebsd" ? Io = BO() : Io = RO();
  NO.exports = Io;
});

// ../node_modules/is-docker/index.js
var wD = I((Sbe, MO) => {
  "use strict";
  var jO = require("fs"), CD;
  function Dne() {
    try {
      return jO.statSync("/.dockerenv"), !0;
    } catch {
      return !1;
    }
  }
  s(Dne, "hasDockerEnv");
  function xne() {
    try {
      return jO.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch {
      return !1;
    }
  }
  s(xne, "hasDockerCGroup");
  MO.exports = () => (CD === void 0 && (CD = Dne() || xne()), CD);
});

// ../node_modules/open/node_modules/is-wsl/index.js
var VO = I((Fbe, SD) => {
  "use strict";
  var bne = require("os"), vne = require("fs"), qO = wD(), $O = /* @__PURE__ */ s(() => {
    if (process.platform !== "linux")
      return !1;
    if (bne.release().toLowerCase().includes("microsoft"))
      return !qO();
    try {
      return vne.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !qO() : !1;
    } catch {
      return !1;
    }
  }, "isWsl");
  process.env.__IS_WSL_TEST__ ? SD.exports = $O : SD.exports = $O();
});

// ../node_modules/open/node_modules/define-lazy-prop/index.js
var WO = I((kbe, UO) => {
  "use strict";
  UO.exports = (e, t, r) => {
    let n = /* @__PURE__ */ s((i) => Object.defineProperty(e, t, { value: i, enumerable: !0, writable: !0 }), "define");
    return Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !0,
      get() {
        let i = r();
        return n(i), i;
      },
      set(i) {
        n(i);
      }
    }), e;
  };
});

// ../node_modules/open/index.js
var KO = I((Ibe, XO) => {
  var Ene = require("path"), Cne = require("child_process"), { promises: Np, constants: ZO } = require("fs"), Rp = VO(), wne = wD(), FD = WO(),
  zO = Ene.join(__dirname, "xdg-open"), { platform: Po, arch: HO } = process, Sne = /* @__PURE__ */ s(() => {
    try {
      return Np.statSync("/run/.containerenv"), !0;
    } catch {
      return !1;
    }
  }, "hasContainerEnv"), AD;
  function Ane() {
    return AD === void 0 && (AD = Sne() || wne()), AD;
  }
  s(Ane, "isInsideContainer");
  var Fne = /* @__PURE__ */ (() => {
    let e = "/mnt/", t;
    return async function() {
      if (t)
        return t;
      let r = "/etc/wsl.conf", n = !1;
      try {
        await Np.access(r, ZO.F_OK), n = !0;
      } catch {
      }
      if (!n)
        return e;
      let i = await Np.readFile(r, { encoding: "utf8" }), o = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(i);
      return o ? (t = o.groups.mountPoint.trim(), t = t.endsWith("/") ? t : `${t}/`, t) : e;
    };
  })(), GO = /* @__PURE__ */ s(async (e, t) => {
    let r;
    for (let n of e)
      try {
        return await t(n);
      } catch (i) {
        r = i;
      }
    throw r;
  }, "pTryEach"), Lp = /* @__PURE__ */ s(async (e) => {
    if (e = {
      wait: !1,
      background: !1,
      newInstance: !1,
      allowNonzeroExitCode: !1,
      ...e
    }, Array.isArray(e.app))
      return GO(e.app, (u) => Lp({
        ...e,
        app: u
      }));
    let { name: t, arguments: r = [] } = e.app || {};
    if (r = [...r], Array.isArray(t))
      return GO(t, (u) => Lp({
        ...e,
        app: {
          name: u,
          arguments: r
        }
      }));
    let n, i = [], o = {};
    if (Po === "darwin")
      n = "open", e.wait && i.push("--wait-apps"), e.background && i.push("--background"), e.newInstance && i.push("--new"), t && i.push("-a",
      t);
    else if (Po === "win32" || Rp && !Ane() && !t) {
      let u = await Fne();
      n = Rp ? `${u}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\p\
owershell`, i.push(
        "-NoProfile",
        "-NonInteractive",
        "\u2013ExecutionPolicy",
        "Bypass",
        "-EncodedCommand"
      ), Rp || (o.windowsVerbatimArguments = !0);
      let l = ["Start"];
      e.wait && l.push("-Wait"), t ? (l.push(`"\`"${t}\`""`, "-ArgumentList"), e.target && r.unshift(e.target)) : e.target && l.push(`"${e.target}\
"`), r.length > 0 && (r = r.map((c) => `"\`"${c}\`""`), l.push(r.join(","))), e.target = Buffer.from(l.join(" "), "utf16le").toString("base6\
4");
    } else {
      if (t)
        n = t;
      else {
        let u = !__dirname || __dirname === "/", l = !1;
        try {
          await Np.access(zO, ZO.X_OK), l = !0;
        } catch {
        }
        n = process.versions.electron || Po === "android" || u || !l ? "xdg-open" : zO;
      }
      r.length > 0 && i.push(...r), e.wait || (o.stdio = "ignore", o.detached = !0);
    }
    e.target && i.push(e.target), Po === "darwin" && r.length > 0 && i.push("--args", ...r);
    let a = Cne.spawn(n, i, o);
    return e.wait ? new Promise((u, l) => {
      a.once("error", l), a.once("close", (c) => {
        if (!e.allowNonzeroExitCode && c > 0) {
          l(new Error(`Exited with code ${c}`));
          return;
        }
        u(a);
      });
    }) : (a.unref(), a);
  }, "baseOpen"), _D = /* @__PURE__ */ s((e, t) => {
    if (typeof e != "string")
      throw new TypeError("Expected a `target`");
    return Lp({
      ...t,
      target: e
    });
  }, "open"), _ne = /* @__PURE__ */ s((e, t) => {
    if (typeof e != "string")
      throw new TypeError("Expected a `name`");
    let { arguments: r = [] } = t || {};
    if (r != null && !Array.isArray(r))
      throw new TypeError("Expected `appArguments` as Array type");
    return Lp({
      ...t,
      app: {
        name: e,
        arguments: r
      }
    });
  }, "openApp");
  function JO(e) {
    if (typeof e == "string" || Array.isArray(e))
      return e;
    let { [HO]: t } = e;
    if (!t)
      throw new Error(`${HO} is not supported`);
    return t;
  }
  s(JO, "detectArchBinary");
  function kD({ [Po]: e }, { wsl: t }) {
    if (t && Rp)
      return JO(t);
    if (!e)
      throw new Error(`${Po} is not supported`);
    return JO(e);
  }
  s(kD, "detectPlatformBinary");
  var jp = {};
  FD(jp, "chrome", () => kD({
    darwin: "google chrome",
    win32: "chrome",
    linux: ["google-chrome", "google-chrome-stable", "chromium"]
  }, {
    wsl: {
      ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
      x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
    }
  }));
  FD(jp, "firefox", () => kD({
    darwin: "firefox",
    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
    linux: "firefox"
  }, {
    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
  }));
  FD(jp, "edge", () => kD({
    darwin: "microsoft edge",
    win32: "msedge",
    linux: ["microsoft-edge", "microsoft-edge-dev"]
  }, {
    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
  }));
  _D.apps = jp;
  _D.openApp = _ne;
  XO.exports = _D;
});

// ../node_modules/address/lib/address.js
var c6 = I((Rbe, l6) => {
  "use strict";
  var TD = require("os"), kne = require("fs"), Tne = require("child_process"), Ine = "/etc/resolv.conf";
  function u6() {
    var e = "eth", t = TD.platform();
    return t === "darwin" ? e = "en" : t === "win32" && (e = null), e;
  }
  s(u6, "getInterfaceName");
  function Pne() {
    return TD.platform() === "win32" ? "ipconfig/all" : "/sbin/ifconfig";
  }
  s(Pne, "getIfconfigCMD");
  function i6(e, t) {
    return t === "IPv4" ? e === "IPv4" || e === 4 : t === "IPv6" ? e === "IPv6" || e === 6 : e === t;
  }
  s(i6, "matchName");
  function Xt(e, t) {
    typeof e == "function" && (t = e, e = null);
    var r = {
      ip: Xt.ip(e),
      ipv6: Xt.ipv6(e),
      mac: null
    };
    Xt.mac(e, function(n, i) {
      i && (r.mac = i), t(n, r);
    });
  }
  s(Xt, "address");
  Xt.interface = function(e, t) {
    var r = TD.networkInterfaces(), n = !t;
    t = t || u6(), e = e || "IPv4";
    for (var i = -1; i < 8; i++) {
      var o = t + (i >= 0 ? i : ""), a = r[o];
      if (a)
        for (var u = 0; u < a.length; u++) {
          var l = a[u];
          if (i6(l.family, e))
            return l;
        }
    }
    if (n)
      for (var c in r)
        for (var a = r[c], i = 0; i < a.length; i++) {
          var l = a[i];
          if (i6(l.family, e) && !l.address.startsWith("127."))
            return l;
        }
  };
  Xt.ip = function(e) {
    var t = Xt.interface("IPv4", e);
    return t && t.address;
  };
  Xt.ipv6 = function(e) {
    var t = Xt.interface("IPv6", e);
    return t && t.address;
  };
  var s6 = /^(\w+)\:\s+flags=/, o6 = /^(\w+)\s{2,}link encap:\w+/i, a6 = Xt.MAC_RE = /(?:ether|HWaddr)\s+((?:[a-z0-9]{2}\:){5}[a-z0-9]{2})/i,
  Bne = Xt.MAC_IP_RE = /inet\s(?:addr\:)?(\d+\.\d+\.\d+\.\d+)/;
  function One(e, t, r) {
    for (var n = e.split(`
`), i = 0; i < n.length; i++) {
      var o = n[i].trimRight(), a = s6.exec(o) || o6.exec(o);
      if (a) {
        var u = a[1];
        if (u.indexOf(t) === 0) {
          var l = null, c = null, p = a6.exec(o);
          for (p && (c = p[1]), i++; ; ) {
            if (o = n[i], !o || s6.exec(o) || o6.exec(o)) {
              i--;
              break;
            }
            c || (p = a6.exec(o), p && (c = p[1])), l || (p = Bne.exec(o), p && (l = p[1])), i++;
          }
          if (l === r)
            return c;
        }
      }
    }
  }
  s(One, "getMAC");
  Xt.mac = function(e, t) {
    typeof e == "function" && (t = e, e = null), e = e || u6();
    var r = Xt.interface("IPv4", e);
    if (!r)
      return t();
    if (!process.env.CI && (r.mac === "ff:00:00:00:00:00" || r.mac === "00:00:00:00:00:00") && (r.mac = ""), r.mac)
      return t(null, r.mac);
    Tne.exec(Pne(), { timeout: 5e3 }, function(n, i, o) {
      if (n || !i)
        return t(n);
      var a = One(i || "", e, r.address);
      t(null, a);
    });
  };
  var Rne = /^nameserver\s+(\d+\.\d+\.\d+\.\d+)$/i;
  Xt.dns = function(e, t) {
    typeof e == "function" && (t = e, e = null), e = e || Ine, kne.readFile(e, "utf8", function(r, n) {
      if (r)
        return t(r);
      var i = [];
      n = n || "";
      for (var o = n.split(`
`), a = 0; a < o.length; a++) {
        var u = o[a].trim(), l = Rne.exec(u);
        l && i.push(l[1]);
      }
      t(null, i);
    });
  };
  l6.exports = Xt;
});

// ../node_modules/ms/index.js
var h6 = I((Lbe, p6) => {
  var Bo = 1e3, Oo = Bo * 60, Ro = Oo * 60, ps = Ro * 24, Nne = ps * 7, Lne = ps * 365.25;
  p6.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return jne(e);
    if (r === "number" && isFinite(e))
      return t.long ? qne(e) : Mne(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function jne(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * Lne;
          case "weeks":
          case "week":
          case "w":
            return r * Nne;
          case "days":
          case "day":
          case "d":
            return r * ps;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Ro;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * Oo;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Bo;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  s(jne, "parse");
  function Mne(e) {
    var t = Math.abs(e);
    return t >= ps ? Math.round(e / ps) + "d" : t >= Ro ? Math.round(e / Ro) + "h" : t >= Oo ? Math.round(e / Oo) + "m" : t >= Bo ? Math.round(
    e / Bo) + "s" : e + "ms";
  }
  s(Mne, "fmtShort");
  function qne(e) {
    var t = Math.abs(e);
    return t >= ps ? Mp(e, t, ps, "day") : t >= Ro ? Mp(e, t, Ro, "hour") : t >= Oo ? Mp(e, t, Oo, "minute") : t >= Bo ? Mp(e, t, Bo, "secon\
d") : e + " ms";
  }
  s(qne, "fmtLong");
  function Mp(e, t, r, n) {
    var i = t >= r * 1.5;
    return Math.round(e / r) + " " + n + (i ? "s" : "");
  }
  s(Mp, "plural");
});

// ../node_modules/debug/src/common.js
var ID = I((Mbe, f6) => {
  function $ne(e) {
    r.debug = r, r.default = r, r.coerce = l, r.disable = a, r.enable = i, r.enabled = u, r.humanize = h6(), r.destroy = c, Object.keys(e).forEach(
    (p) => {
      r[p] = e[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(p) {
      let h = 0;
      for (let f = 0; f < p.length; f++)
        h = (h << 5) - h + p.charCodeAt(f), h |= 0;
      return r.colors[Math.abs(h) % r.colors.length];
    }
    s(t, "selectColor"), r.selectColor = t;
    function r(p) {
      let h, f = null, d, m;
      function g(...b) {
        if (!g.enabled)
          return;
        let y = g, E = Number(/* @__PURE__ */ new Date()), A = E - (h || E);
        y.diff = A, y.prev = h, y.curr = E, h = E, b[0] = r.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
        let k = 0;
        b[0] = b[0].replace(/%([a-zA-Z%])/g, (w, C) => {
          if (w === "%%")
            return "%";
          k++;
          let T = r.formatters[C];
          if (typeof T == "function") {
            let F = b[k];
            w = T.call(y, F), b.splice(k, 1), k--;
          }
          return w;
        }), r.formatArgs.call(y, b), (y.log || r.log).apply(y, b);
      }
      return s(g, "debug"), g.namespace = p, g.useColors = r.useColors(), g.color = r.selectColor(p), g.extend = n, g.destroy = r.destroy, Object.
      defineProperty(g, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ s(() => f !== null ? f : (d !== r.namespaces && (d = r.namespaces, m = r.enabled(p)), m), "get"),
        set: /* @__PURE__ */ s((b) => {
          f = b;
        }, "set")
      }), typeof r.init == "function" && r.init(g), g;
    }
    s(r, "createDebug");
    function n(p, h) {
      let f = r(this.namespace + (typeof h > "u" ? ":" : h) + p);
      return f.log = this.log, f;
    }
    s(n, "extend");
    function i(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let h = (typeof p == "string" ? p : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (let f of h)
        f[0] === "-" ? r.skips.push(f.slice(1)) : r.names.push(f);
    }
    s(i, "enable");
    function o(p, h) {
      let f = 0, d = 0, m = -1, g = 0;
      for (; f < p.length; )
        if (d < h.length && (h[d] === p[f] || h[d] === "*"))
          h[d] === "*" ? (m = d, g = f, d++) : (f++, d++);
        else if (m !== -1)
          d = m + 1, g++, f = g;
        else
          return !1;
      for (; d < h.length && h[d] === "*"; )
        d++;
      return d === h.length;
    }
    s(o, "matchesTemplate");
    function a() {
      let p = [
        ...r.names,
        ...r.skips.map((h) => "-" + h)
      ].join(",");
      return r.enable(""), p;
    }
    s(a, "disable");
    function u(p) {
      for (let h of r.skips)
        if (o(p, h))
          return !1;
      for (let h of r.names)
        if (o(p, h))
          return !0;
      return !1;
    }
    s(u, "enabled");
    function l(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    s(l, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return s(c, "destroy"), r.enable(r.load()), r;
  }
  s($ne, "setup");
  f6.exports = $ne;
});

// ../node_modules/debug/src/browser.js
var d6 = I((nr, qp) => {
  nr.formatArgs = Une;
  nr.save = Wne;
  nr.load = zne;
  nr.useColors = Vne;
  nr.storage = Hne();
  nr.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  nr.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function Vne() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let e;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  s(Vne, "useColors");
  function Une(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    qp.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, n = 0;
    e[0].replace(/%[a-zA-Z%]/g, (i) => {
      i !== "%%" && (r++, i === "%c" && (n = r));
    }), e.splice(n, 0, t);
  }
  s(Une, "formatArgs");
  nr.log = console.debug || console.log || (() => {
  });
  function Wne(e) {
    try {
      e ? nr.storage.setItem("debug", e) : nr.storage.removeItem("debug");
    } catch {
    }
  }
  s(Wne, "save");
  function zne() {
    let e;
    try {
      e = nr.storage.getItem("debug");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  s(zne, "load");
  function Hne() {
    try {
      return localStorage;
    } catch {
    }
  }
  s(Hne, "localstorage");
  qp.exports = ID()(nr);
  var { formatters: Gne } = qp.exports;
  Gne.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var g6 = I((Vbe, m6) => {
  "use strict";
  m6.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
    return n !== -1 && (i === -1 || n < i);
  };
});

// ../node_modules/supports-color/index.js
var x6 = I((Ube, D6) => {
  "use strict";
  var Jne = require("os"), y6 = require("tty"), Ar = g6(), { env: vt } = process, Ei;
  Ar("no-color") || Ar("no-colors") || Ar("color=false") || Ar("color=never") ? Ei = 0 : (Ar("color") || Ar("colors") || Ar("color=true") ||
  Ar("color=always")) && (Ei = 1);
  "FORCE_COLOR" in vt && (vt.FORCE_COLOR === "true" ? Ei = 1 : vt.FORCE_COLOR === "false" ? Ei = 0 : Ei = vt.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(vt.FORCE_COLOR, 10), 3));
  function PD(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(PD, "translateLevel");
  function BD(e, t) {
    if (Ei === 0)
      return 0;
    if (Ar("color=16m") || Ar("color=full") || Ar("color=truecolor"))
      return 3;
    if (Ar("color=256"))
      return 2;
    if (e && !t && Ei === void 0)
      return 0;
    let r = Ei || 0;
    if (vt.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let n = Jne.release().split(".");
      return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in vt)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in vt) || vt.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in vt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(vt.TEAMCITY_VERSION) ? 1 : 0;
    if (vt.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in vt) {
      let n = parseInt((vt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (vt.TERM_PROGRAM) {
        case "iTerm.app":
          return n >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(vt.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(vt.TERM) || "COLORTERM" in
    vt ? 1 : r;
  }
  s(BD, "supportsColor");
  function Zne(e) {
    let t = BD(e, e && e.isTTY);
    return PD(t);
  }
  s(Zne, "getSupportLevel");
  D6.exports = {
    supportsColor: Zne,
    stdout: PD(BD(!0, y6.isatty(1))),
    stderr: PD(BD(!0, y6.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var v6 = I((Et, Vp) => {
  var Xne = require("tty"), $p = require("util");
  Et.init = nie;
  Et.log = eie;
  Et.formatArgs = Yne;
  Et.save = tie;
  Et.load = rie;
  Et.useColors = Kne;
  Et.destroy = $p.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Et.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = x6();
    e && (e.stderr || e).level >= 2 && (Et.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Et.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(n) ? n = !0 : /^(no|off|false|disabled)$/i.test(n) ? n = !1 : n === "null" ? n = null : n = Number(
    n), e[r] = n, e;
  }, {});
  function Kne() {
    return "colors" in Et.inspectOpts ? !!Et.inspectOpts.colors : Xne.isatty(process.stderr.fd);
  }
  s(Kne, "useColors");
  function Yne(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${t} \x1B[0m`;
      e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + Vp.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = Qne() + t + " " + e[0];
  }
  s(Yne, "formatArgs");
  function Qne() {
    return Et.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  s(Qne, "getDate");
  function eie(...e) {
    return process.stderr.write($p.formatWithOptions(Et.inspectOpts, ...e) + `
`);
  }
  s(eie, "log");
  function tie(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  s(tie, "save");
  function rie() {
    return process.env.DEBUG;
  }
  s(rie, "load");
  function nie(e) {
    e.inspectOpts = {};
    let t = Object.keys(Et.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = Et.inspectOpts[t[r]];
  }
  s(nie, "init");
  Vp.exports = ID()(Et);
  var { formatters: b6 } = Vp.exports;
  b6.o = function(e) {
    return this.inspectOpts.colors = this.useColors, $p.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  b6.O = function(e) {
    return this.inspectOpts.colors = this.useColors, $p.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var RD = I((Hbe, OD) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? OD.exports = d6() : OD.exports = v6();
});

// ../node_modules/detect-port/lib/detect-port.js
var LD = I((Gbe, E6) => {
  "use strict";
  var iie = require("net"), sie = c6(), mu = RD()("detect-port");
  E6.exports = (e, t) => {
    let r = "";
    typeof e == "object" && e ? (r = e.hostname, t = e.callback, e = e.port) : typeof e == "function" && (t = e, e = null), e = parseInt(e) ||
    0;
    let n = e + 10;
    return n > 65535 && (n = 65535), mu("detect free port between [%s, %s)", e, n), typeof t == "function" ? ND(e, n, r, t) : new Promise((i) => {
      ND(e, n, r, (o, a) => {
        i(a);
      });
    });
  };
  function ND(e, t, r, n) {
    function i() {
      e++, e >= t && (mu("port: %s >= maxPort: %s, give up and use random port", e, t), e = 0, t = 0), ND(e, t, r, n);
    }
    s(i, "handleError"), r ? du(e, r, (o, a) => {
      if (o)
        return o.code === "EADDRNOTAVAIL" ? n(new Error("the ip that is not unknown on the machine")) : i();
      n(null, a);
    }) : du(e, null, (o, a) => {
      if (e === 0)
        return n(o, a);
      if (o)
        return i(o);
      du(e, "0.0.0.0", (u) => {
        if (u)
          return i(u);
        du(e, "localhost", (l) => {
          if (l && l.code !== "EADDRNOTAVAIL")
            return i(l);
          du(e, sie.ip(), (c, p) => {
            if (c)
              return i(c);
            n(null, p);
          });
        });
      });
    });
  }
  s(ND, "tryListen");
  function du(e, t, r) {
    let n = new iie.Server();
    n.on("error", (i) => (mu("listen %s:%s error: %s", t, e, i), n.close(), i.code === "ENOTFOUND" ? (mu("ignore dns ENOTFOUND error, get fr\
ee %s:%s", t, e), r(null, e)) : r(i))), n.listen(e, t, () => (e = n.address().port, n.close(), mu("get free %s:%s", t, e), r(null, e)));
  }
  s(du, "listen");
});

// ../node_modules/detect-port/lib/wait-port.js
var w6 = I((Zbe, C6) => {
  "use strict";
  var oie = RD()("wait-port"), aie = LD(), uie = /* @__PURE__ */ s((e) => new Promise((t) => setTimeout(t, e)), "sleep");
  async function lie(e, t = {}) {
    let { retryInterval: r = 1e3, retries: n = 1 / 0 } = t, i = 1;
    async function o() {
      if (oie("retries", n, "count", i), i > n) {
        let u = new Error("retries exceeded");
        throw u.retries = n, u.count = i, u;
      }
      return i++, await aie(e) === e ? (await uie(r), o()) : !0;
    }
    return s(o, "loop"), await o();
  }
  s(lie, "waitPort");
  C6.exports = lie;
});

// ../node_modules/detect-port/index.js
var S6 = I((Kbe, jD) => {
  "use strict";
  jD.exports = LD();
  jD.exports.waitPort = w6();
});

// ../node_modules/eastasianwidth/eastasianwidth.js
var UD = I((Sve, VD) => {
  var Ci = {};
  typeof VD > "u" ? window.eastasianwidth = Ci : VD.exports = Ci;
  Ci.eastAsianWidth = function(e) {
    var t = e.charCodeAt(0), r = e.length == 2 ? e.charCodeAt(1) : 0, n = t;
    return 55296 <= t && t <= 56319 && 56320 <= r && r <= 57343 && (t &= 1023, r &= 1023, n = t << 10 | r, n += 65536), n == 12288 || 65281 <=
    n && n <= 65376 || 65504 <= n && n <= 65510 ? "F" : n == 8361 || 65377 <= n && n <= 65470 || 65474 <= n && n <= 65479 || 65482 <= n && n <=
    65487 || 65490 <= n && n <= 65495 || 65498 <= n && n <= 65500 || 65512 <= n && n <= 65518 ? "H" : 4352 <= n && n <= 4447 || 4515 <= n &&
    n <= 4519 || 4602 <= n && n <= 4607 || 9001 <= n && n <= 9002 || 11904 <= n && n <= 11929 || 11931 <= n && n <= 12019 || 12032 <= n && n <=
    12245 || 12272 <= n && n <= 12283 || 12289 <= n && n <= 12350 || 12353 <= n && n <= 12438 || 12441 <= n && n <= 12543 || 12549 <= n && n <=
    12589 || 12593 <= n && n <= 12686 || 12688 <= n && n <= 12730 || 12736 <= n && n <= 12771 || 12784 <= n && n <= 12830 || 12832 <= n && n <=
    12871 || 12880 <= n && n <= 13054 || 13056 <= n && n <= 19903 || 19968 <= n && n <= 42124 || 42128 <= n && n <= 42182 || 43360 <= n && n <=
    43388 || 44032 <= n && n <= 55203 || 55216 <= n && n <= 55238 || 55243 <= n && n <= 55291 || 63744 <= n && n <= 64255 || 65040 <= n && n <=
    65049 || 65072 <= n && n <= 65106 || 65108 <= n && n <= 65126 || 65128 <= n && n <= 65131 || 110592 <= n && n <= 110593 || 127488 <= n &&
    n <= 127490 || 127504 <= n && n <= 127546 || 127552 <= n && n <= 127560 || 127568 <= n && n <= 127569 || 131072 <= n && n <= 194367 || 177984 <=
    n && n <= 196605 || 196608 <= n && n <= 262141 ? "W" : 32 <= n && n <= 126 || 162 <= n && n <= 163 || 165 <= n && n <= 166 || n == 172 ||
    n == 175 || 10214 <= n && n <= 10221 || 10629 <= n && n <= 10630 ? "Na" : n == 161 || n == 164 || 167 <= n && n <= 168 || n == 170 || 173 <=
    n && n <= 174 || 176 <= n && n <= 180 || 182 <= n && n <= 186 || 188 <= n && n <= 191 || n == 198 || n == 208 || 215 <= n && n <= 216 ||
    222 <= n && n <= 225 || n == 230 || 232 <= n && n <= 234 || 236 <= n && n <= 237 || n == 240 || 242 <= n && n <= 243 || 247 <= n && n <=
    250 || n == 252 || n == 254 || n == 257 || n == 273 || n == 275 || n == 283 || 294 <= n && n <= 295 || n == 299 || 305 <= n && n <= 307 ||
    n == 312 || 319 <= n && n <= 322 || n == 324 || 328 <= n && n <= 331 || n == 333 || 338 <= n && n <= 339 || 358 <= n && n <= 359 || n ==
    363 || n == 462 || n == 464 || n == 466 || n == 468 || n == 470 || n == 472 || n == 474 || n == 476 || n == 593 || n == 609 || n == 708 ||
    n == 711 || 713 <= n && n <= 715 || n == 717 || n == 720 || 728 <= n && n <= 731 || n == 733 || n == 735 || 768 <= n && n <= 879 || 913 <=
    n && n <= 929 || 931 <= n && n <= 937 || 945 <= n && n <= 961 || 963 <= n && n <= 969 || n == 1025 || 1040 <= n && n <= 1103 || n == 1105 ||
    n == 8208 || 8211 <= n && n <= 8214 || 8216 <= n && n <= 8217 || 8220 <= n && n <= 8221 || 8224 <= n && n <= 8226 || 8228 <= n && n <= 8231 ||
    n == 8240 || 8242 <= n && n <= 8243 || n == 8245 || n == 8251 || n == 8254 || n == 8308 || n == 8319 || 8321 <= n && n <= 8324 || n == 8364 ||
    n == 8451 || n == 8453 || n == 8457 || n == 8467 || n == 8470 || 8481 <= n && n <= 8482 || n == 8486 || n == 8491 || 8531 <= n && n <= 8532 ||
    8539 <= n && n <= 8542 || 8544 <= n && n <= 8555 || 8560 <= n && n <= 8569 || n == 8585 || 8592 <= n && n <= 8601 || 8632 <= n && n <= 8633 ||
    n == 8658 || n == 8660 || n == 8679 || n == 8704 || 8706 <= n && n <= 8707 || 8711 <= n && n <= 8712 || n == 8715 || n == 8719 || n == 8721 ||
    n == 8725 || n == 8730 || 8733 <= n && n <= 8736 || n == 8739 || n == 8741 || 8743 <= n && n <= 8748 || n == 8750 || 8756 <= n && n <= 8759 ||
    8764 <= n && n <= 8765 || n == 8776 || n == 8780 || n == 8786 || 8800 <= n && n <= 8801 || 8804 <= n && n <= 8807 || 8810 <= n && n <= 8811 ||
    8814 <= n && n <= 8815 || 8834 <= n && n <= 8835 || 8838 <= n && n <= 8839 || n == 8853 || n == 8857 || n == 8869 || n == 8895 || n == 8978 ||
    9312 <= n && n <= 9449 || 9451 <= n && n <= 9547 || 9552 <= n && n <= 9587 || 9600 <= n && n <= 9615 || 9618 <= n && n <= 9621 || 9632 <=
    n && n <= 9633 || 9635 <= n && n <= 9641 || 9650 <= n && n <= 9651 || 9654 <= n && n <= 9655 || 9660 <= n && n <= 9661 || 9664 <= n && n <=
    9665 || 9670 <= n && n <= 9672 || n == 9675 || 9678 <= n && n <= 9681 || 9698 <= n && n <= 9701 || n == 9711 || 9733 <= n && n <= 9734 ||
    n == 9737 || 9742 <= n && n <= 9743 || 9748 <= n && n <= 9749 || n == 9756 || n == 9758 || n == 9792 || n == 9794 || 9824 <= n && n <= 9825 ||
    9827 <= n && n <= 9829 || 9831 <= n && n <= 9834 || 9836 <= n && n <= 9837 || n == 9839 || 9886 <= n && n <= 9887 || 9918 <= n && n <= 9919 ||
    9924 <= n && n <= 9933 || 9935 <= n && n <= 9953 || n == 9955 || 9960 <= n && n <= 9983 || n == 10045 || n == 10071 || 10102 <= n && n <=
    10111 || 11093 <= n && n <= 11097 || 12872 <= n && n <= 12879 || 57344 <= n && n <= 63743 || 65024 <= n && n <= 65039 || n == 65533 || 127232 <=
    n && n <= 127242 || 127248 <= n && n <= 127277 || 127280 <= n && n <= 127337 || 127344 <= n && n <= 127386 || 917760 <= n && n <= 917999 ||
    983040 <= n && n <= 1048573 || 1048576 <= n && n <= 1114109 ? "A" : "N";
  };
  Ci.characterLength = function(e) {
    var t = this.eastAsianWidth(e);
    return t == "F" || t == "W" || t == "A" ? 2 : 1;
  };
  function j6(e) {
    return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  s(j6, "stringToArray");
  Ci.length = function(e) {
    for (var t = j6(e), r = 0, n = 0; n < t.length; n++)
      r = r + this.characterLength(t[n]);
    return r;
  };
  Ci.slice = function(e, t, r) {
    textLen = Ci.length(e), t = t || 0, r = r || 1, t < 0 && (t = textLen + t), r < 0 && (r = textLen + r);
    for (var n = "", i = 0, o = j6(e), a = 0; a < o.length; a++) {
      var u = o[a], l = Ci.length(u);
      if (i >= t - (l == 2 ? 1 : 0))
        if (i + l <= r)
          n += u;
        else
          break;
      i += l;
    }
    return n;
  };
});

// ../node_modules/emoji-regex/index.js
var WD = I((Fve, M6) => {
  "use strict";
  M6.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/cli-boxes/boxes.json
var Q6 = I((Jve, Aie) => {
  Aie.exports = {
    single: {
      topLeft: "\u250C",
      top: "\u2500",
      topRight: "\u2510",
      right: "\u2502",
      bottomRight: "\u2518",
      bottom: "\u2500",
      bottomLeft: "\u2514",
      left: "\u2502"
    },
    double: {
      topLeft: "\u2554",
      top: "\u2550",
      topRight: "\u2557",
      right: "\u2551",
      bottomRight: "\u255D",
      bottom: "\u2550",
      bottomLeft: "\u255A",
      left: "\u2551"
    },
    round: {
      topLeft: "\u256D",
      top: "\u2500",
      topRight: "\u256E",
      right: "\u2502",
      bottomRight: "\u256F",
      bottom: "\u2500",
      bottomLeft: "\u2570",
      left: "\u2502"
    },
    bold: {
      topLeft: "\u250F",
      top: "\u2501",
      topRight: "\u2513",
      right: "\u2503",
      bottomRight: "\u251B",
      bottom: "\u2501",
      bottomLeft: "\u2517",
      left: "\u2503"
    },
    singleDouble: {
      topLeft: "\u2553",
      top: "\u2500",
      topRight: "\u2556",
      right: "\u2551",
      bottomRight: "\u255C",
      bottom: "\u2500",
      bottomLeft: "\u2559",
      left: "\u2551"
    },
    doubleSingle: {
      topLeft: "\u2552",
      top: "\u2550",
      topRight: "\u2555",
      right: "\u2502",
      bottomRight: "\u255B",
      bottom: "\u2550",
      bottomLeft: "\u2558",
      left: "\u2502"
    },
    classic: {
      topLeft: "+",
      top: "-",
      topRight: "+",
      right: "|",
      bottomRight: "+",
      bottom: "-",
      bottomLeft: "+",
      left: "|"
    },
    arrow: {
      topLeft: "\u2198",
      top: "\u2193",
      topRight: "\u2199",
      right: "\u2190",
      bottomRight: "\u2196",
      bottom: "\u2191",
      bottomLeft: "\u2197",
      left: "\u2192"
    }
  };
});

// ../node_modules/cli-boxes/index.js
var XD = I((Zve, ZD) => {
  "use strict";
  var e8 = Q6();
  ZD.exports = e8;
  ZD.exports.default = e8;
});

// ../node_modules/string-width/node_modules/ansi-regex/index.js
var o8 = I((Yve, s8) => {
  "use strict";
  s8.exports = ({ onlyFirst: e = !1 } = {}) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  };
});

// ../node_modules/string-width/node_modules/strip-ansi/index.js
var u8 = I((Qve, a8) => {
  "use strict";
  var Bie = o8();
  a8.exports = (e) => typeof e == "string" ? e.replace(Bie(), "") : e;
});

// ../node_modules/is-fullwidth-code-point/index.js
var c8 = I((eEe, QD) => {
  "use strict";
  var l8 = /* @__PURE__ */ s((e) => Number.isNaN(e) ? !1 : e >= 4352 && (e <= 4447 || // Hangul Jamo
  e === 9001 || // LEFT-POINTING ANGLE BRACKET
  e === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= e && e <= 12871 && e !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= e && e <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= e && e <= 42182 || // Hangul Jamo Extended-A
  43360 <= e && e <= 43388 || // Hangul Syllables
  44032 <= e && e <= 55203 || // CJK Compatibility Ideographs
  63744 <= e && e <= 64255 || // Vertical Forms
  65040 <= e && e <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= e && e <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || // Kana Supplement
  110592 <= e && e <= 110593 || // Enclosed Ideographic Supplement
  127488 <= e && e <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= e && e <= 262141), "isFullwidthCodePoint");
  QD.exports = l8;
  QD.exports.default = l8;
});

// ../node_modules/string-width/node_modules/emoji-regex/index.js
var h8 = I((rEe, p8) => {
  "use strict";
  p8.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/string-width/index.js
var tx = I((nEe, ex) => {
  "use strict";
  var Oie = u8(), Rie = c8(), Nie = h8(), f8 = /* @__PURE__ */ s((e) => {
    if (typeof e != "string" || e.length === 0 || (e = Oie(e), e.length === 0))
      return 0;
    e = e.replace(Nie(), "  ");
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      let n = e.codePointAt(r);
      n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (n > 65535 && r++, t += Rie(n) ? 2 : 1);
    }
    return t;
  }, "stringWidth");
  ex.exports = f8;
  ex.exports.default = f8;
});

// ../node_modules/ansi-align/index.js
var m8 = I((sEe, d8) => {
  "use strict";
  var Lie = tx();
  function ds(e, t) {
    if (!e) return e;
    t = t || {};
    let r = t.align || "center";
    if (r === "left") return e;
    let n = t.split || `
`, i = t.pad || " ", o = r !== "right" ? jie : Mie, a = !1;
    Array.isArray(e) || (a = !0, e = String(e).split(n));
    let u, l = 0;
    return e = e.map(function(c) {
      return c = String(c), u = Lie(c), l = Math.max(u, l), {
        str: c,
        width: u
      };
    }).map(function(c) {
      return new Array(o(l, c.width) + 1).join(i) + c.str;
    }), a ? e.join(n) : e;
  }
  s(ds, "ansiAlign");
  ds.left = /* @__PURE__ */ s(function(t) {
    return ds(t, { align: "left" });
  }, "left");
  ds.center = /* @__PURE__ */ s(function(t) {
    return ds(t, { align: "center" });
  }, "center");
  ds.right = /* @__PURE__ */ s(function(t) {
    return ds(t, { align: "right" });
  }, "right");
  d8.exports = ds;
  function jie(e, t) {
    return Math.floor((e - t) / 2);
  }
  s(jie, "halfDiff");
  function Mie(e, t) {
    return e - t;
  }
  s(Mie, "fullDiff");
});

// ../node_modules/cli-table3/src/debug.js
var Xp = I((AEe, P8) => {
  var ux = [], I8 = 0, Tt = /* @__PURE__ */ s((e, t) => {
    I8 >= t && ux.push(e);
  }, "debug");
  Tt.WARN = 1;
  Tt.INFO = 2;
  Tt.DEBUG = 3;
  Tt.reset = () => {
    ux = [];
  };
  Tt.setDebugLevel = (e) => {
    I8 = e;
  };
  Tt.warn = (e) => Tt(e, Tt.WARN);
  Tt.info = (e) => Tt(e, Tt.INFO);
  Tt.debug = (e) => Tt(e, Tt.DEBUG);
  Tt.debugMessages = () => ux;
  P8.exports = Tt;
});

// ../node_modules/cli-table3/src/utils.js
var lx = I((_Ee, N8) => {
  var B8 = tx();
  function Kp(e) {
    return e ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
  }
  s(Kp, "codeRegex");
  function vn(e) {
    let t = Kp();
    return ("" + e).replace(t, "").split(`
`).reduce(function(i, o) {
      return B8(o) > i ? B8(o) : i;
    }, 0);
  }
  s(vn, "strlen");
  function vu(e, t) {
    return Array(t + 1).join(e);
  }
  s(vu, "repeat");
  function ise(e, t, r, n) {
    let i = vn(e);
    if (t + 1 >= i) {
      let o = t - i;
      switch (n) {
        case "right": {
          e = vu(r, o) + e;
          break;
        }
        case "center": {
          let a = Math.ceil(o / 2), u = o - a;
          e = vu(r, u) + e + vu(r, a);
          break;
        }
        default: {
          e = e + vu(r, o);
          break;
        }
      }
    }
    return e;
  }
  s(ise, "pad");
  var jo = {};
  function Eu(e, t, r) {
    t = "\x1B[" + t + "m", r = "\x1B[" + r + "m", jo[t] = { set: e, to: !0 }, jo[r] = { set: e, to: !1 }, jo[e] = { on: t, off: r };
  }
  s(Eu, "addToCodeCache");
  Eu("bold", 1, 22);
  Eu("italics", 3, 23);
  Eu("underline", 4, 24);
  Eu("inverse", 7, 27);
  Eu("strikethrough", 9, 29);
  function O8(e, t) {
    let r = t[1] ? parseInt(t[1].split(";")[0]) : 0;
    if (r >= 30 && r <= 39 || r >= 90 && r <= 97) {
      e.lastForegroundAdded = t[0];
      return;
    }
    if (r >= 40 && r <= 49 || r >= 100 && r <= 107) {
      e.lastBackgroundAdded = t[0];
      return;
    }
    if (r === 0) {
      for (let i in e)
        Object.prototype.hasOwnProperty.call(e, i) && delete e[i];
      return;
    }
    let n = jo[t[0]];
    n && (e[n.set] = n.to);
  }
  s(O8, "updateState");
  function sse(e) {
    let t = Kp(!0), r = t.exec(e), n = {};
    for (; r !== null; )
      O8(n, r), r = t.exec(e);
    return n;
  }
  s(sse, "readState");
  function R8(e, t) {
    let r = e.lastBackgroundAdded, n = e.lastForegroundAdded;
    return delete e.lastBackgroundAdded, delete e.lastForegroundAdded, Object.keys(e).forEach(function(i) {
      e[i] && (t += jo[i].off);
    }), r && r != "\x1B[49m" && (t += "\x1B[49m"), n && n != "\x1B[39m" && (t += "\x1B[39m"), t;
  }
  s(R8, "unwindState");
  function ose(e, t) {
    let r = e.lastBackgroundAdded, n = e.lastForegroundAdded;
    return delete e.lastBackgroundAdded, delete e.lastForegroundAdded, Object.keys(e).forEach(function(i) {
      e[i] && (t = jo[i].on + t);
    }), r && r != "\x1B[49m" && (t = r + t), n && n != "\x1B[39m" && (t = n + t), t;
  }
  s(ose, "rewindState");
  function ase(e, t) {
    if (e.length === vn(e))
      return e.substr(0, t);
    for (; vn(e) > t; )
      e = e.slice(0, -1);
    return e;
  }
  s(ase, "truncateWidth");
  function use(e, t) {
    let r = Kp(!0), n = e.split(Kp()), i = 0, o = 0, a = "", u, l = {};
    for (; o < t; ) {
      u = r.exec(e);
      let c = n[i];
      if (i++, o + vn(c) > t && (c = ase(c, t - o)), a += c, o += vn(c), o < t) {
        if (!u)
          break;
        a += u[0], O8(l, u);
      }
    }
    return R8(l, a);
  }
  s(use, "truncateWidthWithAnsi");
  function lse(e, t, r) {
    if (r = r || "\u2026", vn(e) <= t)
      return e;
    t -= vn(r);
    let i = use(e, t);
    i += r;
    let o = "\x1B]8;;\x07";
    return e.includes(o) && !i.includes(o) && (i += o), i;
  }
  s(lse, "truncate");
  function cse() {
    return {
      chars: {
        top: "\u2500",
        "top-mid": "\u252C",
        "top-left": "\u250C",
        "top-right": "\u2510",
        bottom: "\u2500",
        "bottom-mid": "\u2534",
        "bottom-left": "\u2514",
        "bottom-right": "\u2518",
        left: "\u2502",
        "left-mid": "\u251C",
        mid: "\u2500",
        "mid-mid": "\u253C",
        right: "\u2502",
        "right-mid": "\u2524",
        middle: "\u2502"
      },
      truncate: "\u2026",
      colWidths: [],
      rowHeights: [],
      colAligns: [],
      rowAligns: [],
      style: {
        "padding-left": 1,
        "padding-right": 1,
        head: ["red"],
        border: ["grey"],
        compact: !1
      },
      head: []
    };
  }
  s(cse, "defaultOptions");
  function pse(e, t) {
    e = e || {}, t = t || cse();
    let r = Object.assign({}, t, e);
    return r.chars = Object.assign({}, t.chars, e.chars), r.style = Object.assign({}, t.style, e.style), r;
  }
  s(pse, "mergeOptions");
  function hse(e, t) {
    let r = [], n = t.split(/(\s+)/g), i = [], o = 0, a;
    for (let u = 0; u < n.length; u += 2) {
      let l = n[u], c = o + vn(l);
      o > 0 && a && (c += a.length), c > e ? (o !== 0 && r.push(i.join("")), i = [l], o = vn(l)) : (i.push(a || "", l), o = c), a = n[u + 1];
    }
    return o && r.push(i.join("")), r;
  }
  s(hse, "wordWrap");
  function fse(e, t) {
    let r = [], n = "";
    function i(a, u) {
      for (n.length && u && (n += u), n += a; n.length > e; )
        r.push(n.slice(0, e)), n = n.slice(e);
    }
    s(i, "pushLine");
    let o = t.split(/(\s+)/g);
    for (let a = 0; a < o.length; a += 2)
      i(o[a], a && o[a - 1]);
    return n.length && r.push(n), r;
  }
  s(fse, "textWrap");
  function dse(e, t, r = !0) {
    let n = [];
    t = t.split(`
`);
    let i = r ? hse : fse;
    for (let o = 0; o < t.length; o++)
      n.push.apply(n, i(e, t[o]));
    return n;
  }
  s(dse, "multiLineWordWrap");
  function mse(e) {
    let t = {}, r = [];
    for (let n = 0; n < e.length; n++) {
      let i = ose(t, e[n]);
      t = sse(i);
      let o = Object.assign({}, t);
      r.push(R8(o, i));
    }
    return r;
  }
  s(mse, "colorizeLines");
  function gse(e, t) {
    let r = "\x1B]", n = "\x07", i = ";";
    return [r, "8", i, i, e || t, n, t, r, "8", i, i, n].join("");
  }
  s(gse, "hyperlink");
  N8.exports = {
    strlen: vn,
    repeat: vu,
    pad: ise,
    truncate: lse,
    mergeOptions: pse,
    wordWrap: dse,
    colorizeLines: mse,
    hyperlink: gse
  };
});

// ../node_modules/@colors/colors/lib/styles.js
var q8 = I((TEe, M8) => {
  var j8 = {};
  M8.exports = j8;
  var L8 = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    // legacy styles for colors pre v1.0.0
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(L8).forEach(function(e) {
    var t = L8[e], r = j8[e] = [];
    r.open = "\x1B[" + t[0] + "m", r.close = "\x1B[" + t[1] + "m";
  });
});

// ../node_modules/@colors/colors/lib/system/has-flag.js
var V8 = I((IEe, $8) => {
  "use strict";
  $8.exports = function(e, t) {
    t = t || process.argv;
    var r = t.indexOf("--"), n = /^-{1,2}/.test(e) ? "" : "--", i = t.indexOf(n + e);
    return i !== -1 && (r === -1 ? !0 : i < r);
  };
});

// ../node_modules/@colors/colors/lib/system/supports-colors.js
var W8 = I((PEe, U8) => {
  "use strict";
  var yse = require("os"), Zr = V8(), Mt = process.env, Mo = void 0;
  Zr("no-color") || Zr("no-colors") || Zr("color=false") ? Mo = !1 : (Zr("color") || Zr("colors") || Zr("color=true") || Zr("color=always")) &&
  (Mo = !0);
  "FORCE_COLOR" in Mt && (Mo = Mt.FORCE_COLOR.length === 0 || parseInt(Mt.FORCE_COLOR, 10) !== 0);
  function Dse(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  s(Dse, "translateLevel");
  function xse(e) {
    if (Mo === !1)
      return 0;
    if (Zr("color=16m") || Zr("color=full") || Zr("color=truecolor"))
      return 3;
    if (Zr("color=256"))
      return 2;
    if (e && !e.isTTY && Mo !== !0)
      return 0;
    var t = Mo ? 1 : 0;
    if (process.platform === "win32") {
      var r = yse.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 :
      1;
    }
    if ("CI" in Mt)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(i) {
        return i in Mt;
      }) || Mt.CI_NAME === "codeship" ? 1 : t;
    if ("TEAMCITY_VERSION" in Mt)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Mt.TEAMCITY_VERSION) ? 1 : 0;
    if ("TERM_PROGRAM" in Mt) {
      var n = parseInt((Mt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Mt.TERM_PROGRAM) {
        case "iTerm.app":
          return n >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Mt.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(Mt.TERM) || "COLORTERM" in Mt ? 1 :
    (Mt.TERM === "dumb", t);
  }
  s(xse, "supportsColor");
  function cx(e) {
    var t = xse(e);
    return Dse(t);
  }
  s(cx, "getSupportLevel");
  U8.exports = {
    supportsColor: cx,
    stdout: cx(process.stdout),
    stderr: cx(process.stderr)
  };
});

// ../node_modules/@colors/colors/lib/custom/trap.js
var H8 = I((OEe, z8) => {
  z8.exports = /* @__PURE__ */ s(function(t, r) {
    var n = "";
    t = t || "Run the trap, drop the bass", t = t.split("");
    var i = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    return t.forEach(function(o) {
      o = o.toLowerCase();
      var a = i[o] || [" "], u = Math.floor(Math.random() * a.length);
      typeof i[o] < "u" ? n += i[o][u] : n += o;
    }), n;
  }, "runTheTrap");
});

// ../node_modules/@colors/colors/lib/custom/zalgo.js
var J8 = I((NEe, G8) => {
  G8.exports = /* @__PURE__ */ s(function(t, r) {
    t = t || "   he is here   ";
    var n = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    }, i = [].concat(n.up, n.down, n.mid);
    function o(l) {
      var c = Math.floor(Math.random() * l);
      return c;
    }
    s(o, "randomNumber");
    function a(l) {
      var c = !1;
      return i.filter(function(p) {
        c = p === l;
      }), c;
    }
    s(a, "isChar");
    function u(l, c) {
      var p = "", h, f;
      c = c || {}, c.up = typeof c.up < "u" ? c.up : !0, c.mid = typeof c.mid < "u" ? c.mid : !0, c.down = typeof c.down < "u" ? c.down : !0,
      c.size = typeof c.size < "u" ? c.size : "maxi", l = l.split("");
      for (f in l)
        if (!a(f)) {
          switch (p = p + l[f], h = { up: 0, down: 0, mid: 0 }, c.size) {
            case "mini":
              h.up = o(8), h.mid = o(2), h.down = o(8);
              break;
            case "maxi":
              h.up = o(16) + 3, h.mid = o(4) + 1, h.down = o(64) + 3;
              break;
            default:
              h.up = o(8) + 1, h.mid = o(6) / 2, h.down = o(8) + 1;
              break;
          }
          var d = ["up", "mid", "down"];
          for (var m in d)
            for (var g = d[m], b = 0; b <= h[g]; b++)
              c[g] && (p = p + n[g][o(n[g].length)]);
        }
      return p;
    }
    return s(u, "heComes"), u(t, r);
  }, "zalgo");
});

// ../node_modules/@colors/colors/lib/maps/america.js
var X8 = I((jEe, Z8) => {
  Z8.exports = function(e) {
    return function(t, r, n) {
      if (t === " ") return t;
      switch (r % 3) {
        case 0:
          return e.red(t);
        case 1:
          return e.white(t);
        case 2:
          return e.blue(t);
      }
    };
  };
});

// ../node_modules/@colors/colors/lib/maps/zebra.js
var Y8 = I((MEe, K8) => {
  K8.exports = function(e) {
    return function(t, r, n) {
      return r % 2 === 0 ? t : e.inverse(t);
    };
  };
});

// ../node_modules/@colors/colors/lib/maps/rainbow.js
var eR = I((qEe, Q8) => {
  Q8.exports = function(e) {
    var t = ["red", "yellow", "green", "blue", "magenta"];
    return function(r, n, i) {
      return r === " " ? r : e[t[n++ % t.length]](r);
    };
  };
});

// ../node_modules/@colors/colors/lib/maps/random.js
var rR = I(($Ee, tR) => {
  tR.exports = function(e) {
    var t = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(r, n, i) {
      return r === " " ? r : e[t[Math.round(Math.random() * (t.length - 2))]](r);
    };
  };
});

// ../node_modules/@colors/colors/lib/colors.js
var uR = I((UEe, aR) => {
  var Te = {};
  aR.exports = Te;
  Te.themes = {};
  var bse = require("util"), gs = Te.styles = q8(), iR = Object.defineProperties, vse = new RegExp(/[\r\n]+/g);
  Te.supportsColor = W8().supportsColor;
  typeof Te.enabled > "u" && (Te.enabled = Te.supportsColor() !== !1);
  Te.enable = function() {
    Te.enabled = !0;
  };
  Te.disable = function() {
    Te.enabled = !1;
  };
  Te.stripColors = Te.strip = function(e) {
    return ("" + e).replace(/\x1B\[\d+m/g, "");
  };
  var VEe = Te.stylize = /* @__PURE__ */ s(function(t, r) {
    if (!Te.enabled)
      return t + "";
    var n = gs[r];
    return !n && r in Te ? Te[r](t) : n.open + t + n.close;
  }, "stylize"), Ese = /[|\\{}()[\]^$+*?.]/g, Cse = /* @__PURE__ */ s(function(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(Ese, "\\$&");
  }, "escapeStringRegexp");
  function sR(e) {
    var t = /* @__PURE__ */ s(function r() {
      return Sse.apply(r, arguments);
    }, "builder");
    return t._styles = e, t.__proto__ = wse, t;
  }
  s(sR, "build");
  var oR = function() {
    var e = {};
    return gs.grey = gs.gray, Object.keys(gs).forEach(function(t) {
      gs[t].closeRe = new RegExp(Cse(gs[t].close), "g"), e[t] = {
        get: /* @__PURE__ */ s(function() {
          return sR(this._styles.concat(t));
        }, "get")
      };
    }), e;
  }(), wse = iR(/* @__PURE__ */ s(function() {
  }, "colors"), oR);
  function Sse() {
    var e = Array.prototype.slice.call(arguments), t = e.map(function(a) {
      return a != null && a.constructor === String ? a : bse.inspect(a);
    }).join(" ");
    if (!Te.enabled || !t)
      return t;
    for (var r = t.indexOf(`
`) != -1, n = this._styles, i = n.length; i--; ) {
      var o = gs[n[i]];
      t = o.open + t.replace(o.closeRe, o.open) + o.close, r && (t = t.replace(vse, function(a) {
        return o.close + a + o.open;
      }));
    }
    return t;
  }
  s(Sse, "applyStyle");
  Te.setTheme = function(e) {
    if (typeof e == "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (\
the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); \
The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
      return;
    }
    for (var t in e)
      (function(r) {
        Te[r] = function(n) {
          if (typeof e[r] == "object") {
            var i = n;
            for (var o in e[r])
              i = Te[e[r][o]](i);
            return i;
          }
          return Te[e[r]](n);
        };
      })(t);
  };
  function Ase() {
    var e = {};
    return Object.keys(oR).forEach(function(t) {
      e[t] = {
        get: /* @__PURE__ */ s(function() {
          return sR([t]);
        }, "get")
      };
    }), e;
  }
  s(Ase, "init");
  var Fse = /* @__PURE__ */ s(function(t, r) {
    var n = r.split("");
    return n = n.map(t), n.join("");
  }, "sequencer");
  Te.trap = H8();
  Te.zalgo = J8();
  Te.maps = {};
  Te.maps.america = X8()(Te);
  Te.maps.zebra = Y8()(Te);
  Te.maps.rainbow = eR()(Te);
  Te.maps.random = rR()(Te);
  for (nR in Te.maps)
    (function(e) {
      Te[e] = function(t) {
        return Fse(Te.maps[e], t);
      };
    })(nR);
  var nR;
  iR(Te, Ase());
});

// ../node_modules/@colors/colors/safe.js
var cR = I((zEe, lR) => {
  var _se = uR();
  lR.exports = _se;
});

// ../node_modules/cli-table3/src/cell.js
var dR = I((HEe, Yp) => {
  var { info: kse, debug: fR } = Xp(), ir = lx(), hx = class e {
    static {
      s(this, "Cell");
    }
    /**
     * A representation of a cell within the table.
     * Implementations must have `init` and `draw` methods,
     * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.
     * @param options
     * @constructor
     */
    constructor(t) {
      this.setOptions(t), this.x = null, this.y = null;
    }
    setOptions(t) {
      ["boolean", "number", "bigint", "string"].indexOf(typeof t) !== -1 && (t = { content: "" + t }), t = t || {}, this.options = t;
      let r = t.content;
      if (["boolean", "number", "bigint", "string"].indexOf(typeof r) !== -1)
        this.content = String(r);
      else if (!r)
        this.content = this.options.href || "";
      else
        throw new Error("Content needs to be a primitive, got: " + typeof r);
      this.colSpan = t.colSpan || 1, this.rowSpan = t.rowSpan || 1, this.options.href && Object.defineProperty(this, "href", {
        get() {
          return this.options.href;
        }
      });
    }
    mergeTableOptions(t, r) {
      this.cells = r;
      let n = this.options.chars || {}, i = t.chars, o = this.chars = {};
      Ise.forEach(function(l) {
        px(n, i, l, o);
      }), this.truncate = this.options.truncate || t.truncate;
      let a = this.options.style = this.options.style || {}, u = t.style;
      px(a, u, "padding-left", this), px(a, u, "padding-right", this), this.head = a.head || u.head, this.border = a.border || u.border, this.
      fixedWidth = t.colWidths[this.x], this.lines = this.computeLines(t), this.desiredWidth = ir.strlen(this.content) + this.paddingLeft + this.
      paddingRight, this.desiredHeight = this.lines.length;
    }
    computeLines(t) {
      let r = t.wordWrap || t.textWrap, { wordWrap: n = r } = this.options;
      if (this.fixedWidth && n) {
        if (this.fixedWidth -= this.paddingLeft + this.paddingRight, this.colSpan) {
          let a = 1;
          for (; a < this.colSpan; )
            this.fixedWidth += t.colWidths[this.x + a], a++;
        }
        let { wrapOnWordBoundary: i = !0 } = t, { wrapOnWordBoundary: o = i } = this.options;
        return this.wrapLines(ir.wordWrap(this.fixedWidth, this.content, o));
      }
      return this.wrapLines(this.content.split(`
`));
    }
    wrapLines(t) {
      let r = ir.colorizeLines(t);
      return this.href ? r.map((n) => ir.hyperlink(this.href, n)) : r;
    }
    /**
     * Initializes the Cells data structure.
     *
     * @param tableOptions - A fully populated set of tableOptions.
     * In addition to the standard default values, tableOptions must have fully populated the
     * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number
     * of columns or rows (respectively) in this table, and each array item must be a Number.
     *
     */
    init(t) {
      let r = this.x, n = this.y;
      this.widths = t.colWidths.slice(r, r + this.colSpan), this.heights = t.rowHeights.slice(n, n + this.rowSpan), this.width = this.widths.
      reduce(hR, -1), this.height = this.heights.reduce(hR, -1), this.hAlign = this.options.hAlign || t.colAligns[r], this.vAlign = this.options.
      vAlign || t.rowAligns[n], this.drawRight = r + this.colSpan == t.colWidths.length;
    }
    /**
     * Draws the given line of the cell.
     * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.
     * @param lineNum - can be `top`, `bottom` or a numerical line number.
     * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how
     * many rows below it's being called from. Otherwise it's undefined.
     * @returns {String} The representation of this line.
     */
    draw(t, r) {
      if (t == "top") return this.drawTop(this.drawRight);
      if (t == "bottom") return this.drawBottom(this.drawRight);
      let n = ir.truncate(this.content, 10, this.truncate);
      t || kse(`${this.y}-${this.x}: ${this.rowSpan - t}x${this.colSpan} Cell ${n}`);
      let i = Math.max(this.height - this.lines.length, 0), o;
      switch (this.vAlign) {
        case "center":
          o = Math.ceil(i / 2);
          break;
        case "bottom":
          o = i;
          break;
        default:
          o = 0;
      }
      if (t < o || t >= o + this.lines.length)
        return this.drawEmpty(this.drawRight, r);
      let a = this.lines.length > this.height && t + 1 >= this.height;
      return this.drawLine(t - o, this.drawRight, a, r);
    }
    /**
     * Renders the top line of the cell.
     * @param drawRight - true if this method should render the right edge of the cell.
     * @returns {String}
     */
    drawTop(t) {
      let r = [];
      return this.cells ? this.widths.forEach(function(n, i) {
        r.push(this._topLeftChar(i)), r.push(ir.repeat(this.chars[this.y == 0 ? "top" : "mid"], n));
      }, this) : (r.push(this._topLeftChar(0)), r.push(ir.repeat(this.chars[this.y == 0 ? "top" : "mid"], this.width))), t && r.push(this.chars[this.
      y == 0 ? "topRight" : "rightMid"]), this.wrapWithStyleColors("border", r.join(""));
    }
    _topLeftChar(t) {
      let r = this.x + t, n;
      if (this.y == 0)
        n = r == 0 ? "topLeft" : t == 0 ? "topMid" : "top";
      else if (r == 0)
        n = "leftMid";
      else if (n = t == 0 ? "midMid" : "bottomMid", this.cells && (this.cells[this.y - 1][r] instanceof e.ColSpanCell && (n = t == 0 ? "topM\
id" : "mid"), t == 0)) {
        let o = 1;
        for (; this.cells[this.y][r - o] instanceof e.ColSpanCell; )
          o++;
        this.cells[this.y][r - o] instanceof e.RowSpanCell && (n = "leftMid");
      }
      return this.chars[n];
    }
    wrapWithStyleColors(t, r) {
      if (this[t] && this[t].length)
        try {
          let n = cR();
          for (let i = this[t].length - 1; i >= 0; i--)
            n = n[this[t][i]];
          return n(r);
        } catch {
          return r;
        }
      else
        return r;
    }
    /**
     * Renders a line of text.
     * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.
     * There may be top-padding above the first line of text.
     * @param drawRight - true if this method should render the right edge of the cell.
     * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even
     * if the text fits. This is used when the cell is vertically truncated. If `false` the text should
     * only include the truncation symbol if the text will not fit horizontally within the cell width.
     * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.
     * @returns {String}
     */
    drawLine(t, r, n, i) {
      let o = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && i && this.cells) {
        let f = this.cells[this.y + i][this.x - 1];
        for (; f instanceof Cu; )
          f = this.cells[f.y][f.x - 1];
        f instanceof wu || (o = this.chars.rightMid);
      }
      let a = ir.repeat(" ", this.paddingLeft), u = r ? this.chars.right : "", l = ir.repeat(" ", this.paddingRight), c = this.lines[t], p = this.
      width - (this.paddingLeft + this.paddingRight);
      n && (c += this.truncate || "\u2026");
      let h = ir.truncate(c, p, this.truncate);
      return h = ir.pad(h, p, " ", this.hAlign), h = a + h + l, this.stylizeLine(o, h, u);
    }
    stylizeLine(t, r, n) {
      return t = this.wrapWithStyleColors("border", t), n = this.wrapWithStyleColors("border", n), this.y === 0 && (r = this.wrapWithStyleColors(
      "head", r)), t + r + n;
    }
    /**
     * Renders the bottom line of the cell.
     * @param drawRight - true if this method should render the right edge of the cell.
     * @returns {String}
     */
    drawBottom(t) {
      let r = this.chars[this.x == 0 ? "bottomLeft" : "bottomMid"], n = ir.repeat(this.chars.bottom, this.width), i = t ? this.chars.bottomRight :
      "";
      return this.wrapWithStyleColors("border", r + n + i);
    }
    /**
     * Renders a blank line of text within the cell. Used for top and/or bottom padding.
     * @param drawRight - true if this method should render the right edge of the cell.
     * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.
     * @returns {String}
     */
    drawEmpty(t, r) {
      let n = this.chars[this.x == 0 ? "left" : "middle"];
      if (this.x && r && this.cells) {
        let a = this.cells[this.y + r][this.x - 1];
        for (; a instanceof Cu; )
          a = this.cells[a.y][a.x - 1];
        a instanceof wu || (n = this.chars.rightMid);
      }
      let i = t ? this.chars.right : "", o = ir.repeat(" ", this.width);
      return this.stylizeLine(n, o, i);
    }
  }, Cu = class {
    static {
      s(this, "ColSpanCell");
    }
    /**
     * A Cell that doesn't do anything. It just draws empty lines.
     * Used as a placeholder in column spanning.
     * @constructor
     */
    constructor() {
    }
    draw(t) {
      return typeof t == "number" && fR(`${this.y}-${this.x}: 1x1 ColSpanCell`), "";
    }
    init() {
    }
    mergeTableOptions() {
    }
  }, wu = class {
    static {
      s(this, "RowSpanCell");
    }
    /**
     * A placeholder Cell for a Cell that spans multiple rows.
     * It delegates rendering to the original cell, but adds the appropriate offset.
     * @param originalCell
     * @constructor
     */
    constructor(t) {
      this.originalCell = t;
    }
    init(t) {
      let r = this.y, n = this.originalCell.y;
      this.cellOffset = r - n, this.offset = Tse(t.rowHeights, n, this.cellOffset);
    }
    draw(t) {
      return t == "top" ? this.originalCell.draw(this.offset, this.cellOffset) : t == "bottom" ? this.originalCell.draw("bottom") : (fR(`${this.
      y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`), this.originalCell.draw(this.offset + 1 + t));
    }
    mergeTableOptions() {
    }
  };
  function pR(...e) {
    return e.filter((t) => t != null).shift();
  }
  s(pR, "firstDefined");
  function px(e, t, r, n) {
    let i = r.split("-");
    i.length > 1 ? (i[1] = i[1].charAt(0).toUpperCase() + i[1].substr(1), i = i.join(""), n[i] = pR(e[i], e[r], t[i], t[r])) : n[r] = pR(e[r],
    t[r]);
  }
  s(px, "setOption");
  function Tse(e, t, r) {
    let n = e[t];
    for (let i = 1; i < r; i++)
      n += 1 + e[t + i];
    return n;
  }
  s(Tse, "findDimension");
  function hR(e, t) {
    return e + t + 1;
  }
  s(hR, "sumPlusOne");
  var Ise = [
    "top",
    "top-mid",
    "top-left",
    "top-right",
    "bottom",
    "bottom-mid",
    "bottom-left",
    "bottom-right",
    "left",
    "left-mid",
    "mid",
    "mid-mid",
    "right",
    "right-mid",
    "middle"
  ];
  Yp.exports = hx;
  Yp.exports.ColSpanCell = Cu;
  Yp.exports.RowSpanCell = wu;
});

// ../node_modules/cli-table3/src/layout-manager.js
var yR = I((JEe, gR) => {
  var { warn: Pse, debug: Bse } = Xp(), fx = dR(), { ColSpanCell: Ose, RowSpanCell: Rse } = fx;
  (function() {
    function e(d, m) {
      return d[m] > 0 ? e(d, m + 1) : m;
    }
    s(e, "next");
    function t(d) {
      let m = {};
      d.forEach(function(g, b) {
        let y = 0;
        g.forEach(function(E) {
          E.y = b, E.x = b ? e(m, y) : y;
          let A = E.rowSpan || 1, k = E.colSpan || 1;
          if (A > 1)
            for (let O = 0; O < k; O++)
              m[E.x + O] = A;
          y = E.x + k;
        }), Object.keys(m).forEach((E) => {
          m[E]--, m[E] < 1 && delete m[E];
        });
      });
    }
    s(t, "layoutTable");
    function r(d) {
      let m = 0;
      return d.forEach(function(g) {
        g.forEach(function(b) {
          m = Math.max(m, b.x + (b.colSpan || 1));
        });
      }), m;
    }
    s(r, "maxWidth");
    function n(d) {
      return d.length;
    }
    s(n, "maxHeight");
    function i(d, m) {
      let g = d.y, b = d.y - 1 + (d.rowSpan || 1), y = m.y, E = m.y - 1 + (m.rowSpan || 1), A = !(g > E || y > b), k = d.x, O = d.x - 1 + (d.
      colSpan || 1), w = m.x, C = m.x - 1 + (m.colSpan || 1), T = !(k > C || w > O);
      return A && T;
    }
    s(i, "cellsConflict");
    function o(d, m, g) {
      let b = Math.min(d.length - 1, g), y = { x: m, y: g };
      for (let E = 0; E <= b; E++) {
        let A = d[E];
        for (let k = 0; k < A.length; k++)
          if (i(y, A[k]))
            return !0;
      }
      return !1;
    }
    s(o, "conflictExists");
    function a(d, m, g, b) {
      for (let y = g; y < b; y++)
        if (o(d, y, m))
          return !1;
      return !0;
    }
    s(a, "allBlank");
    function u(d) {
      d.forEach(function(m, g) {
        m.forEach(function(b) {
          for (let y = 1; y < b.rowSpan; y++) {
            let E = new Rse(b);
            E.x = b.x, E.y = b.y + y, E.colSpan = b.colSpan, c(E, d[g + y]);
          }
        });
      });
    }
    s(u, "addRowSpanCells");
    function l(d) {
      for (let m = d.length - 1; m >= 0; m--) {
        let g = d[m];
        for (let b = 0; b < g.length; b++) {
          let y = g[b];
          for (let E = 1; E < y.colSpan; E++) {
            let A = new Ose();
            A.x = y.x + E, A.y = y.y, g.splice(b + 1, 0, A);
          }
        }
      }
    }
    s(l, "addColSpanCells");
    function c(d, m) {
      let g = 0;
      for (; g < m.length && m[g].x < d.x; )
        g++;
      m.splice(g, 0, d);
    }
    s(c, "insertCell");
    function p(d) {
      let m = n(d), g = r(d);
      Bse(`Max rows: ${m}; Max cols: ${g}`);
      for (let b = 0; b < m; b++)
        for (let y = 0; y < g; y++)
          if (!o(d, y, b)) {
            let E = { x: y, y: b, colSpan: 1, rowSpan: 1 };
            for (y++; y < g && !o(d, y, b); )
              E.colSpan++, y++;
            let A = b + 1;
            for (; A < m && a(d, A, E.x, E.x + E.colSpan); )
              E.rowSpan++, A++;
            let k = new fx(E);
            k.x = E.x, k.y = E.y, Pse(`Missing cell at ${k.y}-${k.x}.`), c(k, d[b]);
          }
    }
    s(p, "fillInTable");
    function h(d) {
      return d.map(function(m) {
        if (!Array.isArray(m)) {
          let g = Object.keys(m)[0];
          m = m[g], Array.isArray(m) ? (m = m.slice(), m.unshift(g)) : m = [g, m];
        }
        return m.map(function(g) {
          return new fx(g);
        });
      });
    }
    s(h, "generateCells");
    function f(d) {
      let m = h(d);
      return t(m), p(m), u(m), l(m), m;
    }
    s(f, "makeTableLayout"), gR.exports = {
      makeTableLayout: f,
      layoutTable: t,
      addRowSpanCells: u,
      maxWidth: r,
      fillInTable: p,
      computeWidths: mR("colSpan", "desiredWidth", "x", 1),
      computeHeights: mR("rowSpan", "desiredHeight", "y", 1)
    };
  })();
  function mR(e, t, r, n) {
    return function(i, o) {
      let a = [], u = [], l = {};
      o.forEach(function(c) {
        c.forEach(function(p) {
          (p[e] || 1) > 1 ? u.push(p) : a[p[r]] = Math.max(a[p[r]] || 0, p[t] || 0, n);
        });
      }), i.forEach(function(c, p) {
        typeof c == "number" && (a[p] = c);
      });
      for (let c = u.length - 1; c >= 0; c--) {
        let p = u[c], h = p[e], f = p[r], d = a[f], m = typeof i[f] == "number" ? 0 : 1;
        if (typeof d == "number")
          for (let g = 1; g < h; g++)
            d += 1 + a[f + g], typeof i[f + g] != "number" && m++;
        else
          d = t === "desiredWidth" ? p.desiredWidth - 1 : 1, (!l[f] || l[f] < d) && (l[f] = d);
        if (p[t] > d) {
          let g = 0;
          for (; m > 0 && p[t] > d; ) {
            if (typeof i[f + g] != "number") {
              let b = Math.round((p[t] - d) / m);
              d += b, a[f + g] += b, m--;
            }
            g++;
          }
        }
      }
      Object.assign(i, a, l);
      for (let c = 0; c < i.length; c++)
        i[c] = Math.max(n, i[c] || 0);
    };
  }
  s(mR, "makeComputeWidths");
});

// ../node_modules/cli-table3/src/table.js
var xR = I((XEe, DR) => {
  var Hn = Xp(), Nse = lx(), dx = yR(), Qp = class extends Array {
    static {
      s(this, "Table");
    }
    constructor(t) {
      super();
      let r = Nse.mergeOptions(t);
      if (Object.defineProperty(this, "options", {
        value: r,
        enumerable: r.debug
      }), r.debug) {
        switch (typeof r.debug) {
          case "boolean":
            Hn.setDebugLevel(Hn.WARN);
            break;
          case "number":
            Hn.setDebugLevel(r.debug);
            break;
          case "string":
            Hn.setDebugLevel(parseInt(r.debug, 10));
            break;
          default:
            Hn.setDebugLevel(Hn.WARN), Hn.warn(`Debug option is expected to be boolean, number, or string. Received a ${typeof r.debug}`);
        }
        Object.defineProperty(this, "messages", {
          get() {
            return Hn.debugMessages();
          }
        });
      }
    }
    toString() {
      let t = this, r = this.options.head && this.options.head.length;
      r ? (t = [this.options.head], this.length && t.push.apply(t, this)) : this.options.style.head = [];
      let n = dx.makeTableLayout(t);
      n.forEach(function(o) {
        o.forEach(function(a) {
          a.mergeTableOptions(this.options, n);
        }, this);
      }, this), dx.computeWidths(this.options.colWidths, n), dx.computeHeights(this.options.rowHeights, n), n.forEach(function(o) {
        o.forEach(function(a) {
          a.init(this.options);
        }, this);
      }, this);
      let i = [];
      for (let o = 0; o < n.length; o++) {
        let a = n[o], u = this.options.rowHeights[o];
        (o === 0 || !this.options.style.compact || o == 1 && r) && mx(a, "top", i);
        for (let l = 0; l < u; l++)
          mx(a, l, i);
        o + 1 == n.length && mx(a, "bottom", i);
      }
      return i.join(`
`);
    }
    get width() {
      return this.toString().split(`
`)[0].length;
    }
  };
  Qp.reset = () => Hn.reset();
  function mx(e, t, r) {
    let n = [];
    e.forEach(function(o) {
      n.push(o.draw(t));
    });
    let i = n.join("");
    i.length && r.push(i);
  }
  s(mx, "doDraw");
  DR.exports = Qp;
});

// ../node_modules/cli-table3/index.js
var vR = I((YEe, bR) => {
  bR.exports = xR();
});

// ../node_modules/pretty-hrtime/index.js
var wR = I((QEe, CR) => {
  "use strict";
  var Lse = ["h", "min", "s", "ms", "\u03BCs", "ns"], jse = ["hour", "minute", "second", "millisecond", "microsecond", "nanosecond"], ER = [
  3600, 60, 1, 1e6, 1e3, 1];
  CR.exports = function(e, t) {
    var r, n, i, o, a, u, l, c, p, h;
    if (r = !1, n = !1, t && (r = t.verbose || !1, n = t.precise || !1), !Array.isArray(e) || e.length !== 2 || typeof e[0] != "number" || typeof e[1] !=
    "number")
      return "";
    for (e[1] < 0 && (h = e[0] + e[1] / 1e9, e[0] = parseInt(h), e[1] = parseFloat((h % 1).toPrecision(9)) * 1e9), p = "", i = 0; i < 6 && (o =
    i < 3 ? 0 : 1, a = e[o], i !== 3 && i !== 0 && (a = a % ER[i - 1]), i === 2 && (a += e[1] / 1e9), u = a / ER[i], !(u >= 1 && (r && (u = Math.
    floor(u)), n ? c = u.toString() : (l = u >= 10 ? 0 : 2, c = u.toFixed(l)), c.indexOf(".") > -1 && c[c.length - 1] === "0" && (c = c.replace(
    /\.?0+$/, "")), p && (p += " "), p += c, r ? (p += " " + jse[i], c !== "1" && (p += "s")) : p += " " + Lse[i], !r))); i++)
      ;
    return p;
  };
});

// src/core-server/index.ts
var Gse = {};
Gn(Gse, {
  StoryIndexGenerator: () => an,
  build: () => e9,
  buildDevStandalone: () => bx,
  buildIndex: () => YR,
  buildIndexStandalone: () => vx,
  buildStaticStandalone: () => Ng,
  experimental_MockUniversalStore: () => ih,
  experimental_UniversalStore: () => kt,
  experimental_getStatusStore: () => u9,
  experimental_getTestProviderStore: () => f9,
  experimental_loadStorybook: () => nh,
  getErrorLevel: () => AB,
  getPreviewBodyTemplate: () => uh.getPreviewBodyTemplate,
  getPreviewHeadTemplate: () => uh.getPreviewHeadTemplate,
  internal_fullStatusStore: () => a9,
  internal_fullTestProviderStore: () => h9,
  internal_universalStatusStore: () => l9,
  internal_universalTestProviderStore: () => d9,
  mapStaticDir: () => ag,
  sendTelemetryError: () => Fp,
  withTelemetry: () => YQ
});
module.exports = Fu(Gse);
var uh = require("storybook/internal/common");

// src/core-server/build-static.ts
var bc = require("node:fs/promises"), fF = require("node:fs/promises"), vr = require("node:path"), Vr = require("storybook/internal/common"),
Rn = require("storybook/internal/node-logger"), Pa = require("storybook/internal/telemetry"), dF = require("@storybook/global"), mF = J(Tr(), 1);

// src/core-server/utils/StoryIndexGenerator.ts
var Km = require("node:fs"), Ym = require("node:fs/promises"), Ve = require("node:path"), On = require("storybook/internal/common"), $r = require("storybook/internal/csf"),
Kl = require("storybook/internal/csf-tools"), qi = require("storybook/internal/node-logger"), yS = require("storybook/internal/telemetry");

// ../node_modules/find-up/index.js
var Ir = J(require("node:path"), 1);

// ../node_modules/locate-path/index.js
var dh = J(require("node:process"), 1), mh = J(require("node:path"), 1), Ds = J(require("node:fs"), 1), Fx = require("node:url");

// ../node_modules/locate-path/node_modules/p-limit/index.js
Ax();
function Tu(e) {
  if (!((Number.isInteger(e) || e === Number.POSITIVE_INFINITY) && e > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  let t = new Wo(), r = 0, n = /* @__PURE__ */ s(() => {
    r--, t.size > 0 && t.dequeue()();
  }, "next"), i = /* @__PURE__ */ s(async (u, l, c) => {
    r++;
    let p = (async () => u(...c))();
    l(p);
    try {
      await p;
    } catch {
    }
    n();
  }, "run"), o = /* @__PURE__ */ s((u, l, c) => {
    t.enqueue(i.bind(void 0, u, l, c)), (async () => (await Promise.resolve(), r < e && t.size > 0 && t.dequeue()()))();
  }, "enqueue"), a = /* @__PURE__ */ s((u, ...l) => new Promise((c) => {
    o(u, c, l);
  }), "generator");
  return Object.defineProperties(a, {
    activeCount: {
      get: /* @__PURE__ */ s(() => r, "get")
    },
    pendingCount: {
      get: /* @__PURE__ */ s(() => t.size, "get")
    },
    clearQueue: {
      value: /* @__PURE__ */ s(() => {
        t.clear();
      }, "value")
    }
  }), a;
}
s(Tu, "pLimit");

// ../node_modules/locate-path/node_modules/p-locate/index.js
var Iu = class extends Error {
  static {
    s(this, "EndError");
  }
  constructor(t) {
    super(), this.value = t;
  }
}, C9 = /* @__PURE__ */ s(async (e, t) => t(await e), "testElement"), w9 = /* @__PURE__ */ s(async (e) => {
  let t = await Promise.all(e);
  if (t[1] === !0)
    throw new Iu(t[0]);
  return !1;
}, "finder");
async function fh(e, t, {
  concurrency: r = Number.POSITIVE_INFINITY,
  preserveOrder: n = !0
} = {}) {
  let i = Tu(r), o = [...e].map((u) => [u, i(C9, u, t)]), a = Tu(n ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(o.map((u) => a(w9, u)));
  } catch (u) {
    if (u instanceof Iu)
      return u.value;
    throw u;
  }
}
s(fh, "pLocate");

// ../node_modules/locate-path/index.js
var _x = {
  directory: "isDirectory",
  file: "isFile"
};
function kx(e) {
  if (!Object.hasOwnProperty.call(_x, e))
    throw new Error(`Invalid type specified: ${e}`);
}
s(kx, "checkType");
var Tx = /* @__PURE__ */ s((e, t) => t[_x[e]](), "matchType"), Ix = /* @__PURE__ */ s((e) => e instanceof URL ? (0, Fx.fileURLToPath)(e) : e,
"toPath");
async function Pu(e, {
  cwd: t = dh.default.cwd(),
  type: r = "file",
  allowSymlinks: n = !0,
  concurrency: i,
  preserveOrder: o
} = {}) {
  kx(r), t = Ix(t);
  let a = n ? Ds.promises.stat : Ds.promises.lstat;
  return fh(e, async (u) => {
    try {
      let l = await a(mh.default.resolve(t, u));
      return Tx(r, l);
    } catch {
      return !1;
    }
  }, { concurrency: i, preserveOrder: o });
}
s(Pu, "locatePath");
function xs(e, {
  cwd: t = dh.default.cwd(),
  type: r = "file",
  allowSymlinks: n = !0
} = {}) {
  kx(r), t = Ix(t);
  let i = n ? Ds.default.statSync : Ds.default.lstatSync;
  for (let o of e)
    try {
      let a = i(mh.default.resolve(t, o), {
        throwIfNoEntry: !1
      });
      if (!a)
        continue;
      if (Tx(r, a))
        return o;
    } catch {
    }
}
s(xs, "locatePathSync");

// ../node_modules/find-up/node_modules/unicorn-magic/node.js
var Px = require("node:url");
function zo(e) {
  return e instanceof URL ? (0, Px.fileURLToPath)(e) : e;
}
s(zo, "toPath");

// ../node_modules/find-up/node_modules/path-exists/index.js
var Bx = J(require("node:fs"), 1);

// ../node_modules/find-up/index.js
var Ox = Symbol("findUpStop");
async function S9(e, t = {}) {
  let r = Ir.default.resolve(zo(t.cwd) ?? ""), { root: n } = Ir.default.parse(r), i = Ir.default.resolve(r, zo(t.stopAt ?? n)), o = t.limit ??
  Number.POSITIVE_INFINITY, a = [e].flat(), u = /* @__PURE__ */ s(async (c) => {
    if (typeof e != "function")
      return Pu(a, c);
    let p = await e(c.cwd);
    return typeof p == "string" ? Pu([p], c) : p;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = await u({ ...t, cwd: r });
    if (c === Ox || (c && l.push(Ir.default.resolve(r, c)), r === i || l.length >= o))
      break;
    r = Ir.default.dirname(r);
  }
  return l;
}
s(S9, "findUpMultiple");
function A9(e, t = {}) {
  let r = Ir.default.resolve(zo(t.cwd) ?? ""), { root: n } = Ir.default.parse(r), i = Ir.default.resolve(r, zo(t.stopAt) ?? n), o = t.limit ??
  Number.POSITIVE_INFINITY, a = [e].flat(), u = /* @__PURE__ */ s((c) => {
    if (typeof e != "function")
      return xs(a, c);
    let p = e(c.cwd);
    return typeof p == "string" ? xs([p], c) : p;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = u({ ...t, cwd: r });
    if (c === Ox || (c && l.push(Ir.default.resolve(r, c)), r === i || l.length >= o))
      break;
    r = Ir.default.dirname(r);
  }
  return l;
}
s(A9, "findUpMultipleSync");
async function Bu(e, t = {}) {
  return (await S9(e, { ...t, limit: 1 }))[0];
}
s(Bu, "findUp");
function Ho(e, t = {}) {
  return A9(e, { ...t, limit: 1 })[0];
}
s(Ho, "findUpSync");

// src/core-server/utils/StoryIndexGenerator.ts
var Qm = J(Tr(), 1);
_i();

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var F9 = process.env.NODE_ENV === "production", gh = "Invariant failed";
function Pt(e, t) {
  if (!e) {
    if (F9)
      throw new Error(gh);
    var r = typeof t == "function" ? t() : t, n = r ? "".concat(gh, ": ").concat(r) : gh;
    throw new Error(n);
  }
}
s(Pt, "invariant");

// src/core-server/utils/StoryIndexGenerator.ts
var eg = J(Bt(), 1), Yl = J(gb(), 1);

// src/preview-api/modules/store/autoTitle.ts
var Db = require("storybook/internal/client-logger");
_i();
var xb = J(Bt(), 1);
var y4 = /* @__PURE__ */ s((e) => {
  if (e.length === 0)
    return e;
  let t = e[e.length - 1], r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, "");
  if (e.length === 1)
    return [r];
  let n = e[e.length - 2];
  return r && n && r.toLowerCase() === n.toLowerCase() ? [...e.slice(0, -2), r] : r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.
  test(r)) ? e.slice(0, -1) : [...e.slice(0, -1), r];
}, "sanitize");
function yb(e) {
  return e.flatMap((t) => t.split("/")).filter(Boolean).join("/");
}
s(yb, "pathJoin");
var Oh = /* @__PURE__ */ s((e, t, r) => {
  let { directory: n, importPathMatcher: i, titlePrefix: o = "" } = t || {};
  typeof e == "number" && Db.once.warn(xb.dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
  let a = it(String(e));
  if (i.exec(a)) {
    if (!r) {
      let u = a.replace(n, ""), l = yb([o, u]).split("/");
      return l = y4(l), l.join("/");
    }
    return o ? yb([o, r]) : r;
  }
}, "userOrAutoTitleFromSpecifier");

// src/preview-api/modules/store/sortStories.ts
var Eb = J(Bt(), 1);

// src/preview-api/modules/store/storySort.ts
var bb = /\s*\/\s*/, vb = /* @__PURE__ */ s((e = {}) => (t, r) => {
  if (t.title === r.title && !e.includeNames)
    return 0;
  let n = e.method || "configure", i = e.order || [], o = t.title.trim().split(bb), a = r.title.trim().split(bb);
  e.includeNames && (o.push(t.name), a.push(r.name));
  let u = 0;
  for (; o[u] || a[u]; ) {
    if (!o[u])
      return -1;
    if (!a[u])
      return 1;
    let l = o[u], c = a[u];
    if (l !== c) {
      let h = i.indexOf(l), f = i.indexOf(c), d = i.indexOf("*");
      return h !== -1 || f !== -1 ? (h === -1 && (d !== -1 ? h = d : h = i.length), f === -1 && (d !== -1 ? f = d : f = i.length), h - f) : n ===
      "configure" ? 0 : l.localeCompare(c, e.locales ? e.locales : void 0, {
        numeric: !0,
        sensitivity: "accent"
      });
    }
    let p = i.indexOf(l);
    p === -1 && (p = i.indexOf("*")), i = p !== -1 && Array.isArray(i[p + 1]) ? i[p + 1] : [], u += 1;
  }
  return 0;
}, "storySort");

// src/preview-api/modules/store/sortStories.ts
var D4 = /* @__PURE__ */ s((e, t, r) => {
  if (t) {
    let n;
    typeof t == "function" ? n = t : n = vb(t), e.sort(n);
  } else
    e.sort(
      (n, i) => r.indexOf(n.importPath) - r.indexOf(i.importPath)
    );
  return e;
}, "sortStoriesCommon"), Cb = /* @__PURE__ */ s((e, t, r) => {
  try {
    return D4(e, t, r);
  } catch (n) {
    throw new Error(Eb.dedent`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
  }
}, "sortStoriesV7");

// src/core-server/utils/IndexingError.ts
_i();
var Yr = class extends Error {
  static {
    s(this, "IndexingError");
  }
  constructor(t, r, n) {
    super(), this.message = t, this.importPaths = r, n && (this.stack = n);
  }
  pathsString() {
    return this.importPaths.length === 1 ? `${it(this.importPaths[0])}` : `${this.importPaths.map(it).join(",")}`;
  }
  toString() {
    return `${this.pathsString()}: ${this.message}`;
  }
}, Yo = class extends Error {
  constructor(r) {
    super();
    this.indexingErrors = r;
    if (this.indexingErrors.length === 0)
      throw new Error("Unexpected empty error list");
    if (this.indexingErrors.length === 1) {
      let [n] = this.indexingErrors;
      this.message = `Unable to index ${n.pathsString()}`;
    } else
      this.message = `Unable to index files:
${this.indexingErrors.map((n) => `- ${n}`).join(`
`)}`;
  }
  static {
    s(this, "MultipleIndexingError");
  }
  toString() {
    return this.indexingErrors.length === 1 ? `${this.message}:
  ${this.indexingErrors[0].stack}` : this.message;
  }
};

// src/core-server/utils/autoName.ts
var Rh = require("node:path");
function wb(e, t, r) {
  let n = (0, Rh.basename)(e), i = (0, Rh.basename)(t), [o] = n.split("."), [a] = i.split(".");
  return o === a ? r : o;
}
s(wb, "autoName");

// src/core-server/utils/summarizeStats.ts
var Sb = /* @__PURE__ */ s((e, t) => {
  Object.entries(e).forEach(([r, n]) => {
    let i = r;
    t[i] || (t[i] = 0), t[i] += n ? 1 : 0;
  });
}, "addStats");

// src/core-server/utils/StoryIndexGenerator.ts
var Ks = "autodocs", fz = "attached-mdx", dz = "unattached-mdx", DS = "play-fn";
function Mi({ tags: e }) {
  return e?.includes(dz) || e?.includes(fz);
}
s(Mi, "isMdxEntry");
var gS = /* @__PURE__ */ s((e, t, r) => e.startsWith(".") ? it((0, Ve.resolve)(r, (0, On.normalizeStoryPath)((0, Ve.join)((0, Ve.dirname)(t),
e)))) : e, "makeAbsolute"), an = class e {
  constructor(t, r) {
    this.specifiers = t;
    this.options = r;
    this.specifierToCache = /* @__PURE__ */ new Map();
  }
  static {
    s(this, "StoryIndexGenerator");
  }
  static {
    /** Cache for findMatchingFiles results */
    this.findMatchingFilesCache = /* @__PURE__ */ new Map();
  }
  /** Generate a cache key for findMatchingFiles */
  static getFindMatchingFilesCacheKey(t, r, n) {
    return JSON.stringify({
      directory: t.directory,
      files: t.files,
      workingDir: r,
      ignoreWarnings: n
    });
  }
  /** Clear the findMatchingFiles cache */
  static clearFindMatchingFilesCache() {
    this.findMatchingFilesCache.clear();
  }
  static async findMatchingFiles(t, r, n = !1) {
    let i = this.getFindMatchingFilesCacheKey(t, r, n), o = this.findMatchingFilesCache.get(i);
    if (o)
      return o;
    let a = {}, u = it((0, Ve.join)(t.directory, t.files)), { globby: l } = await Promise.resolve().then(() => (Wd(), Ud)), c = await l(u, {
      absolute: !0,
      cwd: r,
      ...(0, On.commonGlobOptions)(u)
    });
    return c.length === 0 && !n && qi.once.warn(
      `No story files found for the specified pattern: ${Qm.default.blue(
        (0, Ve.join)(t.directory, t.files)
      )}`
    ), c.sort().forEach((p) => {
      let h = (0, Ve.extname)(p);
      if (h === ".storyshot") {
        let f = (0, Ve.relative)(r, p);
        qi.logger.info(`Skipping ${h} file ${f}`);
        return;
      }
      a[p] = !1;
    }), this.findMatchingFilesCache.set(i, a), a;
  }
  static async findMatchingFilesForSpecifiers(t, r, n = !1) {
    return Promise.all(
      t.map(async (i) => {
        let o = await e.findMatchingFiles(
          i,
          r,
          n
        );
        return [i, o];
      })
    );
  }
  async initialize() {
    (await e.findMatchingFilesForSpecifiers(
      this.specifiers,
      this.options.workingDir
    )).forEach(
      ([i, o]) => this.specifierToCache.set(i, o)
    );
    let r = await this.getPreviewCode(), n = this.getProjectTags(r);
    await this.ensureExtracted({ projectTags: n });
  }
  /** Run the updater function over all the empty cache entries */
  async updateExtracted(t, r = !1) {
    await Promise.all(
      this.specifiers.map(async (n) => {
        let i = this.specifierToCache.get(n);
        return Pt(
          i,
          `specifier does not have a matching cache entry in specifierToCache: ${JSON.stringify(
            n
          )}`
        ), Promise.all(
          Object.keys(i).map(async (o) => {
            if (!(i[o] && !r))
              try {
                i[o] = await t(n, o, i[o]);
              } catch (a) {
                let u = `.${Ve.sep}${(0, Ve.relative)(this.options.workingDir, o)}`;
                i[o] = {
                  type: "error",
                  err: new Yr(
                    a instanceof Error ? a.message : String(a),
                    [u],
                    a instanceof Error ? a.stack : void 0
                  )
                };
              }
          })
        );
      })
    );
  }
  isDocsMdx(t) {
    return /(?<!\.stories)\.mdx$/i.test(t);
  }
  async ensureExtracted({
    projectTags: t
  }) {
    await this.updateExtracted(
      async (i, o) => this.isDocsMdx(o) ? !1 : this.extractStories(i, o, t)
    ), await this.updateExtracted(
      async (i, o) => this.extractDocs(i, o, t)
    );
    let r = {};
    return { entries: this.specifiers.flatMap((i) => {
      let o = this.specifierToCache.get(i);
      return Pt(
        o,
        `specifier does not have a matching cache entry in specifierToCache: ${JSON.stringify(
          i
        )}`
      ), Object.values(o).flatMap((a) => a ? a.type === "docs" ? [a] : a.type === "error" ? [a] : a.entries.map((u) => {
        if (u.type === "docs")
          return u;
        (0, yS.isExampleStoryId)(u.id) || Sb(u.extra.stats, r);
        let { extra: l, ...c } = u;
        return c;
      }) : []);
    }), stats: r };
  }
  findDependencies(t) {
    return [...this.specifierToCache.values()].flatMap(
      (r) => Object.entries(r).filter(([n, i]) => !i || i.type !== "stories" ? !1 : !!t.find(
        (o) => n.match(
          new RegExp(`^${o.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\.[^.]+)?$`)
        )
      )).map(([n, i]) => i)
    );
  }
  /**
   * Try to find the component path from a raw import string and return it in the same format as
   * `importPath`. Respect tsconfig paths if available.
   *
   * If no such file exists, assume that the import is from a package and return the raw
   */
  resolveComponentPath(t, r, n) {
    let i = t;
    n && (i = n(i) ?? i);
    let o = (0, Ve.resolve)((0, Ve.dirname)(r), i), a = ["", ".js", ".ts", ".jsx", ".tsx", ".mjs", ".mts"].map((u) => `${o}${u}`).find((u) => (0, Km.existsSync)(
    u));
    if (a) {
      let u = (0, Ve.relative)(this.options.workingDir, a);
      return it((0, On.normalizeStoryPath)(u));
    }
    return t;
  }
  async extractStories(t, r, n = []) {
    let i = (0, Ve.relative)(this.options.workingDir, r), o = it((0, On.normalizeStoryPath)(i)), a = /* @__PURE__ */ s((g) => {
      let b = Oh(o, t, g);
      return Pt(
        b,
        "makeTitle created an undefined title. This happens when the fileName doesn't match any specifier from main.js"
      ), b;
    }, "defaultMakeTitle"), u = this.options.indexers.find((g) => g.test.exec(r));
    Pt(u, `No matching indexer found for ${r}`);
    let l = await u.createIndex(r, { makeTitle: a }), c = await Bu("tsconfig.json", {
      cwd: this.options.workingDir,
      stopAt: (0, On.getProjectRoot)()
    }), p = Yl.loadConfig(c), h;
    p.resultType === "success" && (h = Yl.createMatchPath(p.absoluteBaseUrl, p.paths, [
      "browser",
      "module",
      "main"
    ]));
    let f = l.map((g) => {
      let b = g.name ?? (0, $r.storyNameFromExport)(g.exportName), y = g.rawComponentPath && this.resolveComponentPath(g.rawComponentPath, r,
      h), E = g.title ?? a(), A = g.__id ?? (0, $r.toId)(g.metaId ?? E, (0, $r.storyNameFromExport)(g.exportName)), k = (0, $r.combineTags)(
      ...n, ...g.tags ?? []);
      return {
        type: "story",
        id: A,
        extra: {
          metaId: g.metaId,
          stats: g.__stats ?? {}
        },
        name: b,
        title: E,
        importPath: o,
        componentPath: y,
        tags: k
      };
    });
    if (f.some((g) => g.tags.includes(Ks)) && !!this.options.docs && this.options.build?.test?.disableAutoDocs !== !0) {
      let b = this.options.docs?.defaultName ?? "Docs", { metaId: y } = l[0], { title: E } = f[0], A = (0, $r.toId)(y ?? E, b), k = (0, $r.combineTags)(
      ...n, ...l[0].tags ?? []);
      f.unshift({
        id: A,
        title: E,
        name: b,
        importPath: o,
        type: "docs",
        tags: k,
        storiesImports: []
      });
    }
    return {
      entries: f,
      dependents: [],
      type: "stories"
    };
  }
  async extractDocs(t, r, n = []) {
    let i = (0, Ve.relative)(this.options.workingDir, r);
    try {
      let o = (0, On.normalizeStoryPath)(i), a = it(o), u = await (0, Ym.readFile)(r, { encoding: "utf8" }), { analyze: l } = await Promise.resolve().then(() => (mS(), dS)),
      c = await l(u);
      if (c.isTemplate)
        return !1;
      let p = c.imports.map(
        (k) => gS(k, o, this.options.workingDir)
      ), h = this.findDependencies(p), f = h, d;
      if (c.of) {
        let k = gS(c.of, o, this.options.workingDir);
        h.forEach((O) => {
          if (O.entries.length > 0) {
            let w = O.entries.find((C) => C.type !== "docs");
            (0, Ve.normalize)((0, Ve.resolve)(this.options.workingDir, w.importPath)).startsWith(
              (0, Ve.normalize)(k)
            ) && (d = w);
          }
          f = [O, ...h.filter((w) => w !== O)];
        }), Pt(
          d,
          eg.dedent`
            Could not find or load CSF file at path "${c.of}" referenced by \`of={}\` in docs file "${i}".

            - Does that file exist?
            - If so, is it a CSF file (\`.stories.*\`)?
            - If so, is it matched by the \`stories\` glob in \`main.js\`?
            - If so, has the file successfully loaded in Storybook and are its stories visible?
          `
        );
      }
      h.forEach((k) => {
        k.dependents.push(r);
      });
      let m = d?.title || Oh(a, t, c.title);
      Pt(
        m,
        "makeTitle created an undefined title. This happens when a specifier's doesn't have any matches in its fileName"
      );
      let g = this.options.docs?.defaultName ?? "Docs", b = c.name || (d ? wb(a, d.importPath, g) : g), y = (0, $r.toId)(d?.extra.metaId || m,
      b), E = (0, $r.combineTags)(
        ...n,
        ...d?.tags ?? [],
        ...c.metaTags ?? [],
        d ? "attached-mdx" : "unattached-mdx"
      );
      return {
        id: y,
        title: m,
        name: b,
        importPath: a,
        storiesImports: f.map((k) => k.entries[0].importPath),
        type: "docs",
        tags: E
      };
    } catch (o) {
      throw o && o.source?.match(/mdast-util-mdx-jsx/g) && qi.logger.warn(
        `\u{1F4A1} This seems to be an MDX2 syntax error. Please refer to the MDX section in the following resource for assistance on how to fix th\
is: ${Qm.default.yellow(
          "https://storybook.js.org/docs/7/migration-guide?ref=error"
        )}`
      ), o;
    }
  }
  chooseDuplicate(t, r, n) {
    if (t.importPath === r.importPath)
      return t;
    let i = !0;
    (r.type === "story" || Mi(r) && t.type === "docs" && !Mi(t)) && (i = !1);
    let o = i ? t : r, a = i ? r : t, u = 'Use `<Meta of={} name="Other Name">` to distinguish them.';
    if (a.type === "story")
      throw new Yr(`Duplicate stories with id: ${t.id}`, [
        t.importPath,
        r.importPath
      ]);
    if (o.type === "story") {
      let l = Mi(a) ? "component docs page" : "automatically generated docs page", c = this.options.docs?.defaultName ?? "Docs";
      throw o.name === c ? new Yr(
        `You have a story for ${o.title} with the same name as your default docs entry name (${o.name}), so the docs page is being dropped. \
Consider changing the story name.`,
        [t.importPath, r.importPath]
      ) : new Yr(
        `You have a story for ${o.title} with the same name as your ${l} (${a.name}), so the docs page is being dropped. ${u}`,
        [t.importPath, r.importPath]
      );
    } else if (Mi(o)) {
      if (Mi(a))
        throw new Yr(
          `You have two component docs pages with the same name ${o.title}:${o.name}. ${u}`,
          [t.importPath, r.importPath]
        );
      if (a.tags?.includes(Ks) && !n?.includes(Ks))
        throw new Yr(
          `You created a component docs page for '${a.title}', but also tagged the CSF file with '${Ks}'. This is probably a mistake.`,
          [o.importPath, a.importPath]
        );
    } else
      return {
        ...o,
        storiesImports: [
          ...o.storiesImports,
          a.importPath,
          ...a.storiesImports
        ]
      };
    return o;
  }
  async sortStories(t, r) {
    let n = Object.values(t), i = e.storyFileNames(this.specifierToCache);
    return Cb(n, r, i), n.reduce(
      (o, a) => (o[a.id] = a, o),
      {}
    );
  }
  async getIndex() {
    return (await this.getIndexAndStats()).storyIndex;
  }
  async getIndexAndStats() {
    if (this.lastIndex && this.lastStats)
      return { storyIndex: this.lastIndex, stats: this.lastStats };
    if (this.lastError)
      throw this.lastError;
    let t = await this.getPreviewCode(), r = this.getProjectTags(t), { entries: n, stats: i } = await this.ensureExtracted({ projectTags: r });
    try {
      let o = n.filter((c) => c.type === "error");
      if (o.length)
        throw new Yo(o.map((c) => c.err));
      let a = [], u = {};
      if (n.forEach((c) => {
        try {
          let p = u[c.id];
          p ? u[c.id] = this.chooseDuplicate(p, c, r) : u[c.id] = c;
        } catch (p) {
          p instanceof Yr && a.push(p);
        }
      }), a.length)
        throw new Yo(a);
      let l = await this.sortStories(
        u,
        t && (0, Kl.getStorySortParameter)(t)
      );
      return this.lastStats = i, this.lastIndex = {
        v: 5,
        entries: l
      }, { storyIndex: this.lastIndex, stats: this.lastStats };
    } catch (o) {
      throw this.lastError = o == null || o instanceof Error ? o : void 0, Pt(this.lastError), qi.logger.warn(`\u{1F6A8} ${this.lastError.toString()}`),
      this.lastError;
    }
  }
  invalidateAll() {
    this.specifierToCache.forEach((t) => {
      Object.keys(t).forEach((r) => {
        t[r] = !1;
      });
    }), this.lastIndex = null, this.lastError = null;
  }
  invalidate(t, r, n) {
    let i = it((0, Ve.resolve)(this.options.workingDir, r)), o = this.specifierToCache.get(t);
    Pt(
      o,
      `specifier does not have a matching cache entry in specifierToCache: ${JSON.stringify(
        t
      )}`
    );
    let a = o[i];
    if (a && a.type === "stories") {
      let { dependents: u } = a, l = /* @__PURE__ */ new Set();
      this.specifierToCache.forEach((c) => {
        u.forEach((p) => {
          c[p] && (l.add(p), c[p] = !1);
        });
      });
    }
    if (n) {
      if (a && a.type === "docs") {
        let u = a.storiesImports.map(
          (c) => (0, Ve.resolve)(this.options.workingDir, c)
        );
        this.findDependencies(u).forEach(
          (c) => c.dependents.splice(c.dependents.indexOf(i), 1)
        );
      }
      delete o[i];
    } else
      o[i] = !1;
    this.lastIndex = null, this.lastError = null;
  }
  async getPreviewCode() {
    let t = ["js", "jsx", "ts", "tsx", "mjs", "cjs", "mts"].map((r) => (0, Ve.join)(this.options.configDir, `preview.${r}`)).find((r) => (0, Km.existsSync)(
    r));
    return t && (await (0, Ym.readFile)(t, { encoding: "utf8" })).toString();
  }
  getProjectTags(t) {
    let r = [], n = ["dev", "test"];
    if (t)
      try {
        r = (0, Kl.loadConfig)(t).parse().getFieldValue(["tags"]) ?? [];
      } catch {
        qi.once.warn(eg.dedent`
          Unable to parse tags from project configuration. If defined, tags should be specified inline, e.g.

          export default {
            tags: ['foo'],
          }

          ---

          Received:

          ${t}
        `);
      }
    return [...n, ...r];
  }
  // Get the story file names in "imported order"
  static storyFileNames(t) {
    return Array.from(t.values()).flatMap((r) => Object.keys(r));
  }
};

// src/core-server/utils/build-or-throw.ts
var xS = require("storybook/internal/server-errors");
async function Ql(e) {
  try {
    return await e();
  } catch (t) {
    let r = t.errors;
    throw r && r.find(
      (i) => i.text?.includes("No matching export")
    ) ? new xS.NoMatchingExportError(t) : t;
  }
}
s(Ql, "buildOrThrow");

// src/core-server/utils/copy-all-static-files.ts
var LS = require("node:fs/promises"), Ca = require("node:path"), jS = require("storybook/internal/common"), MS = require("storybook/internal/node-logger"),
ug = J(Tr(), 1);

// src/core-server/utils/server-statics.ts
var Qs = require("node:fs"), rc = require("node:fs/promises"), lt = require("node:path"), nc = require("storybook/internal/common"), Ea = require("storybook/internal/node-logger"),
tc = J(Tr(), 1), BS = J(IS(), 1), OS = J(Bt(), 1);
var kz = (0, nc.resolvePathInStorybookCache)("", "ignored-sub").split("ignored-sub")[0], ig = /* @__PURE__ */ new Map(), PS = /* @__PURE__ */ s(
async (e) => {
  if (ig.has(e))
    return ig.get(e);
  {
    let [t, r] = await Promise.all([(0, rc.readFile)(e, "utf-8"), (0, rc.stat)(e)]), n = { data: t, mtime: r.mtimeMs };
    return ig.set(e, n), n;
  }
}, "readFileOnce"), Tz = (0, lt.join)(
  (0, lt.dirname)(require.resolve("storybook/internal/package.json")),
  "/assets/browser/favicon-wrapper.svg"
), Iz = /* @__PURE__ */ s((e) => {
  let [, t, r, n] = e?.match(/(<svg[^>]*>)(.*?)(<\/svg>)/s) ?? [];
  if (!t || !r || !n)
    return e;
  let i, o, a = t.replace(/width=["']([^"']*)["']/g, (l, c) => (i = parseFloat(c), 'width="32px"')).replace(/height=["']([^"']*)["']/g, (l, c) => (o =
  parseFloat(c), 'height="32px"'));
  return !/viewBox=["'][^"']*["']/.test(a) && i && o && (a = a.replace(/>$/, ` viewBox="0 0 ${i} ${o}">`)), a = a.replace(/preserveAspectRatio=["'][^"']*["']/g,
  "").replace(/>$/, ' preserveAspectRatio="xMidYMid meet">'), a + r + n;
}, "prepareNestedSvg");
async function RS(e, t) {
  let r = await t.presets.apply("staticDirs") ?? [], n = await t.presets.apply("favicon"), i = (0, lt.resolve)(n, ".."), o = (0, lt.basename)(
  n);
  e.use(`/${o}`, async (a, u, l) => {
    let c = a.query.status;
    if (c && o.endsWith(".svg") && ["active", "critical", "negative", "positive", "warning"].includes(c)) {
      let [p, h] = await Promise.all([
        PS((0, lt.join)(i, o)),
        PS(Tz)
      ]).catch((f) => (f instanceof Error && Ea.once.warn(`Failed to read favicon: ${f.message}`), [null, null]));
      if (p && h) {
        let f = h.data.replace('<g id="mask"', `<g mask="url(#${c}-mask)"`).replace('<use id="status"', `<use href="#${c}"`).replace('<use i\
d="icon" />', Iz(p.data));
        u.setHeader("Content-Type", "image/svg+xml"), u.setHeader("ETag", `"${h.mtime}-${p.mtime}"`), u.end(f);
        return;
      }
    }
    return a.url = `/${o}`, sg(i)(a, u, l);
  }), r.map((a) => {
    try {
      let { staticDir: u, staticPath: l, targetEndpoint: c } = ag(a, t.configDir);
      if (!c.startsWith("/sb-") && !u.startsWith(kz) && Ea.logger.info(
        `=> Serving static files from ${tc.default.cyan(u)} at ${tc.default.cyan(c)}`
      ), (0, Qs.existsSync)(l) && (0, Qs.statSync)(l).isFile()) {
        let p = (0, lt.resolve)(l, ".."), h = (0, lt.basename)(l);
        e.use(c, (f, d, m) => {
          f.url = `/${h}`, sg(p)(f, d, m);
        });
      } else
        e.use(c, sg(l));
    } catch (u) {
      u instanceof Error && Ea.logger.warn(u.message);
    }
  });
}
s(RS, "useStatics");
var sg = /* @__PURE__ */ s((e, t = {}) => (r, n, i) => {
  let o = r._parsedUrl, a = i ? () => {
    r._parsedUrl = o, i();
  } : void 0;
  (0, BS.default)(e, { dev: !0, etag: !0, extensions: [], ...t })(r, n, a);
}, "sirvWorkaround"), og = /* @__PURE__ */ s((e) => {
  let t = e.lastIndexOf(":"), n = lt.win32.isAbsolute(e) && t === 1, i = t !== -1 && !n ? t : e.length, [o, a] = [e.slice(0, i), e.slice(i +
  1)], u = (0, lt.isAbsolute)(o) ? o : `./${o}`, l = (0, lt.resolve)(u);
  if (!(0, Qs.existsSync)(l))
    throw new Error(
      OS.dedent`
        Failed to load static files, no such directory: ${tc.default.cyan(l)}
        Make sure this directory exists.
      `
    );
  let h = (a || ((0, Qs.statSync)(l).isFile() ? (0, lt.basename)(l) : "/")).split(lt.sep).join(lt.posix.sep).replace(/^\/?/, "./"), f = h.substring(
  1);
  return { staticDir: u, staticPath: l, targetDir: h, targetEndpoint: f };
}, "parseStaticDir"), ag = /* @__PURE__ */ s((e, t) => {
  let r = typeof e == "string" ? e : `${e.from}:${e.to}`, n = (0, lt.isAbsolute)(r) ? r : (0, nc.getDirectoryFromWorkingDir)({ configDir: t,
  workingDir: process.cwd(), directory: r });
  return og(n);
}, "mapStaticDir");

// src/core-server/utils/copy-all-static-files.ts
async function qS(e, t, r) {
  let n = process.cwd();
  return e?.reduce(async (i, o) => {
    await i;
    let a = typeof o == "string" ? o : `${o.from}:${o.to}`, { staticPath: u, targetEndpoint: l } = og(
      (0, jS.getDirectoryFromWorkingDir)({
        configDir: r,
        workingDir: n,
        directory: a
      })
    ), c = (0, Ca.join)(t, l), p = ["index.html", "iframe.html"].map((h) => (0, Ca.join)(c, h));
    u.includes("node_modules") || MS.logger.info(
      `=> Copying static files: ${ug.default.cyan(NS(u))} at ${ug.default.cyan(NS(c))}`
    ), await (0, LS.cp)(u, c, {
      dereference: !0,
      preserveTimestamps: !0,
      filter: /* @__PURE__ */ s((h, f) => !p.includes(f), "filter"),
      recursive: !0
    });
  }, Promise.resolve());
}
s(qS, "copyAllStaticFilesRelativeToMain");
function NS(e) {
  return (0, Ca.relative)(process.cwd(), e);
}
s(NS, "print");

// src/core-server/utils/get-builders.ts
var $S = require("node:url"), VS = require("storybook/internal/server-errors");
async function wa() {
  return import("storybook/internal/builder-manager");
}
s(wa, "getManagerBuilder");
async function Sa(e, t) {
  let r = require.resolve(
    ["webpack5"].includes(e) ? `@storybook/builder-${e}` : e,
    { paths: [t] }
  );
  return await import((0, $S.pathToFileURL)(r).href);
}
s(Sa, "getPreviewBuilder");
async function US({ presets: e, configDir: t }) {
  let { builder: r } = await e.apply("core", {});
  if (!r)
    throw new VS.MissingBuilderError();
  let n = typeof r == "string" ? r : r.name;
  return Promise.all([Sa(n, t), wa()]);
}
s(US, "getBuilders");

// src/core-server/utils/metadata.ts
var WS = require("node:fs/promises"), lg = require("storybook/internal/telemetry");
async function zS(e, t) {
  let r = await (0, lg.getStorybookMetadata)(t);
  await (0, WS.writeFile)(e, JSON.stringify(r));
}
s(zS, "extractStorybookMetadata");
function HS(e, t) {
  e.use("/project.json", async (r, n) => {
    let i = await (0, lg.getStorybookMetadata)(t);
    n.setHeader("Content-Type", "application/json"), n.write(JSON.stringify(i)), n.end();
  });
}
s(HS, "useStorybookMetadata");

// src/core-server/utils/output-stats.ts
var xA = require("node:fs"), bA = require("node:path"), dg = require("storybook/internal/node-logger"), vA = J(yA(), 1), mg = J(Tr(), 1);
async function sc(e, t, r) {
  if (t) {
    let n = await DA(e, "preview", t);
    dg.logger.info(`=> preview stats written to ${mg.default.cyan(n)}`);
  }
  if (r) {
    let n = await DA(e, "manager", r);
    dg.logger.info(`=> manager stats written to ${mg.default.cyan(n)}`);
  }
}
s(sc, "outputStats");
var DA = /* @__PURE__ */ s(async (e, t, r) => {
  let n = (0, bA.join)(e, `${t}-stats.json`), { chunks: i, ...o } = r.toJson();
  return await new Promise((a, u) => {
    (0, vA.stringifyStream)(o, null, 2).on("error", u).pipe((0, xA.createWriteStream)(n)).on("error", u).on("finish", a);
  }), n;
}, "writeStats");

// src/core-server/utils/stories-json.ts
var aF = require("node:fs/promises"), uF = require("node:path"), lF = require("storybook/internal/core-events");

// ../node_modules/es-toolkit/dist/function/debounce.mjs
function EA(e, t, { signal: r, edges: n } = {}) {
  let i, o = null, a = n != null && n.includes("leading"), u = n == null || n.includes("trailing"), l = /* @__PURE__ */ s(() => {
    o !== null && (e.apply(i, o), i = void 0, o = null);
  }, "invoke"), c = /* @__PURE__ */ s(() => {
    u && l(), d();
  }, "onTimerEnd"), p = null, h = /* @__PURE__ */ s(() => {
    p != null && clearTimeout(p), p = setTimeout(() => {
      p = null, c();
    }, t);
  }, "schedule"), f = /* @__PURE__ */ s(() => {
    p !== null && (clearTimeout(p), p = null);
  }, "cancelTimer"), d = /* @__PURE__ */ s(() => {
    f(), i = void 0, o = null;
  }, "cancel"), m = /* @__PURE__ */ s(() => {
    f(), l();
  }, "flush"), g = /* @__PURE__ */ s(function(...b) {
    if (r?.aborted)
      return;
    i = this, o = b;
    let y = p == null;
    h(), a && y && l();
  }, "debounced");
  return g.schedule = h, g.cancel = d, g.flush = m, r?.addEventListener("abort", d, { once: !0 }), g;
}
s(EA, "debounce");

// ../node_modules/es-toolkit/dist/compat/function/debounce.mjs
function gg(e, t = 0, r = {}) {
  typeof r != "object" && (r = {});
  let { signal: n, leading: i = !1, trailing: o = !0, maxWait: a } = r, u = Array(2);
  i && (u[0] = "leading"), o && (u[1] = "trailing");
  let l, c = null, p = EA(function(...d) {
    l = e.apply(this, d), c = null;
  }, t, { signal: n, edges: u }), h = /* @__PURE__ */ s(function(...d) {
    if (a != null) {
      if (c === null)
        c = Date.now();
      else if (Date.now() - c >= a)
        return l = e.apply(this, d), c = Date.now(), p.cancel(), p.schedule(), l;
    }
    return p.apply(this, d), l;
  }, "debounced"), f = /* @__PURE__ */ s(() => (p.flush(), l), "flush");
  return h.cancel = p.cancel, h.flush = f, h;
}
s(gg, "debounce");

// src/core-server/utils/watch-story-specifiers.ts
var xc = require("node:fs"), un = require("node:path"), tF = require("storybook/internal/common");
_i();
var rF = J(Rg(), 1);
var nF = /* @__PURE__ */ s((e) => {
  try {
    return (0, xc.lstatSync)(e).isDirectory();
  } catch {
    return !1;
  }
}, "isDirectory");
function QH(e) {
  let t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ s((i) => {
    t.has(i) || ((0, xc.readdirSync)(i, { withFileTypes: !0 }).forEach((o) => {
      o.isDirectory() ? n((0, un.join)(i, o.name)) : o.isFile() && r.add((0, un.join)(i, o.name));
    }), t.add(i));
  }, "traverse");
  return e.filter(nF).forEach(n), { files: Array.from(r), directories: Array.from(t) };
}
s(QH, "getNestedFilesAndDirectories");
function iF(e, t, r) {
  let { files: n, directories: i } = QH(
    e.map((l) => (0, un.resolve)(t.workingDir, l.directory))
  ), o = new rF.default({
    // poll: true, // Slow!!! Enable only in special cases
    followSymlinks: !1,
    ignored: ["**/.git", "**/node_modules"]
  });
  o.watch({ files: n, directories: i });
  let a = /* @__PURE__ */ s((l) => {
    let c = (0, un.relative)(t.workingDir, l);
    return it(c.startsWith(".") ? c : `./${c}`);
  }, "toImportPath");
  async function u(l, c) {
    let p = a(l), h = e.find((f) => f.importPathMatcher.exec(p));
    if (h) {
      r(h, p, c);
      return;
    }
    !c && nF(l) && await Promise.all(
      e.filter((f) => p.startsWith(f.directory)).map(async (f) => {
        let d = (0, un.join)(
          l,
          "**",
          // files can be e.g. '**/foo/*/*.js' so we just want the last bit,
          // because the directory could already be within the files part (e.g. './x/foo/bar')
          (0, un.basename)(f.files)
        ), { globby: m } = await Promise.resolve().then(() => (Wd(), Ud));
        (await m(it(d), (0, tF.commonGlobOptions)(d))).forEach((b) => {
          let y = a(b);
          f.importPathMatcher.exec(y) && r(f, y, c);
        });
      })
    );
  }
  return s(u, "onChangeOrRemove"), o.on("change", async (l, c, p) => {
    await u(l, !c);
  }), o.on("remove", async (l, c) => {
    await u(l, !0);
  }), () => o.close();
}
s(iF, "watchStorySpecifiers");

// src/core-server/utils/watchConfig.ts
var sF = J(Rg(), 1);
function oF(e, t) {
  let r = new sF.default({
    followSymlinks: !1,
    ignored: ["**/.git", "**/node_modules"]
  });
  return r.watch({
    directories: [e]
  }), r.on("change", async (n, i, o) => {
    await t(n, !i);
  }), r.on("remove", async (n, i) => {
    await t(n, !0);
  }), () => r.close();
}
s(oF, "watchConfig");

// src/core-server/utils/stories-json.ts
var eG = 100;
async function cF(e, t, r) {
  let i = await (await t).getIndex();
  await (0, aF.writeFile)(e, JSON.stringify(r ? r(i) : i));
}
s(cF, "extractStoriesJson");
function pF({
  app: e,
  initializedStoryIndexGenerator: t,
  workingDir: r = process.cwd(),
  configDir: n,
  serverChannel: i,
  normalizedStories: o
}) {
  let a = gg(() => i.emit(lF.STORY_INDEX_INVALIDATED), eG, {
    leading: !0
  });
  iF(o, { workingDir: r }, async (u, l, c) => {
    (await t).invalidate(u, l, c), a();
  }), n && oF(n, async (u) => {
    (0, uF.basename)(u).startsWith("preview") && ((await t).invalidateAll(), a());
  }), e.use("/index.json", async (u, l) => {
    try {
      let p = await (await t).getIndex();
      l.setHeader("Content-Type", "application/json"), l.end(JSON.stringify(p));
    } catch (c) {
      l.statusCode = 500, l.end(c instanceof Error ? c.toString() : String(c));
    }
  });
}
s(pF, "useStoriesJson");

// src/core-server/utils/summarizeIndex.ts
var hF = require("storybook/internal/telemetry");
var tG = /(page|screen)/i;
var rG = /* @__PURE__ */ s((e) => tG.test(e), "isPageStory"), nG = /* @__PURE__ */ s((e) => [
  "example-introduction--docs",
  "configure-your-project--docs",
  "example-button--docs",
  "example-button--primary",
  "example-button--secondary",
  "example-button--large",
  "example-button--small",
  "example-header--docs",
  "example-header--logged-in",
  "example-header--logged-out",
  "example-page--logged-in",
  "example-page--logged-out"
].includes(e.id), "isCLIExampleEntry");
function io(e) {
  let t = 0, r = /* @__PURE__ */ new Set(), n = 0, i = 0, o = 0, a = 0, u = 0, l = 0, c = 0, p = 0, h = 0, f = 0;
  Object.values(e.entries).forEach((m) => {
    nG(m) ? (m.type === "story" && (n += 1), m.type === "docs" && (a += 1)) : (0, hF.isExampleStoryId)(m.id) ? (m.type === "story" && (i += 1),
    m.type === "docs" && (o += 1)) : m.type === "story" ? (t += 1, r.add(m.title), rG(m.title) && (u += 1), m.tags?.includes(DS) && (l += 1),
    m.tags?.includes("svelte-csf-v4") ? h += 1 : m.tags?.includes("svelte-csf-v5") && (f += 1)) : m.type === "docs" && (Mi(m) ? p += 1 : m.tags?.
    includes(Ks) && (c += 1));
  });
  let d = r.size;
  return {
    storyCount: t,
    componentCount: d,
    pageStoryCount: u,
    playStoryCount: l,
    autodocsCount: c,
    mdxCount: p,
    exampleStoryCount: n,
    exampleDocsCount: a,
    onboardingStoryCount: i,
    onboardingDocsCount: o,
    svelteCsfV4Count: h,
    svelteCsfV5Count: f,
    version: e.v
  };
}
s(io, "summarizeIndex");

// src/core-server/build-static.ts
async function Ng(e) {
  if (e.configType = "PRODUCTION", e.outputDir === "")
    throw new Error("Won't remove current directory. Check your outputDir!");
  if (e.outputDir = (0, vr.resolve)(e.outputDir), e.configDir = (0, vr.resolve)(e.configDir), Rn.logger.info(
    `=> Cleaning outputDir: ${mF.default.cyan((0, vr.relative)(process.cwd(), e.outputDir))}`
  ), e.outputDir === "/")
    throw new Error("Won't remove directory '/'. Check your outputDir!");
  await (0, fF.rm)(e.outputDir, { recursive: !0, force: !0 }).catch(() => {
  }), await (0, bc.mkdir)(e.outputDir, { recursive: !0 });
  let t = await (0, Vr.loadMainConfig)(e), { framework: r } = t, n = [], i = typeof r == "string" ? r : r?.name;
  i ? n.push((0, vr.join)(i, "preset")) : e.ignorePreview || Rn.logger.warn(`you have not specified a framework in your ${e.configDir}/main.\
js`), Rn.logger.info("=> Loading presets");
  let o = await (0, Vr.loadAllPresets)({
    corePresets: [
      require.resolve("storybook/internal/core-server/presets/common-preset"),
      ...n
    ],
    overridePresets: [
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    isCritical: !0,
    ...e
  }), { renderer: a } = await o.apply("core", {}), u = await o.apply("build", {}), [l, c] = await US({ ...e, presets: o, build: u }), p = a ?
  (0, Vr.resolveAddonName)(e.configDir, a, e) : void 0;
  o = await (0, Vr.loadAllPresets)({
    corePresets: [
      require.resolve("storybook/internal/core-server/presets/common-preset"),
      ...c.corePresets || [],
      ...l.corePresets || [],
      ...p ? [p] : [],
      ...n
    ],
    overridePresets: [
      ...l.overridePresets || [],
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    ...e,
    build: u
  });
  let [h, f, d, m, g, b] = await Promise.all([
    o.apply("features"),
    o.apply("core"),
    o.apply("staticDirs"),
    o.apply("experimental_indexers", []),
    o.apply("stories"),
    o.apply("docs")
  ]), y = process.env.STORYBOOK_INVOKED_BY;
  !f?.disableTelemetry && y && (0, Pa.telemetry)("test-run", { runner: y, watch: !1 }, { configDir: e.configDir });
  let E = {
    ...e,
    presets: o,
    features: h,
    build: u
  }, A = [];
  dF.global.FEATURES = h, e.previewOnly || await Ql(
    async () => c.build({ startTime: process.hrtime(), options: E })
  ), d && A.push(
    qS(d, e.outputDir, e.configDir)
  );
  let k = (0, vr.join)(
    (0, vr.dirname)(require.resolve("storybook/internal/package.json")),
    "assets/browser"
  );
  A.push((0, bc.cp)(k, e.outputDir, { recursive: !0 }));
  let O = Promise.resolve(void 0);
  if (!e.ignorePreview) {
    let C = process.cwd(), T = {
      configDir: e.configDir,
      workingDir: C
    }, F = (0, Vr.normalizeStories)(g, T), $ = new an(F, {
      ...T,
      indexers: m,
      docs: b,
      build: u
    });
    O = $.initialize().then(() => $), A.push(
      cF(
        (0, vr.join)(e.outputDir, "index.json"),
        O
      )
    );
  }
  f?.disableProjectJson || A.push(
    zS((0, vr.join)(e.outputDir, "project.json"), e.configDir)
  ), e.debugWebpack && (0, Vr.logConfig)("Preview webpack config", await l.getConfig(E)), e.ignorePreview ? Rn.logger.info("=> Not building \
preview") : Rn.logger.info("=> Building preview..");
  let w = process.hrtime();
  await Promise.all([
    ...e.ignorePreview ? [] : [
      l.build({
        startTime: w,
        options: E
      }).then(async (C) => {
        Rn.logger.trace({ message: "=> Preview built", time: process.hrtime(w) });
        let T = e.webpackStatsJson || e.statsJson;
        if (T) {
          let F = T === !0 ? e.outputDir : T;
          await sc(F, C);
        }
      }).catch((C) => {
        throw Rn.logger.error("=> Failed to build the preview"), process.exitCode = 1, C;
      })
    ],
    ...A
  ]), !f?.disableTelemetry && !e.test && A.push(
    O.then(async (C) => {
      let T = await C?.getIndex(), F = {
        precedingUpgrade: await (0, Pa.getPrecedingUpgrade)()
      };
      T && Object.assign(F, {
        storyIndex: io(T)
      }), await (0, Pa.telemetry)("build", F, { configDir: e.configDir });
    })
  ), Rn.logger.info(`=> Output directory: ${e.outputDir}`);
}
s(Ng, "buildStaticStandalone");

// src/core-server/build-dev.ts
var UR = require("node:fs/promises"), Ai = require("node:path"), ft = require("storybook/internal/common"), ys = require("storybook/internal/node-logger"),
th = require("storybook/internal/server-errors"), rh = require("storybook/internal/telemetry"), WR = require("@storybook/global"), zR = J(J0(), 1);
var HR = J(Bt(), 1);

// src/core-server/dev-server.ts
var R6 = require("storybook/internal/common"), qD = require("storybook/internal/node-logger"), N6 = require("storybook/internal/server-errors");

// ../node_modules/@polka/compression/build.mjs
var lo = J(require("node:zlib"), 1);
var uX = /* @__PURE__ */ s(() => {
}, "NOOP"), lX = /text|javascript|\/json|xml/i;
function zk(e, t) {
  return e ? Buffer.byteLength(e, t) : 0;
}
s(zk, "getChunkSize");
function Z0({ threshold: e = 1024, level: t = -1, brotli: r = !1, gzip: n = !0, mimes: i = lX } = {}) {
  let o = typeof r == "object" && r || {}, a = typeof n == "object" && n || {};
  return lo.default.createBrotliCompress || (r = !1), (u, l, c = uX) => {
    let p = u.headers["accept-encoding"] + "", h = (r && /\bbr\b/.exec(p) || n && /\bgzip\b/.exec(p) || [])[0];
    if (u.method === "HEAD" || !h) return c();
    let f, d = [], m = 0, g = !1, b = 0;
    function y() {
      g = !0, b = l.getHeader("Content-Length") | 0 || b;
      let w = i.test(
        String(l.getHeader("Content-Type") || "text/plain")
      ), C = !l.getHeader("Content-Encoding"), T = d || [];
      w && C && b >= e ? (l.setHeader("Content-Encoding", h), l.removeHeader("Content-Length"), h === "br" ? f = lo.default.createBrotliCompress(
      {
        params: Object.assign({
          [lo.default.constants.BROTLI_PARAM_QUALITY]: t,
          [lo.default.constants.BROTLI_PARAM_SIZE_HINT]: b
        }, o)
      }) : f = lo.default.createGzip(
        Object.assign({ level: t }, a)
      ), f.on("data", (F) => A.call(l, F) || f.pause()), k.call(l, "drain", () => f.resume()), f.on("end", () => E.call(l)), T.forEach((F) => f.
      on.apply(f, F))) : (d = null, T.forEach((F) => k.apply(l, F))), O.call(l, m || l.statusCode);
    }
    s(y, "start");
    let { end: E, write: A, on: k, writeHead: O } = l;
    l.writeHead = function(w, C, T) {
      if (typeof C != "string" && ([T, C] = [C, T]), T) for (let F in T) l.setHeader(F, T[F]);
      return m = w, this;
    }, l.write = function(w, C) {
      return b += zk(w, C), g || y(), f ? f.write.apply(f, arguments) : A.apply(this, arguments);
    }, l.end = function(w, C) {
      return arguments.length > 0 && typeof w != "function" && (b += zk(w, C)), g || y(), f ? f.end.apply(f, arguments) : E.apply(this, arguments);
    }, l.on = function(w, C) {
      return d ? f ? f.on(w, C) : d.push([w, C]) : k.call(this, w, C), this;
    }, c();
  };
}
s(Z0, "default");

// ../node_modules/polka/build.mjs
var Q0 = J(require("node:http"), 1), Hk = require("node:timers");

// ../node_modules/regexparam/dist/index.mjs
function X0(e, t) {
  if (e instanceof RegExp) return { keys: !1, pattern: e };
  var r, n, i, o, a = [], u = "", l = e.split("/");
  for (l[0] || l.shift(); i = l.shift(); )
    r = i[0], r === "*" ? (a.push(r), u += i[1] === "?" ? "(?:/(.*))?" : "/(.*)") : r === ":" ? (n = i.indexOf("?", 1), o = i.indexOf(".", 1),
    a.push(i.substring(1, ~n ? n : ~o ? o : i.length)), u += ~n && !~o ? "(?:/([^/]+?))?" : "/([^/]+?)", ~o && (u += (~n ? "?" : "") + "\\" +
    i.substring(o))) : u += "/" + i;
  return {
    keys: a,
    pattern: new RegExp("^" + u + (t ? "(?=$|/)" : "/?$"), "i")
  };
}
s(X0, "parse");

// ../node_modules/trouter/index.mjs
var K0 = {
  "": 0,
  GET: 1,
  HEAD: 2,
  PATCH: 3,
  OPTIONS: 4,
  CONNECT: 5,
  DELETE: 6,
  TRACE: 7,
  POST: 8,
  PUT: 9
}, Lc = class {
  static {
    s(this, "Trouter");
  }
  constructor() {
    this.routes = [], this.all = this.add.bind(this, ""), this.get = this.add.bind(this, "GET"), this.head = this.add.bind(this, "HEAD"), this.
    patch = this.add.bind(this, "PATCH"), this.options = this.add.bind(this, "OPTIONS"), this.connect = this.add.bind(this, "CONNECT"), this.
    delete = this.add.bind(this, "DELETE"), this.trace = this.add.bind(this, "TRACE"), this.post = this.add.bind(this, "POST"), this.put = this.
    add.bind(this, "PUT");
  }
  use(t, ...r) {
    let n = [].concat.apply([], r), { keys: i, pattern: o } = X0(t, !0);
    return this.routes.push({ keys: i, pattern: o, method: "", handlers: n, midx: K0[""] }), this;
  }
  add(t, r, ...n) {
    let { keys: i, pattern: o } = X0(r), a = [].concat.apply([], n);
    return this.routes.push({ keys: i, pattern: o, method: t, handlers: a, midx: K0[t] }), this;
  }
  find(t, r) {
    let n = K0[t], i = n === 2, o = 0, a = 0, u, l, c = this.routes, p = [], h = {}, f = [];
    for (; o < c.length; o++)
      if (l = c[o], l.midx === n || l.midx === 0 || i && l.midx === 1)
        if (l.keys === !1) {
          if (p = l.pattern.exec(r), p === null) continue;
          if (p.groups !== void 0) for (u in p.groups) h[u] = p.groups[u];
          l.handlers.length > 1 ? f = f.concat(l.handlers) : f.push(l.handlers[0]);
        } else if (l.keys.length > 0) {
          if (p = l.pattern.exec(r), p === null) continue;
          for (a = 0; a < l.keys.length; ) h[l.keys[a]] = p[++a];
          l.handlers.length > 1 ? f = f.concat(l.handlers) : f.push(l.handlers[0]);
        } else l.pattern.test(r) && (l.handlers.length > 1 ? f = f.concat(l.handlers) : f.push(l.handlers[0]));
    return { params: h, handlers: f };
  }
};

// ../node_modules/polka/build.mjs
rg();
function cX(e, t, r) {
  let n = typeof e.status == "number" && e.status;
  n = r.statusCode = n && n >= 100 ? n : 500, typeof e == "string" || Buffer.isBuffer(e) ? r.end(e) : r.end(e.message || Q0.default.STATUS_CODES[n]);
}
s(cX, "onError");
var Y0 = /* @__PURE__ */ s((e) => e instanceof jc ? e.attach : e, "mount"), jc = class e extends Lc {
  static {
    s(this, "Polka");
  }
  constructor(t = {}) {
    super(), this.parse = tg, this.server = t.server, this.handler = this.handler.bind(this), this.onError = t.onError || cX, this.onNoMatch =
    t.onNoMatch || this.onError.bind(null, { status: 404 }), this.attach = (r, n) => (0, Hk.setImmediate)(this.handler, r, n);
  }
  use(t, ...r) {
    return t === "/" ? super.use(t, r.map(Y0)) : typeof t == "function" || t instanceof e ? super.use("/", [t, ...r].map(Y0)) : super.use(
      t,
      (n, i, o) => {
        if (typeof t == "string") {
          let a = t.length;
          t.startsWith("/") || a++, n.url = n.url.substring(a) || "/", n.path = n.path.substring(a) || "/";
        } else
          n.url = n.url.replace(t, "") || "/", n.path = n.path.replace(t, "") || "/";
        n.url.charAt(0) !== "/" && (n.url = "/" + n.url), o();
      },
      r.map(Y0),
      (n, i, o) => {
        n.path = n._parsedUrl.pathname, n.url = n.path + n._parsedUrl.search, o();
      }
    ), this;
  }
  listen() {
    return (this.server = this.server || Q0.default.createServer()).on("request", this.attach), this.server.listen.apply(this.server, arguments),
    this;
  }
  handler(t, r, n) {
    let i = this.parse(t), o = i.pathname, a = this.find(t.method, t.path = o);
    if (t.url = o + i.search, t.originalUrl = t.originalUrl || t.url, t.query = i.query || {}, t.search = i.search, t.params = a.params, o.length >
    1 && o.indexOf("%", 1) !== -1)
      for (let h in t.params)
        try {
          t.params[h] = decodeURIComponent(t.params[h]);
        } catch {
        }
    let u = 0, l = a.handlers.concat(this.onNoMatch), c = l.length, p = /* @__PURE__ */ s(async () => r.finished || u < c && l[u++](t, r, n),
    "loop");
    (n = n || ((h) => h ? this.onError(h, t, r, n) : p().catch(n)))();
  }
};
function ey(e) {
  return new jc(e);
}
s(ey, "default");

// src/telemetry/index.ts
var uD = require("storybook/internal/node-logger");

// src/telemetry/notify.ts
var ty = require("storybook/internal/common"), zi = require("storybook/internal/node-logger"), Jk = J(Tr(), 1);
var Gk = "telemetry-notification-date", Zk = /* @__PURE__ */ s(async () => {
  await ty.cache.get(Gk, null) || (ty.cache.set(Gk, Date.now()), zi.logger.log(
    `${zi.CLI_COLORS.info("Attention:")} Storybook now collects completely anonymous telemetry regarding usage. This information is used to \
shape Storybook's roadmap and prioritize features.`
  ), zi.logger.log(
    "You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:"
  ), zi.logger.log(Jk.default.cyan("https://storybook.js.org/telemetry")), zi.logger.log(""));
}, "notify");

// src/telemetry/sanitize.ts
var ry = J(require("node:path"), 1);
function Xk(e) {
  return e.replace(/[-[/{}()*+?.\\^$|]/g, "\\$&");
}
s(Xk, "regexpEscape");
function Kk(e = "") {
  return e.replace(/\u001B\[[0-9;]*m/g, "");
}
s(Kk, "removeAnsiEscapeCodes");
function Wa(e, t = ry.default.sep) {
  if (!e)
    return e;
  let r = process.cwd().split(t);
  for (; r.length > 1; ) {
    let n = r.join(t), i = new RegExp(Xk(n), "gi");
    e = e.replace(i, "$SNIP");
    let o = r.join(t + t), a = new RegExp(Xk(o), "gi");
    e = e.replace(a, "$SNIP"), r.pop();
  }
  return e;
}
s(Wa, "cleanPaths");
function Mc(e, t = ry.default.sep) {
  try {
    e = {
      ...JSON.parse(JSON.stringify(e)),
      message: Kk(e.message),
      stack: Kk(e.stack),
      cause: e.cause,
      name: e.name
    };
    let r = Wa(JSON.stringify(e), t);
    return JSON.parse(r);
  } catch (r) {
    return `Sanitization error: ${r?.message}`;
  }
}
s(Mc, "sanitizeError");

// src/telemetry/storybook-metadata.ts
var iB = require("node:path"), xn = require("storybook/internal/common"), sB = require("storybook/internal/csf-tools");

// ../node_modules/fd-package-json/dist/esm/main.js
var eT = J(Qk(), 1), tT = require("node:path"), $c = require("node:fs/promises"), rT = require("node:fs");
async function hX(e) {
  try {
    return (await (0, $c.stat)(e)).isFile();
  } catch {
    return !1;
  }
}
s(hX, "fileExists");
async function ny(e) {
  for (let t of (0, eT.walkUp)(e)) {
    let r = (0, tT.resolve)(t, "package.json");
    if (await hX(r))
      return r;
  }
  return null;
}
s(ny, "findPackagePath");
async function nT(e) {
  let t = await ny(e);
  if (!t)
    return null;
  try {
    let r = await (0, $c.readFile)(t, { encoding: "utf8" });
    return JSON.parse(r);
  } catch {
    return null;
  }
}
s(nT, "findPackage");

// package.json
var Vc = "9.1.4";

// src/cli/globalSettings.ts
var Kc = J(require("node:fs/promises"), 1), kT = require("node:os"), Qc = require("node:path"), TT = J(Bt(), 1), xo = J(_T(), 1);
var RK = (0, Qc.join)((0, kT.homedir)(), ".storybook", "settings.json"), NK = 1, LK = xo.z.object({
  version: xo.z.number(),
  // NOTE: every key (and subkey) below must be optional, for forwards compatibility reasons
  // (we can remove keys once they are deprecated)
  userSince: xo.z.number().optional(),
  init: xo.z.object({ skipOnboarding: xo.z.boolean().optional() }).optional()
}), Do;
async function IT(e = RK) {
  if (Do)
    return Do;
  try {
    let t = await Kc.default.readFile(e, "utf8"), r = LK.parse(JSON.parse(t));
    Do = new Yc(e, r);
  } catch {
    Do = new Yc(e, { version: NK, userSince: Date.now() }), await Do.save();
  }
  return Do;
}
s(IT, "globalSettings");
var Yc = class {
  static {
    s(this, "Settings");
  }
  /**
   * Create a new Settings instance
   *
   * @param filePath Path to the JSON settings file
   * @param value Loaded value of settings
   */
  constructor(t, r) {
    this.filePath = t, this.value = r;
  }
  /** Save settings to the file */
  async save() {
    try {
      await Kc.default.mkdir((0, Qc.dirname)(this.filePath), { recursive: !0 }), await Kc.default.writeFile(this.filePath, JSON.stringify(this.
      value, null, 2));
    } catch (t) {
      console.warn(TT.dedent`
        Unable to save global settings file to ${this.filePath}
        ${t && `Reason: ${t.message ?? t}`}`);
    }
  }
};

// src/telemetry/get-application-file-count.ts
var MP = require("node:path");

// src/telemetry/exec-command-count-lines.ts
var CP = require("node:readline");

// node_modules/execa/index.js
var yP = require("node:buffer"), DP = J(require("node:path"), 1), dp = J(require("node:child_process"), 1), eu = J(require("node:process"), 1),
xP = J(xI(), 1);

// ../node_modules/strip-final-newline/index.js
function vy(e) {
  let t = typeof e == "string" ? `
` : 10, r = typeof e == "string" ? "\r" : 13;
  return e[e.length - 1] === t && (e = e.slice(0, -1)), e[e.length - 1] === r && (e = e.slice(0, -1)), e;
}
s(vy, "stripFinalNewline");

// node_modules/npm-run-path/index.js
var Ka = J(require("node:process"), 1), Eo = J(require("node:path"), 1), Ey = require("node:url");

// node_modules/path-key/index.js
function tp(e = {}) {
  let {
    env: t = process.env,
    platform: r = process.platform
  } = e;
  return r !== "win32" ? "PATH" : Object.keys(t).reverse().find((n) => n.toUpperCase() === "PATH") || "Path";
}
s(tp, "pathKey");

// node_modules/npm-run-path/index.js
var cY = /* @__PURE__ */ s(({
  cwd: e = Ka.default.cwd(),
  path: t = Ka.default.env[tp()],
  preferLocal: r = !0,
  execPath: n = Ka.default.execPath,
  addExecPath: i = !0
} = {}) => {
  let o = e instanceof URL ? (0, Ey.fileURLToPath)(e) : e, a = Eo.default.resolve(o), u = [];
  return r && pY(u, a), i && hY(u, n, a), [...u, t].join(Eo.default.delimiter);
}, "npmRunPath"), pY = /* @__PURE__ */ s((e, t) => {
  let r;
  for (; r !== t; )
    e.push(Eo.default.join(t, "node_modules/.bin")), r = t, t = Eo.default.resolve(t, "..");
}, "applyPreferLocal"), hY = /* @__PURE__ */ s((e, t, r) => {
  let n = t instanceof URL ? (0, Ey.fileURLToPath)(t) : t;
  e.push(Eo.default.resolve(r, n, ".."));
}, "applyExecPath"), bI = /* @__PURE__ */ s(({ env: e = Ka.default.env, ...t } = {}) => {
  e = { ...e };
  let r = tp({ env: e });
  return t.path = e[r], e[r] = cY(t), e;
}, "npmRunPathEnv");

// node_modules/mimic-fn/index.js
var fY = /* @__PURE__ */ s((e, t, r, n) => {
  if (r === "length" || r === "prototype" || r === "arguments" || r === "caller")
    return;
  let i = Object.getOwnPropertyDescriptor(e, r), o = Object.getOwnPropertyDescriptor(t, r);
  !dY(i, o) && n || Object.defineProperty(e, r, o);
}, "copyProperty"), dY = /* @__PURE__ */ s(function(e, t) {
  return e === void 0 || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable &&
  (e.writable || e.value === t.value);
}, "canCopyProperty"), mY = /* @__PURE__ */ s((e, t) => {
  let r = Object.getPrototypeOf(t);
  r !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, r);
}, "changePrototype"), gY = /* @__PURE__ */ s((e, t) => `/* Wrapped ${e}*/
${t}`, "wrappedToString"), yY = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), DY = Object.getOwnPropertyDescriptor(Function.
prototype.toString, "name"), xY = /* @__PURE__ */ s((e, t, r) => {
  let n = r === "" ? "" : `with ${r.trim()}() `, i = gY.bind(null, n, t.toString());
  Object.defineProperty(i, "name", DY), Object.defineProperty(e, "toString", { ...yY, value: i });
}, "changeToString");
function Cy(e, t, { ignoreNonConfigurable: r = !1 } = {}) {
  let { name: n } = e;
  for (let i of Reflect.ownKeys(t))
    fY(e, t, i, r);
  return mY(e, t), xY(e, t, n), e;
}
s(Cy, "mimicFunction");

// node_modules/onetime/index.js
var rp = /* @__PURE__ */ new WeakMap(), vI = /* @__PURE__ */ s((e, t = {}) => {
  if (typeof e != "function")
    throw new TypeError("Expected a function");
  let r, n = 0, i = e.displayName || e.name || "<anonymous>", o = /* @__PURE__ */ s(function(...a) {
    if (rp.set(o, ++n), n === 1)
      r = e.apply(this, a), e = null;
    else if (t.throw === !0)
      throw new Error(`Function \`${i}\` can only be called once`);
    return r;
  }, "onetime");
  return Cy(o, e), rp.set(o, n), o;
}, "onetime");
vI.callCount = (e) => {
  if (!rp.has(e))
    throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`);
  return rp.get(e);
};
var EI = vI;

// node_modules/execa/lib/error.js
var kI = J(require("node:process"), 1);

// node_modules/human-signals/build/src/main.js
var FI = require("node:os");

// node_modules/human-signals/build/src/realtime.js
var CI = /* @__PURE__ */ s(() => {
  let e = wy - wI + 1;
  return Array.from({ length: e }, bY);
}, "getRealtimeSignals"), bY = /* @__PURE__ */ s((e, t) => ({
  name: `SIGRT${t + 1}`,
  number: wI + t,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
}), "getRealtimeSignal"), wI = 34, wy = 64;

// node_modules/human-signals/build/src/signals.js
var AI = require("node:os");

// node_modules/human-signals/build/src/core.js
var SI = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var Sy = /* @__PURE__ */ s(() => {
  let e = CI();
  return [...SI, ...e].map(vY);
}, "getSignals"), vY = /* @__PURE__ */ s(({
  name: e,
  number: t,
  description: r,
  action: n,
  forced: i = !1,
  standard: o
}) => {
  let {
    signals: { [e]: a }
  } = AI.constants, u = a !== void 0;
  return { name: e, number: u ? a : t, description: r, supported: u, action: n, forced: i, standard: o };
}, "normalizeSignal");

// node_modules/human-signals/build/src/main.js
var EY = /* @__PURE__ */ s(() => {
  let e = Sy();
  return Object.fromEntries(e.map(CY));
}, "getSignalsByName"), CY = /* @__PURE__ */ s(({
  name: e,
  number: t,
  description: r,
  supported: n,
  action: i,
  forced: o,
  standard: a
}) => [e, { name: e, number: t, description: r, supported: n, action: i, forced: o, standard: a }], "getSignalByName"), _I = EY(), wY = /* @__PURE__ */ s(
() => {
  let e = Sy(), t = wy + 1, r = Array.from(
    { length: t },
    (n, i) => SY(i, e)
  );
  return Object.assign({}, ...r);
}, "getSignalsByNumber"), SY = /* @__PURE__ */ s((e, t) => {
  let r = AY(e, t);
  if (r === void 0)
    return {};
  let { name: n, description: i, supported: o, action: a, forced: u, standard: l } = r;
  return {
    [e]: {
      name: n,
      number: e,
      description: i,
      supported: o,
      action: a,
      forced: u,
      standard: l
    }
  };
}, "getSignalByNumber"), AY = /* @__PURE__ */ s((e, t) => {
  let r = t.find(({ name: n }) => FI.constants.signals[n] === e);
  return r !== void 0 ? r : t.find((n) => n.number === e);
}, "findSignalByNumber"), pge = wY();

// node_modules/execa/lib/error.js
var FY = /* @__PURE__ */ s(({ timedOut: e, timeout: t, errorCode: r, signal: n, signalDescription: i, exitCode: o, isCanceled: a }) => e ? `\
timed out after ${t} milliseconds` : a ? "was canceled" : r !== void 0 ? `failed with ${r}` : n !== void 0 ? `was killed with ${n} (${i})` :
o !== void 0 ? `failed with exit code ${o}` : "failed", "getErrorPrefix"), Ya = /* @__PURE__ */ s(({
  stdout: e,
  stderr: t,
  all: r,
  error: n,
  signal: i,
  exitCode: o,
  command: a,
  escapedCommand: u,
  timedOut: l,
  isCanceled: c,
  killed: p,
  parsed: { options: { timeout: h, cwd: f = kI.default.cwd() } }
}) => {
  o = o === null ? void 0 : o, i = i === null ? void 0 : i;
  let d = i === void 0 ? void 0 : _I[i].description, m = n && n.code, b = `Command ${FY({ timedOut: l, timeout: h, errorCode: m, signal: i, signalDescription: d,
  exitCode: o, isCanceled: c })}: ${a}`, y = Object.prototype.toString.call(n) === "[object Error]", E = y ? `${b}
${n.message}` : b, A = [E, t, e].filter(Boolean).join(`
`);
  return y ? (n.originalMessage = n.message, n.message = A) : n = new Error(A), n.shortMessage = E, n.command = a, n.escapedCommand = u, n.exitCode =
  o, n.signal = i, n.signalDescription = d, n.stdout = e, n.stderr = t, n.cwd = f, r !== void 0 && (n.all = r), "bufferedData" in n && delete n.
  bufferedData, n.failed = !0, n.timedOut = !!l, n.isCanceled = c, n.killed = p && !l, n;
}, "makeError");

// node_modules/execa/lib/stdio.js
var np = ["stdin", "stdout", "stderr"], _Y = /* @__PURE__ */ s((e) => np.some((t) => e[t] !== void 0), "hasAlias"), TI = /* @__PURE__ */ s((e) => {
  if (!e)
    return;
  let { stdio: t } = e;
  if (t === void 0)
    return np.map((n) => e[n]);
  if (_Y(e))
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${np.map((n) => `\`${n}\``).join(", ")}`);
  if (typeof t == "string")
    return t;
  if (!Array.isArray(t))
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);
  let r = Math.max(t.length, np.length);
  return Array.from({ length: r }, (n, i) => t[i]);
}, "normalizeStdio");

// node_modules/execa/lib/kill.js
var PI = J(require("node:os"), 1);

// node_modules/signal-exit/dist/mjs/signals.js
var us = [];
us.push("SIGHUP", "SIGINT", "SIGTERM");
process.platform !== "win32" && us.push(
  "SIGALRM",
  "SIGABRT",
  "SIGVTALRM",
  "SIGXCPU",
  "SIGXFSZ",
  "SIGUSR2",
  "SIGTRAP",
  "SIGSYS",
  "SIGQUIT",
  "SIGIOT"
  // should detect profiler and enable/disable accordingly.
  // see #21
  // 'SIGPROF'
);
process.platform === "linux" && us.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");

// node_modules/signal-exit/dist/mjs/index.js
var ip = /* @__PURE__ */ s((e) => !!e && typeof e == "object" && typeof e.removeListener == "function" && typeof e.emit == "function" && typeof e.
reallyExit == "function" && typeof e.listeners == "function" && typeof e.kill == "function" && typeof e.pid == "number" && typeof e.on == "f\
unction", "processOk"), Ay = Symbol.for("signal-exit emitter"), Fy = globalThis, kY = Object.defineProperty.bind(Object), _y = class {
  static {
    s(this, "Emitter");
  }
  emitted = {
    afterExit: !1,
    exit: !1
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (Fy[Ay])
      return Fy[Ay];
    kY(Fy, Ay, {
      value: this,
      writable: !1,
      enumerable: !1,
      configurable: !1
    });
  }
  on(t, r) {
    this.listeners[t].push(r);
  }
  removeListener(t, r) {
    let n = this.listeners[t], i = n.indexOf(r);
    i !== -1 && (i === 0 && n.length === 1 ? n.length = 0 : n.splice(i, 1));
  }
  emit(t, r, n) {
    if (this.emitted[t])
      return !1;
    this.emitted[t] = !0;
    let i = !1;
    for (let o of this.listeners[t])
      i = o(r, n) === !0 || i;
    return t === "exit" && (i = this.emit("afterExit", r, n) || i), i;
  }
}, sp = class {
  static {
    s(this, "SignalExitBase");
  }
}, TY = /* @__PURE__ */ s((e) => ({
  onExit(t, r) {
    return e.onExit(t, r);
  },
  load() {
    return e.load();
  },
  unload() {
    return e.unload();
  }
}), "signalExitWrap"), ky = class extends sp {
  static {
    s(this, "SignalExitFallback");
  }
  onExit() {
    return () => {
    };
  }
  load() {
  }
  unload() {
  }
}, Ty = class extends sp {
  static {
    s(this, "SignalExit");
  }
  // "SIGHUP" throws an `ENOSYS` error on Windows,
  // so use a supported signal instead
  /* c8 ignore start */
  #t = Iy.platform === "win32" ? "SIGINT" : "SIGHUP";
  /* c8 ignore stop */
  #r = new _y();
  #e;
  #n;
  #o;
  #s = {};
  #i = !1;
  constructor(t) {
    super(), this.#e = t, this.#s = {};
    for (let r of us)
      this.#s[r] = () => {
        let n = this.#e.listeners(r), { count: i } = this.#r, o = t;
        if (typeof o.__signal_exit_emitter__ == "object" && typeof o.__signal_exit_emitter__.count == "number" && (i += o.__signal_exit_emitter__.
        count), n.length === i) {
          this.unload();
          let a = this.#r.emit("exit", null, r), u = r === "SIGHUP" ? this.#t : r;
          a || t.kill(t.pid, u);
        }
      };
    this.#o = t.reallyExit, this.#n = t.emit;
  }
  onExit(t, r) {
    if (!ip(this.#e))
      return () => {
      };
    this.#i === !1 && this.load();
    let n = r?.alwaysLast ? "afterExit" : "exit";
    return this.#r.on(n, t), () => {
      this.#r.removeListener(n, t), this.#r.listeners.exit.length === 0 && this.#r.listeners.afterExit.length === 0 && this.unload();
    };
  }
  load() {
    if (!this.#i) {
      this.#i = !0, this.#r.count += 1;
      for (let t of us)
        try {
          let r = this.#s[t];
          r && this.#e.on(t, r);
        } catch {
        }
      this.#e.emit = (t, ...r) => this.#u(t, ...r), this.#e.reallyExit = (t) => this.#a(t);
    }
  }
  unload() {
    this.#i && (this.#i = !1, us.forEach((t) => {
      let r = this.#s[t];
      if (!r)
        throw new Error("Listener not defined for signal: " + t);
      try {
        this.#e.removeListener(t, r);
      } catch {
      }
    }), this.#e.emit = this.#n, this.#e.reallyExit = this.#o, this.#r.count -= 1);
  }
  #a(t) {
    return ip(this.#e) ? (this.#e.exitCode = t || 0, this.#r.emit("exit", this.#e.exitCode, null), this.#o.call(this.#e, this.#e.exitCode)) :
    0;
  }
  #u(t, ...r) {
    let n = this.#n;
    if (t === "exit" && ip(this.#e)) {
      typeof r[0] == "number" && (this.#e.exitCode = r[0]);
      let i = n.call(this.#e, t, ...r);
      return this.#r.emit("exit", this.#e.exitCode, null), i;
    } else
      return n.call(this.#e, t, ...r);
  }
}, Iy = globalThis.process, {
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  onExit: II,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  load: vge,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  unload: Ege
} = TY(ip(Iy) ? new Ty(Iy) : new ky());

// node_modules/execa/lib/kill.js
var IY = 1e3 * 5, BI = /* @__PURE__ */ s((e, t = "SIGTERM", r = {}) => {
  let n = e(t);
  return PY(e, t, r, n), n;
}, "spawnedKill"), PY = /* @__PURE__ */ s((e, t, r, n) => {
  if (!BY(t, r, n))
    return;
  let i = RY(r), o = setTimeout(() => {
    e("SIGKILL");
  }, i);
  o.unref && o.unref();
}, "setKillTimeout"), BY = /* @__PURE__ */ s((e, { forceKillAfterTimeout: t }, r) => OY(e) && t !== !1 && r, "shouldForceKill"), OY = /* @__PURE__ */ s(
(e) => e === PI.default.constants.signals.SIGTERM || typeof e == "string" && e.toUpperCase() === "SIGTERM", "isSigterm"), RY = /* @__PURE__ */ s(
({ forceKillAfterTimeout: e = !0 }) => {
  if (e === !0)
    return IY;
  if (!Number.isFinite(e) || e < 0)
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);
  return e;
}, "getForceKillAfterTimeout"), OI = /* @__PURE__ */ s((e, t) => {
  e.kill() && (t.isCanceled = !0);
}, "spawnedCancel"), NY = /* @__PURE__ */ s((e, t, r) => {
  e.kill(t), r(Object.assign(new Error("Timed out"), { timedOut: !0, signal: t }));
}, "timeoutKill"), RI = /* @__PURE__ */ s((e, { timeout: t, killSignal: r = "SIGTERM" }, n) => {
  if (t === 0 || t === void 0)
    return n;
  let i, o = new Promise((u, l) => {
    i = setTimeout(() => {
      NY(e, r, l);
    }, t);
  }), a = n.finally(() => {
    clearTimeout(i);
  });
  return Promise.race([o, a]);
}, "setupTimeout"), NI = /* @__PURE__ */ s(({ timeout: e }) => {
  if (e !== void 0 && (!Number.isFinite(e) || e < 0))
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);
}, "validateTimeout"), LI = /* @__PURE__ */ s(async (e, { cleanup: t, detached: r }, n) => {
  if (!t || r)
    return n;
  let i = II(() => {
    e.kill();
  });
  return n.finally(() => {
    i();
  });
}, "setExitHandler");

// node_modules/execa/lib/pipe.js
var jI = require("node:fs"), MI = require("node:child_process");

// node_modules/is-stream/index.js
function op(e) {
  return e !== null && typeof e == "object" && typeof e.pipe == "function";
}
s(op, "isStream");
function Py(e) {
  return op(e) && e.writable !== !1 && typeof e._write == "function" && typeof e._writableState == "object";
}
s(Py, "isWritableStream");

// node_modules/execa/lib/pipe.js
var LY = /* @__PURE__ */ s((e) => e instanceof MI.ChildProcess && typeof e.then == "function", "isExecaChildProcess"), By = /* @__PURE__ */ s(
(e, t, r) => {
  if (typeof r == "string")
    return e[t].pipe((0, jI.createWriteStream)(r)), e;
  if (Py(r))
    return e[t].pipe(r), e;
  if (!LY(r))
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  if (!Py(r.stdin))
    throw new TypeError("The target child process's stdin must be available.");
  return e[t].pipe(r.stdin), r;
}, "pipeToTarget"), qI = /* @__PURE__ */ s((e) => {
  e.stdout !== null && (e.pipeStdout = By.bind(void 0, e, "stdout")), e.stderr !== null && (e.pipeStderr = By.bind(void 0, e, "stderr")), e.
  all !== void 0 && (e.pipeAll = By.bind(void 0, e, "all"));
}, "addPipeMethods");

// node_modules/execa/lib/stream.js
var hp = require("node:fs"), YI = require("node:timers/promises");

// node_modules/get-stream/source/contents.js
var Qa = /* @__PURE__ */ s(async (e, { init: t, convertChunk: r, getSize: n, truncateChunk: i, addChunk: o, getFinalChunk: a, finalize: u }, {
maxBuffer: l = Number.POSITIVE_INFINITY } = {}) => {
  if (!MY(e))
    throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
  let c = t();
  c.length = 0;
  try {
    for await (let p of e) {
      let h = qY(p), f = r[h](p, c);
      UI({ convertedChunk: f, state: c, getSize: n, truncateChunk: i, addChunk: o, maxBuffer: l });
    }
    return jY({ state: c, convertChunk: r, getSize: n, truncateChunk: i, addChunk: o, getFinalChunk: a, maxBuffer: l }), u(c);
  } catch (p) {
    throw p.bufferedData = u(c), p;
  }
}, "getStreamContents"), jY = /* @__PURE__ */ s(({ state: e, getSize: t, truncateChunk: r, addChunk: n, getFinalChunk: i, maxBuffer: o }) => {
  let a = i(e);
  a !== void 0 && UI({ convertedChunk: a, state: e, getSize: t, truncateChunk: r, addChunk: n, maxBuffer: o });
}, "appendFinalChunk"), UI = /* @__PURE__ */ s(({ convertedChunk: e, state: t, getSize: r, truncateChunk: n, addChunk: i, maxBuffer: o }) => {
  let a = r(e), u = t.length + a;
  if (u <= o) {
    $I(e, t, i, u);
    return;
  }
  let l = n(e, o - t.length);
  throw l !== void 0 && $I(l, t, i, o), new ap();
}, "appendChunk"), $I = /* @__PURE__ */ s((e, t, r, n) => {
  t.contents = r(e, t, n), t.length = n;
}, "addNewChunk"), MY = /* @__PURE__ */ s((e) => typeof e == "object" && e !== null && typeof e[Symbol.asyncIterator] == "function", "isAsyn\
cIterable"), qY = /* @__PURE__ */ s((e) => {
  let t = typeof e;
  if (t === "string")
    return "string";
  if (t !== "object" || e === null)
    return "others";
  if (globalThis.Buffer?.isBuffer(e))
    return "buffer";
  let r = VI.call(e);
  return r === "[object ArrayBuffer]" ? "arrayBuffer" : r === "[object DataView]" ? "dataView" : Number.isInteger(e.byteLength) && Number.isInteger(
  e.byteOffset) && VI.call(e.buffer) === "[object ArrayBuffer]" ? "typedArray" : "others";
}, "getChunkType"), { toString: VI } = Object.prototype, ap = class extends Error {
  static {
    s(this, "MaxBufferError");
  }
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
};

// node_modules/get-stream/source/utils.js
var Oy = /* @__PURE__ */ s((e) => e, "identity"), Ry = /* @__PURE__ */ s(() => {
}, "noop"), Ny = /* @__PURE__ */ s(({ contents: e }) => e, "getContentsProp"), up = /* @__PURE__ */ s((e) => {
  throw new Error(`Streams in object mode are not supported: ${String(e)}`);
}, "throwObjectStream"), lp = /* @__PURE__ */ s((e) => e.length, "getLengthProp");

// node_modules/get-stream/source/array-buffer.js
async function Ly(e, t) {
  return Qa(e, ZY, t);
}
s(Ly, "getStreamAsArrayBuffer");
var $Y = /* @__PURE__ */ s(() => ({ contents: new ArrayBuffer(0) }), "initArrayBuffer"), VY = /* @__PURE__ */ s((e) => UY.encode(e), "useTex\
tEncoder"), UY = new TextEncoder(), WI = /* @__PURE__ */ s((e) => new Uint8Array(e), "useUint8Array"), zI = /* @__PURE__ */ s((e) => new Uint8Array(
e.buffer, e.byteOffset, e.byteLength), "useUint8ArrayWithOffset"), WY = /* @__PURE__ */ s((e, t) => e.slice(0, t), "truncateArrayBufferChunk"),
zY = /* @__PURE__ */ s((e, { contents: t, length: r }, n) => {
  let i = JI() ? GY(t, n) : HY(t, n);
  return new Uint8Array(i).set(e, r), i;
}, "addArrayBufferChunk"), HY = /* @__PURE__ */ s((e, t) => {
  if (t <= e.byteLength)
    return e;
  let r = new ArrayBuffer(GI(t));
  return new Uint8Array(r).set(new Uint8Array(e), 0), r;
}, "resizeArrayBufferSlow"), GY = /* @__PURE__ */ s((e, t) => {
  if (t <= e.maxByteLength)
    return e.resize(t), e;
  let r = new ArrayBuffer(t, { maxByteLength: GI(t) });
  return new Uint8Array(r).set(new Uint8Array(e), 0), r;
}, "resizeArrayBuffer"), GI = /* @__PURE__ */ s((e) => HI ** Math.ceil(Math.log(e) / Math.log(HI)), "getNewContentsLength"), HI = 2, JY = /* @__PURE__ */ s(
({ contents: e, length: t }) => JI() ? e : e.slice(0, t), "finalizeArrayBuffer"), JI = /* @__PURE__ */ s(() => "resize" in ArrayBuffer.prototype,
"hasArrayBufferResize"), ZY = {
  init: $Y,
  convertChunk: {
    string: VY,
    buffer: WI,
    arrayBuffer: WI,
    dataView: zI,
    typedArray: zI,
    others: up
  },
  getSize: lp,
  truncateChunk: WY,
  addChunk: zY,
  getFinalChunk: Ry,
  finalize: JY
};

// node_modules/get-stream/source/buffer.js
async function cp(e, t) {
  if (!("Buffer" in globalThis))
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  try {
    return ZI(await Ly(e, t));
  } catch (r) {
    throw r.bufferedData !== void 0 && (r.bufferedData = ZI(r.bufferedData)), r;
  }
}
s(cp, "getStreamAsBuffer");
var ZI = /* @__PURE__ */ s((e) => globalThis.Buffer.from(e), "arrayBufferToNodeBuffer");

// node_modules/get-stream/source/string.js
async function jy(e, t) {
  return Qa(e, eQ, t);
}
s(jy, "getStreamAsString");
var XY = /* @__PURE__ */ s(() => ({ contents: "", textDecoder: new TextDecoder() }), "initString"), pp = /* @__PURE__ */ s((e, { textDecoder: t }) => t.
decode(e, { stream: !0 }), "useTextDecoder"), KY = /* @__PURE__ */ s((e, { contents: t }) => t + e, "addStringChunk"), YY = /* @__PURE__ */ s(
(e, t) => e.slice(0, t), "truncateStringChunk"), QY = /* @__PURE__ */ s(({ textDecoder: e }) => {
  let t = e.decode();
  return t === "" ? void 0 : t;
}, "getFinalStringChunk"), eQ = {
  init: XY,
  convertChunk: {
    string: Oy,
    buffer: pp,
    arrayBuffer: pp,
    dataView: pp,
    typedArray: pp,
    others: up
  },
  getSize: lp,
  truncateChunk: YY,
  addChunk: KY,
  getFinalChunk: QY,
  finalize: Ny
};

// node_modules/execa/lib/stream.js
var QI = J(KI(), 1);
var eP = /* @__PURE__ */ s((e) => {
  if (e !== void 0)
    throw new TypeError("The `input` and `inputFile` options cannot be both set.");
}, "validateInputOptions"), rQ = /* @__PURE__ */ s(({ input: e, inputFile: t }) => typeof t != "string" ? e : (eP(e), (0, hp.readFileSync)(t)),
"getInputSync"), tP = /* @__PURE__ */ s((e) => {
  let t = rQ(e);
  if (op(t))
    throw new TypeError("The `input` option cannot be a stream in sync mode");
  return t;
}, "handleInputSync"), nQ = /* @__PURE__ */ s(({ input: e, inputFile: t }) => typeof t != "string" ? e : (eP(e), (0, hp.createReadStream)(t)),
"getInput"), rP = /* @__PURE__ */ s((e, t) => {
  let r = nQ(t);
  r !== void 0 && (op(r) ? r.pipe(e.stdin) : e.stdin.end(r));
}, "handleInput"), nP = /* @__PURE__ */ s((e, { all: t }) => {
  if (!t || !e.stdout && !e.stderr)
    return;
  let r = (0, QI.default)();
  return e.stdout && r.add(e.stdout), e.stderr && r.add(e.stderr), r;
}, "makeAllStream"), My = /* @__PURE__ */ s(async (e, t) => {
  if (!(!e || t === void 0)) {
    await (0, YI.setTimeout)(0), e.destroy();
    try {
      return await t;
    } catch (r) {
      return r.bufferedData;
    }
  }
}, "getBufferedData"), qy = /* @__PURE__ */ s((e, { encoding: t, buffer: r, maxBuffer: n }) => {
  if (!(!e || !r))
    return t === "utf8" || t === "utf-8" ? jy(e, { maxBuffer: n }) : t === null || t === "buffer" ? cp(e, { maxBuffer: n }) : iQ(e, n, t);
}, "getStreamPromise"), iQ = /* @__PURE__ */ s(async (e, t, r) => (await cp(e, { maxBuffer: t })).toString(r), "applyEncoding"), iP = /* @__PURE__ */ s(
async ({ stdout: e, stderr: t, all: r }, { encoding: n, buffer: i, maxBuffer: o }, a) => {
  let u = qy(e, { encoding: n, buffer: i, maxBuffer: o }), l = qy(t, { encoding: n, buffer: i, maxBuffer: o }), c = qy(r, { encoding: n, buffer: i,
  maxBuffer: o * 2 });
  try {
    return await Promise.all([a, u, l, c]);
  } catch (p) {
    return Promise.all([
      { error: p, signal: p.signal, timedOut: p.timedOut },
      My(e, u),
      My(t, l),
      My(r, c)
    ]);
  }
}, "getSpawnedResult");

// node_modules/execa/lib/promise.js
var sQ = (async () => {
})().constructor.prototype, oQ = ["then", "catch", "finally"].map((e) => [
  e,
  Reflect.getOwnPropertyDescriptor(sQ, e)
]), $y = /* @__PURE__ */ s((e, t) => {
  for (let [r, n] of oQ) {
    let i = typeof t == "function" ? (...o) => Reflect.apply(n.value, t(), o) : n.value.bind(t);
    Reflect.defineProperty(e, r, { ...n, value: i });
  }
}, "mergePromise"), sP = /* @__PURE__ */ s((e) => new Promise((t, r) => {
  e.on("exit", (n, i) => {
    t({ exitCode: n, signal: i });
  }), e.on("error", (n) => {
    r(n);
  }), e.stdin && e.stdin.on("error", (n) => {
    r(n);
  });
}), "getSpawnedPromise");

// node_modules/execa/lib/command.js
var uP = require("node:buffer"), lP = require("node:child_process");
var cP = /* @__PURE__ */ s((e, t = []) => Array.isArray(t) ? [e, ...t] : [e], "normalizeArgs"), aQ = /^[\w.-]+$/, uQ = /* @__PURE__ */ s((e) => typeof e !=
"string" || aQ.test(e) ? e : `"${e.replaceAll('"', '\\"')}"`, "escapeArg"), Vy = /* @__PURE__ */ s((e, t) => cP(e, t).join(" "), "joinComman\
d"), Uy = /* @__PURE__ */ s((e, t) => cP(e, t).map((r) => uQ(r)).join(" "), "getEscapedCommand"), pP = / +/g, hP = /* @__PURE__ */ s((e) => {
  let t = [];
  for (let r of e.trim().split(pP)) {
    let n = t.at(-1);
    n && n.endsWith("\\") ? t[t.length - 1] = `${n.slice(0, -1)} ${r}` : t.push(r);
  }
  return t;
}, "parseCommand"), oP = /* @__PURE__ */ s((e) => {
  let t = typeof e;
  if (t === "string")
    return e;
  if (t === "number")
    return String(e);
  if (t === "object" && e !== null && !(e instanceof lP.ChildProcess) && "stdout" in e) {
    let r = typeof e.stdout;
    if (r === "string")
      return e.stdout;
    if (uP.Buffer.isBuffer(e.stdout))
      return e.stdout.toString();
    throw new TypeError(`Unexpected "${r}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${t}" in template expression`);
}, "parseExpression"), aP = /* @__PURE__ */ s((e, t, r) => r || e.length === 0 || t.length === 0 ? [...e, ...t] : [
  ...e.slice(0, -1),
  `${e.at(-1)}${t[0]}`,
  ...t.slice(1)
], "concatTokens"), lQ = /* @__PURE__ */ s(({ templates: e, expressions: t, tokens: r, index: n, template: i }) => {
  let o = i ?? e.raw[n], a = o.split(pP).filter(Boolean), u = aP(
    r,
    a,
    o.startsWith(" ")
  );
  if (n === t.length)
    return u;
  let l = t[n], c = Array.isArray(l) ? l.map((p) => oP(p)) : [oP(l)];
  return aP(
    u,
    c,
    o.endsWith(" ")
  );
}, "parseTemplate"), Wy = /* @__PURE__ */ s((e, t) => {
  let r = [];
  for (let [n, i] of e.entries())
    r = lQ({ templates: e, expressions: t, tokens: r, index: n, template: i });
  return r;
}, "parseTemplates");

// node_modules/execa/lib/verbose.js
var fP = require("node:util"), dP = J(require("node:process"), 1);
var mP = (0, fP.debuglog)("execa").enabled, fp = /* @__PURE__ */ s((e, t) => String(e).padStart(t, "0"), "padField"), cQ = /* @__PURE__ */ s(
() => {
  let e = /* @__PURE__ */ new Date();
  return `${fp(e.getHours(), 2)}:${fp(e.getMinutes(), 2)}:${fp(e.getSeconds(), 2)}.${fp(e.getMilliseconds(), 3)}`;
}, "getTimestamp"), zy = /* @__PURE__ */ s((e, { verbose: t }) => {
  t && dP.default.stderr.write(`[${cQ()}] ${e}
`);
}, "logCommand");

// node_modules/execa/index.js
var pQ = 1e3 * 1e3 * 100, hQ = /* @__PURE__ */ s(({ env: e, extendEnv: t, preferLocal: r, localDir: n, execPath: i }) => {
  let o = t ? { ...eu.default.env, ...e } : e;
  return r ? bI({ env: o, cwd: n, execPath: i }) : o;
}, "getEnv"), bP = /* @__PURE__ */ s((e, t, r = {}) => {
  let n = xP.default._parse(e, t, r);
  return e = n.command, t = n.args, r = n.options, r = {
    maxBuffer: pQ,
    buffer: !0,
    stripFinalNewline: !0,
    extendEnv: !0,
    preferLocal: !1,
    localDir: r.cwd || eu.default.cwd(),
    execPath: eu.default.execPath,
    encoding: "utf8",
    reject: !0,
    cleanup: !0,
    all: !1,
    windowsHide: !0,
    verbose: mP,
    ...r
  }, r.env = hQ(r), r.stdio = TI(r), eu.default.platform === "win32" && DP.default.basename(e, ".exe") === "cmd" && t.unshift("/q"), { file: e,
  args: t, options: r, parsed: n };
}, "handleArguments"), tu = /* @__PURE__ */ s((e, t, r) => typeof t != "string" && !yP.Buffer.isBuffer(t) ? r === void 0 ? void 0 : "" : e.stripFinalNewline ?
vy(t) : t, "handleOutput");
function vP(e, t, r) {
  let n = bP(e, t, r), i = Vy(e, t), o = Uy(e, t);
  zy(o, n.options), NI(n.options);
  let a;
  try {
    a = dp.default.spawn(n.file, n.args, n.options);
  } catch (d) {
    let m = new dp.default.ChildProcess(), g = Promise.reject(Ya({
      error: d,
      stdout: "",
      stderr: "",
      all: "",
      command: i,
      escapedCommand: o,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    }));
    return $y(m, g), m;
  }
  let u = sP(a), l = RI(a, n.options, u), c = LI(a, n.options, l), p = { isCanceled: !1 };
  a.kill = BI.bind(null, a.kill.bind(a)), a.cancel = OI.bind(null, a, p);
  let f = EI(/* @__PURE__ */ s(async () => {
    let [{ error: d, exitCode: m, signal: g, timedOut: b }, y, E, A] = await iP(a, n.options, c), k = tu(n.options, y), O = tu(n.options, E),
    w = tu(n.options, A);
    if (d || m !== 0 || g !== null) {
      let C = Ya({
        error: d,
        exitCode: m,
        signal: g,
        stdout: k,
        stderr: O,
        all: w,
        command: i,
        escapedCommand: o,
        parsed: n,
        timedOut: b,
        isCanceled: p.isCanceled || (n.options.signal ? n.options.signal.aborted : !1),
        killed: a.killed
      });
      if (!n.options.reject)
        return C;
      throw C;
    }
    return {
      command: i,
      escapedCommand: o,
      exitCode: 0,
      stdout: k,
      stderr: O,
      all: w,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  }, "handlePromise"));
  return rP(a, n.options), a.all = nP(a, n.options), qI(a), $y(a, f), a;
}
s(vP, "execa");
function fQ(e, t, r) {
  let n = bP(e, t, r), i = Vy(e, t), o = Uy(e, t);
  zy(o, n.options);
  let a = tP(n.options), u;
  try {
    u = dp.default.spawnSync(n.file, n.args, { ...n.options, input: a });
  } catch (p) {
    throw Ya({
      error: p,
      stdout: "",
      stderr: "",
      all: "",
      command: i,
      escapedCommand: o,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    });
  }
  let l = tu(n.options, u.stdout, u.error), c = tu(n.options, u.stderr, u.error);
  if (u.error || u.status !== 0 || u.signal !== null) {
    let p = Ya({
      stdout: l,
      stderr: c,
      error: u.error,
      signal: u.signal,
      exitCode: u.status,
      command: i,
      escapedCommand: o,
      parsed: n,
      timedOut: u.error && u.error.code === "ETIMEDOUT",
      isCanceled: !1,
      killed: u.signal !== null
    });
    if (!n.options.reject)
      return p;
    throw p;
  }
  return {
    command: i,
    escapedCommand: o,
    exitCode: 0,
    stdout: l,
    stderr: c,
    failed: !1,
    timedOut: !1,
    isCanceled: !1,
    killed: !1
  };
}
s(fQ, "execaSync");
var dQ = /* @__PURE__ */ s(({ input: e, inputFile: t, stdio: r }) => e === void 0 && t === void 0 && r === void 0 ? { stdin: "inherit" } : {},
"normalizeScriptStdin"), gP = /* @__PURE__ */ s((e = {}) => ({
  preferLocal: !0,
  ...dQ(e),
  ...e
}), "normalizeScriptOptions");
function EP(e) {
  function t(r, ...n) {
    if (!Array.isArray(r))
      return EP({ ...e, ...r });
    let [i, ...o] = Wy(r, n);
    return vP(i, o, gP(e));
  }
  return s(t, "$"), t.sync = (r, ...n) => {
    if (!Array.isArray(r))
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    let [i, ...o] = Wy(r, n);
    return fQ(i, o, gP(e));
  }, t;
}
s(EP, "create$");
var k0e = EP();
function ru(e, t) {
  let [r, ...n] = hP(e);
  return vP(r, n, t);
}
s(ru, "execaCommand");

// src/telemetry/exec-command-count-lines.ts
async function mp(e, t) {
  let r = ru(e, { shell: !0, buffer: !1, ...t });
  if (!r.stdout)
    throw new Error("Unexpected missing stdout");
  let n = 0, i = (0, CP.createInterface)(r.stdout);
  return i.on("line", () => {
    n += 1;
  }), await r, i.close(), n;
}
s(mp, "execCommandCountLines");

// src/common/utils/file-cache.ts
var nu = require("node:crypto"), rr = require("node:fs"), Hr = require("node:fs/promises"), wP = require("node:os"), Co = require("node:path");
var gp = class {
  static {
    s(this, "FileSystemCache");
  }
  constructor(t = {}) {
    this.prefix = (t.ns || t.prefix || "") + "-", this.hash_alg = t.hash_alg || "sha256", this.cache_dir = t.basePath || (0, Co.join)((0, wP.tmpdir)(),
    (0, nu.randomBytes)(15).toString("base64").replace(/\//g, "-")), this.ttl = t.ttl || 0, (0, nu.createHash)(this.hash_alg), (0, rr.mkdirSync)(
    this.cache_dir, { recursive: !0 });
  }
  generateHash(t) {
    return (0, Co.join)(this.cache_dir, this.prefix + (0, nu.createHash)(this.hash_alg).update(t).digest("hex"));
  }
  isExpired(t, r) {
    return t.ttl != null && r > t.ttl;
  }
  parseCacheData(t, r) {
    let n = JSON.parse(t);
    return this.isExpired(n, Date.now()) ? r : n.content;
  }
  parseSetData(t, r, n = {}) {
    let i = n.ttl ?? this.ttl;
    return JSON.stringify({ key: t, content: r, ...i && { ttl: Date.now() + i * 1e3 } });
  }
  async get(t, r) {
    try {
      let n = await (0, Hr.readFile)(this.generateHash(t), "utf8");
      return this.parseCacheData(n, r);
    } catch {
      return r;
    }
  }
  getSync(t, r) {
    try {
      let n = (0, rr.readFileSync)(this.generateHash(t), "utf8");
      return this.parseCacheData(n, r);
    } catch {
      return r;
    }
  }
  async set(t, r, n = {}) {
    let i = typeof n == "number" ? { ttl: n } : n;
    (0, rr.mkdirSync)(this.cache_dir, { recursive: !0 }), await (0, Hr.writeFile)(this.generateHash(t), this.parseSetData(t, r, i), {
      encoding: i.encoding || "utf8"
    });
  }
  setSync(t, r, n = {}) {
    let i = typeof n == "number" ? { ttl: n } : n;
    (0, rr.mkdirSync)(this.cache_dir, { recursive: !0 }), (0, rr.writeFileSync)(this.generateHash(t), this.parseSetData(t, r, i), {
      encoding: i.encoding || "utf8"
    });
  }
  async setMany(t, r) {
    await Promise.all(t.map((n) => this.set(n.key, n.content ?? n.value, r)));
  }
  setManySync(t, r) {
    t.forEach((n) => this.setSync(n.key, n.content ?? n.value, r));
  }
  async remove(t) {
    await (0, Hr.rm)(this.generateHash(t), { force: !0 });
  }
  removeSync(t) {
    (0, rr.rmSync)(this.generateHash(t), { force: !0 });
  }
  async clear() {
    let t = await (0, Hr.readdir)(this.cache_dir);
    await Promise.all(
      t.filter((r) => r.startsWith(this.prefix)).map((r) => (0, Hr.rm)((0, Co.join)(this.cache_dir, r), { force: !0 }))
    );
  }
  clearSync() {
    (0, rr.readdirSync)(this.cache_dir).filter((t) => t.startsWith(this.prefix)).forEach((t) => (0, rr.rmSync)((0, Co.join)(this.cache_dir, t),
    { force: !0 }));
  }
  async getAll() {
    let t = Date.now(), r = await (0, Hr.readdir)(this.cache_dir);
    return (await Promise.all(
      r.filter((i) => i.startsWith(this.prefix)).map((i) => (0, Hr.readFile)((0, Co.join)(this.cache_dir, i), "utf8"))
    )).map((i) => JSON.parse(i)).filter((i) => i.content && !this.isExpired(i, t));
  }
  async load() {
    return {
      files: (await this.getAll()).map((r) => ({
        path: this.generateHash(r.key),
        value: r.content,
        key: r.key
      }))
    };
  }
};
function Hy(e) {
  return new gp(e);
}
s(Hy, "createFileSystemCache");

// src/common/utils/resolve-path-in-sb-cache.ts
var Zy = require("node:path");

// node_modules/find-cache-dir/index.js
var OP = J(require("node:process"), 1), wo = J(require("node:path"), 1), su = J(require("node:fs"), 1), RP = J(AP(), 1);

// ../node_modules/pkg-dir/index.js
var TP = J(require("node:path"), 1);

// ../node_modules/pkg-dir/node_modules/find-up/index.js
var iu = J(require("node:path"), 1), _P = require("node:url");

// ../node_modules/pkg-dir/node_modules/path-exists/index.js
var FP = J(require("node:fs"), 1);

// ../node_modules/pkg-dir/node_modules/find-up/index.js
var yQ = /* @__PURE__ */ s((e) => e instanceof URL ? (0, _P.fileURLToPath)(e) : e, "toPath"), DQ = Symbol("findUpStop");
function xQ(e, t = {}) {
  let r = iu.default.resolve(yQ(t.cwd) || ""), { root: n } = iu.default.parse(r), i = t.stopAt || n, o = t.limit || Number.POSITIVE_INFINITY,
  a = [e].flat(), u = /* @__PURE__ */ s((c) => {
    if (typeof e != "function")
      return xs(a, c);
    let p = e(c.cwd);
    return typeof p == "string" ? xs([p], c) : p;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = u({ ...t, cwd: r });
    if (c === DQ || (c && l.push(iu.default.resolve(r, c)), r === i || l.length >= o))
      break;
    r = iu.default.dirname(r);
  }
  return l;
}
s(xQ, "findUpMultipleSync");
function kP(e, t = {}) {
  return xQ(e, { ...t, limit: 1 })[0];
}
s(kP, "findUpSync");

// ../node_modules/pkg-dir/index.js
function IP({ cwd: e } = {}) {
  let t = kP("package.json", { cwd: e });
  return t && TP.default.dirname(t);
}
s(IP, "packageDirectorySync");

// node_modules/find-cache-dir/index.js
var { env: Gy, cwd: bQ } = OP.default, PP = /* @__PURE__ */ s((e) => {
  try {
    return su.default.accessSync(e, su.default.constants.W_OK), !0;
  } catch {
    return !1;
  }
}, "isWritable");
function BP(e, t) {
  return t.create && su.default.mkdirSync(e, { recursive: !0 }), e;
}
s(BP, "useDirectory");
function vQ(e) {
  let t = wo.default.join(e, "node_modules");
  if (!(!PP(t) && (su.default.existsSync(t) || !PP(wo.default.join(e)))))
    return t;
}
s(vQ, "getNodeModuleDirectory");
function Jy(e = {}) {
  if (Gy.CACHE_DIR && !["true", "false", "1", "0"].includes(Gy.CACHE_DIR))
    return BP(wo.default.join(Gy.CACHE_DIR, e.name), e);
  let { cwd: t = bQ(), files: r } = e;
  if (r) {
    if (!Array.isArray(r))
      throw new TypeError(`Expected \`files\` option to be an array, got \`${typeof r}\`.`);
    t = (0, RP.default)(r.map((i) => wo.default.resolve(t, i)));
  }
  if (t = IP({ cwd: t }), !(!t || !vQ(t)))
    return BP(wo.default.join(t, "node_modules", ".cache", e.name), e);
}
s(Jy, "findCacheDirectory");

// src/common/utils/resolve-path-in-sb-cache.ts
function NP(e, t = "default") {
  let r = Jy({ name: "storybook" });
  return r ||= (0, Zy.join)(process.cwd(), "node_modules", ".cache", "storybook"), (0, Zy.join)(r, t, e);
}
s(NP, "resolvePathInStorybookCache");

// src/common/utils/paths.ts
var Gr = require("node:path");

// src/common/js-package-manager/constants.ts
var EQ = "package-lock.json", CQ = "pnpm-lock.yaml", wQ = "yarn.lock", SQ = "bun.lock", AQ = "bun.lockb", LP = [
  EQ,
  CQ,
  wQ,
  SQ,
  AQ
];

// src/common/utils/paths.ts
var Dn, yp = /* @__PURE__ */ s(() => {
  if (Dn)
    return Dn;
  if (process.env.STORYBOOK_PROJECT_ROOT)
    return process.env.STORYBOOK_PROJECT_ROOT;
  try {
    let e = Ho(".git", { type: "directory" }) || Ho(".svn", { type: "directory" }) || Ho(".hg", { type: "directory" });
    if (e)
      return Dn = (0, Gr.join)(e, ".."), Dn;
  } catch (e) {
    process.stdout.write(`
error searching for repository root: ${e}
`);
  }
  try {
    let e = Ho(LP, { type: "file" });
    if (e)
      return Dn = (0, Gr.join)(e, ".."), Dn;
  } catch (e) {
    process.stdout.write(`
error searching for lock file: ${e}
`);
  }
  try {
    let [e, t] = __dirname.split(`${Gr.sep}node_modules${Gr.sep}`, 2);
    if (t && !e.includes(`${Gr.sep}npm-cache${Gr.sep}`) && !(0, Gr.relative)(e, process.cwd()).startsWith(".."))
      return Dn = e, Dn;
  } catch (e) {
    process.stdout.write(`
error searching for splitDirname: ${e}
`);
  }
  return Dn = process.cwd(), Dn;
}, "getProjectRoot");

// src/common/utils/envs.ts
var Dp = /* @__PURE__ */ s((e) => {
  if (e !== void 0)
    return e.toUpperCase() === "FALSE" || e === "0" ? !1 : e.toUpperCase() === "TRUE" || e === "1" ? !0 : !!e;
}, "optionalEnvToBoolean");

// src/telemetry/run-telemetry-operation.ts
var jP = Hy({
  basePath: NP("telemetry"),
  ns: "storybook",
  ttl: 24 * 60 * 60 * 1e3
  // 24h
}), xp = /* @__PURE__ */ s(async (e, t) => {
  let r = await jP.get(e);
  return r === void 0 && (r = await t(), r !== void 0 && await jP.set(e, r)), r;
}, "runTelemetryOperation");

// src/telemetry/get-application-file-count.ts
var FQ = ["page", "screen"], _Q = ["js", "jsx", "ts", "tsx"], kQ = /* @__PURE__ */ s(async (e) => {
  let r = FQ.flatMap((n) => [
    n,
    [n[0].toUpperCase(), ...n.slice(1)].join("")
  ]).flatMap(
    (n) => _Q.map((i) => `"${e}${MP.sep}*${n}*.${i}"`)
  );
  try {
    let n = `git ls-files -- ${r.join(" ")}`;
    return await mp(n);
  } catch {
    return;
  }
}, "getApplicationFilesCountUncached"), qP = /* @__PURE__ */ s(async (e) => xp(
  "applicationFiles",
  async () => kQ(e)
), "getApplicationFileCount");

// src/telemetry/get-chromatic-version.ts
function $P(e) {
  let t = e.dependencies?.chromatic || e.devDependencies?.chromatic || e.peerDependencies?.chromatic;
  return t || (e.scripts && Object.values(e.scripts).find((r) => r?.match(/chromatic/)) ? "latest" : void 0);
}
s($P, "getChromaticVersionSpecifier");

// src/telemetry/get-framework-info.ts
var zP = require("node:path"), HP = require("storybook/internal/common");

// src/telemetry/package-json.ts
var VP = require("node:fs/promises"), UP = require("node:path");
var Xy = /* @__PURE__ */ s(async (e) => {
  let t = Object.keys(e);
  return Promise.all(t.map(bp));
}, "getActualPackageVersions"), bp = /* @__PURE__ */ s(async (e) => {
  try {
    let t = await Ky(e);
    return {
      name: t?.name || e,
      version: t?.version || null
    };
  } catch {
    return {
      name: e,
      version: null
    };
  }
}, "getActualPackageVersion"), Ky = /* @__PURE__ */ s(async (e) => {
  try {
    let t = await Bu("package.json", { cwd: require.resolve(e) });
    return t || (t = require.resolve((0, UP.join)(e, "package.json"), {
      paths: [process.cwd()]
    })), JSON.parse(await (0, VP.readFile)(t, { encoding: "utf8" }));
  } catch {
    return;
  }
}, "getActualPackageJson");

// src/telemetry/get-framework-info.ts
var TQ = [
  "html",
  "react",
  "svelte",
  "vue3",
  "preact",
  "server",
  "vue",
  "web-components",
  "angular",
  "ember"
], IQ = ["builder-webpack5", "builder-vite"];
function WP(e, t) {
  let { name: r = "", version: n, dependencies: i, devDependencies: o, peerDependencies: a } = e, u = {
    // We include the framework itself because it may be a renderer too (e.g. angular)
    [r]: n,
    ...i,
    ...o,
    ...a
  };
  return t.map((l) => `@storybook/${l}`).find((l) => u[l]);
}
s(WP, "findMatchingPackage");
var PQ = /* @__PURE__ */ s((e) => {
  let t = (0, zP.normalize)(e).replace(new RegExp(/\\/, "g"), "/");
  return Object.keys(HP.frameworkPackages).find((n) => t.endsWith(n)) || Wa(e).replace(/.*node_modules[\\/]/, "");
}, "getFrameworkPackageName");
async function GP(e) {
  if (!e?.framework)
    return {};
  let t = typeof e.framework == "string" ? e.framework : e.framework?.name;
  if (!t)
    return {};
  let r = await Ky(t);
  if (!r)
    return {};
  let n = WP(r, IQ), i = WP(r, TQ), o = PQ(t), a = typeof e.framework == "object" ? e.framework.options : {};
  return {
    framework: {
      name: o,
      options: a
    },
    builder: n,
    renderer: i
  };
}
s(GP, "getFrameworkInfo");

// src/telemetry/get-has-router-package.ts
var BQ = /* @__PURE__ */ new Set([
  "react-router",
  "react-router-dom",
  "remix",
  "@tanstack/react-router",
  "expo-router",
  "@reach/router",
  "react-easy-router",
  "@remix-run/router",
  "wouter",
  "wouter-preact",
  "preact-router",
  "vue-router",
  "unplugin-vue-router",
  "@angular/router",
  "@solidjs/router",
  // metaframeworks that imply routing
  "next",
  "react-scripts",
  "gatsby",
  "nuxt",
  "@sveltejs/kit"
]);
function JP(e) {
  return Object.keys(e?.dependencies ?? {}).some(
    (t) => BQ.has(t)
  );
}
s(JP, "getHasRouterPackage");

// src/telemetry/get-monorepo-type.ts
var ou = require("node:fs"), vp = require("node:path"), Ep = require("storybook/internal/common");
var ZP = {
  Nx: "nx.json",
  Turborepo: "turbo.json",
  Lerna: "lerna.json",
  Rush: "rush.json",
  Lage: "lage.config.json"
}, XP = /* @__PURE__ */ s(() => {
  let t = Object.keys(ZP).find((n) => {
    let i = (0, vp.join)((0, Ep.getProjectRoot)(), ZP[n]);
    return (0, ou.existsSync)(i);
  });
  if (t)
    return t;
  if (!(0, ou.existsSync)((0, vp.join)((0, Ep.getProjectRoot)(), "package.json")))
    return;
  if (JSON.parse(
    (0, ou.readFileSync)((0, vp.join)((0, Ep.getProjectRoot)(), "package.json"), { encoding: "utf8" })
  )?.workspaces)
    return "Workspaces";
}, "getMonorepoType");

// ../node_modules/package-manager-detector/dist/constants.mjs
var KP = [
  "npm",
  "yarn",
  "yarn@berry",
  "pnpm",
  "pnpm@6",
  "bun",
  "deno"
], Yy = {
  "bun.lock": "bun",
  "bun.lockb": "bun",
  "deno.lock": "deno",
  "pnpm-lock.yaml": "pnpm",
  "pnpm-workspace.yaml": "pnpm",
  "yarn.lock": "yarn",
  "package-lock.json": "npm",
  "npm-shrinkwrap.json": "npm"
}, Qy = {
  "node_modules/.deno/": "deno",
  "node_modules/.pnpm/": "pnpm",
  "node_modules/.yarn-state.yml": "yarn",
  // yarn v2+ (node-modules)
  "node_modules/.yarn_integrity": "yarn",
  // yarn v1
  "node_modules/.package-lock.json": "npm",
  ".pnp.cjs": "yarn",
  // yarn v3+ (pnp)
  ".pnp.js": "yarn",
  // yarn v2 (pnp)
  "bun.lock": "bun",
  "bun.lockb": "bun"
};

// ../node_modules/package-manager-detector/dist/detect.mjs
var tD = J(require("node:fs/promises"), 1), Di = J(require("node:path"), 1), QP = J(require("node:process"), 1);
async function eD(e, t) {
  try {
    let r = await tD.default.stat(e);
    return t === "file" ? r.isFile() : r.isDirectory();
  } catch {
    return !1;
  }
}
s(eD, "pathExists");
function* OQ(e = QP.default.cwd()) {
  let t = Di.default.resolve(e), { root: r } = Di.default.parse(t);
  for (; t && t !== r; )
    yield t, t = Di.default.dirname(t);
}
s(OQ, "lookup");
async function YP(e, t) {
  return !e || !eD(e, "file") ? null : await NQ(e, t);
}
s(YP, "parsePackageJson");
async function rD(e = {}) {
  let { cwd: t, strategies: r = ["lockfile", "packageManager-field", "devEngines-field"], onUnknown: n } = e;
  for (let i of OQ(t))
    for (let o of r)
      switch (o) {
        case "lockfile": {
          for (let a of Object.keys(Yy))
            if (await eD(Di.default.join(i, a), "file")) {
              let u = Yy[a], l = await YP(Di.default.join(i, "package.json"), n);
              return l || { name: u, agent: u };
            }
          break;
        }
        case "packageManager-field":
        case "devEngines-field": {
          let a = await YP(Di.default.join(i, "package.json"), n);
          if (a)
            return a;
          break;
        }
        case "install-metadata": {
          for (let a of Object.keys(Qy)) {
            let u = a.endsWith("/") ? "dir" : "file";
            if (await eD(Di.default.join(i, a), u)) {
              let l = Qy[a], c = l === "yarn" ? LQ(a) ? "yarn" : "yarn@berry" : l;
              return { name: l, agent: c };
            }
          }
          break;
        }
      }
  return null;
}
s(rD, "detect");
function RQ(e) {
  let t = /* @__PURE__ */ s((r) => r?.match(/\d+(\.\d+){0,2}/)?.[0] ?? r, "handelVer");
  if (typeof e.packageManager == "string") {
    let [r, n] = e.packageManager.replace(/^\^/, "").split("@");
    return { name: r, ver: t(n) };
  }
  if (typeof e.devEngines?.packageManager?.name == "string")
    return {
      name: e.devEngines.packageManager.name,
      ver: t(e.devEngines.packageManager.version)
    };
}
s(RQ, "getNameAndVer");
async function NQ(e, t) {
  try {
    let r = JSON.parse(await tD.default.readFile(e, "utf8")), n, i = RQ(r);
    if (i) {
      let o = i.name, a = i.ver, u = a;
      return o === "yarn" && a && Number.parseInt(a) > 1 ? (n = "yarn@berry", u = "berry", { name: o, agent: n, version: u }) : o === "pnpm" &&
      a && Number.parseInt(a) < 7 ? (n = "pnpm@6", { name: o, agent: n, version: u }) : KP.includes(o) ? (n = o, { name: o, agent: n, version: u }) :
      t?.(r.packageManager) ?? null;
    }
  } catch {
  }
  return null;
}
s(NQ, "handlePackageManager");
function LQ(e) {
  return e.endsWith(".yarn_integrity");
}
s(LQ, "isMetadataYarnClassic");

// ../node_modules/package-manager-detector/dist/index.mjs
var ADe = require("node:fs/promises"), FDe = require("node:path"), _De = require("node:process");

// src/telemetry/get-package-manager-info.ts
var eB = /* @__PURE__ */ s(async () => {
  let e = await rD({ cwd: yp() });
  if (!e)
    return;
  let t = "node_modules";
  if (e.name === "yarn")
    try {
      let { stdout: r } = await ru("yarn config get nodeLinker", {
        cwd: yp()
      });
      t = r.trim();
    } catch {
    }
  if (e.name === "pnpm")
    try {
      let { stdout: r } = await ru("pnpm config get nodeLinker", {
        cwd: yp()
      });
      t = r.trim() ?? "isolated";
    } catch {
    }
  return {
    type: e.name,
    version: e.version,
    agent: e.agent,
    nodeLinker: t
  };
}, "getPackageManagerInfo");

// src/telemetry/get-portable-stories-usage.ts
var jQ = /* @__PURE__ */ s(async (e) => {
  try {
    let t = "git grep -l composeStor" + (e ? ` -- ${e}` : "");
    return await mp(t);
  } catch (t) {
    return t.exitCode === 1 ? 0 : void 0;
  }
}, "getPortableStoriesFileCountUncached"), tB = /* @__PURE__ */ s(async (e) => xp(
  "portableStories",
  async () => jQ(e)
), "getPortableStoriesFileCount");

// src/telemetry/storybook-metadata.ts
var rB = {
  next: "Next",
  "react-scripts": "CRA",
  gatsby: "Gatsby",
  "@nuxtjs/storybook": "nuxt",
  "@nrwl/storybook": "nx",
  "@vue/cli-service": "vue-cli",
  "@sveltejs/kit": "sveltekit"
}, nB = /* @__PURE__ */ s((e) => Wa(e).replace(/\/dist\/.*/, "").replace(/\.[mc]?[tj]?s[x]?$/, "").replace(/\/register$/, "").replace(/\/manager$/,
"").replace(/\/preset$/, ""), "sanitizeAddonName"), MQ = /* @__PURE__ */ s(async ({
  packageJsonPath: e,
  packageJson: t,
  mainConfig: r,
  configDir: n
}) => {
  let i = (0, xn.isCI)() ? void 0 : await IT(), o = {
    generatedAt: (/* @__PURE__ */ new Date()).getTime(),
    userSince: i?.value.userSince,
    hasCustomBabel: !1,
    hasCustomWebpack: !1,
    hasStaticDirs: !1,
    hasStorybookEslint: !1,
    refCount: 0
  }, a = {
    ...t?.dependencies,
    ...t?.devDependencies,
    ...t?.peerDependencies
  }, u = Object.keys(a).find((C) => !!rB[C]);
  if (u) {
    let { version: C } = await bp(u);
    o.metaFramework = {
      name: rB[u],
      packageName: u,
      version: C || "unknown"
    };
  }
  let l = [
    "playwright",
    "vitest",
    "jest",
    "cypress",
    "nightwatch",
    "webdriver",
    "@web/test-runner",
    "puppeteer",
    "karma",
    "jasmine",
    "chai",
    "testing-library",
    "@ngneat/spectator",
    "wdio",
    "msw",
    "miragejs",
    "sinon",
    "chromatic"
  ], c = Object.keys(a).filter(
    (C) => l.find((T) => C.includes(T))
  );
  o.testPackages = Object.fromEntries(
    await Promise.all(
      c.map(async (C) => [C, (await bp(C))?.version])
    )
  ), o.hasRouterPackage = JP(t);
  let p = XP();
  p && (o.monorepo = p), o.packageManager = await eB();
  let h = a.typescript ? "typescript" : "javascript";
  if (!r)
    return {
      ...o,
      storybookVersionSpecifier: xn.versions.storybook,
      language: h
    };
  o.hasCustomBabel = !!r.babel, o.hasCustomWebpack = !!r.webpackFinal, o.hasStaticDirs = !!r.staticDirs, typeof r.typescript == "object" && (o.
  typescriptOptions = r.typescript);
  let f = await GP(r);
  typeof r.refs == "object" && (o.refCount = Object.keys(r.refs).length), typeof r.features == "object" && (o.features = r.features);
  let d = {};
  r.addons && r.addons.forEach((C) => {
    let T, F;
    typeof C == "string" ? T = nB(C) : (C.name.includes("addon-essentials") && (F = C.options), T = nB(C.name)), d[T] = {
      options: F,
      version: void 0
    };
  });
  let m = $P(t);
  m && (d.chromatic = {
    version: void 0,
    versionSpecifier: m,
    options: void 0
  }), (await Xy(d)).forEach(({ name: C, version: T }) => {
    d[C] = d[C] || {
      name: C,
      version: T
    }, d[C].version = T || void 0;
  });
  let b = Object.keys(d), y = Object.keys(a).filter((C) => C.includes("storybook") && !b.includes(C)).reduce((C, T) => ({
    ...C,
    [T]: { version: void 0 }
  }), {});
  (await Xy(y)).forEach(({ name: C, version: T }) => {
    y[C] = y[C] || {
      name: C,
      version: T
    }, y[C].version = T || void 0;
  });
  let A = !!a["eslint-plugin-storybook"], k = (0, xn.getStorybookInfo)(n);
  try {
    let { previewConfigPath: C } = k;
    if (C) {
      let T = await (0, sB.readConfig)(C), F = !!(T.getFieldNode(["globals"]) || T.getFieldNode(["globalTypes"]));
      o.preview = { ...o.preview, usesGlobals: F };
    }
  } catch {
  }
  let O = await tB(), w = await qP((0, iB.dirname)(e));
  return {
    ...o,
    ...f,
    portableStoriesFileCount: O,
    applicationFileCount: w,
    storybookVersion: Vc,
    storybookVersionSpecifier: k.version,
    language: h,
    storybookPackages: y,
    addons: d,
    hasStorybookEslint: A
  };
}, "computeStorybookMetadata");
async function qQ() {
  let e = await ny(process.cwd());
  return e ? {
    packageJsonPath: e,
    packageJson: await nT(e) || {}
  } : {
    packageJsonPath: process.cwd(),
    packageJson: {}
  };
}
s(qQ, "getPackageJsonDetails");
var Cp, oB = /* @__PURE__ */ s(async (e) => {
  if (Cp)
    return Cp;
  let { packageJson: t, packageJsonPath: r } = await qQ(), n = (e || (0, xn.getStorybookConfiguration)(
    String(t?.scripts?.storybook || ""),
    "-c",
    "--config-dir"
  )) ?? ".storybook", i = await (0, xn.loadMainConfig)({ configDir: n }).catch(() => {
  });
  return Cp = await MQ({
    mainConfig: i,
    packageJson: t,
    packageJsonPath: r,
    configDir: n
  }), Cp;
}, "getStorybookMetadata");

// src/telemetry/telemetry.ts
var xB = J(require("node:os"), 1), bB = require("storybook/internal/common"), vB = J(uB(), 1);

// ../node_modules/nanoid/index.js
var nD = require("crypto");

// ../node_modules/nanoid/url-alphabet/index.js
var lB = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/nanoid/index.js
var $Q = 128, ls, So, VQ = /* @__PURE__ */ s((e) => {
  !ls || ls.length < e ? (ls = Buffer.allocUnsafe(e * $Q), (0, nD.randomFillSync)(ls), So = 0) : So + e > ls.length && ((0, nD.randomFillSync)(
  ls), So = 0), So += e;
}, "fillPool");
var au = /* @__PURE__ */ s((e = 21) => {
  VQ(e -= 0);
  let t = "";
  for (let r = So - e; r < So; r++)
    t += lB[ls[r] & 63];
  return t;
}, "nanoid");

// src/telemetry/anonymous-id.ts
var hB = require("node:path"), fB = require("storybook/internal/common"), dB = require("child_process");
_i();

// src/telemetry/one-way-hash.ts
var cB = require("crypto");
var pB = /* @__PURE__ */ s((e) => {
  let t = (0, cB.createHash)("sha256");
  return t.update("storybook-telemetry-salt"), t.update(e), t.digest("hex");
}, "oneWayHash");

// src/telemetry/anonymous-id.ts
function UQ(e) {
  let n = e.trim().replace(/#.*$/, "").replace(/^.*@/, "").replace(/^.*\/\//, "");
  return (n.endsWith(".git") ? n : `${n}.git`).replace(":", "/");
}
s(UQ, "normalizeGitUrl");
function WQ(e, t) {
  return `${UQ(e)}${it(t)}`;
}
s(WQ, "unhashedProjectId");
var Sp, mB = /* @__PURE__ */ s(() => {
  if (Sp)
    return Sp;
  try {
    let e = (0, hB.relative)((0, fB.getProjectRoot)(), process.cwd()), t = (0, dB.execSync)("git config --local --get remote.origin.url", {
      timeout: 1e3,
      stdio: "pipe"
    });
    Sp = pB(WQ(String(t), e));
  } catch {
  }
  return Sp;
}, "getAnonymousProjectId");

// src/telemetry/event-cache.ts
var sD = require("storybook/internal/common");
var iD = Promise.resolve(), zQ = /* @__PURE__ */ s(async (e, t) => {
  let r = await sD.cache.get("lastEvents") || {};
  r[e] = { body: t, timestamp: Date.now() }, await sD.cache.set("lastEvents", r);
}, "setHelper"), gB = /* @__PURE__ */ s(async (e, t) => (await iD, iD = zQ(e, t), iD), "set");

// src/telemetry/fetch.ts
var yB = global.fetch;

// src/telemetry/session-id.ts
var oD = require("storybook/internal/common");
var HQ = 1e3 * 60 * 60 * 2, uu;
var aD = /* @__PURE__ */ s(async () => {
  let e = Date.now();
  if (!uu) {
    let t = await oD.cache.get("session");
    t && t.lastUsed >= e - HQ ? uu = t.id : uu = au();
  }
  return await oD.cache.set("session", { id: uu, lastUsed: e }), uu;
}, "getSessionId");

// src/telemetry/telemetry.ts
var GQ = (0, vB.default)(yB), JQ = process.env.STORYBOOK_TELEMETRY_URL || "https://storybook.js.org/event-log", Ap = [];
var ZQ = /* @__PURE__ */ s(() => {
  try {
    let e = xB.platform();
    return e === "win32" ? "Windows" : e === "darwin" ? "macOS" : e === "linux" ? "Linux" : `Other: ${e}`;
  } catch {
    return "Unknown";
  }
}, "getOperatingSystem"), DB = {
  inCI: (0, bB.isCI)(),
  isTTY: process.stdout.isTTY,
  platform: ZQ(),
  nodeVersion: process.versions.node,
  storybookVersion: Vc
}, XQ = /* @__PURE__ */ s(async (e, t, r) => {
  let { eventType: n, payload: i, metadata: o, ...a } = e, u = await aD(), l = au(), c = { ...a, eventType: n, eventId: l, sessionId: u, metadata: o,
  payload: i, context: t };
  return GQ(JQ, {
    method: "post",
    body: JSON.stringify(c),
    headers: { "Content-Type": "application/json" },
    retries: 3,
    retryOn: [503, 504],
    retryDelay: /* @__PURE__ */ s((p) => 2 ** p * (typeof r?.retryDelay == "number" && !Number.isNaN(r?.retryDelay) ? r.retryDelay : 1e3), "\
retryDelay")
  });
}, "prepareRequest");
async function EB(e, t = { retryDelay: 1e3, immediate: !1 }) {
  let { eventType: r, payload: n, metadata: i, ...o } = e, a = t.stripMetadata ? DB : {
    ...DB,
    anonymousId: mB()
  }, u;
  try {
    u = XQ(e, a, t), Ap.push(u), t.immediate ? await Promise.all(Ap) : await u;
    let l = await aD(), c = au(), p = { ...o, eventType: r, eventId: c, sessionId: l, metadata: i, payload: n, context: a };
    await gB(r, p);
  } catch {
  } finally {
    Ap = Ap.filter((l) => l !== u);
  }
}
s(EB, "sendTelemetry");

// src/telemetry/index.ts
var CB = /* @__PURE__ */ s(async (e, t = {}, r = {}) => {
  e !== "boot" && r.notify !== !1 && await Zk();
  let n = {
    eventType: e,
    payload: t
  };
  try {
    r?.stripMetadata || (n.metadata = await oB(r?.configDir));
  } catch (i) {
    n.payload.metadataErrorMessage = Mc(i).message, r?.enableCrashReports && (n.payload.metadataError = Mc(i));
  } finally {
    let { error: i } = n.payload;
    i && (n.payload.error = Mc(i)), (!n.payload.error || r?.enableCrashReports) && (process.env?.STORYBOOK_TELEMETRY_DEBUG && (uD.logger.info(
    `
[telemetry]`), uD.logger.info(JSON.stringify(n, null, 2))), await EB(n, r));
  }
}, "telemetry");

// src/core-server/utils/doTelemetry.ts
var _p = require("storybook/internal/telemetry");

// src/core-server/withTelemetry.ts
var bn = require("storybook/internal/common"), wB = require("storybook/internal/node-logger"), bi = require("storybook/internal/telemetry"),
SB = J(J0(), 1);
var KQ = /* @__PURE__ */ s(async () => {
  if ((0, bn.isCI)() || !process.stdout.isTTY)
    return;
  let { enableCrashReports: e } = await (0, SB.default)({
    type: "confirm",
    name: "enableCrashReports",
    message: "Would you like to help improve Storybook by sending anonymous crash reports?",
    initial: !0
  });
  return await bn.cache.set("enableCrashReports", e), e;
}, "promptCrashReports");
async function AB({
  cliOptions: e,
  presetOptions: t,
  skipPrompt: r
}) {
  if (e.disableTelemetry)
    return "none";
  if (!t)
    return "full";
  let i = await (await (0, bn.loadAllPresets)(t)).apply("core");
  if (i?.enableCrashReports !== void 0)
    return i.enableCrashReports ? "full" : "error";
  if (i?.disableTelemetry)
    return "none";
  let o = await bn.cache.get("enableCrashReports") ?? await bn.cache.get("enableCrashreports");
  if (o !== void 0)
    return o ? "full" : "error";
  if (r)
    return "error";
  let a = await KQ();
  return a !== void 0 ? a ? "full" : "error" : "full";
}
s(AB, "getErrorLevel");
async function Fp(e, t, r) {
  try {
    let n = "error";
    try {
      n = await AB(r);
    } catch {
    }
    if (n !== "none") {
      let i = await (0, bi.getPrecedingUpgrade)(), o = e, a;
      "message" in o ? a = o.message ? (0, bi.oneWayHash)(o.message) : "EMPTY_MESSAGE" : a = "NO_MESSAGE";
      let { code: u, name: l, category: c } = o;
      await (0, bi.telemetry)(
        "error",
        {
          code: u,
          name: l,
          category: c,
          eventType: t,
          precedingUpgrade: i,
          error: n === "full" ? o : void 0,
          errorHash: a,
          // if we ever end up sending a non-error instance, we'd like to know
          isErrorInstance: o instanceof Error
        },
        {
          immediate: !0,
          configDir: r.cliOptions.configDir || r.presetOptions?.configDir,
          enableCrashReports: n === "full"
        }
      );
    }
  } catch {
  }
}
s(Fp, "sendTelemetryError");
async function YQ(e, t, r) {
  let n = !(t.cliOptions.disableTelemetry || t.cliOptions.test === !0), i = !1;
  async function o() {
    i = !0, n && await (0, bi.telemetry)("canceled", { eventType: e }, { stripMetadata: !0, immediate: !0 }), process.exit(0);
  }
  s(o, "cancelTelemetry"), e === "init" && process.on("SIGINT", o), n && (0, bi.telemetry)("boot", { eventType: e }, { stripMetadata: !0 });
  try {
    return await r();
  } catch (a) {
    if (i)
      return;
    if (!(a instanceof bn.HandledError)) {
      let { printError: u = wB.logger.error } = t;
      u(a);
    }
    throw n && await Fp(a, e, t), a;
  } finally {
    process.off("SIGINT", o);
  }
}
s(YQ, "withTelemetry");

// src/core-server/utils/versionStatus.ts
var FB = /* @__PURE__ */ s((e) => e.error ? "error" : e.cached ? "cached" : "success", "versionStatus");

// src/core-server/utils/doTelemetry.ts
async function _B(e, t, r, n) {
  t?.disableTelemetry || r.then(async (i) => {
    let o;
    try {
      o = await i?.getIndexAndStats();
    } catch (c) {
      if (!(c instanceof Error))
        throw new Error("encountered a non-recoverable error");
      Fp(c, "dev", {
        cliOptions: n,
        presetOptions: { ...n, corePresets: [], overridePresets: [] }
      });
      return;
    }
    let { versionCheck: a, versionUpdates: u } = n;
    Pt(
      !u || u && a,
      "versionCheck should be defined when versionUpdates is true"
    );
    let l = {
      precedingUpgrade: await (0, _p.getPrecedingUpgrade)()
    };
    o && Object.assign(l, {
      versionStatus: u && a ? FB(a) : "disabled",
      storyIndex: io(o.storyIndex),
      storyStats: o.stats
    }), (0, _p.telemetry)("dev", l, { configDir: n.configDir });
  }), t?.disableProjectJson || HS(e, n.configDir);
}
s(_B, "doTelemetry");

// src/core-server/utils/get-caching-middleware.ts
function kB() {
  return (e, t, r) => {
    t.setHeader("Cache-Control", "no-store"), r();
  };
}
s(kB, "getCachingMiddleware");

// src/core-server/utils/get-server-channel.ts
var Bp = require("storybook/internal/channels"), To = J(sO(), 1), pu = J(require("ws"), 1);

// src/shared/universal-store/index.ts
var cs = J(Bt(), 1);

// src/shared/universal-store/instances.ts
var bD = /* @__PURE__ */ new Map();

// src/shared/universal-store/index.ts
var nne = "UNIVERSAL_STORE:", Sr = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, kt = class e {
  constructor(t, r) {
    /** Enable debug logs for this store */
    this.debugging = !1;
    // TODO: narrow type of listeners based on event type
    this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]);
    /** Gets the current state */
    this.getState = /* @__PURE__ */ s(() => (this.debug("getState", { state: this.state }), this.state), "getState");
    /**
     * Subscribes to store events
     *
     * @returns A function to unsubscribe
     */
    this.subscribe = /* @__PURE__ */ s((t, r) => {
      let n = typeof t == "function", i = n ? "*" : t, o = n ? t : r;
      if (this.debug("subscribe", { eventType: i, listener: o }), !o)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(i) || this.listeners.set(i, /* @__PURE__ */ new Set()), this.listeners.get(i).add(o), () => {
        this.debug("unsubscribe", { eventType: i, listener: o }), this.listeners.has(i) && (this.listeners.get(i).delete(o), this.listeners.
        get(i)?.size === 0 && this.listeners.delete(i));
      };
    }, "subscribe");
    /** Sends a custom event to the other stores */
    this.send = /* @__PURE__ */ s((t) => {
      if (this.debug("send", { event: t }), this.status !== e.Status.READY)
        throw new TypeError(
          cs.dedent`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: t,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(t, { actor: this.actor }), this.emitToChannel(t, { actor: this.actor });
    }, "send");
    if (this.debugging = t.debug ?? !1, !e.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (e.isInternalConstructing = !1, this.id = t.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.
    actorType = t.leader ? e.ActorType.LEADER : e.ActorType.FOLLOWER, this.state = t.initialState, this.channelEventName = `${nne}${this.id}`,
    this.debug("constructor", {
      options: t,
      environmentOverrides: r,
      channelEventName: this.channelEventName
    }), this.actor.type === e.ActorType.LEADER)
      this.syncing = {
        state: Sr.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let n, i, o = new Promise((a, u) => {
        n = /* @__PURE__ */ s(() => {
          this.syncing.state === Sr.PENDING && (this.syncing.state = Sr.RESOLVED, a());
        }, "syncingResolve"), i = /* @__PURE__ */ s((l) => {
          this.syncing.state === Sr.PENDING && (this.syncing.state = Sr.REJECTED, u(l));
        }, "syncingReject");
      });
      this.syncing = {
        state: Sr.PENDING,
        promise: o,
        resolve: n,
        reject: i
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange =
    this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.
    prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(
    this), this.debug = this.debug.bind(this), this.channel = r?.channel ?? e.preparation.channel, this.environment = r?.environment ?? e.preparation.
    environment, this.channel && this.environment ? (e.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis(
    { channel: this.channel, environment: this.environment })) : e.preparation.promise.then(this.prepareThis);
  }
  static {
    s(this, "UniversalStore");
  }
  static {
    /**
     * Defines the possible actor types in the store system
     *
     * @readonly
     */
    this.ActorType = {
      LEADER: "LEADER",
      FOLLOWER: "FOLLOWER"
    };
  }
  static {
    /**
     * Defines the possible environments the store can run in
     *
     * @readonly
     */
    this.Environment = {
      SERVER: "SERVER",
      MANAGER: "MANAGER",
      PREVIEW: "PREVIEW",
      UNKNOWN: "UNKNOWN",
      MOCK: "MOCK"
    };
  }
  static {
    /**
     * Internal event types used for store synchronization
     *
     * @readonly
     */
    this.InternalEventType = {
      EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
      EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
      SET_STATE: "__SET_STATE",
      LEADER_CREATED: "__LEADER_CREATED",
      FOLLOWER_CREATED: "__FOLLOWER_CREATED"
    };
  }
  static {
    this.Status = {
      UNPREPARED: "UNPREPARED",
      SYNCING: "SYNCING",
      READY: "READY",
      ERROR: "ERROR"
    };
  }
  static {
    // This is used to check if constructor was called from the static factory create()
    this.isInternalConstructing = !1;
  }
  static {
    e.setupPreparationPromise();
  }
  static setupPreparationPromise() {
    let t, r, n = new Promise(
      (i, o) => {
        t = /* @__PURE__ */ s((a) => {
          i(a);
        }, "resolveRef"), r = /* @__PURE__ */ s((...a) => {
          o(a);
        }, "rejectRef");
      }
    );
    e.preparation = {
      resolve: t,
      reject: r,
      promise: n
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? e.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return e.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case Sr.PENDING:
      case void 0:
        return e.Status.SYNCING;
      case Sr.REJECTED:
        return e.Status.ERROR;
      case Sr.RESOLVED:
      default:
        return e.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([e.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(t) {
    if (!t || typeof t?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    t.debug && console.debug(
      cs.dedent`[UniversalStore]
        create`,
      { options: t }
    );
    let r = bD.get(t.id);
    if (r)
      return console.warn(cs.dedent`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), r;
    e.isInternalConstructing = !0;
    let n = new e(t);
    return bD.set(t.id, n), n;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(t, r) {
    e.preparation.channel = t, e.preparation.environment = r, e.preparation.resolve({ channel: t, environment: r });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(t) {
    let r = this.state, n = typeof t == "function" ? t(r) : t;
    if (this.debug("setState", { newState: n, previousState: r, updater: t }), this.status !== e.Status.READY)
      throw new TypeError(
        cs.dedent`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: n,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = n;
    let i = {
      type: e.InternalEventType.SET_STATE,
      payload: {
        state: n,
        previousState: r
      }
    };
    this.emitToChannel(i, { actor: this.actor }), this.emitToListeners(i, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(t) {
    return this.debug("onStateChange", { listener: t }), this.subscribe(
      e.InternalEventType.SET_STATE,
      ({ payload: r }, n) => {
        t(r.state, r.previousState, n);
      }
    );
  }
  emitToChannel(t, r) {
    this.debug("emitToChannel", { event: t, eventInfo: r, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event: t,
      eventInfo: r
    });
  }
  prepareThis({
    channel: t,
    environment: r
  }) {
    this.channel = t, this.environment = r, this.debug("prepared", { channel: !!t, environment: r }), this.channel.on(this.channelEventName,
    this.handleChannelEvents), this.actor.type === e.ActorType.LEADER ? this.emitToChannel(
      { type: e.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: e.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: e.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower\
.`
        )
      );
    }, 1e3));
  }
  emitToListeners(t, r) {
    let n = this.listeners.get(t.type), i = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: t,
      eventInfo: r,
      eventTypeListeners: n,
      everythingListeners: i
    }), [...n ?? [], ...i ?? []].forEach(
      (o) => o(t, r)
    );
  }
  handleChannelEvents(t) {
    let { event: r, eventInfo: n } = t;
    if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: t });
      return;
    } else if (this.syncing?.state === Sr.PENDING && r.type !== e.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: t });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: t }), this.actor.type === e.ActorType.LEADER) {
      let i = !0;
      switch (r.type) {
        case e.InternalEventType.EXISTING_STATE_REQUEST:
          i = !1;
          let o = {
            type: e.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: o
          }), this.emitToChannel(o, { actor: this.actor }), this.emitToListeners(o, { actor: this.actor });
          break;
        case e.InternalEventType.LEADER_CREATED:
          i = !1, this.syncing.state = Sr.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: r
          }), console.error(
            cs.dedent`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`
          );
          break;
      }
      i && (this.debug("handleChannelEvents: forwarding event", { channelEvent: t }), this.emitToChannel(r, { actor: n.actor, forwardingActor: this.
      actor }));
    }
    if (this.actor.type === e.ActorType.FOLLOWER)
      switch (r.type) {
        case e.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: r
          }), this.syncing?.state !== Sr.PENDING)
            break;
          this.syncing.resolve?.();
          let i = {
            type: e.InternalEventType.SET_STATE,
            payload: {
              state: r.payload,
              previousState: this.state
            }
          };
          this.state = r.payload, this.emitToListeners(i, n);
          break;
      }
    switch (r.type) {
      case e.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: r }), this.state = r.payload.state;
        break;
    }
    this.emitToListeners(r, { actor: n.actor });
  }
  debug(t, r) {
    this.debugging && console.debug(
      cs.dedent`[UniversalStore::${this.id}::${this.environment ?? e.Environment.UNKNOWN}]
        ${t}`,
      JSON.stringify(
        {
          data: r,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    e.preparation.reject(new Error("reset")), e.setupPreparationPromise(), e.isInternalConstructing = !1;
  }
};

// src/core-server/utils/get-server-channel.ts
var vD = class {
  static {
    s(this, "ServerChannelTransport");
  }
  constructor(t) {
    this.socket = new pu.WebSocketServer({ noServer: !0 }), t.on("upgrade", (n, i, o) => {
      n.url === "/storybook-server-channel" && this.socket.handleUpgrade(n, i, o, (a) => {
        this.socket.emit("connection", a, n);
      });
    }), this.socket.on("connection", (n) => {
      n.on("message", (i) => {
        let o = i.toString(), a = typeof o == "string" && (0, To.isJSON)(o) ? (0, To.parse)(o, {}) : o;
        this.handler?.(a);
      });
    });
    let r = setInterval(() => {
      this.send({ type: "ping" });
    }, Bp.HEARTBEAT_INTERVAL);
    this.socket.on("close", /* @__PURE__ */ s(function() {
      clearInterval(r);
    }, "close")), process.on("SIGTERM", () => {
      this.socket.clients.forEach((n) => {
        n.readyState === pu.default.OPEN && n.close(1001, "Server is shutting down");
      }), this.socket.close(() => process.exit(0));
    });
  }
  setHandler(t) {
    this.handler = t;
  }
  send(t) {
    let r = (0, To.stringify)(t, { maxDepth: 15 });
    Array.from(this.socket.clients).filter((n) => n.readyState === pu.default.OPEN).forEach((n) => n.send(r));
  }
};
function oO(e) {
  let t = [new vD(e)], r = new Bp.Channel({ transports: t, async: !0 });
  return kt.__prepare(r, kt.Environment.SERVER), r;
}
s(oO, "getServerChannel");

// src/core-server/utils/getAccessControlMiddleware.ts
function aO(e) {
  return (t, r, n) => {
    r.setHeader("Access-Control-Allow-Origin", "*"), r.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Ac\
cept"), e && (r.setHeader("Cross-Origin-Opener-Policy", "same-origin"), r.setHeader("Cross-Origin-Embedder-Policy", "require-corp")), n();
  };
}
s(aO, "getAccessControlMiddleware");

// src/core-server/utils/getStoryIndexGenerator.ts
var uO = require("storybook/internal/common");
async function lO(e, t, r) {
  let n = process.cwd(), i = t.configDir, o = {
    configDir: i,
    workingDir: n
  }, a = t.presets.apply("stories"), u = t.presets.apply("experimental_indexers", []), l = t.presets.apply("docs"), c = (0, uO.normalizeStories)(
  await a, o), p = new an(c, {
    ...o,
    indexers: await u,
    docs: await l,
    workingDir: n
  }), h = p.initialize().then(() => p);
  return pF({
    app: e,
    initializedStoryIndexGenerator: h,
    normalizedStories: c,
    serverChannel: r,
    workingDir: n,
    configDir: i
  }), h;
}
s(lO, "getStoryIndexGenerator");

// src/core-server/utils/middleware.ts
var cO = require("node:fs"), pO = require("node:path");
var ine = /* @__PURE__ */ s((e) => [".js", ".cjs"].reduce((t, r) => {
  let n = `${e}${r}`;
  return !t && (0, cO.existsSync)(n) ? n : t;
}, ""), "fileExists");
function hO(e) {
  let t = ine((0, pO.resolve)(e, "middleware"));
  if (t) {
    let r = require(t);
    return r.__esModule && (r = r.default), r;
  }
  return () => {
  };
}
s(hO, "getMiddleware");

// src/core-server/utils/open-in-browser.ts
var YO = require("storybook/internal/node-logger"), QO = J(LO(), 1), e6 = J(require("better-opn"), 1), t6 = J(KO(), 1), r6 = J(Bt(), 1);
function n6(e) {
  let t = process.env.BROWSER, r = t === "chrome" || t === "chromium" || t === "brave" || t === "com.brave.browser", n = t ? { app: { name: t } } :
  {};
  (0, QO.default)(async (i, o) => {
    try {
      o && (o.isChrome || o.isChromium || o.identity === "com.brave.browser" || r) ? await (0, e6.default)(e) : await (0, t6.default)(e, n);
    } catch {
      YO.logger.error(r6.dedent`
        Could not open ${e} inside a browser. If you're running this command inside a
        docker container or on a CI, you need to pass the '--ci' flag to prevent opening a
        browser by default.
      `);
    }
  });
}
s(n6, "openInBrowser");

// src/core-server/utils/server-address.ts
var A6 = J(require("node:os"), 1), F6 = require("storybook/internal/node-logger"), _6 = J(S6(), 1);
function k6(e, t, r, n) {
  let i = new URL(`${r}://localhost:${e}/`), o = new URL(`${r}://${t || cie()}:${e}/`);
  if (n) {
    let a = `?path=${decodeURIComponent(
      n.startsWith("/") ? n : `/${n}`
    )}`;
    i.search = a, o.search = a;
  }
  return {
    address: i.href,
    networkAddress: o.href
  };
}
s(k6, "getServerAddresses");
var T6 = /* @__PURE__ */ s((e, { exactPort: t } = {}) => (0, _6.default)(e).then((r) => (r !== e && t && process.exit(-1), r)).catch((r) => {
  F6.logger.error(r), process.exit(-1);
}), "getServerPort"), I6 = /* @__PURE__ */ s((e, { https: t }) => `${t ? "wss" : "ws"}://localhost:${e}/storybook-server-channel`, "getServe\
rChannelUrl"), cie = /* @__PURE__ */ s(() => {
  let t = Object.values(A6.default.networkInterfaces()).flat().filter((r) => r && r.family === "IPv4" && !r.internal);
  return t.length ? t[0]?.address : "0.0.0.0";
}, "getLocalIp");

// src/core-server/utils/server-init.ts
var Up = require("node:fs/promises"), MD = require("storybook/internal/node-logger"), P6 = J(require("http"), 1), B6 = J(require("https"), 1);
async function O6(e) {
  if (!e.https)
    return P6.default.createServer();
  e.sslCert || (MD.logger.error("Error: --ssl-cert is required with --https"), process.exit(-1)), e.sslKey || (MD.logger.error("Error: --ssl\
-key is required with --https"), process.exit(-1));
  let t = {
    ca: await Promise.all((e.sslCa || []).map((r) => (0, Up.readFile)(r, { encoding: "utf8" }))),
    cert: await (0, Up.readFile)(e.sslCert, { encoding: "utf8" }),
    key: await (0, Up.readFile)(e.sslKey, { encoding: "utf8" })
  };
  return B6.default.createServer(t);
}
s(O6, "getServer");

// src/core-server/dev-server.ts
async function L6(e) {
  let [t, r] = await Promise.all([O6(e), e.presets.apply("core")]), n = ey({ server: t }), i = await e.presets.apply(
    "experimental_serverChannel",
    oO(t)
  ), o, a = lO(n, e, i).catch((k) => {
    o = k;
  });
  n.use(Z0({ level: 1 })), typeof e.extendServer == "function" && e.extendServer(t), n.use(aO(r?.crossOriginIsolated ?? !1)), n.use(kB()), hO(
  e.configDir)(n);
  let { port: u, host: l, initialPath: c } = e;
  Pt(u, "expected options to have a port");
  let p = e.https ? "https" : "http", { address: h, networkAddress: f } = k6(u, l, p, c);
  if (!r?.builder)
    throw new N6.MissingBuilderError();
  let d = typeof r?.builder == "string" ? r.builder : r?.builder?.name, [m, g] = await Promise.all([
    Sa(d, e.configDir),
    wa(),
    RS(n, e)
  ]);
  e.debugWebpack && (0, R6.logConfig)("Preview webpack config", await m.getConfig(e));
  let b = e.previewOnly ? void 0 : await g.start({
    startTime: process.hrtime(),
    options: e,
    router: n,
    server: t,
    channel: i
  }), y = await Promise.resolve();
  e.ignorePreview || (e.quiet || qD.logger.info("=> Starting preview.."), y = await m.start({
    startTime: process.hrtime(),
    options: e,
    router: n,
    server: t,
    channel: i
  }).catch(async (k) => {
    throw qD.logger.error("=> Failed to build the preview"), process.exitCode = 1, await g?.bail().catch(), await m?.bail().catch(), k;
  }));
  let E = new Promise((k, O) => {
    t.once("error", O), n.listen({ port: u, host: l }, k);
  });
  if (await Promise.all([a, E]).then(async ([k]) => {
    if (k && !e.ci && !e.smokeTest && e.open) {
      let O = l ? f : h;
      n6(e.previewOnly ? `${O}iframe.html?navigator=true` : O);
    }
  }), o)
    throw await g?.bail().catch(), await m?.bail().catch(), o;
  _B(n, r, a, e);
  async function A() {
    let k = { eventType: "dev" };
    try {
      let w = await (await a)?.getIndexAndStats();
      w && Object.assign(k, {
        storyIndex: io(w.storyIndex),
        storyStats: w.stats
      });
    } catch {
    }
    await CB("canceled", k, { immediate: !0 }), process.exit(0);
  }
  return s(A, "cancelTelemetry"), r?.disableTelemetry || (process.on("SIGINT", A), process.on("SIGTERM", A)), { previewResult: y, managerResult: b,
  address: h, networkAddress: f };
}
s(L6, "storybookDevServer");

// src/core-server/utils/output-startup-information.ts
var _R = require("storybook/internal/node-logger");

// ../node_modules/boxen/index.js
var Du = J(require("node:process"), 1);

// ../node_modules/ansi-regex/index.js
function $D({ onlyFirst: e = !1 } = {}) {
  let r = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u00\
9C))",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
s($D, "ansiRegex");

// ../node_modules/strip-ansi/index.js
var pie = $D();
function hs(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(pie, "");
}
s(hs, "stripAnsi");

// ../node_modules/boxen/node_modules/string-width/index.js
var q6 = J(UD(), 1), $6 = J(WD(), 1);
function Fr(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = hs(e), e.length === 0))
    return 0;
  e = e.replace((0, $6.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, n = 0;
  for (let i of e) {
    let o = i.codePointAt(0);
    if (o <= 31 || o >= 127 && o <= 159 || o >= 768 && o <= 879)
      continue;
    switch (q6.default.eastAsianWidth(i)) {
      case "F":
      case "W":
        n += 2;
        break;
      case "A":
        n += r;
        break;
      default:
        n += 1;
    }
  }
  return n;
}
s(Fr, "stringWidth");

// ../node_modules/boxen/node_modules/chalk/source/vendor/ansi-styles/index.js
var V6 = /* @__PURE__ */ s((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), U6 = /* @__PURE__ */ s((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), W6 = /* @__PURE__ */ s((e = 0) => (t, r, n) => `\x1B[${38 + e};2;${t};${r};${n}m`, "wrapAnsi16m"), et = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, Ive = Object.keys(et.modifier), hie = Object.keys(et.color), fie = Object.keys(et.bgColor), Pve = [...hie, ...fie];
function die() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(et)) {
    for (let [n, i] of Object.entries(r))
      et[n] = {
        open: `\x1B[${i[0]}m`,
        close: `\x1B[${i[1]}m`
      }, r[n] = et[n], e.set(i[0], i[1]);
    Object.defineProperty(et, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(et, "codes", {
    value: e,
    enumerable: !1
  }), et.color.close = "\x1B[39m", et.bgColor.close = "\x1B[49m", et.color.ansi = V6(), et.color.ansi256 = U6(), et.color.ansi16m = W6(), et.
  bgColor.ansi = V6(10), et.bgColor.ansi256 = U6(10), et.bgColor.ansi16m = W6(10), Object.defineProperties(et, {
    rgbToAnsi256: {
      value(t, r, n) {
        return t === r && r === n ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(n / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [n] = r;
        n.length === 3 && (n = [...n].map((o) => o + o).join(""));
        let i = Number.parseInt(n, 16);
        return [
          /* eslint-disable no-bitwise */
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ s((t) => et.rgbToAnsi256(...et.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, n, i;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, n = r, i = r;
        else {
          t -= 16;
          let u = t % 36;
          r = Math.floor(t / 36) / 5, n = Math.floor(u / 6) / 5, i = u % 6 / 5;
        }
        let o = Math.max(r, n, i) * 2;
        if (o === 0)
          return 30;
        let a = 30 + (Math.round(i) << 2 | Math.round(n) << 1 | Math.round(r));
        return o === 2 && (a += 60), a;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ s((t, r, n) => et.ansi256ToAnsi(et.rgbToAnsi256(t, r, n)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ s((t) => et.ansi256ToAnsi(et.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), et;
}
s(die, "assembleStyles");
var mie = die(), Jr = mie;

// ../node_modules/boxen/node_modules/chalk/source/vendor/supports-color/index.js
var zp = J(require("node:process"), 1), H6 = J(require("node:os"), 1), zD = J(require("node:tty"), 1);
function _r(e, t = globalThis.Deno ? globalThis.Deno.args : zp.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
  return n !== -1 && (i === -1 || n < i);
}
s(_r, "hasFlag");
var { env: ct } = zp.default, Wp;
_r("no-color") || _r("no-colors") || _r("color=false") || _r("color=never") ? Wp = 0 : (_r("color") || _r("colors") || _r("color=true") || _r(
"color=always")) && (Wp = 1);
function gie() {
  if ("FORCE_COLOR" in ct)
    return ct.FORCE_COLOR === "true" ? 1 : ct.FORCE_COLOR === "false" ? 0 : ct.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(ct.FORCE_COLOR,
    10), 3);
}
s(gie, "envForceColor");
function yie(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
s(yie, "translateLevel");
function Die(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  let n = gie();
  n !== void 0 && (Wp = n);
  let i = r ? Wp : n;
  if (i === 0)
    return 0;
  if (r) {
    if (_r("color=16m") || _r("color=full") || _r("color=truecolor"))
      return 3;
    if (_r("color=256"))
      return 2;
  }
  if ("TF_BUILD" in ct && "AGENT_NAME" in ct)
    return 1;
  if (e && !t && i === void 0)
    return 0;
  let o = i || 0;
  if (ct.TERM === "dumb")
    return o;
  if (zp.default.platform === "win32") {
    let a = H6.default.release().split(".");
    return Number(a[0]) >= 10 && Number(a[2]) >= 10586 ? Number(a[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in ct)
    return ["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((a) => a in ct) ? 3 : ["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRON\
E"].some((a) => a in ct) || ct.CI_NAME === "codeship" ? 1 : o;
  if ("TEAMCITY_VERSION" in ct)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ct.TEAMCITY_VERSION) ? 1 : 0;
  if (ct.COLORTERM === "truecolor" || ct.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in ct) {
    let a = Number.parseInt((ct.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (ct.TERM_PROGRAM) {
      case "iTerm.app":
        return a >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(ct.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ct.TERM) || "COLORTERM" in ct ?
  1 : o;
}
s(Die, "_supportsColor");
function z6(e, t = {}) {
  let r = Die(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return yie(r);
}
s(z6, "createSupportsColor");
var xie = {
  stdout: z6({ isTTY: zD.default.isatty(1) }),
  stderr: z6({ isTTY: zD.default.isatty(2) })
}, G6 = xie;

// ../node_modules/boxen/node_modules/chalk/source/utilities.js
function J6(e, t, r) {
  let n = e.indexOf(t);
  if (n === -1)
    return e;
  let i = t.length, o = 0, a = "";
  do
    a += e.slice(o, n) + t + r, o = n + i, n = e.indexOf(t, o);
  while (n !== -1);
  return a += e.slice(o), a;
}
s(J6, "stringReplaceAll");
function Z6(e, t, r, n) {
  let i = 0, o = "";
  do {
    let a = e[n - 1] === "\r";
    o += e.slice(i, a ? n - 1 : n) + t + (a ? `\r
` : `
`) + r, i = n + 1, n = e.indexOf(`
`, i);
  } while (n !== -1);
  return o += e.slice(i), o;
}
s(Z6, "stringEncaseCRLFWithFirstIndex");

// ../node_modules/boxen/node_modules/chalk/source/index.js
var { stdout: X6, stderr: K6 } = G6, HD = Symbol("GENERATOR"), No = Symbol("STYLER"), gu = Symbol("IS_EMPTY"), Y6 = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Lo = /* @__PURE__ */ Object.create(null), bie = /* @__PURE__ */ s((e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = X6 ? X6.level : 0;
  e.level = t.level === void 0 ? r : t.level;
}, "applyOptions");
var vie = /* @__PURE__ */ s((e) => {
  let t = /* @__PURE__ */ s((...r) => r.join(" "), "chalk");
  return bie(t, e), Object.setPrototypeOf(t, yu.prototype), t;
}, "chalkFactory");
function yu(e) {
  return vie(e);
}
s(yu, "createChalk");
Object.setPrototypeOf(yu.prototype, Function.prototype);
for (let [e, t] of Object.entries(Jr))
  Lo[e] = {
    get() {
      let r = Hp(this, JD(t.open, t.close, this[No]), this[gu]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Lo.visible = {
  get() {
    let e = Hp(this, this[No], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var GD = /* @__PURE__ */ s((e, t, r, ...n) => e === "rgb" ? t === "ansi16m" ? Jr[r].ansi16m(...n) : t === "ansi256" ? Jr[r].ansi256(Jr.rgbToAnsi256(
...n)) : Jr[r].ansi(Jr.rgbToAnsi(...n)) : e === "hex" ? GD("rgb", t, r, ...Jr.hexToRgb(...n)) : Jr[r][e](...n), "getModelAnsi"), Eie = ["rgb",
"hex", "ansi256"];
for (let e of Eie) {
  Lo[e] = {
    get() {
      let { level: r } = this;
      return function(...n) {
        let i = JD(GD(e, Y6[r], "color", ...n), Jr.color.close, this[No]);
        return Hp(this, i, this[gu]);
      };
    }
  };
  let t = "bg" + e[0].toUpperCase() + e.slice(1);
  Lo[t] = {
    get() {
      let { level: r } = this;
      return function(...n) {
        let i = JD(GD(e, Y6[r], "bgColor", ...n), Jr.bgColor.close, this[No]);
        return Hp(this, i, this[gu]);
      };
    }
  };
}
var Cie = Object.defineProperties(() => {
}, {
  ...Lo,
  level: {
    enumerable: !0,
    get() {
      return this[HD].level;
    },
    set(e) {
      this[HD].level = e;
    }
  }
}), JD = /* @__PURE__ */ s((e, t, r) => {
  let n, i;
  return r === void 0 ? (n = e, i = t) : (n = r.openAll + e, i = t + r.closeAll), {
    open: e,
    close: t,
    openAll: n,
    closeAll: i,
    parent: r
  };
}, "createStyler"), Hp = /* @__PURE__ */ s((e, t, r) => {
  let n = /* @__PURE__ */ s((...i) => wie(n, i.length === 1 ? "" + i[0] : i.join(" ")), "builder");
  return Object.setPrototypeOf(n, Cie), n[HD] = e, n[No] = t, n[gu] = r, n;
}, "createBuilder"), wie = /* @__PURE__ */ s((e, t) => {
  if (e.level <= 0 || !t)
    return e[gu] ? "" : t;
  let r = e[No];
  if (r === void 0)
    return t;
  let { openAll: n, closeAll: i } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = J6(t, r.close, r.open), r = r.parent;
  let o = t.indexOf(`
`);
  return o !== -1 && (t = Z6(t, i, n, o)), n + t + i;
}, "applyStyle");
Object.defineProperties(yu.prototype, Lo);
var Sie = yu(), Vve = yu({ level: K6 ? K6.level : 0 });
var fs = Sie;

// ../node_modules/boxen/node_modules/widest-line/index.js
function Gp(e) {
  let t = 0;
  for (let r of e.split(`
`))
    t = Math.max(t, Fr(r));
  return t;
}
s(Gp, "widestLine");

// ../node_modules/boxen/index.js
var k8 = J(XD(), 1);

// ../node_modules/boxen/node_modules/camelcase/index.js
var Fie = /[\p{Lu}]/u, _ie = /[\p{Ll}]/u, t8 = /^[\p{Lu}](?![\p{Lu}])/gu, i8 = /([\p{Alpha}\p{N}_]|$)/u, KD = /[_.\- ]+/, kie = new RegExp("\
^" + KD.source), r8 = new RegExp(KD.source + i8.source, "gu"), n8 = new RegExp("\\d+" + i8.source, "gu"), Tie = /* @__PURE__ */ s((e, t, r, n) => {
  let i = !1, o = !1, a = !1, u = !1;
  for (let l = 0; l < e.length; l++) {
    let c = e[l];
    u = l > 2 ? e[l - 3] === "-" : !0, i && Fie.test(c) ? (e = e.slice(0, l) + "-" + e.slice(l), i = !1, a = o, o = !0, l++) : o && a && _ie.
    test(c) && (!u || n) ? (e = e.slice(0, l - 1) + "-" + e.slice(l - 1), a = o, o = !1, i = !0) : (i = t(c) === c && r(c) !== c, a = o, o =
    r(c) === c && t(c) !== c);
  }
  return e;
}, "preserveCamelCase"), Iie = /* @__PURE__ */ s((e, t) => (t8.lastIndex = 0, e.replace(t8, (r) => t(r))), "preserveConsecutiveUppercase"), Pie = /* @__PURE__ */ s(
(e, t) => (r8.lastIndex = 0, n8.lastIndex = 0, e.replace(r8, (r, n) => t(n)).replace(n8, (r) => t(r))), "postProcess");
function YD(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((o) => o.trim()).filter((o) => o.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  let r = t.locale === !1 ? (o) => o.toLowerCase() : (o) => o.toLocaleLowerCase(t.locale), n = t.locale === !1 ? (o) => o.toUpperCase() : (o) => o.
  toLocaleUpperCase(t.locale);
  return e.length === 1 ? KD.test(e) ? "" : t.pascalCase ? n(e) : r(e) : (e !== r(e) && (e = Tie(e, r, n, t.preserveConsecutiveUppercase)), e =
  e.replace(kie, ""), e = t.preserveConsecutiveUppercase ? Iie(e, r) : r(e), t.pascalCase && (e = n(e.charAt(0)) + e.slice(1)), Pie(e, n));
}
s(YD, "camelCase");

// ../node_modules/boxen/index.js
var sx = J(m8(), 1);

// ../node_modules/wrap-ansi/node_modules/string-width/index.js
var g8 = J(UD(), 1), y8 = J(WD(), 1);
function ms(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = hs(e), e.length === 0))
    return 0;
  e = e.replace((0, y8.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, n = 0;
  for (let i of e) {
    let o = i.codePointAt(0);
    if (o <= 31 || o >= 127 && o <= 159 || o >= 768 && o <= 879)
      continue;
    switch (g8.default.eastAsianWidth(i)) {
      case "F":
      case "W":
        n += 2;
        break;
      case "A":
        n += r;
        break;
      default:
        n += 1;
    }
  }
  return n;
}
s(ms, "stringWidth");

// ../node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var D8 = /* @__PURE__ */ s((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), x8 = /* @__PURE__ */ s((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), b8 = /* @__PURE__ */ s((e = 0) => (t, r, n) => `\x1B[${38 + e};2;${t};${r};${n}m`, "wrapAnsi16m"), tt = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, cEe = Object.keys(tt.modifier), qie = Object.keys(tt.color), $ie = Object.keys(tt.bgColor), pEe = [...qie, ...$ie];
function Vie() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(tt)) {
    for (let [n, i] of Object.entries(r))
      tt[n] = {
        open: `\x1B[${i[0]}m`,
        close: `\x1B[${i[1]}m`
      }, r[n] = tt[n], e.set(i[0], i[1]);
    Object.defineProperty(tt, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(tt, "codes", {
    value: e,
    enumerable: !1
  }), tt.color.close = "\x1B[39m", tt.bgColor.close = "\x1B[49m", tt.color.ansi = D8(), tt.color.ansi256 = x8(), tt.color.ansi16m = b8(), tt.
  bgColor.ansi = D8(10), tt.bgColor.ansi256 = x8(10), tt.bgColor.ansi16m = b8(10), Object.defineProperties(tt, {
    rgbToAnsi256: {
      value: /* @__PURE__ */ s((t, r, n) => t === r && r === n ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 *
      Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5), "value"),
      enumerable: !1
    },
    hexToRgb: {
      value: /* @__PURE__ */ s((t) => {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [n] = r;
        n.length === 3 && (n = [...n].map((o) => o + o).join(""));
        let i = Number.parseInt(n, 16);
        return [
          /* eslint-disable no-bitwise */
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
          /* eslint-enable no-bitwise */
        ];
      }, "value"),
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ s((t) => tt.rgbToAnsi256(...tt.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: /* @__PURE__ */ s((t) => {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, n, i;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, n = r, i = r;
        else {
          t -= 16;
          let u = t % 36;
          r = Math.floor(t / 36) / 5, n = Math.floor(u / 6) / 5, i = u % 6 / 5;
        }
        let o = Math.max(r, n, i) * 2;
        if (o === 0)
          return 30;
        let a = 30 + (Math.round(i) << 2 | Math.round(n) << 1 | Math.round(r));
        return o === 2 && (a += 60), a;
      }, "value"),
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ s((t, r, n) => tt.ansi256ToAnsi(tt.rgbToAnsi256(t, r, n)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ s((t) => tt.ansi256ToAnsi(tt.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), tt;
}
s(Vie, "assembleStyles");
var Uie = Vie(), v8 = Uie;

// ../node_modules/wrap-ansi/index.js
var Jp = /* @__PURE__ */ new Set([
  "\x1B",
  "\x9B"
]), Wie = 39, nx = "\x07", w8 = "[", zie = "]", S8 = "m", ix = `${zie}8;;`, E8 = /* @__PURE__ */ s((e) => `${Jp.values().next().value}${w8}${e}${S8}`,
"wrapAnsiCode"), C8 = /* @__PURE__ */ s((e) => `${Jp.values().next().value}${ix}${e}${nx}`, "wrapAnsiHyperlink"), Hie = /* @__PURE__ */ s((e) => e.
split(" ").map((t) => ms(t)), "wordLengths"), rx = /* @__PURE__ */ s((e, t, r) => {
  let n = [...t], i = !1, o = !1, a = ms(hs(e[e.length - 1]));
  for (let [u, l] of n.entries()) {
    let c = ms(l);
    if (a + c <= r ? e[e.length - 1] += l : (e.push(l), a = 0), Jp.has(l) && (i = !0, o = n.slice(u + 1).join("").startsWith(ix)), i) {
      o ? l === nx && (i = !1, o = !1) : l === S8 && (i = !1);
      continue;
    }
    a += c, a === r && u < n.length - 1 && (e.push(""), a = 0);
  }
  !a && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, "wrapWord"), Gie = /* @__PURE__ */ s((e) => {
  let t = e.split(" "), r = t.length;
  for (; r > 0 && !(ms(t[r - 1]) > 0); )
    r--;
  return r === t.length ? e : t.slice(0, r).join(" ") + t.slice(r).join("");
}, "stringVisibleTrimSpacesRight"), Jie = /* @__PURE__ */ s((e, t, r = {}) => {
  if (r.trim !== !1 && e.trim() === "")
    return "";
  let n = "", i, o, a = Hie(e), u = [""];
  for (let [c, p] of e.split(" ").entries()) {
    r.trim !== !1 && (u[u.length - 1] = u[u.length - 1].trimStart());
    let h = ms(u[u.length - 1]);
    if (c !== 0 && (h >= t && (r.wordWrap === !1 || r.trim === !1) && (u.push(""), h = 0), (h > 0 || r.trim === !1) && (u[u.length - 1] += "\
 ", h++)), r.hard && a[c] > t) {
      let f = t - h, d = 1 + Math.floor((a[c] - f - 1) / t);
      Math.floor((a[c] - 1) / t) < d && u.push(""), rx(u, p, t);
      continue;
    }
    if (h + a[c] > t && h > 0 && a[c] > 0) {
      if (r.wordWrap === !1 && h < t) {
        rx(u, p, t);
        continue;
      }
      u.push("");
    }
    if (h + a[c] > t && r.wordWrap === !1) {
      rx(u, p, t);
      continue;
    }
    u[u.length - 1] += p;
  }
  r.trim !== !1 && (u = u.map((c) => Gie(c)));
  let l = [...u.join(`
`)];
  for (let [c, p] of l.entries()) {
    if (n += p, Jp.has(p)) {
      let { groups: f } = new RegExp(`(?:\\${w8}(?<code>\\d+)m|\\${ix}(?<uri>.*)${nx})`).exec(l.slice(c).join("")) || { groups: {} };
      if (f.code !== void 0) {
        let d = Number.parseFloat(f.code);
        i = d === Wie ? void 0 : d;
      } else f.uri !== void 0 && (o = f.uri.length === 0 ? void 0 : f.uri);
    }
    let h = v8.codes.get(Number(i));
    l[c + 1] === `
` ? (o && (n += C8("")), i && h && (n += E8(h))) : p === `
` && (i && h && (n += E8(i)), o && (n += C8(o)));
  }
  return n;
}, "exec");
function Zp(e, t, r) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((n) => Jie(n, t, r)).join(`
`);
}
s(Zp, "wrapAnsi");

// ../node_modules/boxen/index.js
var nse = J(XD(), 1);
var wi = `
`, jt = " ", xu = "none", T8 = /* @__PURE__ */ s(() => {
  let { env: e, stdout: t, stderr: r } = Du.default;
  return t?.columns ? t.columns : r?.columns ? r.columns : e.COLUMNS ? Number.parseInt(e.COLUMNS, 10) : 80;
}, "terminalColumns"), A8 = /* @__PURE__ */ s((e) => typeof e == "number" ? {
  top: e,
  right: e * 3,
  bottom: e,
  left: e * 3
} : {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  ...e
}, "getObject"), bu = /* @__PURE__ */ s((e) => e === xu ? 0 : 2, "getBorderWidth"), Zie = /* @__PURE__ */ s((e) => {
  let t = [
    "topLeft",
    "topRight",
    "bottomRight",
    "bottomLeft",
    "left",
    "right",
    "top",
    "bottom"
  ], r;
  if (e === xu) {
    e = {};
    for (let n of t)
      e[n] = "";
  }
  if (typeof e == "string") {
    if (r = k8.default[e], !r)
      throw new TypeError(`Invalid border style: ${e}`);
  } else {
    typeof e?.vertical == "string" && (e.left = e.vertical, e.right = e.vertical), typeof e?.horizontal == "string" && (e.top = e.horizontal,
    e.bottom = e.horizontal);
    for (let n of t)
      if (e[n] === null || typeof e[n] != "string")
        throw new TypeError(`Invalid border style: ${n}`);
    r = e;
  }
  return r;
}, "getBorderChars"), Xie = /* @__PURE__ */ s((e, t, r) => {
  let n = "", i = Fr(e);
  switch (r) {
    case "left": {
      n = e + t.slice(i);
      break;
    }
    case "right": {
      n = t.slice(i) + e;
      break;
    }
    default: {
      t = t.slice(i), t.length % 2 === 1 ? (t = t.slice(Math.floor(t.length / 2)), n = t.slice(1) + e + t) : (t = t.slice(t.length / 2), n =
      t + e + t);
      break;
    }
  }
  return n;
}, "makeTitle"), Kie = /* @__PURE__ */ s((e, { padding: t, width: r, textAlignment: n, height: i }) => {
  e = (0, sx.default)(e, { align: n });
  let o = e.split(wi), a = Gp(e), u = r - t.left - t.right;
  if (a > u) {
    let p = [];
    for (let h of o) {
      let f = Zp(h, u, { hard: !0 }), m = (0, sx.default)(f, { align: n }).split(`
`), g = Math.max(...m.map((b) => Fr(b)));
      for (let b of m) {
        let y;
        switch (n) {
          case "center": {
            y = jt.repeat((u - g) / 2) + b;
            break;
          }
          case "right": {
            y = jt.repeat(u - g) + b;
            break;
          }
          default: {
            y = b;
            break;
          }
        }
        p.push(y);
      }
    }
    o = p;
  }
  n === "center" && a < u ? o = o.map((p) => jt.repeat((u - a) / 2) + p) : n === "right" && a < u && (o = o.map((p) => jt.repeat(u - a) + p));
  let l = jt.repeat(t.left), c = jt.repeat(t.right);
  return o = o.map((p) => l + p + c), o = o.map((p) => {
    if (r - Fr(p) > 0)
      switch (n) {
        case "center":
          return p + jt.repeat(r - Fr(p));
        case "right":
          return p + jt.repeat(r - Fr(p));
        default:
          return p + jt.repeat(r - Fr(p));
      }
    return p;
  }), t.top > 0 && (o = [...Array.from({ length: t.top }).fill(jt.repeat(r)), ...o]), t.bottom > 0 && (o = [...o, ...Array.from({ length: t.
  bottom }).fill(jt.repeat(r))]), i && o.length > i ? o = o.slice(0, i) : i && o.length < i && (o = [...o, ...Array.from({ length: i - o.length }).
  fill(jt.repeat(r))]), o.join(wi);
}, "makeContentText"), Yie = /* @__PURE__ */ s((e, t, r) => {
  let n = /* @__PURE__ */ s((p) => {
    let h = r.borderColor ? tse(r.borderColor)(p) : p;
    return r.dimBorder ? fs.dim(h) : h;
  }, "colorizeBorder"), i = /* @__PURE__ */ s((p) => r.backgroundColor ? rse(r.backgroundColor)(p) : p, "colorizeContent"), o = Zie(r.borderStyle),
  a = T8(), u = jt.repeat(r.margin.left);
  if (r.float === "center") {
    let p = Math.max((a - t - bu(r.borderStyle)) / 2, 0);
    u = jt.repeat(p);
  } else if (r.float === "right") {
    let p = Math.max(a - t - r.margin.right - bu(r.borderStyle), 0);
    u = jt.repeat(p);
  }
  let l = "";
  r.margin.top && (l += wi.repeat(r.margin.top)), (r.borderStyle !== xu || r.title) && (l += n(u + o.topLeft + (r.title ? Xie(r.title, o.top.
  repeat(t), r.titleAlignment) : o.top.repeat(t)) + o.topRight) + wi);
  let c = e.split(wi);
  return l += c.map((p) => u + n(o.left) + i(p) + n(o.right)).join(wi), r.borderStyle !== xu && (l += wi + n(u + o.bottomLeft + o.bottom.repeat(
  t) + o.bottomRight)), r.margin.bottom && (l += wi.repeat(r.margin.bottom)), l;
}, "boxContent"), Qie = /* @__PURE__ */ s((e) => {
  if (e.fullscreen && Du.default?.stdout) {
    let t = [Du.default.stdout.columns, Du.default.stdout.rows];
    typeof e.fullscreen == "function" && (t = e.fullscreen(...t)), e.width || (e.width = t[0]), e.height || (e.height = t[1]);
  }
  return e.width && (e.width = Math.max(1, e.width - bu(e.borderStyle))), e.height && (e.height = Math.max(1, e.height - bu(e.borderStyle))),
  e;
}, "sanitizeOptions"), F8 = /* @__PURE__ */ s((e, t) => t === xu ? e : ` ${e} `, "formatTitle"), ese = /* @__PURE__ */ s((e, t) => {
  t = Qie(t);
  let r = t.width !== void 0, n = T8(), i = bu(t.borderStyle), o = n - t.margin.left - t.margin.right - i, a = Gp(Zp(e, n - i, { hard: !0, trim: !1 })) +
  t.padding.left + t.padding.right;
  if (t.title && r ? (t.title = t.title.slice(0, Math.max(0, t.width - 2)), t.title && (t.title = F8(t.title, t.borderStyle))) : t.title && (t.
  title = t.title.slice(0, Math.max(0, o - 2)), t.title && (t.title = F8(t.title, t.borderStyle), Fr(t.title) > a && (t.width = Fr(t.title)))),
  t.width = t.width ? t.width : a, !r) {
    if (t.margin.left && t.margin.right && t.width > o) {
      let l = (n - t.width - i) / (t.margin.left + t.margin.right);
      t.margin.left = Math.max(0, Math.floor(t.margin.left * l)), t.margin.right = Math.max(0, Math.floor(t.margin.right * l));
    }
    t.width = Math.min(t.width, n - i - t.margin.left - t.margin.right);
  }
  return t.width - (t.padding.left + t.padding.right) <= 0 && (t.padding.left = 0, t.padding.right = 0), t.height && t.height - (t.padding.top +
  t.padding.bottom) <= 0 && (t.padding.top = 0, t.padding.bottom = 0), t;
}, "determineDimensions"), ox = /* @__PURE__ */ s((e) => e.match(/^#(?:[0-f]{3}){1,2}$/i), "isHex"), _8 = /* @__PURE__ */ s((e) => typeof e ==
"string" && (fs[e] ?? ox(e)), "isColorValid"), tse = /* @__PURE__ */ s((e) => ox(e) ? fs.hex(e) : fs[e], "getColorFn"), rse = /* @__PURE__ */ s(
(e) => ox(e) ? fs.bgHex(e) : fs[YD(["bg", e])], "getBGColorFn");
function ax(e, t) {
  if (t = {
    padding: 0,
    borderStyle: "single",
    dimBorder: !1,
    textAlignment: "left",
    float: "left",
    titleAlignment: "left",
    ...t
  }, t.align && (t.textAlignment = t.align), t.borderColor && !_8(t.borderColor))
    throw new Error(`${t.borderColor} is not a valid borderColor`);
  if (t.backgroundColor && !_8(t.backgroundColor))
    throw new Error(`${t.backgroundColor} is not a valid backgroundColor`);
  return t.padding = A8(t.padding), t.margin = A8(t.margin), t = ese(e, t), e = Kie(e, t), Yie(e, t.width, t);
}
s(ax, "boxen");

// src/core-server/utils/output-startup-information.ts
var kR = J(vR(), 1), Si = J(Tr(), 1), xx = J(wR(), 1), TR = J(Bt(), 1);

// src/core-server/utils/update-check.ts
var gx = require("storybook/internal/common"), yx = require("storybook/internal/node-logger"), qo = J(Tr(), 1), Dx = J(require("semver"), 1),
SR = J(Bt(), 1);
var { STORYBOOK_VERSION_BASE: Mse = "https://storybook.js.org", CI: qse } = process.env, AR = /* @__PURE__ */ s(async (e) => {
  let t, r = Date.now();
  try {
    let n = await gx.cache.get("lastUpdateCheck", { success: !1, time: 0 });
    r - 864e5 > n.time && !qse ? (t = { success: !0, cached: !1, data: await (await Promise.race([
      fetch(`${Mse}/versions.json?current=${e}`),
      // if fetch is too slow, we won't wait for it
      new Promise((a, u) => global.setTimeout(u, 1500))
    ])).json(), time: r }, await gx.cache.set("lastUpdateCheck", t)) : t = { ...n, cached: !0 };
  } catch (n) {
    t = { success: !1, cached: !1, error: n, time: r };
  }
  return t;
}, "updateCheck");
function FR(e, t) {
  let r;
  try {
    let i = `npx storybook@${Dx.default.prerelease(e.data.latest.version) ? "next" : "latest"} upgrade`;
    r = e.success && Dx.default.lt(t, e.data.latest.version) ? SR.dedent`
          ${yx.colors.orange(
      `A new version (${qo.default.bold(e.data.latest.version)}) is available!`
    )}

          ${qo.default.gray("Upgrade now:")} ${yx.colors.green(i)}

          ${qo.default.gray("Read full changelog:")} ${qo.default.gray(
      qo.default.underline("https://github.com/storybookjs/storybook/blob/main/CHANGELOG.md")
    )}
        ` : "";
  } catch {
    r = "";
  }
  return r;
}
s(FR, "createUpdateMessage");

// src/core-server/utils/output-startup-information.ts
function IR(e) {
  let { updateInfo: t, version: r, name: n, address: i, networkAddress: o, managerTotalTime: a, previewTotalTime: u } = e, l = FR(t, r), c = new kR.default(
  {
    chars: {
      top: "",
      "top-mid": "",
      "top-left": "",
      "top-right": "",
      bottom: "",
      "bottom-mid": "",
      "bottom-left": "",
      "bottom-right": "",
      left: "",
      "left-mid": "",
      mid: "",
      "mid-mid": "",
      right: "",
      "right-mid": "",
      middle: ""
    },
    // @ts-expect-error (Converted from ts-ignore)
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    paddingBottom: 0
  });
  c.push(
    ["Local:", Si.default.cyan(i)],
    ["On your network:", Si.default.cyan(o)]
  );
  let p = [
    a && `${Si.default.underline((0, xx.default)(a))} for manager`,
    u && `${Si.default.underline((0, xx.default)(u))} for preview`
  ].filter(Boolean).join(" and ");
  console.log(
    ax(
      TR.dedent`
          ${_R.colors.green(
        `Storybook ${Si.default.bold(r)} for ${Si.default.bold(n)} started`
      )}
          ${Si.default.gray(p)}

          ${c.toString()}${l ? `

${l}` : ""}
        `,
      { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
    )
  );
}
s(IR, "outputStartupInformation");

// src/core-server/utils/warnOnIncompatibleAddons.ts
var NR = require("storybook/internal/node-logger");

// ../lib/cli-storybook/src/doctor/getIncompatibleStorybookPackages.ts
var eh = require("storybook/internal/common"), BR = require("storybook/internal/node-logger"), Su = J(Tr(), 1), Au = J(require("semver"), 1);

// ../lib/cli-storybook/src/automigrate/helpers/consolidated-packages.ts
var PR = {
  "@storybook/channels": "storybook/internal/channels",
  "@storybook/client-logger": "storybook/internal/client-logger",
  "@storybook/core-common": "storybook/internal/common",
  "@storybook/core-events": "storybook/internal/core-events",
  "@storybook/csf": "storybook/internal/csf",
  "@storybook/csf-tools": "storybook/internal/csf-tools",
  "@storybook/docs-tools": "storybook/internal/docs-tools",
  "@storybook/node-logger": "storybook/internal/node-logger",
  "@storybook/preview-api": "storybook/preview-api",
  "@storybook/router": "storybook/internal/router",
  "@storybook/telemetry": "storybook/internal/telemetry",
  "@storybook/theming": "storybook/theming",
  "@storybook/types": "storybook/internal/types",
  "@storybook/manager-api": "storybook/manager-api",
  "@storybook/manager": "storybook/internal/manager",
  "@storybook/preview": "storybook/internal/preview",
  "@storybook/core-server": "storybook/internal/core-server",
  "@storybook/builder-manager": "storybook/internal/builder-manager",
  "@storybook/components": "storybook/internal/components",
  "@storybook/test": "storybook/test",
  "@storybook/experimental-nextjs-vite": "@storybook/nextjs-vite",
  "@storybook/instrumenter": "storybook/internal/instrumenter",
  "@storybook/blocks": "@storybook/addon-docs/blocks"
};

// ../lib/cli-storybook/src/doctor/getIncompatibleStorybookPackages.ts
var $se = /* @__PURE__ */ s(async (e, t) => {
  let { currentStorybookVersion: r, skipErrors: n, packageManager: i } = t;
  try {
    let o = i.getModulePackageJSON(e);
    if (o === null)
      return { packageName: e };
    let {
      version: a,
      name: u = e,
      dependencies: l,
      peerDependencies: c,
      homepage: p
    } = o, h = Object.entries({
      ...l,
      ...c
    }).filter(
      ([g]) => eh.versions[g] || PR[g]
    ).map(([g, b]) => b).find((g) => g && // We can't check compatibility for 0.x packages, so we skip them
    !/^[~^]?0\./.test(g) && Au.default.validRange(g) && !Au.default.satisfies(r, g)), f = eh.versions[u], d, m;
    return f && a && Au.default.gt(r, a) && (d = r), f && a && Au.default.gt(a, r) && (m = a), {
      packageName: u,
      packageVersion: a,
      homepage: p,
      hasIncompatibleDependencies: h != null,
      packageStorybookVersion: h,
      availableUpdate: d,
      availableCoreUpdate: m
    };
  } catch (o) {
    return n || BR.logger.log(
      `Error checking compatibility for ${e}, please report an issue:
` + String(o)
    ), { packageName: e };
  }
}, "checkPackageCompatibility"), OR = /* @__PURE__ */ s(async (e) => {
  if (e.currentStorybookVersion.includes("0.0.0"))
    return [];
  let t = e.packageManager.getAllDependencies(), r = Object.keys(t).filter((n) => n.includes("storybook"));
  if (r.length === 0 && !e.skipErrors)
    throw new Error("No Storybook dependencies found in the package.json");
  return Promise.all(
    r.filter((n) => !eh.versions[n]).map((n) => $se(n, e))
  );
}, "getIncompatibleStorybookPackages"), RR = /* @__PURE__ */ s((e, t) => {
  let r = [], n = e.filter(
    (i) => i.hasIncompatibleDependencies
  );
  return n.length > 0 && (r.push(
    `You are currently using Storybook ${Su.default.bold(
      t
    )} but you have packages which are incompatible with it:
`
  ), n.forEach(
    ({
      packageName: i,
      packageVersion: o,
      homepage: a,
      availableUpdate: u,
      packageStorybookVersion: l
    }) => {
      let c = `${i}@${o}`, p = u ? ` (${u} available!)` : "", h = l != null ? ` which depends on ${l}` : "", f = a ? `
 Repo: ${a}` : "";
      r.push(
        `- ${c}${p}${h}${f}`
      );
    }
  ), r.push(
    `
Please consider updating your packages or contacting the maintainers for compatibility details.`,
    `
For more on Storybook 9 compatibility, see the linked GitHub issue:`,
    "https://github.com/storybookjs/storybook/issues/30944"
  ), n.some((i) => i.availableCoreUpdate) && r.push(
    `
`,
    `The version of ${Su.default.blue(`storybook@${t}`)} is behind the following core packages:`,
    `${n.filter((i) => i.availableCoreUpdate).map(
      ({ packageName: i, packageVersion: o }) => `- ${Su.default.blue(`${i}@${o}`)}`
    ).join(`
`)}`,
    `
`,
    "Upgrade Storybook with:",
    Su.default.blue("npx storybook@latest upgrade")
  )), r.join(`
`);
}, "getIncompatiblePackagesSummary");

// src/core-server/utils/warnOnIncompatibleAddons.ts
var LR = /* @__PURE__ */ s(async (e, t) => {
  let r = await OR({
    skipUpgradeCheck: !0,
    skipErrors: !0,
    currentStorybookVersion: e,
    packageManager: t
  }), n = RR(
    r,
    e
  );
  n && NR.logger.warn(n);
}, "warnOnIncompatibleAddons");

// src/core-server/utils/warnWhenUsingArgTypesRegex.ts
var jR = require("node:fs/promises"), MR = require("storybook/internal/babel"), qR = require("storybook/internal/csf-tools"), $o = J(Tr(), 1),
$R = J(Bt(), 1);
async function VR(e, t) {
  let r = e ? await (0, jR.readFile)(e, { encoding: "utf8" }) : "";
  (t?.addons?.some(
    (i) => typeof i == "string" ? i === "@chromatic-com/storybook" : i.name === "@chromatic-com/storybook"
  ) ?? !1) && e && r.includes("argTypesRegex") && new MR.core.File(
    { filename: e },
    { code: r, ast: (0, qR.babelParse)(r) }
  ).path.traverse({
    Identifier: /* @__PURE__ */ s((o) => {
      if (o.node.name === "argTypesRegex") {
        let a = $R.dedent`
            ${$o.default.bold("Attention")}: We've detected that you're using ${$o.default.cyan(
          "actions.argTypesRegex"
        )} together with the visual test addon:
            
            ${o.buildCodeFrameError(e).message}
            
            We recommend removing the ${$o.default.cyan(
          "argTypesRegex"
        )} and assigning explicit action with the ${$o.default.cyan(
          "fn"
        )} function from ${$o.default.cyan("storybook/test")} instead:
            https://storybook.js.org/docs/essentials/actions#via-storybooktest-fn-spy-function
            
            The build used by the addon for snapshot testing doesn't take the regex into account, which can cause hard to debug problems when a snapshot depends on the presence of action props.
          `;
        console.warn(a);
      }
    }, "Identifier")
  });
}
s(VR, "warnWhenUsingArgTypesRegex");

// src/core-server/build-dev.ts
async function bx(e) {
  let { packageJson: t, versionUpdates: r } = e, { storybookVersion: n, previewConfigPath: i } = e, o = (0, Ai.resolve)(e.configDir);
  t ? (Pt(
    t.version !== void 0,
    `Expected package.json#version to be defined in the "${t.name}" package}`
  ), n = t.version, i = (0, ft.getConfigInfo)(o).previewConfigPath ?? void 0) : n || (n = ft.versions.storybook);
  let [a, u] = await Promise.all([
    T6(e.port, { exactPort: e.exactPort }),
    r ? AR(n) : Promise.resolve({ success: !1, cached: !1, data: {}, time: Date.now() })
  ]);
  if (!e.ci && !e.smokeTest && e.port != null && a !== e.port) {
    let { shouldChangePort: ie } = await (0, zR.default)({
      type: "confirm",
      initial: !0,
      name: "shouldChangePort",
      message: `Port ${e.port} is not available. Would you like to run Storybook on port ${a} instead?`
    });
    ie || process.exit(1);
  }
  let l = (0, rh.oneWayHash)((0, Ai.relative)((0, ft.getProjectRoot)(), o)), c = (0, ft.resolvePathInStorybookCache)("public", l), p = (0, Ai.resolve)(
  e.outputDir || c);
  e.smokeTest && (p = c), e.port = a, e.versionCheck = u, e.configType = "DEVELOPMENT", e.configDir = o, e.cacheKey = l, e.outputDir = p, e.
  serverChannelUrl = I6(a, e);
  let h = await (0, ft.loadMainConfig)(e), { framework: f } = h, d = [], m = typeof f == "string" ? f : f?.name;
  e.ignorePreview || (0, ft.validateFrameworkName)(m), m && d.push((0, Ai.join)(m, "preset")), m = m || "custom";
  let g = ft.JsPackageManagerFactory.getPackageManager({
    configDir: e.configDir
  });
  try {
    await LR(n, g);
  } catch (ie) {
    ys.logger.warn("Storybook failed to check addon compatibility"), ys.logger.debug(`${ie instanceof Error ? ie.stack : String(ie)}`);
  }
  try {
    await VR(i, h);
  } catch {
  }
  let b = await (0, ft.loadAllPresets)({
    corePresets: d,
    overridePresets: [
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    ...e,
    isCritical: !0
  }), { renderer: y, builder: E, disableTelemetry: A } = await b.apply("core", {});
  if (!E)
    throw new th.MissingBuilderError();
  !e.disableTelemetry && !A && u.success && !u.cached && (0, rh.telemetry)("version-update");
  let k = typeof E == "string" ? E : E.name, [O, w] = await Promise.all([
    Sa(k, e.configDir),
    wa()
  ]);
  if (k.includes("builder-vite")) {
    let ie = (0, HR.dedent)(`Using CommonJS in your main configuration file is deprecated with Vite.
              - Refer to the migration guide at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#commonjs-with-vite-is-deprec\
ated`), B = (0, ft.serverResolve)((0, Ai.resolve)(e.configDir || ".storybook", "main"));
    /\.c[jt]s$/.test(B) && (0, ys.deprecate)(ie);
    let ce = await (0, UR.readFile)(B, { encoding: "utf8" });
    /\bmodule\.exports\b|\bexports[.[]|\brequire\s*\(|\bObject\.(?:defineProperty|defineProperties|assign)\s*\(\s*exports\b/.test(ce) && (0, ys.deprecate)(
    ie);
  }
  let C = y && (0, ft.resolveAddonName)(e.configDir, y, e);
  b = await (0, ft.loadAllPresets)({
    corePresets: [
      require.resolve("storybook/internal/core-server/presets/common-preset"),
      ...w.corePresets || [],
      ...O.corePresets || [],
      ...C ? [C] : [],
      ...d
    ],
    overridePresets: [
      ...O.overridePresets || [],
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    ...e
  });
  let T = await b.apply("features");
  WR.global.FEATURES = T;
  let F = {
    ...e,
    presets: b,
    features: T
  }, { address: $, networkAddress: R, managerResult: U, previewResult: W } = await Ql(
    async () => L6(F)
  ), Y = W?.totalTime, j = U?.totalTime, N = W?.stats, z = U?.stats, Q = e.webpackStatsJson || e.statsJson;
  if (Q) {
    let ie = Q === !0 ? e.outputDir : Q;
    await sc(ie, N);
  }
  if (e.smokeTest) {
    let ie = [];
    ie.push(...z?.toJson()?.warnings || []);
    try {
      ie.push(...N?.toJson()?.warnings || []);
    } catch (ce) {
      if (!(ce instanceof th.NoStatsForViteDevError))
        throw ce;
    }
    let B = ie.filter((ce) => !ce.message.includes("export 'useInsertionEffect'")).filter((ce) => !ce.message.includes("compilation but it's\
 unused")).filter(
      (ce) => !ce.message.includes("Conflicting values for 'process.env.NODE_ENV'")
    );
    ys.logger.log(B.map((ce) => ce.stack).join(`
`)), process.exit(B.length > 0 ? 1 : 0);
  } else {
    let ie = m.split("@storybook/").length > 1 ? m.split("@storybook/")[1] : m;
    e.quiet || IR({
      updateInfo: u,
      version: n,
      name: ie,
      address: $,
      networkAddress: R,
      managerTotalTime: j,
      previewTotalTime: Y
    });
  }
  return { port: a, address: $, networkAddress: R };
}
s(bx, "buildDevStandalone");

// src/core-server/build-index.ts
var ZR = require("node:fs/promises"), XR = require("storybook/internal/common"), KR = require("storybook/internal/node-logger");

// src/core-server/load.ts
var Vo = require("node:path"), Xr = require("storybook/internal/common"), GR = require("storybook/internal/telemetry"), JR = require("@storybook/global");
async function nh(e) {
  let t = (0, Vo.resolve)(e.configDir), r = (0, GR.oneWayHash)((0, Vo.relative)((0, Xr.getProjectRoot)(), t));
  e.configType = "DEVELOPMENT", e.configDir = t, e.cacheKey = r;
  let n = await (0, Xr.loadMainConfig)(e), { framework: i } = n, o = [], a = typeof i == "string" ? i : i?.name;
  e.ignorePreview || (0, Xr.validateFrameworkName)(a), a && o.push((0, Vo.join)(a, "preset")), a = a || "custom";
  let u = await (0, Xr.loadAllPresets)({
    corePresets: o,
    overridePresets: [
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    ...e,
    isCritical: !0
  }), { renderer: l } = await u.apply("core", {}), c = l && (0, Xr.resolveAddonName)(e.configDir, l, e);
  u = await (0, Xr.loadAllPresets)({
    corePresets: [
      require.resolve("storybook/internal/core-server/presets/common-preset"),
      ...c ? [c] : [],
      ...o
    ],
    overridePresets: [
      require.resolve("storybook/internal/core-server/presets/common-override-preset")
    ],
    ...e
  });
  let p = await u.apply("features");
  return JR.global.FEATURES = p, {
    ...e,
    presets: u,
    features: p
  };
}
s(nh, "loadStorybook");

// src/core-server/build-index.ts
var YR = /* @__PURE__ */ s(async (e) => {
  let { presets: t } = await nh(e), [r, n, i] = await Promise.all([
    t.apply("experimental_indexers", []),
    t.apply("stories", []),
    t.apply("docs")
  ]), { configDir: o } = e, a = process.cwd(), u = {
    configDir: o,
    workingDir: a
  }, l = (0, XR.normalizeStories)(n, u), c = new an(l, {
    ...u,
    indexers: r,
    docs: i,
    build: {}
  });
  return await c.initialize(), c.getIndex();
}, "buildIndex"), vx = /* @__PURE__ */ s(async (e) => {
  let t = await YR(e);
  KR.logger.info(`Writing index to ${e.outputFile}`), await (0, ZR.writeFile)(e.outputFile, JSON.stringify(t));
}, "buildIndexStandalone");

// src/core-server/standalone.ts
var QR = require("node:path");
async function Vse(e = {}, t = {}) {
  let { mode: r = "dev" } = e, n = (0, QR.dirname)(require.resolve("storybook/internal/package.json")), i = JSON.parse(require("fs").readFileSync(
  `${n}/package.json`)), o = {
    ...e,
    ...t,
    frameworkPresets: [
      ...e.frameworkPresets || [],
      ...t.frameworkPresets || []
    ],
    packageJson: i
  };
  if (r === "dev")
    return bx(o);
  if (r === "static")
    return Ng(o);
  if (r === "index")
    return vx(o);
  throw new Error("'mode' parameter should be either 'dev', 'static', or 'index'");
}
s(Vse, "build");
var e9 = Vse;

// src/shared/universal-store/mock.ts
var t9 = require("storybook/internal/channels"), r9 = J(Bt(), 1);
var ih = class e extends kt {
  static {
    s(this, "MockUniversalStore");
  }
  constructor(t, r) {
    kt.isInternalConstructing = !0, super(
      { ...t, leader: !0 },
      { channel: new t9.Channel({}), environment: kt.Environment.MOCK }
    ), kt.isInternalConstructing = !1, typeof r?.fn == "function" && (this.testUtils = r, this.getState = r.fn(this.getState), this.setState =
    r.fn(this.setState), this.subscribe = r.fn(this.subscribe), this.onStateChange = r.fn(this.onStateChange), this.send = r.fn(this.send));
  }
  /** Create a mock universal store. This is just an alias for the constructor */
  static create(t, r) {
    return new e(t, r);
  }
  unsubscribeAll() {
    if (!this.testUtils)
      throw new Error(
        r9.default`Cannot call unsubscribeAll on a store that does not have testUtils.
        Please provide testUtils as the second argument when creating the store.`
      );
    let t = /* @__PURE__ */ s((r) => {
      try {
        r.value();
      } catch {
      }
    }, "callReturnedUnsubscribeFn");
    this.subscribe.mock?.results.forEach(t), this.onStateChange.mock?.results.forEach(t);
  }
};

// src/storybook-error.ts
function n9({
  code: e,
  category: t
}) {
  let r = String(e).padStart(4, "0");
  return `SB_${t}_${r}`;
}
s(n9, "parseErrorCode");
function i9(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e))
    return e;
  try {
    let t = new URL(e);
    return t.searchParams.set("ref", "error"), t.toString();
  } catch {
    return e;
  }
}
s(i9, "appendErrorRef");
var Fi = class e extends Error {
  constructor(r) {
    super(e.getFullMessage(r));
    /**
     * Data associated with the error. Used to provide additional information in the error message or
     * to be passed to telemetry.
     */
    this.data = {};
    /** Flag used to easily determine if the error originates from Storybook. */
    this.fromStorybook = !0;
    this.category = r.category, this.documentation = r.documentation ?? !1, this.code = r.code;
  }
  static {
    s(this, "StorybookError");
  }
  get fullErrorCode() {
    return n9({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let r = this.constructor.name;
    return `${this.fullErrorCode} (${r})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: r,
    code: n,
    category: i,
    message: o
  }) {
    let a;
    return r === !0 ? a = `https://storybook.js.org/error/${n9({ code: n, category: i })}?ref=error` : typeof r == "string" ? a = i9(r) : Array.
    isArray(r) && (a = `
${r.map((u) => `	- ${i9(u)}`).join(`
`)}`), `${o}${a != null ? `

More info: ${a}
` : ""}`;
  }
};

// src/manager-errors.ts
var sh = class extends Fi {
  constructor(r) {
    super({
      category: "MANAGER_API",
      code: 1,
      message: `Status has typeId "${r.status.typeId}" but was added to store with typeId "${r.typeId}". Full status: ${JSON.stringify(
        r.status,
        null,
        2
      )}`
    });
    this.data = r;
  }
  static {
    s(this, "StatusTypeIdMismatchError");
  }
};

// src/preview-errors.ts
var Use = J(Bt(), 1);
var oh = class extends Fi {
  constructor(r) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${r.status.typeId}" but was added to store with typeId "${r.typeId}". Full status: ${JSON.stringify(
        r.status,
        null,
        2
      )}`
    });
    this.data = r;
  }
  static {
    s(this, "StatusTypeIdMismatchError");
  }
};

// src/server-errors.ts
var Wse = J(Bt(), 1);
var ah = class extends Fi {
  constructor(r) {
    super({
      category: "CORE-SERVER",
      code: 16,
      message: `Status has typeId "${r.status.typeId}" but was added to store with typeId "${r.typeId}". Full status: ${JSON.stringify(
        r.status,
        null,
        2
      )}`
    });
    this.data = r;
  }
  static {
    s(this, "StatusTypeIdMismatchError");
  }
};

// src/shared/status-store/index.ts
var s9 = {
  id: "storybook/status",
  leader: !0,
  initialState: {}
}, Ex = {
  SELECT: "select"
};
function o9({
  universalStatusStore: e,
  useUniversalStore: t,
  environment: r
}) {
  let n = {
    getAll() {
      return e.getState();
    },
    set(o) {
      e.setState((a) => {
        let u = { ...a };
        for (let l of o) {
          let { storyId: c, typeId: p } = l;
          u[c] = { ...u[c] ?? {}, [p]: l };
        }
        return u;
      });
    },
    onAllStatusChange(o) {
      return e.onStateChange((a, u) => {
        o(a, u);
      });
    },
    onSelect(o) {
      return e.subscribe(Ex.SELECT, (a) => {
        o(a.payload);
      });
    },
    selectStatuses: /* @__PURE__ */ s((o) => {
      e.send({ type: Ex.SELECT, payload: o });
    }, "selectStatuses"),
    unset(o) {
      if (!o) {
        e.setState({});
        return;
      }
      e.setState((a) => {
        let u = { ...a };
        for (let l of o)
          delete u[l];
        return u;
      });
    },
    typeId: void 0
  }, i = /* @__PURE__ */ s((o) => ({
    getAll: n.getAll,
    set(a) {
      e.setState((u) => {
        let l = { ...u };
        for (let c of a) {
          let { storyId: p } = c;
          if (c.typeId !== o)
            switch (r) {
              case "server":
                throw new ah({
                  status: c,
                  typeId: o
                });
              case "manager":
                throw new sh({
                  status: c,
                  typeId: o
                });
              case "preview":
              default:
                throw new oh({
                  status: c,
                  typeId: o
                });
            }
          l[p] = { ...l[p] ?? {}, [o]: c };
        }
        return l;
      });
    },
    onAllStatusChange: n.onAllStatusChange,
    onSelect(a) {
      return e.subscribe(Ex.SELECT, (u) => {
        u.payload.some((l) => l.typeId === o) && a(u.payload);
      });
    },
    unset(a) {
      e.setState((u) => {
        let l = { ...u };
        for (let c in l)
          if (l[c]?.[o] && (!a || a?.includes(c))) {
            let { [o]: p, ...h } = l[c];
            l[c] = h;
          }
        return l;
      });
    },
    typeId: o
  }), "getStatusStoreByTypeId");
  return t ? {
    getStatusStoreByTypeId: i,
    fullStatusStore: n,
    universalStatusStore: e,
    useStatusStore: /* @__PURE__ */ s((o) => t(e, o)[0], "useStatusStore")
  } : { getStatusStoreByTypeId: i, fullStatusStore: n, universalStatusStore: e };
}
s(o9, "createStatusStore");

// src/core-server/stores/status.ts
var zse = o9({
  universalStatusStore: kt.create({
    ...s9,
    /*
      This is a temporary workaround, to ensure that the store is not created in the
      vitest sub-process in addon-vitest, even though it imports from core-server
      If it was created in the sub-process, it would try to connect to the leader in the dev server
      before it was ready.
      This will be fixed when we do the planned UniversalStore v0.2.
    */
    leader: !Dp(process.env.VITEST_CHILD_PROCESS)
  }),
  environment: "server"
}), { fullStatusStore: a9, getStatusStoreByTypeId: u9, universalStatusStore: l9 } = zse;

// src/shared/test-provider-store/index.ts
var c9 = {
  id: "storybook/test-provider",
  leader: !0,
  initialState: {}
};
function p9({
  universalTestProviderStore: e,
  useUniversalStore: t
}) {
  let r = {
    settingsChanged: /* @__PURE__ */ s(() => {
      e.untilReady().then(() => {
        e.send({ type: "settings-changed" });
      });
    }, "settingsChanged"),
    onRunAll: /* @__PURE__ */ s((o) => e.subscribe("run-all", o), "onRunAll"),
    onClearAll: /* @__PURE__ */ s((o) => e.subscribe("clear-all", o), "onClearAll")
  }, n = {
    ...r,
    getFullState: e.getState,
    setFullState: e.setState,
    onSettingsChanged: /* @__PURE__ */ s((o) => e.subscribe("settings-changed", o), "onSettingsChanged"),
    runAll: /* @__PURE__ */ s(async () => {
      await e.untilReady(), e.send({ type: "run-all" });
    }, "runAll"),
    clearAll: /* @__PURE__ */ s(async () => {
      await e.untilReady(), e.send({ type: "clear-all" });
    }, "clearAll")
  }, i = /* @__PURE__ */ s((o) => {
    let a = /* @__PURE__ */ s(() => e.getState()[o] ?? "test-provider-state:pending", "getStateForTestProvider"), u = /* @__PURE__ */ s((l) => {
      e.untilReady().then(() => {
        e.setState((c) => ({
          ...c,
          [o]: l
        }));
      });
    }, "setStateForTestProvider");
    return {
      ...r,
      testProviderId: o,
      getState: a,
      setState: u,
      runWithState: /* @__PURE__ */ s(async (l) => {
        u("test-provider-state:running");
        try {
          await l(), u("test-provider-state:succeeded");
        } catch {
          u("test-provider-state:crashed");
        }
      }, "runWithState")
    };
  }, "getTestProviderStoreById");
  return t ? {
    getTestProviderStoreById: i,
    fullTestProviderStore: n,
    universalTestProviderStore: e,
    useTestProviderStore: /* @__PURE__ */ s((o) => t(e, o)[0], "useTestProviderStore")
  } : {
    getTestProviderStoreById: i,
    fullTestProviderStore: n,
    universalTestProviderStore: e
  };
}
s(p9, "createTestProviderStore");

// src/core-server/stores/test-provider.ts
var Hse = p9({
  universalTestProviderStore: kt.create({
    ...c9,
    /*
            This is a temporary workaround, to ensure that the store is not created in the
            vitest sub-process in addon-vitest, even though it imports from core-server
            If it was created in the sub-process, it would try to connect to the leader in the dev server
            before it was ready.
            This will be fixed when we do the planned UniversalStore v0.2.
          */
    leader: !Dp(process.env.VITEST_CHILD_PROCESS)
  })
}), { fullTestProviderStore: h9, getTestProviderStoreById: f9, universalTestProviderStore: d9 } = Hse;
