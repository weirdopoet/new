'use strict';

var ethers = require('ethers');
var url = require('./url-8b7f19db.cjs.prod.js');
var headers = require('./headers-140df57f.cjs.prod.js');
var utils = require('./utils-5241e2ba.cjs.prod.js');

async function hexlifyUserOp(
// TODO: types
op) {
  const userOp = await ethers.utils.resolveProperties(op);
  return Object.keys(userOp).map(key => {
    let val = userOp[key];
    if (typeof val !== "string" || !val.startsWith("0x")) {
      val = ethers.utils.hexValue(val);
    }
    return [key, val];
  }).reduce((set, _ref) => {
    let [k, v] = _ref;
    return {
      ...set,
      [k]: v
    };
  }, {});
}

// v0.6 userOpHash calculation
async function getUserOpHashV06(userOp, entryPoint, chainId) {
  const op = await ethers.utils.resolveProperties(userOp);
  const hashedUserOp = {
    sender: op.sender,
    nonce: op.nonce,
    initCodeHash: ethers.utils.keccak256(op.initCode),
    callDataHash: ethers.utils.keccak256(op.callData),
    callGasLimit: op.callGasLimit,
    verificationGasLimit: op.verificationGasLimit,
    preVerificationGas: op.preVerificationGas,
    maxFeePerGas: op.maxFeePerGas,
    maxPriorityFeePerGas: op.maxPriorityFeePerGas,
    paymasterAndDataHash: ethers.utils.keccak256(op.paymasterAndData)
  };
  const userOpType = {
    components: [{
      type: "address",
      name: "sender"
    }, {
      type: "uint256",
      name: "nonce"
    }, {
      type: "bytes32",
      name: "initCodeHash"
    }, {
      type: "bytes32",
      name: "callDataHash"
    }, {
      type: "uint256",
      name: "callGasLimit"
    }, {
      type: "uint256",
      name: "verificationGasLimit"
    }, {
      type: "uint256",
      name: "preVerificationGas"
    }, {
      type: "uint256",
      name: "maxFeePerGas"
    }, {
      type: "uint256",
      name: "maxPriorityFeePerGas"
    }, {
      type: "bytes32",
      name: "paymasterAndDataHash"
    }],
    name: "hashedUserOp",
    type: "tuple"
  };
  const encoded = ethers.utils.defaultAbiCoder.encode([userOpType], [{
    ...hashedUserOp
  }]);
  // remove leading word (total length) and trailing word (zero-length signature)

  const userOpHash = ethers.utils.keccak256(encoded);
  const enc = ethers.utils.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, entryPoint, chainId]);
  return ethers.utils.keccak256(enc);
}
const generateRandomUint192 = () => {
  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));
  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));
  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));
  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));
  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));
  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));
  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;
};
const randomNonce = () => {
  let hexString = generateRandomUint192().toString(16);
  if (hexString.length % 2 !== 0) {
    hexString = "0" + hexString;
  }
  hexString = "0x" + hexString;
  return ethers.BigNumber.from(ethers.utils.concat([hexString, "0x0000000000000000"]));
};

const DEBUG = false; // TODO set as public flag

class HttpRpcClient {
  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {
    this.bundlerUrl = bundlerUrl;
    this.entryPointAddress = entryPointAddress;
    this.chainId = chainId;
    const headers$1 = {};
    if (url.isTwUrl(this.bundlerUrl)) {
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;
      if (secretKey) {
        headers$1["x-secret-key"] = secretKey;
      } else if (clientId) {
        headers$1["x-client-id"] = clientId;
        if (bundleId) {
          headers$1["x-bundle-id"] = bundleId;
        }
      }

      // Dashboard token
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers$1["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
      }

      // CLI token
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers$1["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
        headers$1["x-authorize-wallet"] = "true";
      }
      headers.setAnalyticsHeaders(headers$1);
    }
    this.userOpJsonRpcProvider = new ethers.providers.StaticJsonRpcProvider({
      url: this.bundlerUrl,
      headers: headers$1
    }, {
      name: "Connected bundler network",
      chainId
    });
    this.initializing = this.validateChainId();
  }
  async validateChainId() {
    if (await utils.isZkSyncChain(this.chainId)) {
      return;
    }
    // validate chainId is in sync with expected chainid
    const chain = await this.userOpJsonRpcProvider.send("eth_chainId", []);
    const bundlerChain = parseInt(chain);
    if (bundlerChain !== this.chainId) {
      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);
    }
  }

  /**
   * send a UserOperation to the bundler
   * @param userOp1 - The UserOperation to send
   * @returns userOpHash the id of this operation, for getUserOperationTransaction
   */
  async sendUserOpToBundler(userOp1) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp1);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_sendUserOperation", jsonRequestData);
    return await this.userOpJsonRpcProvider.send("eth_sendUserOperation", [hexifiedUserOp, this.entryPointAddress]);
  }
  async estimateUserOpGas(userOp) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_estimateUserOperationGas", jsonRequestData);
    const data = await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas", [hexifiedUserOp, this.entryPointAddress]);
    // adds gas buffer to callGasLimit to account for ManagedAccountFactory delegate calls
    return {
      preVerificationGas: ethers.BigNumber.from(data.preVerificationGas),
      verificationGas: ethers.BigNumber.from(data.verificationGas),
      verificationGasLimit: ethers.BigNumber.from(data.verificationGasLimit),
      callGasLimit: ethers.BigNumber.from(data.callGasLimit).add(utils.MANAGED_ACCOUNT_GAS_BUFFER)
    };
  }
  async getUserOperationGasPrice() {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("thirdweb_getUserOperationGasPrice", []);
  }
  async getUserOperationReceipt(userOpHash) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("eth_getUserOperationReceipt", [userOpHash]);
  }
  async zkPaymasterData(transactionInput) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("zk_paymasterData", [await hexlifyUserOp({
      ...transactionInput,
      gas: transactionInput.gasLimit
    })]);
  }
  async zkBroadcastTransaction(transactionInput) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("zk_broadcastTransaction", [transactionInput]);
  }
  async printUserOperation(method, _ref) {
    {
      return;
    }
  }
}

exports.DEBUG = DEBUG;
exports.HttpRpcClient = HttpRpcClient;
exports.getUserOpHashV06 = getUserOpHashV06;
exports.hexlifyUserOp = hexlifyUserOp;
exports.randomNonce = randomNonce;
