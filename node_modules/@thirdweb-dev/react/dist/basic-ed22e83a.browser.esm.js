import { mauveDark, tomato, green, mauve } from '@radix-ui/colors';
import { useContext, createContext, useState } from 'react';
import { jsx, jsxs } from 'react/jsx-runtime';
import styled from '@emotion/styled';
import { ChevronLeftIcon } from '@radix-ui/react-icons';
import { useStorage } from '@thirdweb-dev/react-core';
import { keyframes } from '@emotion/react';

const darkColors = {
  base1: "hsl(230deg 11.63% 8.43%)",
  base2: "hsl(230deg 11.63% 12%)",
  base3: "hsl(230deg 11.63% 15%)",
  base4: "hsl(230deg 11.63% 17%)",
  primaryText: mauveDark.mauve12,
  secondaryText: mauveDark.mauve10,
  danger: tomato.tomato9,
  success: green.green8,
  overlay: "rgba(0, 0, 0, 0.7)",
  accentText: "#3385FF",
  accentBg: "hsl(216 100% 50%)",
  textOnAccent: mauveDark.mauve12
};
const lightColors = {
  base1: mauve.mauve1,
  base2: mauve.mauve3,
  base3: mauve.mauve5,
  base4: mauve.mauve6,
  primaryText: mauve.mauve12,
  secondaryText: mauveDark.mauve9,
  accentText: "hsl(216 100% 45%)",
  success: green.green9,
  danger: tomato.tomato9,
  overlay: "rgba(0, 0, 0, 0.7)",
  accentBg: "hsl(216 100% 50%)",
  textOnAccent: mauve.mauve1
};

/**
 * @theme
 */

function createThemeObj(colors) {
  return {
    type: "dark",
    colors: {
      primaryText: colors.primaryText,
      secondaryText: colors.secondaryText,
      accentText: colors.accentText,
      danger: colors.danger,
      success: colors.success,
      modalOverlayBg: colors.overlay,
      accentButtonBg: colors.accentBg,
      accentButtonText: colors.textOnAccent,
      primaryButtonBg: colors.primaryText,
      primaryButtonText: colors.base1,
      secondaryButtonBg: colors.base3,
      secondaryButtonText: colors.primaryText,
      secondaryButtonHoverBg: colors.base4,
      modalBg: colors.base1,
      tooltipBg: colors.primaryText,
      tooltipText: colors.base1,
      inputAutofillBg: colors.base2,
      scrollbarBg: colors.base2,
      walletSelectorButtonHoverBg: colors.base2,
      separatorLine: colors.base4,
      secondaryIconColor: colors.secondaryText,
      secondaryIconHoverBg: colors.base3,
      secondaryIconHoverColor: colors.primaryText,
      borderColor: colors.base4,
      skeletonBg: colors.base3,
      selectedTextColor: colors.base1,
      selectedTextBg: colors.primaryText,
      connectedButtonBg: colors.base1,
      connectedButtonBgHover: colors.base2
    },
    fontFamily: "inherit"
  };
}
const darkThemeObj = /* @__PURE__ */createThemeObj(darkColors);
const lightThemeObj = /* @__PURE__ */createThemeObj(lightColors);

/**
 * @theme
 */

const fontSize = {
  xs: "12px",
  sm: "14px",
  md: "16px",
  lg: "20px",
  xl: "24px"
};
const spacing = {
  xxs: "6px",
  xs: "8px",
  sm: "12px",
  md: "16px",
  lg: "24px",
  xl: "32px",
  xxl: "48px",
  "3xl": "64px"
};
const radius = {
  sm: "6px",
  md: "8px",
  lg: "12px",
  xl: "20px",
  xxl: "32px"
};
const iconSize = {
  xs: "12",
  sm: "16",
  md: "24",
  lg: "32",
  xl: "48",
  xxl: "64",
  "3xl": "96",
  "4xl": "128"
};

// desktop first style media query
const media = {
  mobile: `@media (max-width: 640px)`
};

// TODO - move to theme
const shadow = {
  sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
  md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
  lg: "0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
  xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
};

/**
 * Create a custom light theme object by using the default dark theme as a base and applying overrides.
 *
 * @example
 * ### Get the default light theme
 * ```ts
 * const defaultLightTheme = lightTheme()
 * ```
 *
 * ### Create a custom light theme
 * ```ts
 * const customTheme = lightTheme({
 *   colors: {
 *     modalBg: "red",
 *   },
 * });
 * ```
 *
 * @param overrides - The overrides to apply to the default light theme.
 * @theme
 */
function lightTheme(overrides) {
  if (!overrides) {
    return lightThemeObj;
  }
  return applyThemeOverrides(lightThemeObj, overrides);
}

/**
 * Create a custom dark theme object by using the default dark theme as a base and applying overrides.
 *
 * @example
 * ### Get the default dark theme
 * ```ts
 * const defaultDarkTheme = darkTheme()
 * ```
 *
 * ### Create a custom dark theme
 * ```ts
 * const customTheme = darkTheme({
 *   colors: {
 *     modalBg: "red",
 *   },
 * });
 * ```
 *
 * @param overrides - The overrides to apply to the default dark theme.
 * @theme
 */
function darkTheme(overrides) {
  if (!overrides) {
    return darkThemeObj;
  }
  return applyThemeOverrides(darkThemeObj, overrides);
}
function applyThemeOverrides(baseTheme, themeOverrides) {
  const theme = {
    ...baseTheme
  };
  if (themeOverrides.colors) {
    theme.colors = {
      ...theme.colors,
      ...themeOverrides.colors
    };
  }
  if (themeOverrides.fontFamily) {
    theme.fontFamily = themeOverrides.fontFamily;
  }
  return theme;
}

const CustomThemeCtx = /* @__PURE__ */createContext(darkThemeObj);
function CustomThemeProvider(props) {
  const {
    theme,
    children
  } = props;
  let themeObj;
  if (typeof theme === "string") {
    themeObj = theme === "light" ? lightThemeObj : darkThemeObj;
  } else {
    themeObj = theme;
  }
  return /*#__PURE__*/jsx(CustomThemeCtx.Provider, {
    value: themeObj,
    children: children
  });
}
function useCustomTheme() {
  return useContext(CustomThemeCtx);
}

const StyledDiv = styled.div;
const StyledSvg = styled.svg;
const StyledCircle = styled.circle;
const StyledSpan = styled.span;
const StyledAnchor = styled.a;
const StyledButton = styled.button;
const StyledLabel = styled.label;
const StyledInput = styled.input;
const StyledH2 = styled.h2;
const StyledP = styled.p;
const StyledUl = styled.ul;
const StyledSelect = styled.select;
const StyledOption = styled.option;

const Button = /* @__PURE__ */StyledButton(props => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    cursor: "pointer",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: radius.md,
    padding: `${fontSize.sm} ${fontSize.sm}`,
    fontSize: fontSize.md,
    fontWeight: 500,
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    lineHeight: "normal",
    flexShrink: 0,
    transition: "border 200ms ease",
    gap: props.gap && spacing[props.gap] || 0,
    width: props.fullWidth ? "100%" : undefined,
    textAlign: "center",
    maxWidth: "100%",
    background: (() => {
      switch (props.variant) {
        case "primary":
          return theme.colors.primaryButtonBg;
        case "accent":
          return theme.colors.accentButtonBg;
        case "secondary":
          return theme.colors.secondaryButtonBg;
        default:
          return "none";
      }
    })(),
    color: (() => {
      switch (props.variant) {
        case "primary":
          return theme.colors.primaryButtonText;
        case "accent":
          return theme.colors.accentButtonText;
        case "secondary":
          return theme.colors.secondaryButtonText;
        case "outline":
          return theme.colors.secondaryButtonText;
        case "link":
          return theme.colors.accentText;
        default:
          return theme.colors.primaryButtonText;
      }
    })(),
    "&:active": {
      transform: "translateY(1px)"
    },
    "&[disabled]": {
      cursor: "not-allowed"
    },
    "&[data-disabled='true']": {
      background: theme.colors.walletSelectorButtonHoverBg,
      color: theme.colors.secondaryText,
      borderColor: "transparent",
      boxShadow: "none",
      "&:hover": {
        borderColor: "transparent"
      }
    },
    ...(() => {
      if (props.variant === "outline") {
        return {
          border: `1.5px solid ${theme.colors.borderColor}`,
          "&:hover": {
            borderColor: theme.colors.accentText
          }
        };
      }
      if (props.variant === "secondary") {
        return {
          "&:hover": {
            background: theme.colors.secondaryButtonHoverBg
          }
        };
      }
      if (props.variant === "link") {
        return {
          padding: 0,
          "&:hover": {
            color: theme.colors.primaryText
          }
        };
      }
      return {};
    })()
  };
});
const IconButton = /* @__PURE__ */StyledButton(() => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    cursor: "pointer",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: radius.sm,
    WebkitTapHighlightColor: "transparent",
    color: theme.colors.secondaryIconColor,
    padding: "2px",
    transition: "background 200ms ease, color 200ms ease",
    "&:hover": {
      background: theme.colors.secondaryIconHoverBg,
      color: theme.colors.secondaryIconHoverColor
    }
  };
});
const InputButton = /* @__PURE__ */StyledButton(() => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: radius.sm,
    padding: spacing.sm,
    cursor: "pointer",
    WebkitTapHighlightColor: "transparent",
    color: theme.colors.secondaryText,
    "&:hover": {
      color: theme.colors.primaryText
    },
    "&[disabled]": {
      cursor: "not-allowed"
    }
  };
});

const ModalTitle = /* @__PURE__ */StyledH2(props => {
  const theme = useCustomTheme();
  return {
    margin: 0,
    fontWeight: 600,
    fontSize: fontSize.lg,
    color: theme.colors.primaryText,
    lineHeight: 1.3,
    textAlign: "left",
    [media.mobile]: {
      textAlign: props.centerOnMobile ? "center" : "left"
    }
  };
});
const ModalDescription = /* @__PURE__ */StyledP(props => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    display: "block",
    fontSize: props.sm ? fontSize.sm : fontSize.md,
    color: theme.colors.secondaryText,
    lineHeight: 1.5,
    [media.mobile]: {
      textAlign: props.centerOnMobile ? "center" : "left"
    }
  };
});
const BackButton = props => {
  return /*#__PURE__*/jsx(IconButton, {
    onClick: props.onClick,
    style: {
      transform: "translateX(-25%)",
      ...props.style
    },
    type: "button",
    children: /*#__PURE__*/jsx(ChevronLeftIcon, {
      width: iconSize.md,
      height: iconSize.md
    })
  });
};
const HelperLink = /* @__PURE__ */StyledAnchor(props => {
  const theme = useCustomTheme();
  return {
    all: "unset",
    cursor: "pointer",
    color: theme.colors.accentText,
    fontSize: props.md ? fontSize.md : fontSize.sm,
    textDecoration: "none",
    display: "block",
    lineHeight: 1.5,
    [media.mobile]: {
      textAlign: "center"
    },
    "&:hover": {
      color: theme.colors.primaryText,
      textDecoration: "none"
    }
  };
});

const Skeleton = props => {
  return /*#__PURE__*/jsx(SkeletonDiv, {
    style: {
      height: props.height,
      width: props.width || "auto"
    }
  });
};
const skeletonAnimation = keyframes`
0% {
    opacity: 0.5;
  }
  100% {
    opacity: 1;
  }
`;
const SkeletonDiv = /* @__PURE__ */StyledDiv(() => {
  const theme = useCustomTheme();
  return {
    backgroundSize: "200% 200%",
    backgroundColor: theme.colors.skeletonBg,
    animation: `${skeletonAnimation} 500ms ease-in-out infinite alternate`,
    borderRadius: radius.sm
  };
});

const Img = props => {
  const storage = useStorage();
  const [isLoaded, setIsLoaded] = useState(false);
  const propSrc = props.src;
  const widthPx = props.width + "px";
  const heightPx = (props.height || props.width) + "px";
  if (!propSrc) {
    return /*#__PURE__*/jsx(Skeleton, {
      width: widthPx,
      height: heightPx
    });
  }
  const getSrc = () => {
    if (!props.src) {
      return props.fallbackImage || "";
    }
    try {
      return storage ? storage.resolveScheme(props.src) : props.src.replace("ipfs://", "https://ipfs.io/ipfs/");
    } catch {
      return props.src;
    }
  };
  const src = getSrc();
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      display: "inline-flex",
      flexShrink: 0,
      alignItems: "center"
    },
    children: [!isLoaded && /*#__PURE__*/jsx(Skeleton, {
      width: widthPx,
      height: heightPx
    }), /*#__PURE__*/jsx("img", {
      onLoad: () => {
        setIsLoaded(true);
      },
      width: props.width,
      height: props.height,
      src: src,
      alt: props.alt || "",
      loading: props.loading,
      decoding: "async",
      style: {
        objectFit: "contain",
        height: !isLoaded ? 0 : props.height ? props.height + "px" : undefined,
        width: !isLoaded ? 0 : props.width ? props.width + "px" : undefined,
        userSelect: "none",
        visibility: isLoaded ? "visible" : "hidden",
        opacity: isLoaded ? 1 : 0,
        transition: "opacity 0.4s ease",
        ...props.style
      },
      draggable: false,
      className: props.className,
      onError: e => {
        if (props.fallbackImage && e.currentTarget.src !== props.fallbackImage) {
          e.currentTarget.src = props.fallbackImage;
        }
      }
    }, src)]
  });
};

const floatUpAnimation = keyframes`
  from {
    opacity: 0;
    transform: translateY(20%) scale(0.8) ;
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
const floatDownAnimation = keyframes`
  from {
    opacity: 0;
    transform: translateY(-20%) scale(0.8) ;
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
const fadeInAnimation = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const ScreenBottomContainer = /* @__PURE__ */StyledDiv(() => {
  const theme = useCustomTheme();
  return {
    borderTop: `1px solid ${theme.colors.separatorLine}`,
    display: "flex",
    flexDirection: "column",
    gap: spacing.lg,
    padding: spacing.lg
  };
});
const noScrollBar = {
  scrollbarWidth: "none",
  "&::-webkit-scrollbar": {
    width: 0,
    display: "none"
  }
};
function ModalHeader(props) {
  const {
    onBack,
    title,
    imgSrc
  } = props;
  return /*#__PURE__*/jsxs("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      position: "relative"
    },
    children: [onBack && /*#__PURE__*/jsx(BackButton, {
      onClick: onBack,
      style: {
        position: "absolute",
        left: 0,
        top: 0
      }
    }), /*#__PURE__*/jsxs(Container, {
      flex: "row",
      gap: "xs",
      center: "both",
      children: [imgSrc && /*#__PURE__*/jsx(Img, {
        src: imgSrc,
        width: iconSize.md,
        height: iconSize.md
      }), typeof title === "string" ? /*#__PURE__*/jsx(ModalTitle, {
        children: title
      }) : title]
    })]
  });
}
const Line = /* @__PURE__ */StyledDiv(() => {
  const theme = useCustomTheme();
  return {
    height: "1px",
    background: theme.colors.separatorLine
  };
});
function Container(props) {
  const styles = {};
  if (props.relative) {
    styles.position = "relative";
  }
  if (props.fullHeight) {
    styles.height = "100%";
  }
  if (props.expand) {
    styles.flex = "1 1 0%";
  }
  if (props.flex) {
    styles.display = "flex";
    styles.flexDirection = props.flex;
    if (props.flex === "row") {
      styles.flexWrap = "wrap";
    }
    if (props.gap) {
      styles.gap = spacing[props.gap];
    }
    if (props.center) {
      if (props.center === "both") {
        styles.justifyContent = "center";
        styles.alignItems = "center";
      }
      if (props.center === "x" && props.flex === "row" || props.center === "y" && props.flex === "column") {
        styles.justifyContent = "center";
      }
      if (props.center === "x" && props.flex === "column" || props.center === "y" && props.flex === "row") {
        styles.alignItems = "center";
      }
    }
  }
  if (props.p) {
    styles.padding = spacing[props.p];
  }
  if (props.px) {
    styles.paddingLeft = spacing[props.px];
    styles.paddingRight = spacing[props.px];
  }
  if (props.py) {
    styles.paddingTop = spacing[props.py];
    styles.paddingBottom = spacing[props.py];
  }
  if (props.debug) {
    styles.outline = "1px solid red";
    styles.outlineOffset = "-1px";
  }
  return /*#__PURE__*/jsx(Box, {
    "data-scrolly": props.scrollY,
    "data-animate": props.animate,
    bg: props.bg,
    color: props.color,
    borderColor: props.borderColor,
    style: {
      ...styles,
      ...props.style
    },
    children: props.children
  });
}
const Box = /* @__PURE__ */StyledDiv(props => {
  const theme = useCustomTheme();
  return {
    color: props.color ? theme.colors[props.color] : "inherit",
    background: props.bg ? theme.colors[props.bg] : undefined,
    borderColor: props.borderColor ? theme.colors[props.borderColor] : undefined,
    "&[data-animate='fadein']": {
      opacity: 0,
      animation: `${fadeInAnimation} 350ms ease forwards`
    },
    "&[data-animate='floatup']": {
      opacity: 0,
      animation: `${floatUpAnimation} 350ms ease forwards`
    },
    "&[data-animate='floatdown']": {
      opacity: 0,
      animation: `${floatDownAnimation} 350ms ease forwards`
    },
    "&[data-scrolly='true']": {
      overflowY: "auto",
      ...noScrollBar
    }
  };
});

export { StyledInput as A, Button as B, Container as C, StyledLabel as D, StyledOption as E, HelperLink as H, Img as I, Line as L, ModalHeader as M, StyledDiv as S, ModalDescription as a, StyledButton as b, fadeInAnimation as c, darkTheme as d, InputButton as e, fontSize as f, IconButton as g, ScreenBottomContainer as h, iconSize as i, StyledP as j, shadow as k, lightTheme as l, media as m, noScrollBar as n, CustomThemeProvider as o, ModalTitle as p, Skeleton as q, radius as r, spacing as s, StyledUl as t, useCustomTheme as u, StyledAnchor as v, StyledSelect as w, StyledSpan as x, StyledSvg as y, StyledCircle as z };
